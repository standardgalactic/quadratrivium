1
00:00:00,000 --> 00:00:09,560
When I was a kid, I believed in Santa Claus, I believed in magic, I believed magicians

2
00:00:09,560 --> 00:00:14,400
were really doing magic when they were on stage, and I believed in the Easter Bunny

3
00:00:14,400 --> 00:00:17,920
and all those magical things.

4
00:00:17,920 --> 00:00:26,960
And when I learned Little Older, like, probably I'll have a similar story, there was no magic,

5
00:00:26,960 --> 00:00:34,160
and it was kind of sad, and some years later, I feel like the magic came back.

6
00:00:34,160 --> 00:00:41,440
And to me, tech, you know, the internet, I mean, it's so far beyond anything I could

7
00:00:41,440 --> 00:00:47,480
have imagined and considered magical, you know, and I always talk about magic when I

8
00:00:47,480 --> 00:00:55,120
talk about tech stuff, because to me I'm still in awe, and it's just amazing to the

9
00:00:55,120 --> 00:01:00,240
more you learn, the more you're in awe of all of these things.

10
00:01:00,240 --> 00:01:08,920
And I've been fascinated with Lisp machines, you know, ever since I got into programming.

11
00:01:08,920 --> 00:01:14,640
It's just really great to be here today, I'm so glad to have been asked, and that you've

12
00:01:14,640 --> 00:01:18,880
got such a great group and all these Lisp people here.

13
00:01:18,880 --> 00:01:25,720
I certainly have always felt that the Lisp programmers that I know, the people that are

14
00:01:25,720 --> 00:01:29,840
in the Lisp are the most brilliant software engineers.

15
00:01:29,840 --> 00:01:35,400
I think you know what I'm talking about, it's like people that really are creative, understand

16
00:01:35,400 --> 00:01:41,520
a lot of things, and it's so just awesome to be here with all of you, to meet a lot

17
00:01:41,520 --> 00:01:45,200
of you tonight.

18
00:01:45,200 --> 00:01:55,000
So I spent a lot of years, thirty-five years now, programming Lisp, programming Lisp systems,

19
00:01:55,000 --> 00:02:00,600
and in talking, working out what I was going to talk about, sounded like there was some

20
00:02:00,600 --> 00:02:06,560
interest in, you know, how Cormin Lisp got built and why, and so I'm going to get into

21
00:02:06,560 --> 00:02:12,840
that some, but I also built two other Lisp's, and I think that it's kind of interesting

22
00:02:12,840 --> 00:02:17,800
to talk about that, and I also want to talk a little bit about some projects that I've

23
00:02:17,800 --> 00:02:22,600
done and am working on now, and I didn't really know how to put all that together other than

24
00:02:22,600 --> 00:02:28,480
in a sort of a chronological thing, so I don't want it to be like a scrapbook or something,

25
00:02:28,480 --> 00:02:34,000
I mean I want it, hopefully there's some kind of message you get out of here, and I'm not

26
00:02:34,000 --> 00:02:38,160
just preaching to the choir because I do start to evangelize about Lisp, and I know there's

27
00:02:38,160 --> 00:02:52,280
not a need for that here, but anyway, I will start with where I started, a few things we'll

28
00:02:52,280 --> 00:03:01,160
touch on, why did I develop three Lisp's, I learned Lisp from a musician through essentially

29
00:03:01,200 --> 00:03:09,640
correspondence, of course through the mail, kind of weird, Franz kind of convinced me to

30
00:03:09,640 --> 00:03:15,160
create my own Lisp, and then I think they regretted it later, so this is kind of interesting,

31
00:03:15,160 --> 00:03:22,040
I like Cormin Lisp, what I would say is great about it is I think it's great for hacking,

32
00:03:22,360 --> 00:03:32,280
hacking in the good sense, the white hat sense, I'm interested in other Lisp's, lots of Lisp's

33
00:03:32,280 --> 00:03:40,720
to me, the fact that there's like so many Lisp's, closure and scheme, and whatever Lisp's that are

34
00:03:40,720 --> 00:03:47,160
non-conformant, and ones that people are inventing, to me that's a feature, not a bug, I mean what

35
00:03:47,160 --> 00:03:53,440
other language can you say this about, you know where you could just say a name, a simple name

36
00:03:53,440 --> 00:03:58,720
that describes a whole bunch of languages, and everybody pretty much agrees that they all are

37
00:03:58,720 --> 00:04:07,240
part of that family, and why is the current project I'm working on using a trampoline,

38
00:04:07,240 --> 00:04:16,360
I might get to that if I make it through the slides, so before I got into computing,

39
00:04:17,000 --> 00:04:25,560
I was a musician, a jazz pianist, and I still play, I still do gigs, managed to keep that up over

40
00:04:25,560 --> 00:04:31,720
the years, mostly that was while I was in college that I was doing it professionally, but I was

41
00:04:31,720 --> 00:04:42,440
studying music and computer science at Sonoma State, and computer science classes, I started in

42
00:04:42,520 --> 00:04:49,920
with that and learning Pascal, and it was fun, it was easy, but nothing exciting about it, and my

43
00:04:49,920 --> 00:05:00,840
music professor, Arthur Hills, took a year off, he's an organist and into medieval music, he

44
00:05:00,880 --> 00:05:10,760
took a year off to go study Lisb, and for a sabbatical, and write a Gregorian chant generator,

45
00:05:10,760 --> 00:05:18,720
that's what he did for a year, right, and so he kind of got back in touch, during that year he

46
00:05:18,720 --> 00:05:22,920
got in touch with the people in the music department, and said Sonoma State, and all the other

47
00:05:22,920 --> 00:05:26,960
professors, and said, oh this is great, you got to learn this new language, you got to learn

48
00:05:27,000 --> 00:05:34,240
computer programming, this is in 1981, 1982, and none of them, including him, had done anything with

49
00:05:34,240 --> 00:05:40,000
computers, and he asked me, I wasn't a teacher, but he asked me, because I was a student, a computer

50
00:05:40,000 --> 00:05:52,040
student too, so, I mean yeah, okay, and you know, we started programming on the cyber, it's like a

51
00:05:52,080 --> 00:05:58,080
supercomputer that Sonoma State had, I mean it's designed by Cray, but at very weird architecture

52
00:05:58,080 --> 00:06:04,520
with six-bit bytes, and 60-bit word lengths, and it took two bytes to store a lowercase character,

53
00:06:04,520 --> 00:06:13,560
and one byte to store an uppercase character, and so Art, since he lived, was living in San

54
00:06:13,600 --> 00:06:21,040
Francisco, he would, basically it came down to mostly me and him, he would start to send me

55
00:06:21,040 --> 00:06:29,960
letters, and he would write out longhand these letters about Lisp functions, you know, some code

56
00:06:29,960 --> 00:06:35,520
he was working on with his Gregorian chant generator, or some new, you know, new feature that he

57
00:06:35,520 --> 00:06:41,080
learned, that he wanted to share with me, and sometimes he would take a tractor feed print

58
00:06:41,080 --> 00:06:45,360
out, you know, they're really wide, and fold it all up, and stuff it in the envelope, along with a

59
00:06:45,360 --> 00:06:51,000
handwritten, or typed on his typewriter with lots of corrections, and so this is an example, this

60
00:06:51,000 --> 00:06:58,200
was a postcard, he'd send, hi Roger, I've already conceived improvements of my own, I haven't tried

61
00:06:58,200 --> 00:07:03,400
these yet, but surely they'll work for A-mean, and G-mean, and here's all this code, and after the

62
00:07:03,400 --> 00:07:09,000
last parenthesis, he even signs his name, Arthur, down in the corner, in case I don't know who's

63
00:07:09,040 --> 00:07:15,560
sending me this Lisp code, right, and if you look at the postmarket, it's hard to read, but it's July

64
00:07:15,560 --> 00:07:23,600
17th, 1982, which just about 35 years ago today, so I think that proves I've been using Lisp for that

65
00:07:23,600 --> 00:07:35,800
long, so we, this was basically Lisp 1.5 back in those days, and I just couldn't not believe how

66
00:07:35,840 --> 00:07:44,520
magical it was, how amazing it was to do symbolic computation, and no numbers, you know, I think

67
00:07:44,520 --> 00:07:50,440
worked with Pascal, and with C, you know, everything's a number really, and your C program, your

68
00:07:50,440 --> 00:07:55,920
characters are numbers, and you know, functions are really, you know, addresses, and addresses are

69
00:07:55,920 --> 00:08:00,160
numbers, and you know, just across the board, and you know that, and you have to know that,

70
00:08:00,200 --> 00:08:06,920
and you have to understand to work with it back then, but in Lisp, God, I wrote lots of programs

71
00:08:06,920 --> 00:08:12,880
with no numbers, just lots of lists, and random selections, and application, and I made my own

72
00:08:12,880 --> 00:08:20,000
rules engine, and I worked on a rules engine to do something more original, like it generated

73
00:08:20,160 --> 00:08:25,600
jazz compositions. Okay, Arthur was doing Gregorian chants, I was doing jazz compositions,

74
00:08:29,360 --> 00:08:36,480
but this machine that was like a supercomputer was so fast, it would compile, you know, 5,000 line

75
00:08:36,480 --> 00:08:43,280
Pascal program in a second, you know, and run everything so quickly, my jazz composer generator

76
00:08:44,000 --> 00:08:48,320
would just bring the thing to its knees, you know, it would be like, it would sit there for 30 seconds,

77
00:08:48,320 --> 00:08:52,000
and the other people in the computer lab are complaining that the computer's frozen, and

78
00:08:52,000 --> 00:08:58,480
finally it would time out, and it was working, it's just that it was, I was doing, you know,

79
00:08:58,480 --> 00:09:03,200
multiple levels of recursion and all kinds of stuff that were very inefficient, it was my

80
00:09:03,200 --> 00:09:08,960
own algorithms, my own fault, wasn't the computer's fault, but that got me like, well, how does this

81
00:09:08,960 --> 00:09:15,600
work, you know, disassembling the code, and looking at how, you know, and I found out that like

82
00:09:15,680 --> 00:09:20,800
car and cutter were like two instructions or something on that machine, I mean, it was amazing,

83
00:09:21,360 --> 00:09:23,760
it was amazingly efficient when you started looking at it.

84
00:09:29,600 --> 00:09:36,320
After college, I went to work on microcomputers, 8-bit, 16-bit, very little memory,

85
00:09:38,000 --> 00:09:42,800
I just assumed there was no way you could use lisp on those, after my experience with the

86
00:09:42,800 --> 00:09:50,320
performance thing, I said, okay, you know, I mean, we can use basic or fourth or C, but there was no

87
00:09:50,320 --> 00:09:57,840
way a lisp could possibly run on 64k, but it wasn't entirely true, and after, you know, a couple

88
00:09:57,840 --> 00:10:03,360
years, I started writing my own little lisp interpreters, and using them as scripting languages

89
00:10:03,360 --> 00:10:12,480
inside my C programs, just as AutoCAD or Emacs uses lisp for scripting, and today we would say,

90
00:10:12,480 --> 00:10:17,680
you know, you could use it as for automated testing, and, you know, macros and things like

91
00:10:17,680 --> 00:10:22,560
that, lisp was good for that, and so I started putting them into lots of my, you know, I was doing

92
00:10:22,560 --> 00:10:29,280
computer graphics applications, and so that was useful, and they didn't have to be big,

93
00:10:29,280 --> 00:10:33,920
they just had to be big enough to sort of run the different functions of the application

94
00:10:33,920 --> 00:10:39,840
that they were embedded in, but that's how I learned about how you implement a simple lisp,

95
00:10:39,840 --> 00:10:43,760
I mean, lisp is simple, right, it is simple to make a lisp interpreter.

96
00:10:48,400 --> 00:10:53,120
I didn't really understand how garbage collection worked, that was kind of the hardest part of it,

97
00:10:53,120 --> 00:10:58,320
if you've ever written a garbage collection collector, you know, it's like, that's not so easy,

98
00:10:58,880 --> 00:11:03,760
you got to deal with registers and stacks and all kinds of low level things,

99
00:11:03,760 --> 00:11:15,600
but anyway, that was kind of my first exposure, first use of lisp on, on PCs, and when I moved to

100
00:11:15,600 --> 00:11:23,600
the Mac, fortunately, because the Mac had more memory and was more powerful around that time,

101
00:11:23,600 --> 00:11:32,160
around 1990, I actually saw Mac common lisp in action, and some of you, I'm sure, know Mac common

102
00:11:32,720 --> 00:11:39,120
lisp, coral common lisp, now it's called closure with a Z, and it was an amazing

103
00:11:39,760 --> 00:11:47,360
kind of experience, and it kind of made me realize, wow, lisp could be really, really fast,

104
00:11:48,000 --> 00:11:54,720
I mean, honestly, it seemed like it was as fast as C, and how does that work?

105
00:11:55,680 --> 00:12:01,520
And I would start, you know, read all of their documentation, and like trying to figure out how,

106
00:12:01,520 --> 00:12:04,720
how could, is it, is it really doing what it seems like it's doing?

107
00:12:06,720 --> 00:12:14,080
And it cost $500, and I didn't have $500 to spend on, you know, on a license, since it was more of

108
00:12:14,640 --> 00:12:18,880
less a hobby, at that point, I didn't have a job doing lisp programming,

109
00:12:19,840 --> 00:12:25,920
so I ported over my PC code, and started running that on a Mac, and then started adding all the

110
00:12:25,920 --> 00:12:32,880
common lisp features, because I like the common lisp spec better than the lisp 1.5 spec that I've

111
00:12:32,880 --> 00:12:42,560
been working with, and Mac was big enough to support it, and I ended up developing a pretty

112
00:12:42,560 --> 00:12:51,600
full common lisp, and adding class, and adding, you know, loop, and an editor that was built from

113
00:12:51,600 --> 00:12:57,680
scratch, because we didn't have like, you couldn't just like, take modules, and programs that other

114
00:12:57,680 --> 00:13:01,120
people had written the way you can today, you know, it's like, if you want an editor, basically,

115
00:13:01,120 --> 00:13:08,160
you're going to write it yourself. MarketSweep Collector, had a full 80, 68k,

116
00:13:08,480 --> 00:13:15,520
compiler, code generator, assembler, disassembler, spent years on this,

117
00:13:16,640 --> 00:13:26,080
and it was a lot of fun, release it as shareware, and a lot of people use it, AOL in those days,

118
00:13:26,080 --> 00:13:34,160
we distributed it on AOL, because we didn't have the web yet, and Apple picked it up, and put it

119
00:13:34,160 --> 00:13:39,920
on their developer disk, which was nice, so every month it got sent out to all the Apple developers,

120
00:13:41,520 --> 00:13:49,280
a little notoriety from that. It still didn't begin to compete with Mac common lisp, and speed,

121
00:13:49,280 --> 00:13:52,960
it was cheaper, but it was not anywhere near as fast.

122
00:13:53,120 --> 00:14:05,120
So here it is, running on a PowerBook 170, this is what I developed it, I called it PowerLisp,

123
00:14:05,120 --> 00:14:11,600
because it was developed on a PowerBook, and lest you think this is like an old picture,

124
00:14:11,600 --> 00:14:16,880
I took this two days ago in my office, because that machine still runs, it's a

125
00:14:17,600 --> 00:14:25,360
26 year old machine, and I have to sort of plop it on the table top to get the hard drive to

126
00:14:25,360 --> 00:14:29,520
spin up, I have to sort of knock it around a little bit, but then it gets going and it's pretty good,

127
00:14:30,960 --> 00:14:38,160
surprising what it does, and you can see I got the little disassembly there,

128
00:14:38,240 --> 00:14:48,880
and PowerPC came out, and I redid it for PowerPC, and got into risk architecture,

129
00:14:48,880 --> 00:14:54,000
and learned how all that instruction set, and how arguments are passed, and that was very different,

130
00:14:55,440 --> 00:15:00,880
but you sort of had to do that, if you're on Apple in those days, you had to rewrite your stuff for

131
00:15:00,880 --> 00:15:09,600
PowerPC, and did that, released fat versions of it, fat version meant it would run on PowerPC,

132
00:15:09,600 --> 00:15:18,960
or 68000 max. Questions are fine. How much of the code was actually a assembler versus everything

133
00:15:18,960 --> 00:15:25,200
that you could write on top of it, you were writing a common list, right? So there was a basic,

134
00:15:25,440 --> 00:15:37,360
there was very little assembler in this, mostly a C++ kernel, and then like the compiler, and the

135
00:15:37,360 --> 00:15:45,600
assembler, and all these other parts were all written in Lisp, so mostly Lisp after the kernel,

136
00:15:45,600 --> 00:15:51,920
but it had quite a lot in C++, and I didn't like that, and when I came along later and did another

137
00:15:51,920 --> 00:16:01,440
one, I got rid of most of that, and recoded stuff in Lisp, so kind of a diversion from that path.

138
00:16:02,240 --> 00:16:10,160
Now, I've never really been able to develop Lisp systems for my main job, right? It's always been

139
00:16:10,160 --> 00:16:16,880
kind of a sideline, kind of a hobby. I always had to make money, and there's not that much money,

140
00:16:16,880 --> 00:16:26,480
and that's, I just kept doing it in my evenings, you know, long nights, and at one point I got an

141
00:16:26,480 --> 00:16:36,560
opportunity to build a decision support system for hospital software, which was pretty cool. It was

142
00:16:36,560 --> 00:16:43,520
kind of an AI thing, kind of an expert system to alert physicians to medical problems, and to run

143
00:16:43,520 --> 00:16:49,360
rules that were written in this language called Arden syntax, which is a standard for medical rules,

144
00:16:49,360 --> 00:16:58,880
medical logic, and so I, because I wrote compilers, I got the job, and immediately, you know,

145
00:16:58,880 --> 00:17:06,640
had to build something quickly, and the spec for this language, Arden, was basically, you know,

146
00:17:06,640 --> 00:17:11,760
weakly typed, you know, dynamic typing, it needed garbage collection, it needed a lot of features,

147
00:17:12,240 --> 00:17:18,160
no way I was just going to write this in C, you know, and generate code in C. It just would have

148
00:17:18,160 --> 00:17:24,240
been very inefficient, you know, and you wanted to be able to load rules on the fly, update rules

149
00:17:24,240 --> 00:17:28,960
on the fly, you know, all this stuff, but I thought it would be simple to do this in Lisp, you know,

150
00:17:28,960 --> 00:17:34,800
I could easily generate a Lisp function from these rules, and then those Lisp functions would all

151
00:17:34,800 --> 00:17:39,600
run, and I'd have all the features I needed, and that turned out to have been a very good decision,

152
00:17:39,600 --> 00:17:48,720
so then the problem was, this was back in the mid-90s, companies didn't want you to use any

153
00:17:48,720 --> 00:17:54,560
other language in C++ in those days, it was like the company I was working with at the time just

154
00:17:54,560 --> 00:17:59,200
was like, no, everything's C++, that's just the way it's going to be, you know, there was this idea

155
00:17:59,200 --> 00:18:02,960
that someday everybody was going to be using the same language, that all programming languages

156
00:18:02,960 --> 00:18:08,880
were going to converge, which seems ludicrous today, but that was a thought for a long time,

157
00:18:09,920 --> 00:18:16,560
and so I kind of snuck it in, I just sort of like brought over my code from the Mac,

158
00:18:17,360 --> 00:18:22,560
my Lisp system from the Mac, translated it back to Windows, stripped out a bunch of stuff I didn't

159
00:18:22,560 --> 00:18:35,680
need, and embedded it into the code and said, it's C++, it's all C++, right, and truly that system,

160
00:18:35,680 --> 00:18:43,360
that Arden compiler and everything was mostly written in C++, but the rules all get generated,

161
00:18:43,360 --> 00:18:50,240
all get translated into Lisp, and all get run as Lisp functions, and this system's been very

162
00:18:50,240 --> 00:18:57,120
successful, I can't tell you how successful it's been, and it's definitely the most successful

163
00:18:57,120 --> 00:19:06,640
thing I've worked on. It's still in the top two or three US hospital systems and used today,

164
00:19:07,840 --> 00:19:13,520
I know what it's doing and how it's being used, and we kept expanding it and expanding it to be

165
00:19:13,520 --> 00:19:19,440
used basically as a scripting language for the whole system, so rules don't just alert physicians,

166
00:19:19,440 --> 00:19:24,720
but rules actually fill out forms, you know, look up data in the database and fill out default

167
00:19:24,720 --> 00:19:30,720
values or, you know, prompt the user, there's all kinds of things they do, and I've had the

168
00:19:30,720 --> 00:19:36,800
luck to be sort of work on it over the years and maintaining it, and I've also built a system that

169
00:19:36,800 --> 00:19:44,720
monitors the use of this system in hospitals and logs it, and in one hospital alone, millions of

170
00:19:44,720 --> 00:19:48,800
rules a day are triggered, you know, millions of these Lisp functions a day are triggered,

171
00:19:48,800 --> 00:19:52,960
every single thing that goes into every single patient record goes through all these rules,

172
00:19:53,120 --> 00:19:59,920
and that's the reason that that system is still around 20 years later, because it's getting kind

173
00:19:59,920 --> 00:20:06,800
of, you know, archaic in terms of its age, but it's, we did port it to .NET at one point, so it's

174
00:20:06,800 --> 00:20:16,480
no longer, so it's no longer native code. This is a screenshot of the editor for that system

175
00:20:16,480 --> 00:20:21,120
that's still in use today, it looks old, you know, the user interface looks old because it is,

176
00:20:21,840 --> 00:20:28,240
but it's, if you can see off on the bottom part on the left, there's part of a rule here, there's

177
00:20:28,240 --> 00:20:35,840
not much showing, but the function definition actually shows on that panel on the right,

178
00:20:36,400 --> 00:20:42,000
and you can see that there's a lambda definition, so that's the Lisp code that got generated from

179
00:20:42,000 --> 00:20:50,080
that rule, and this isn't documented and nobody really knows this there, so, but thousands of

180
00:20:50,080 --> 00:20:56,320
users are writing these rules, and the fact that Lisp is in there is completely unknown, most of them.

181
00:20:57,680 --> 00:21:02,240
In fact, if you went to the next tab over the execute tab, there's a repel, there's a hidden

182
00:21:02,240 --> 00:21:07,440
repel, and so I could go in there and like just start executing all kinds of lists, nobody even

183
00:21:07,440 --> 00:21:19,360
knows it's there, right, so it's just kind of interesting. This is just some of the hospitals

184
00:21:19,360 --> 00:21:24,160
that it's running in, New York Presbyterian, Columbia University Cornell, Johns Hopkins,

185
00:21:24,160 --> 00:21:29,840
Cleveland Clinic, Memorial Sloan Kettering, Cancer, National Institute of Health, I mean,

186
00:21:30,640 --> 00:21:34,960
that's just the beginning, but it's, you could tell it's, these are big places, so it's,

187
00:21:36,080 --> 00:21:38,720
you know, we've got Lisp running in those things, and I think that's cool.

188
00:21:39,680 --> 00:21:50,000
There, all scripts has been high on the list of hospitals, software that actually get used by

189
00:21:50,000 --> 00:21:58,000
physicians, as what this is, what CPOE is, physician order entry, or care provider order entry,

190
00:21:58,960 --> 00:22:00,320
so it's been very successful.

191
00:22:04,000 --> 00:22:06,400
Any, any questions, any questions before I move on?

192
00:22:07,360 --> 00:22:10,800
What I'm doing on time? How long am I supposed to talk?

193
00:22:13,600 --> 00:22:19,440
Okay, I'll just, I'll just keep going. I just want to, I probably won't get through all my slides,

194
00:22:19,440 --> 00:22:30,400
but around 1996, I'd say Fritz Kunze, who was the CEO of Franz, makers of Allegro Common Lisp,

195
00:22:30,400 --> 00:22:37,920
contacted me and said, well, why don't you come, come meet me, and you know, in our office,

196
00:22:37,920 --> 00:22:42,400
I have something I want to ask you about, and I, that was great. I got to go down to Franz,

197
00:22:42,400 --> 00:22:49,440
to their office, and, and talk, and what they wanted me to do was pour Allegro Common Lisp to Mac,

198
00:22:50,480 --> 00:22:56,080
because they decided they needed a Mac version, and I'd written a Mac version of Lisp, so I was

199
00:22:56,080 --> 00:23:02,640
a good candidate for that. And so I made them some kind of a bid, like six months or something, you

200
00:23:02,640 --> 00:23:07,840
know, I, no idea how long it was really going to take, but, and, and they never took me up on it,

201
00:23:07,840 --> 00:23:14,560
I think they thought it was too expensive. I don't know, but in the process, they gave me a copy of,

202
00:23:15,120 --> 00:23:21,440
of Allegro Common Lisp for Windows, and it was a big box with a ton of manuals and cost a thousand

203
00:23:21,440 --> 00:23:28,320
dollars, like no way I could ever afford to buy that for myself. Again, you know, unless I was

204
00:23:28,320 --> 00:23:34,080
professional, you know, for professional purpose, but I was very happy, they just gave it to me,

205
00:23:34,800 --> 00:23:43,440
and, and I, I love all the people at Franz are awesome, but when I played with it, this was,

206
00:23:43,440 --> 00:23:51,120
it was crazy, it was like 16-bit fixnums, which was, I think, a holdover from DOS,

207
00:23:51,840 --> 00:23:57,200
you know, and, and this was, this was, you know, Windows 95 was out and Windows NT, and they had

208
00:23:57,200 --> 00:24:02,800
preemptive multi-threading and tons of memory, all these features, and here they were marketing this

209
00:24:02,800 --> 00:24:09,920
system that 16-bit fixnums and eight character limit on filenames, I mean, they were like way

210
00:24:09,920 --> 00:24:16,080
behind the times, and they knew that, I mean, they were like, yeah, well, they had bought it from

211
00:24:16,080 --> 00:24:25,600
some other company, so that they'd have a Windows version, but okay, that, anyway, that was the

212
00:24:25,600 --> 00:24:30,640
state of that, and I, and I was kind of like, well, why don't you guys have your main system

213
00:24:30,640 --> 00:24:35,280
running on it, and they, well, we don't really think Windows is a serious platform, you know,

214
00:24:35,280 --> 00:24:39,760
we've got Unix, you know, our Unix systems is what all the people are really seriously using, and

215
00:24:41,360 --> 00:24:46,240
the Mac one will just be kind of like, you know, we'll see if anybody wants it, but Windows was

216
00:24:46,240 --> 00:24:52,480
not of interest, and then I started going around and going, well, what LISPs are running on Windows,

217
00:24:53,040 --> 00:24:58,480
because at that point in the late 90s, it looked like Windows was the platform, I mean, Windows was

218
00:24:58,480 --> 00:25:03,360
taken off like crazy, and it really was powerful, it was at that point, it got a lot better than the

219
00:25:03,360 --> 00:25:13,840
Mac for some years before OS X, and so LispWorks wasn't running on Windows, they'd see Lisp,

220
00:25:13,840 --> 00:25:18,080
but that was kind of just a port of, you know, something, you know, bytecode compiler,

221
00:25:18,960 --> 00:25:25,600
and it was like, you know, there's a market for here for like a serious Lisp on Windows.

222
00:25:26,080 --> 00:25:34,240
I remember Gold Hill, but I don't think that it got, I think it might have been on

223
00:25:34,240 --> 00:25:44,720
like Windows 3, but not on like Windows 90, I mean, it could have been that that still existed,

224
00:25:44,720 --> 00:25:50,000
I never played with it. In any case, it looked at me like there was a big opportunity for a good

225
00:25:50,000 --> 00:25:57,440
Lisp, so that was when I just decided to get serious and do something like as good as trying

226
00:25:57,440 --> 00:26:03,840
to do something as good as Mac common Lisp in terms of performance, and it had to be a complete

227
00:26:03,840 --> 00:26:09,120
rewrite because I was never going to be able to do it with the code that I built already,

228
00:26:10,000 --> 00:26:16,960
and I knew it needed like a good garbage collector, like a generational garbage collector with

229
00:26:17,040 --> 00:26:24,560
taking advantage of real, you know, hardware virtual memory and, you know, fully tagged.

230
00:26:32,240 --> 00:26:38,400
I kind of modeled it on, in all ways, pretty on what I'd read in Mac common Lisp's

231
00:26:39,200 --> 00:26:46,240
manuals, which are extensive and very enlightening, and again, you know, it wasn't that easy to find

232
00:26:46,240 --> 00:26:52,320
stuff like this, like finding stuff about garbage collectors had been impossible in the 80s, and

233
00:26:52,320 --> 00:26:59,120
in the 90s, it was possible, but mostly it was just some papers that like Henry Baker had written,

234
00:26:59,120 --> 00:27:06,240
like you could find a few papers here and there, but figuring out how to build some of this, and I

235
00:27:06,240 --> 00:27:13,360
wanted to do stew 100% compiled, native compiled, with no interpreter, because actually that's one

236
00:27:13,360 --> 00:27:21,040
of the things I hate about common Lisp is the interpreter slash compiled dual execution path.

237
00:27:24,560 --> 00:27:30,960
So, to step back, everybody's got their own ideas, what they like, and I'd say my favorite things

238
00:27:31,520 --> 00:27:37,920
about Lisp, these are the things I think that make Lisp amazing.

239
00:27:38,880 --> 00:27:45,520
S expressions, is there still not another language that has anything like S expressions,

240
00:27:45,520 --> 00:27:48,320
you know, where the code and the data are the same format?

241
00:27:50,560 --> 00:27:56,720
XSLT, okay, yeah, not as elegant, but okay, yeah.

242
00:27:57,520 --> 00:28:07,600
The Kanzing engine, by Kanzing engine, I mean generates Kanza's fast, doesn't, you know,

243
00:28:07,600 --> 00:28:13,680
you've got a garbage collector to match, it's like every other language can't compete with

244
00:28:13,680 --> 00:28:21,440
a good Lisp in terms of like allocating heap stuff, little heap objects. I found Java VMs,

245
00:28:21,440 --> 00:28:27,600
usually orders of magnitude slower at generating tons of little things, and so the fact that a

246
00:28:27,600 --> 00:28:33,600
Lisp can like generate Kanza's, you know, these eight byte or 16 byte little pieces or small,

247
00:28:34,800 --> 00:28:39,840
you know, tag floats or whatever, can generate those, you know, generate the heap for those and

248
00:28:39,840 --> 00:28:47,760
then clean them up when you throw them away, you know, really fast is a really key element of Lisp

249
00:28:47,760 --> 00:28:54,000
to me, and the fact that you could build any data structure out of Kanza's is great.

250
00:28:58,720 --> 00:29:05,600
I know, I know, yeah, yeah, that's one of the things I don't like about Closure, I guess I'd say,

251
00:29:06,480 --> 00:29:16,160
but macros, well, I've said I guess there's been so many great stuff written about macros and so

252
00:29:16,240 --> 00:29:22,640
many great macros written. Everybody's got garbage collection these days, that's not such a big deal

253
00:29:22,640 --> 00:29:32,160
anymore, but a really efficient one, as I said, for getting rid of tons of, tons of, people worry

254
00:29:32,160 --> 00:29:37,280
about, people were always worrying about Kanzing, you know, when Lisp people were writing, oh, don't

255
00:29:37,280 --> 00:29:44,240
do this, it'll generate too much Kanza, well a good garbage collector is, you know, the amount

256
00:29:44,320 --> 00:29:47,920
of time it takes is relative to the amount of live stuff that you're keeping around,

257
00:29:49,040 --> 00:29:54,880
if it's written right, it's not based on how much stuff you're throwing away, in fact, the one I

258
00:29:54,880 --> 00:30:01,120
wrote takes zero time to throw away, to delete something, I mean, it's all it does is pick up

259
00:30:01,120 --> 00:30:07,280
the live objects and defragment them and move them to a different heap, and zero time is spent,

260
00:30:07,280 --> 00:30:13,840
you know, deleting the dead objects, so you could generate millions of Kanza's and not worry about

261
00:30:13,840 --> 00:30:21,040
garbage collection times, and I really like the multi-paradigm aspects of common Lisp anyway,

262
00:30:21,840 --> 00:30:28,000
you can get, you know, objects if you want, object-oriented paradigms, there it's great,

263
00:30:28,000 --> 00:30:32,880
it's like one of the best, but you don't have to use them, you can use functional, you can use

264
00:30:33,600 --> 00:30:39,840
just simple, you know, procedural programming, works great, whatever you want to do, declarative,

265
00:30:39,840 --> 00:30:45,920
you could make your domain-specific language, just a lot of different, I love that, you know,

266
00:30:45,920 --> 00:30:50,080
I just love not being constricted and having that flexibility.

267
00:30:57,280 --> 00:31:02,400
Some things I don't like about common Lisp, and I'm bringing these up because if you ever used

268
00:31:02,400 --> 00:31:10,320
my system, you'll notice, you'll probably notice, but I don't like the interpreted compile or

269
00:31:10,320 --> 00:31:17,040
compiled model, oh, I'm a Lisp programmer and I write a function, oh, and I run it, oh, well,

270
00:31:17,040 --> 00:31:21,520
but it's not as fast as it should be, oh, well, that's because I didn't compile it, okay, I compile

271
00:31:21,520 --> 00:31:26,480
it, now it does the same thing, but faster, well, why didn't it compile it in the first place,

272
00:31:26,480 --> 00:31:29,840
I didn't get the, oh, because then you wouldn't be able to step through it or something, you wouldn't

273
00:31:29,840 --> 00:31:35,920
mail the trace, you know, to me, that's just crazy, you know, all the common Lisp, all any

274
00:31:35,920 --> 00:31:41,600
language should do is it should make your program run as best it can, you know, when you enter it.

275
00:31:42,480 --> 00:31:42,960
Yeah.

276
00:31:55,440 --> 00:32:02,960
And don't have an interpreter? I don't know why you say that because Frans doesn't do, I mean,

277
00:32:02,960 --> 00:32:08,640
Frans, Allegro interprets and compiles, I mean, I spent three years working with that recently.

278
00:32:12,320 --> 00:32:15,040
You could change the default?

279
00:32:32,160 --> 00:32:36,480
All right, I'm glad you told me that, so I'll remember that next time I'm using it.

280
00:32:37,360 --> 00:32:47,440
And as I said, Frans is like everybody, I love everybody at Frans and they have such a great

281
00:32:47,440 --> 00:32:54,000
compiler, it's the class in common Lisp compilers, my opinion, and I did end up spending $5,000 on

282
00:32:54,000 --> 00:33:04,400
a copy of it when I needed it for a job. I think that the declaration in syntax is atrocious,

283
00:33:04,400 --> 00:33:09,760
unless I just hate declarations, like they just look ugly, they get in the way of perfectly

284
00:33:09,760 --> 00:33:14,720
good code. It's a bunch of stuff that the compiler writer, I mean, that the programmer is supposed

285
00:33:14,720 --> 00:33:20,320
to do to give hints, but you know, what does they know? What does the programmer know about that?

286
00:33:20,320 --> 00:33:26,480
I don't know, it's like, why should they have to worry about that? It's such a huge language that

287
00:33:26,480 --> 00:33:32,160
it's almost impossible to implement. I mean, having worked 10 years implementing when I say that,

288
00:33:32,160 --> 00:33:39,600
it's like ridiculously big. Yes, anybody who has, it's ridiculously big. I mean,

289
00:33:41,280 --> 00:33:47,200
I would never ever take it on again, but I got it, you know, at first, common Lisp, the language

290
00:33:47,200 --> 00:33:52,400
one wasn't that bad, right? But I mean, I'd barely finished implementing that in common Lisp,

291
00:33:52,400 --> 00:33:57,520
the language two came out, and it was twice as big, suddenly, and then I started implementing

292
00:33:57,520 --> 00:34:05,280
that, and then the ANSI spec comes out, and it's like twice as big again. I mean, I'm a guy who

293
00:34:05,280 --> 00:34:11,440
likes a big toolbox. I like a programming language. I don't mind that there's different ways to do

294
00:34:11,440 --> 00:34:18,560
things. I think that's all fine, but it almost is impossible to implement. I mean, it takes a big

295
00:34:18,560 --> 00:34:21,280
organization now. One person cannot do it.

296
00:34:30,480 --> 00:34:41,040
Partly that, you know, you would say it's, nowadays, tons of common Lisp standard would be

297
00:34:41,760 --> 00:34:48,240
in libraries and not just, you know, and so they would be more optional. Like, if there was a

298
00:34:48,240 --> 00:34:55,600
commonly agreed-on subset that was useful, implementers wouldn't have a problem. They

299
00:34:55,600 --> 00:34:59,600
could start with that, right? And then they'd have a useful language, and then, you know, that

300
00:34:59,600 --> 00:35:05,920
could be like the first phase, and they could go on and implement the rest. But as it stands now,

301
00:35:06,000 --> 00:35:14,240
if you don't implement, like, pretty close to 100%, tons of people are going to have, you know,

302
00:35:14,240 --> 00:35:18,640
tons of common Lisp packages that are out there aren't going to work, because they use everything.

303
00:35:19,680 --> 00:35:25,280
There's not a commonly agreed-on set of things. I mean, it all gets used, you know? I mean,

304
00:35:25,280 --> 00:35:29,520
that's a tribute to the people that are doing it. They know their language, and they know what they've

305
00:35:29,520 --> 00:35:36,160
found, these tools, they use them. But it's, I don't like the loop syntax. We were talking about

306
00:35:36,160 --> 00:35:44,000
that a little, you know, to me, it's not Lispy. So, I put in, I just, I think I stole it from,

307
00:35:45,200 --> 00:35:52,320
from SteelBank common Lisp or something, you know, like it's, like, public domain. So, I didn't

308
00:35:52,320 --> 00:35:59,520
write it myself. But, and the whole, the implementation is smart enough to do X, you know?

309
00:35:59,520 --> 00:36:03,440
It's kind of like the people that designed the language weren't really sure how something would

310
00:36:03,440 --> 00:36:06,640
work, and they realized that it was awfully complicated, and it looked like it was going to

311
00:36:06,640 --> 00:36:10,880
perform pretty badly. But, well, those compiler writers in the future, they'll be smart. They'll

312
00:36:10,880 --> 00:36:16,640
figure out some way to, to implement around that. You know, it's like, oh, so many times I bump into

313
00:36:16,640 --> 00:36:33,280
that in the spec. Oh, yeah, well, C loss, I, I think it's the greatest object system there is,

314
00:36:34,240 --> 00:36:41,360
and it's also, in some ways, one of the worst. I, I mean, it does everything, and that's awesome,

315
00:36:41,360 --> 00:36:46,240
and you can hold it up. Anything, anybody else's object system can do, it can do better,

316
00:36:46,640 --> 00:36:52,240
multi-methods and everything else. But, partly, again, that implementing it and making it efficient

317
00:36:52,240 --> 00:36:57,840
is, like, so hard, and then being a programmer and trying to, like, get your, you know, understand

318
00:36:58,640 --> 00:37:05,520
how to make it work, and to make it work well is so complex. And honestly, I'm most of the time,

319
00:37:05,520 --> 00:37:10,640
I just use def struct. Like, structures are great. They're efficient. I know exactly what

320
00:37:10,640 --> 00:37:15,680
they're doing. There's nothing complicated about them. I don't know. I'm just not a big fan.

321
00:37:17,280 --> 00:37:28,640
It took, it took a long time to get the garbage collector working. At least a year, you know,

322
00:37:28,640 --> 00:37:33,440
reading everything I could find about garbage collectors and all the different ways that you

323
00:37:33,440 --> 00:37:41,120
make them work and copy in collectors, and there was, Henry Baker wrote a ton of papers that were

324
00:37:41,120 --> 00:37:52,800
really cool, you know, really useful. And finally, I mean, I built, basically built an IDE, built the

325
00:37:52,800 --> 00:38:02,880
code generator, the assembler for, for Intel, built an FFI based on kind of the, the API that

326
00:38:02,880 --> 00:38:10,160
fonts used in the old version of, the old bad version of Allegro for Windows, which they,

327
00:38:10,960 --> 00:38:16,160
they kind of spanked before when they, when they found out that I'd done it because they have a

328
00:38:16,160 --> 00:38:26,880
better one, but, but it works. And, and release this around 2000. My, my son, when he was a

329
00:38:26,880 --> 00:38:31,360
young, he was somewhat of an artist and he, he made this picture. I thought that, that was

330
00:38:31,360 --> 00:38:36,560
appropriate, that sort of looked like, you know, my, I've been on the keyboard too long and my

331
00:38:36,560 --> 00:38:41,760
fingers are kind of filed down to points and my hair is spikier than usual.

332
00:38:51,120 --> 00:38:56,800
So when I, I'm about ready to like do a first release, and this is a single threaded lisp,

333
00:38:56,800 --> 00:39:02,640
and, and Reiner Joswig, you know, is emailing me and going, you should do multiple threads. You

334
00:39:02,640 --> 00:39:06,640
have to do multiple threads if you're coming out with a new lisp. And I immediately knew he was

335
00:39:06,640 --> 00:39:13,280
right. Like, because I was already using threads in my C++ programs and stuff. And I said, yeah,

336
00:39:13,280 --> 00:39:19,920
but all the lisp's I knew you were, were using lisp threads, you know, sort of cooperative threads

337
00:39:19,920 --> 00:39:24,960
that you could start and stop easily and, you know, manage in the lisp system. It was really one big

338
00:39:24,960 --> 00:39:32,080
thread by the operating system. And I think that was not, not right. I mean, I, I did, I knew enough

339
00:39:32,080 --> 00:39:36,880
about working with threads at that point that I knew you had to use the OS threads. You had to

340
00:39:36,880 --> 00:39:42,640
support that. Windows supports it very well. And, you know, the lisp threads had to be real OS threads

341
00:39:42,640 --> 00:39:49,280
or, or was not competitive with something like C++. And that way, if you've got a multi-processor

342
00:39:49,280 --> 00:39:54,080
machine, which are not too common back then, but coming along, you have parallel execution,

343
00:39:54,160 --> 00:40:00,880
you know, real parallel execution. And that was awesome. I mean, I, I decided to do that.

344
00:40:02,000 --> 00:40:07,440
And it changed practically everything. I mean, it really had to redo almost everything to add

345
00:40:07,440 --> 00:40:14,640
thread support. But I may have been the first or one of the first to actually have, you know,

346
00:40:14,640 --> 00:40:20,560
OS level thread, threading in common lisp. I hate without interrupts. That's one of those things

347
00:40:20,560 --> 00:40:24,560
that you see in a lot of lisp code that uses these lisp threads. It's like always, oh, well,

348
00:40:24,560 --> 00:40:29,760
my synchronization method is that I'm going to basically turn off all the other threads when

349
00:40:29,760 --> 00:40:35,840
I change this variable. You know, and in, in, in Windows, in OS threads, you just can't do that.

350
00:40:35,840 --> 00:40:40,240
You know, you can't just like arbitrarily keep switching threads on and off. You know, you've

351
00:40:40,240 --> 00:40:43,600
got to send them a message or you've got to kill them or something, but they, they're running on

352
00:40:43,600 --> 00:40:50,240
their own. You know, you don't have control, that kind of control. So I think CormidLisp has

353
00:40:50,320 --> 00:40:56,160
a without interrupts in it, but it's kind of not probably really that good to use, not that safe or

354
00:40:56,160 --> 00:41:05,440
efficient. Just to give you an example of all the things had to be changed to support threads,

355
00:41:06,080 --> 00:41:10,880
special variable bindings. You know, I love special variables. I think they're an awesome

356
00:41:10,880 --> 00:41:18,000
feature of lisp. I should add that to that list, that list actually. But according to the common lisp

357
00:41:18,080 --> 00:41:24,480
spec, it, you know, the common lisp spec doesn't address threads. And, and if you read it

358
00:41:25,200 --> 00:41:32,720
precisely, it even basically, you know, says that, you know, when you bind a variable,

359
00:41:32,720 --> 00:41:38,160
it says all programs. It says all lisp programs will now see the new binding.

360
00:41:39,680 --> 00:41:44,160
And, and that, I just realized that can't work. That can't work in a threaded system. Each thread

361
00:41:44,160 --> 00:41:49,840
has to have its own bindings. And I, and I don't, I haven't looked into what other lisps do with

362
00:41:49,840 --> 00:41:55,600
this, but I just implemented every thread has its own bindings. You know, I think that's the only

363
00:41:55,600 --> 00:42:00,960
way to do it personally. But, but once you do it, it's like magic. It's like, once you do it now,

364
00:42:00,960 --> 00:42:08,880
you can have local per thread global variables, special variables as easy as using let. I mean,

365
00:42:08,880 --> 00:42:15,520
it's like, you use them, it makes writing thread safe code actually very easy. Just rebind the

366
00:42:15,520 --> 00:42:20,960
variables using let to themselves or whatever, rebind them at the beginning of your thread.

367
00:42:21,520 --> 00:42:27,200
And then you're good. You have your own copies that only your thread knows about. It's very efficient

368
00:42:27,200 --> 00:42:36,640
and very easy. Heep design and access is affected. You know, you've got to make sure that you

369
00:42:37,600 --> 00:42:42,960
different threads or any thread can trigger garbage collection, right? Could make a memory call,

370
00:42:42,960 --> 00:42:48,320
triggers garbage collection. That means any other thread between any two instructions can,

371
00:42:48,960 --> 00:42:54,160
can have the whole world swept away. That's how the code, that's how the code is. Eating any

372
00:42:54,160 --> 00:43:00,160
two instructions, hardware instructions, the garbage collector can try to like. And when the

373
00:43:00,160 --> 00:43:04,800
garbage collector runs, it moves everything and every address changes. Every function address

374
00:43:04,800 --> 00:43:12,320
changes. The whole world changes. Stack updated, you know. So it's kind of hard to write code,

375
00:43:12,320 --> 00:43:17,680
to generate code that's safe in that kind of an environment when that can happen at any moment.

376
00:43:17,680 --> 00:43:21,360
And a lot of stuff had to be figured out to make that, make that work.

377
00:43:23,840 --> 00:43:29,680
Foreign calls and callbacks. Threads make that more complicated. Your foreign libraries might

378
00:43:29,680 --> 00:43:37,040
not support threads. Who knows? Code generation. Can you generate code in parallel on multiple

379
00:43:37,040 --> 00:43:41,120
threads or should you? You know, they might be trying to update the same functions.

380
00:43:42,720 --> 00:43:49,360
Debugging, of course. Multiple threads. Lisp image saving and loading. If you got a bunch of threads

381
00:43:49,360 --> 00:43:54,880
running and you save the image, you know, are you going to try to restart all those processes when

382
00:43:54,960 --> 00:44:02,160
you load the image? And, you know, thread can come in and call your list code that's not even a

383
00:44:02,160 --> 00:44:08,960
thread you've seen before. It's like one that, you know, where that come from. Now you have to

384
00:44:08,960 --> 00:44:15,040
initialize yourself with your list variable bindings or something. You have problems with

385
00:44:15,040 --> 00:44:21,680
machine architectures that when you're doing a set that they, a simultaneous read can get a different

386
00:44:21,760 --> 00:44:29,840
set of bytes out of the same variable. There's problems where that happens. Yeah, I can imagine.

387
00:44:31,840 --> 00:44:36,160
And this is just a simple, or this is just an example of special variable binding

388
00:44:38,800 --> 00:44:46,080
in Corman list. But, you know, if you've got, instead of just having a slot in a symbol that has the

389
00:44:46,160 --> 00:44:52,720
global variable binding, really those have to be sort of compiled into a table. They're not on the

390
00:44:52,720 --> 00:44:58,160
symbol anymore. They're in their own table. And you don't want to put every symbol in this table

391
00:44:58,880 --> 00:45:03,120
because, you know, if you've got, you might have hundreds of thousands of symbols in your, in your

392
00:45:03,120 --> 00:45:09,840
running system. And most of them, 90% of them, you're never going to rebind. So we only care

393
00:45:09,840 --> 00:45:14,960
about the ones that you're going to bind dynamically. So the compiler and the runtime system needs to

394
00:45:14,960 --> 00:45:22,320
maintain a symbol table that can grow that only has the variable bindings that you need.

395
00:45:23,600 --> 00:45:31,520
And then every thread has to have its own copy of this table so that it can, you know, this thread

396
00:45:31,520 --> 00:45:38,240
can have its own local bindings of those variables, whereas these are still referring to the global

397
00:45:38,240 --> 00:45:43,920
bindings. So that, that's how Corman list dynamic variable binding works basically.

398
00:45:53,200 --> 00:45:59,520
I like getting down and dirty in code. I like just like, as you could tell from what I've told you,

399
00:45:59,520 --> 00:46:07,600
I mean, I like disassembling stuff. I like seeing how things work. I like if somebody has some new

400
00:46:07,600 --> 00:46:14,000
API or some new DLLs or some library, I'd like to be able to just write some Lisp code that calls it.

401
00:46:14,960 --> 00:46:20,560
And it's just really important to me to be able to do anything I could do in like C.

402
00:46:22,880 --> 00:46:29,200
And so Lisp, Corman Lisp really brought out the sort of the low level

403
00:46:30,000 --> 00:46:35,040
ability. The fact that it's only on Windows made this possible, right? If I was trying to support

404
00:46:35,040 --> 00:46:40,400
a bunch of platforms, like say Franz does, I probably wouldn't have done this. But we,

405
00:46:41,200 --> 00:46:48,960
I basically built a lot of different ways to call assembly language, extend the assembler,

406
00:46:48,960 --> 00:46:55,520
you know, to make new operations, which generated code in different ways. A lot of like hacky kind

407
00:46:55,520 --> 00:47:01,360
of things that you could do. So you could easily use it to use, deal with comm objects in, in,

408
00:47:01,920 --> 00:47:07,520
the Windows world comms a big deal. These certain kind of a, you know, built-in object model in

409
00:47:07,520 --> 00:47:13,440
Windows. Def Code Gen lets you define your own sort of code generators, almost like it's,

410
00:47:13,440 --> 00:47:22,160
what a special form would be. And so here's an example of a, just a function, def ASM,

411
00:47:22,800 --> 00:47:30,800
that's all written in assembler, but right in the Lisp file. And the curly braces are used to

412
00:47:30,800 --> 00:47:35,920
designate an assembler block. And as you can see, it looks like, just like Intel assembler, basically,

413
00:47:36,720 --> 00:47:40,720
other than the, you know, the macro, the args offset macro, and a couple things like that.

414
00:47:42,000 --> 00:47:45,520
And if you want to mix assembler right into a Lisp function, you can do that too.

415
00:47:46,400 --> 00:47:53,440
I use the double curly braces in that case. But that's just an example that, it's a normal Lisp

416
00:47:53,440 --> 00:47:58,720
function, it does some Lisp stuff, and then it does some assembler. So you can probably imagine,

417
00:47:59,280 --> 00:48:01,600
if you know what you're doing, you could do almost anything with this.

418
00:48:05,760 --> 00:48:12,320
The assembler has macros. So this is how you define an assembly macro. This particular macro is

419
00:48:13,840 --> 00:48:21,680
the call. It's the way that most Lisp functions get called through callf. And callf pushes a,

420
00:48:21,680 --> 00:48:26,960
pushes the environment, you know, lexical environment on, it will actually puts it in the

421
00:48:26,960 --> 00:48:31,360
DI register and then calls the function. So it's a,

422
00:48:35,680 --> 00:48:44,000
and then we added a way to just basically take big chunks of C headers and bring them in, you know,

423
00:48:44,000 --> 00:48:50,800
so that instead of having to, you know, write Lisp code to, to make the wrappers and bindings on

424
00:48:50,800 --> 00:48:55,840
all of the C functions or the, you know, and this, this thing, it doesn't show it here, but it handles

425
00:48:55,840 --> 00:49:03,920
structures and a lot of macros, defines lots of things. You could just bring direct.h files over

426
00:49:03,920 --> 00:49:09,440
and it will, you know, pull them in and let you call the functions in Lisp. It's very easy.

427
00:49:11,280 --> 00:49:16,880
So I think between all of those things, you know, it makes it easy to use it for, I can make a

428
00:49:16,880 --> 00:49:23,760
Photoshop plugin out of, out of Cormand Lisp, you know, I could generate a DLL that, that could be

429
00:49:23,760 --> 00:49:35,760
used as a plug-in. What's that? I haven't tried, but probably.

430
00:49:40,560 --> 00:49:45,040
I don't know. We can talk about it.

431
00:49:46,000 --> 00:49:56,880
I'll give a little quick demo here of Cormand Lisp running. Nothing too, you know, it's kind of hard

432
00:49:56,880 --> 00:50:04,640
to show this kind of thing, but I have to stop my slideshow, otherwise you won't be able to see it.

433
00:50:04,640 --> 00:50:08,720
Oh, what's Cormand, what's that complaining about?

434
00:50:12,000 --> 00:50:17,280
Remind me later. When you have Windows, when you have a Windows running on a Mac,

435
00:50:18,000 --> 00:50:24,480
it never stops trying to update stuff. You know, it's like, it just drives you crazy.

436
00:50:24,480 --> 00:50:36,720
So, I'm going to put this down for a minute. It's not showing up over there. Oh, it's not.

437
00:50:36,720 --> 00:50:44,800
Okay, so why did it not show up? Just a second. Let's go to displays. Let's say

438
00:50:44,800 --> 00:50:59,920
arrangement, mirror displays. Okay, and it's showing up now, right? Okay.

439
00:51:00,800 --> 00:51:15,680
Now, okay. I just made a program called Minds. I took a program that I found online that's kind

440
00:51:15,680 --> 00:51:22,480
of interesting, and a lot of people have sort of ported it to different languages. It's called

441
00:51:22,480 --> 00:51:34,720
Mind Sweepers, and so I just, for fun recently, ported it from C++ to Lisp, and we've got,

442
00:51:35,920 --> 00:51:38,400
if you look in here, it's got some interesting

443
00:51:41,440 --> 00:51:47,040
bunch of matrix math stuff that we carried over, and it's got neural nets.

444
00:51:48,000 --> 00:51:53,680
The idea is these Mind Sweepers are really dumb when you first turn them on,

445
00:51:54,400 --> 00:52:00,000
and then as they successfully find the minds, they get smarter. And then there's a genetic

446
00:52:00,000 --> 00:52:06,880
algorithm in it, too, that sort of has a random bit pattern that allows it to, you combine those

447
00:52:06,880 --> 00:52:12,960
between different successful Mind Sweepers and they create new ones. So, it combines neural net

448
00:52:13,040 --> 00:52:19,920
and genetic algorithm, and it's kind of cool. So, I'm just going to execute this and run that in a

449
00:52:19,920 --> 00:52:42,240
separate thread, th, create thread, and you see you've got these little guys.

450
00:52:42,960 --> 00:52:50,160
I can change the size, and it'll start to put minds in the other part of the window.

451
00:52:51,360 --> 00:52:58,720
They're really stupidly just going around randomly now. They're not going toward the minds,

452
00:52:58,720 --> 00:53:02,880
particularly, but once in a while they accidentally get one, and they'll go through generations,

453
00:53:02,880 --> 00:53:07,040
and you can go hundreds of generations, and after hundreds of generations, it will start to,

454
00:53:08,000 --> 00:53:12,880
they'll start to be smarter. It seems like it takes too long to me. I think that the

455
00:53:12,880 --> 00:53:19,280
algorithms could be tweaked to have them learn faster, but kind of interesting if we took,

456
00:53:20,080 --> 00:53:26,160
if we wanted to just make some little dynamic changes. Let's see where we are.

457
00:53:26,480 --> 00:53:33,280
I've got a couple of variables here. If we just take,

458
00:53:35,920 --> 00:53:40,640
let's see, Sweeper Scale. I'll take like the Sweeper Scale for controlling the size,

459
00:53:41,360 --> 00:53:48,480
and we just, we wanted to just make it a little bigger on the fly.

460
00:53:49,040 --> 00:54:02,480
You see they got bigger. Do they have senses? They know where the closest mine is,

461
00:54:04,080 --> 00:54:08,800
but what they're not programmed to do is go toward it. Like they have to learn how to go

462
00:54:08,800 --> 00:54:17,040
toward it. You see a lot of them just like turning in circles, but just show you. I mean,

463
00:54:17,120 --> 00:54:21,280
again, we've got fully compiled code, and we can modify it on the fly, and that's pretty cool,

464
00:54:21,280 --> 00:54:28,160
and I can save it as an application. If I was developing a game, I think it'd be pretty nice,

465
00:54:29,200 --> 00:54:32,160
pretty nice interactive development environment.

466
00:54:37,600 --> 00:54:44,560
If we up at the top, you see the little animation Gen 0, Gen 1, that's the garbage collector.

467
00:54:45,360 --> 00:54:52,080
It's mostly just Generation 0. It's just the ephemeral collector. It's got one generation

468
00:54:52,080 --> 00:54:58,640
that keeps getting collected. Generation 1 fills up a lot slower, and then the main one,

469
00:54:58,640 --> 00:55:03,200
you'll hardly notice it growing at all, because most of this stuff gets thrown away.

470
00:55:03,760 --> 00:55:18,080
By the way, on the threads, each thread has its own heap, because otherwise we have to

471
00:55:18,080 --> 00:55:25,120
synchronize around cons, and we don't like to do that. So cons is really fast, because each thread

472
00:55:25,120 --> 00:55:31,680
gets its own sort of mini heap that it keeps refilling from the ephemeral thread, and so they

473
00:55:31,680 --> 00:55:36,880
can allocate small things really quickly. If they allocate something too big, then they go,

474
00:55:36,880 --> 00:55:45,920
then they have to synchronize. I'm having a hard time hearing.

475
00:55:46,240 --> 00:55:52,160
Can a thread be handed a cons or anything else that belongs to another thread?

476
00:55:55,120 --> 00:56:06,560
It can be handed a cons, yes. For example, if you didn't rebind a special variable,

477
00:56:07,680 --> 00:56:10,960
those special variable bindings are shared by all the threads,

478
00:56:11,360 --> 00:56:19,760
and so they're certainly sharing can occur. Since common list doesn't define what things,

479
00:56:19,760 --> 00:56:24,560
like packages and hash tables, and stuff, it doesn't define whether those are thread safe,

480
00:56:24,560 --> 00:56:29,520
because there's no concept of threads. I had to make a lot of just decisions about what to do.

481
00:56:30,160 --> 00:56:37,200
I made hash tables synchronized so that threads couldn't share a hash table, and they wouldn't

482
00:56:38,160 --> 00:56:45,520
have problems, but there's a little overhead there. Probably packages should be synchronized,

483
00:56:45,520 --> 00:56:50,080
and I'm not sure if they are. There's more things that could be synchronized, but generally,

484
00:56:50,080 --> 00:56:57,040
I think you all know you don't want to do that. Generally, we try to avoid sharing between threads,

485
00:56:57,040 --> 00:57:00,560
and if you get an enclosure, they enforce that a lot better.

486
00:57:00,960 --> 00:57:18,560
I don't have too much more anything interesting to demo there, but it's got some nice features

487
00:57:18,560 --> 00:57:25,440
where you can, if I wanted to find the code or do anything, I get a little tool tip there,

488
00:57:26,080 --> 00:57:31,360
and I can also right-click on it and look up the source. Since we include the source to everything,

489
00:57:33,040 --> 00:57:38,880
you can always look up the source to every Lisp function. Here, I just looked up the source to

490
00:57:38,880 --> 00:57:48,240
DefVar, just a macro. For me, I really like to be able to look up the source to all the Lisp

491
00:57:48,240 --> 00:57:53,840
operators in any Lisp I use. You could disassemble it too, but with a macro, that would disassembly

492
00:57:53,840 --> 00:58:03,040
wouldn't do you any good. Any questions on Corman Lisp?

493
00:58:12,480 --> 00:58:18,240
I have a few more slides I could get to, but I know we've gone pretty long here, so I definitely

494
00:58:18,240 --> 00:58:47,920
have gone. I agree with you on that. I certainly feel like Lisp is

495
00:58:48,320 --> 00:58:54,960
so easy to modify and so easy to make it be whatever you want it to be. That's why I say it's a family

496
00:58:54,960 --> 00:59:00,800
of languages. If it doesn't have a particular feature of another Lisp you like, and Corman Lisp,

497
00:59:00,800 --> 00:59:09,120
especially Corman Lisp, is just easy to implement anything. I feel like Closure has a lot of nice

498
00:59:09,120 --> 00:59:15,040
features, say, but I could implement those Closure features in Corman Lisp pretty easily,

499
00:59:15,120 --> 00:59:23,200
I think. I know there are some parts of language that wouldn't be as easy, and the Java VM

500
00:59:23,200 --> 00:59:32,640
interface, obviously. Two questions. In creating your own Lisp, did you make any innovations

501
00:59:32,640 --> 00:59:38,400
around IDE in your own development environment, such as slide and standard stuff for your own thing?

502
00:59:39,040 --> 00:59:46,080
Well, I built this IDE on the Windows Rich Text Edit, which is built into Windows,

503
00:59:46,720 --> 00:59:55,360
so the text windows themselves are all rich text edits, which are calm objects, which Corman Lisp

504
00:59:55,360 --> 01:00:00,880
then calls. When we see a lot of these editor features, those are all written in Lisp and running

505
01:00:00,880 --> 01:00:11,200
in Lisp, the syntax, coloring, and stuff like that. Then it's a C++ Microsoft Foundation Class's

506
01:00:11,200 --> 01:00:21,120
MFC framework. I'm not a very much of a UI programmer, and my UIs always suck. They're

507
01:00:21,120 --> 01:00:27,440
not really beautiful, and that's not where I spend my time. There's nothing really fancy here,

508
01:00:27,440 --> 01:00:33,280
and it looks outdated now. I would like to rewrite the whole editor in Lisp, and that would not be

509
01:00:33,280 --> 01:00:41,920
hard to do, but it's like I needed this to build it. I needed something that it worked with nicely

510
01:00:41,920 --> 01:00:48,160
to build it. When I started, I started with C++ editor.

511
01:00:48,240 --> 01:00:54,640
And then the follow-up question, the same question about around the database,

512
01:00:54,640 --> 01:00:59,840
what should you typically use for your software and stuff like that?

513
01:01:01,840 --> 01:01:05,760
For the database? Did you make something like your own version of LEGO Cache,

514
01:01:05,760 --> 01:01:10,720
or did you just make a connector to a relational database and just use that when you build applications?

515
01:01:11,600 --> 01:01:17,280
I've tended to use SQL databases for most of my projects.

516
01:01:19,600 --> 01:01:24,720
To me, SQL is kind of like Lisp. I mean, SQL relational database is kind of like Lisp in that

517
01:01:25,360 --> 01:01:33,200
they started off really amazing and theoretical, but they sucked performance-wise,

518
01:01:33,760 --> 01:01:37,520
and then people just kept putting more and more and more and more effort into them, and they got

519
01:01:37,520 --> 01:01:43,040
better and better. And now you have these amazing relational databases, and you have these amazing

520
01:01:43,040 --> 01:01:49,920
Lisp systems that so many man-hours and effort went into. And I think SQL database, you know,

521
01:01:49,920 --> 01:01:54,320
they're kind of getting a bad rap now with everybody wanting to go to object databases,

522
01:01:54,320 --> 01:02:04,960
and no SQL and whatever, but generally I'm still content with modern relational databases,

523
01:02:04,960 --> 01:02:09,600
and that's what I've used. I'd like to do something with the LEGO Cache. I think that's an awesome system too.

524
01:02:15,760 --> 01:02:22,560
I definitely recommend a LEGO Cache for any system where you didn't need SQL, you didn't want it.

525
01:02:27,200 --> 01:02:27,680
Yeah.

526
01:02:27,680 --> 01:02:33,360
So what's next? I mean, are you going to sort of just keep proliferating different kinds of

527
01:02:33,440 --> 01:02:35,600
formulas? Are you going to do more DSLs?

528
01:02:36,400 --> 01:02:44,320
Okay, so I might have an interesting slider to left, so I'm going to go ahead and restart this here.

529
01:02:47,840 --> 01:02:57,520
I kind of stopped working on it. Well, I did stop working on it for a long time because I,

530
01:02:57,760 --> 01:03:04,160
the recession hit and our business was, you know, I have a software company and sort of,

531
01:03:04,160 --> 01:03:10,320
we've been an independent software company for 15 years, but it just, you know, all our clients

532
01:03:10,320 --> 01:03:16,640
and contracts went away in 2008, 2009, 2010, and we were kind of hanging on for dear life,

533
01:03:17,360 --> 01:03:24,160
and I just couldn't justify these, you know, nights and effort spent enhancing Corman Lisp,

534
01:03:24,240 --> 01:03:31,920
which I knew was never going to be profitable. And, you know, we just, I just said, and I couldn't

535
01:03:31,920 --> 01:03:36,320
keep, you know, and, you know, the certain amount of client support calls you get and stuff, I just,

536
01:03:36,320 --> 01:03:42,800
so I just, I just stopped doing it. And, you know, a couple, you know, people started letting me know,

537
01:03:42,800 --> 01:03:47,520
yeah, what's going on with Corman Lisp? And I would always say, well, it's on hold for now.

538
01:03:47,520 --> 01:03:54,000
You know, I don't know. And, and that's kind of where it stayed for, for like six years until

539
01:03:54,000 --> 01:03:58,960
Zach Bean came along and said, well, why don't you just open source it? So, you know, people,

540
01:03:58,960 --> 01:04:03,440
other people can work on it. And I said, that sounds great because I'd rather other people

541
01:04:03,440 --> 01:04:09,760
worked on it and it continued to evolve. I think the code's written well, you know, but on the

542
01:04:09,760 --> 01:04:15,280
other hand, it's incredibly complex. And I always kind of wondered, could anybody else work on it?

543
01:04:15,280 --> 01:04:20,560
You know, could anybody figure it out to like fix the bugs that come up in the garbage collector

544
01:04:20,560 --> 01:04:26,400
or whatever? I can barely remember or figure some of that stuff out. But once I open sourced it,

545
01:04:26,400 --> 01:04:32,640
it's an MIT license now. Zach did the work kind of like, you know, getting rid of the licensing

546
01:04:32,640 --> 01:04:41,760
stuff that was in there and everything. And one Artem Boldarev, I think that's his name right,

547
01:04:41,760 --> 01:04:48,640
he's a Ukrainian guy, a young guy. He, he's been taking, kind of taken over, done a lot of stuff

548
01:04:48,640 --> 01:04:56,080
on it. And he fixed a really significant bug that I had with 64-bit windows. Like, like, mostly

549
01:04:56,080 --> 01:05:01,280
every program out there that runs on 32-bit windows will run on 64-bit windows as a six,

550
01:05:01,280 --> 01:05:09,040
as a 32-bit process. This was one that had some problems. And it turns out it has to do with

551
01:05:09,040 --> 01:05:18,080
the thunking between the 34 and 60, the 32 and 64-bit layers. When you are calling out to a

552
01:05:18,080 --> 01:05:26,080
OS call, it's actually always thunking the 64 bits and then coming back to 32 bits. And structured

553
01:05:26,080 --> 01:05:33,200
exceptions don't propagate properly across that thunk. And we were relying on structured exceptions

554
01:05:33,280 --> 01:05:39,040
to implement the right barrier that the, that the garbage collector use. You probably don't know

555
01:05:39,040 --> 01:05:43,040
what a right barrier is, but that's something that has to do with the virtual memory system and

556
01:05:43,040 --> 01:05:49,520
makes the garbage collector really fast. And that was like crashing when you were in a 64-bit

557
01:05:49,520 --> 01:05:56,560
OS and you were doing, you know, FFI calls and callbacks, you know, and he tracked that down.

558
01:05:56,560 --> 01:06:02,400
And I was very impressed. He tracked it down and figured out how to catch the exceptions and how to,

559
01:06:02,400 --> 01:06:08,800
you know, repropagate them and got it working again, you know, in 64-bit. And so then I said,

560
01:06:09,840 --> 01:06:16,160
okay, I want to work on it now. And I've been, I've kind of gotten back into it in the last,

561
01:06:16,160 --> 01:06:22,240
in the last year. Having someone else to work on it with is really great. And of course,

562
01:06:22,240 --> 01:06:28,400
that's the beauty of open source. You can find, I've got somebody from Ukraine. A lot of the work

563
01:06:28,400 --> 01:06:36,640
was done by Vasily Baikov in the earlier days, who's Russian. And he did tons of, he did tons of

564
01:06:36,640 --> 01:06:44,240
stuff in Common Lisp. And it kind of sounds like I'm colluding with the Russians, which I am.

565
01:06:46,000 --> 01:06:54,000
But then basically since then, I've started to use Clojure. I like Common Lisp, but I'm,

566
01:06:54,560 --> 01:07:01,280
I will, I'll never, as much as I love Lisp and I evangelize about it, I won't,

567
01:07:02,640 --> 01:07:06,400
I won't promote it to a client if I don't think it's the right tool for the job.

568
01:07:07,280 --> 01:07:12,400
And a lot of times I think Clojure is a better tool for the job these days. More,

569
01:07:13,840 --> 01:07:19,200
more people are getting into it. The fact that it runs on the Java VM and can run everywhere.

570
01:07:19,680 --> 01:07:27,040
The fact that it's simpler, it's a simpler language. The fact that it can run on the .NET,

571
01:07:27,040 --> 01:07:31,600
which is a platform I've been heavily involved with, the .NET version of Clojure.

572
01:07:33,280 --> 01:07:38,160
There's a lot to like about it. Macros are good enough for me, the way they did macros,

573
01:07:38,160 --> 01:07:44,400
it's, you could do what you want with them. As we said, the S expressions are a little different,

574
01:07:45,200 --> 01:07:52,000
everything's like, there's no dot pairs. You can't put whatever you want on the right side of a

575
01:07:52,000 --> 01:07:59,680
con's call, which is kind of weird. Weird and good, depending on your perspective.

576
01:08:07,120 --> 01:08:11,600
I've never really used Scheme very much, but I'm really interested in it.

577
01:08:12,400 --> 01:08:17,280
And I don't know why, I just, I got into Common Lisp early and I just,

578
01:08:18,400 --> 01:08:24,240
you know, but one of my favorite books in the world is Christian Kennecks Lisp in Small Pieces,

579
01:08:25,120 --> 01:08:30,240
which if you've ever read, you know, he's a Scheme guy and he writes like 30 different

580
01:08:31,520 --> 01:08:37,520
Scheme, Lisp and Scheme interpreters and compilers that he presents in this book. And it's,

581
01:08:38,240 --> 01:08:41,120
for me, it was nice bedside reading.

582
01:08:44,880 --> 01:08:49,920
So I'm building another version of my Arden syntax compiler, this one that I own,

583
01:08:50,960 --> 01:08:57,120
using Clojure. And it was kind of neat because we could take, if you know how you build a compiler,

584
01:08:57,120 --> 01:09:04,960
you have these Bacchus Naur forms. And I just took what you see in comments there is straight

585
01:09:04,960 --> 01:09:11,600
out of the spec for Arden syntax, the BNF straight out of the spec. And then I sort of just

586
01:09:11,600 --> 01:09:17,760
made the, you know, made a macro, a macro parse rule that takes the language as it shows up in

587
01:09:17,760 --> 01:09:23,760
the spec and turns it into a code generator, a parser and a code generator. And the next

588
01:09:23,760 --> 01:09:30,480
expression there is the generated code basically in Clojure. And so this parser actually works

589
01:09:31,200 --> 01:09:36,720
just off of these. And it makes it, you know, pretty easy to write the parser and pretty easy

590
01:09:36,720 --> 01:09:41,040
to update it. And if the spec changes, it's pretty easy to see when it diverges or when, you know,

591
01:09:41,040 --> 01:09:47,600
where you have to change. It's slower than my hand coded C++ parser that I wrote before, but

592
01:09:49,440 --> 01:09:54,720
I, you know, probably could still make it faster. But it was a nice project to do in Clojure. And

593
01:09:54,800 --> 01:09:59,840
I've liked it for that. I could do it in Common Lisp too. It would probably be even, you know,

594
01:09:59,840 --> 01:10:04,800
could probably have written it more easily. But again, I wanted to run a .NET. And

595
01:10:08,720 --> 01:10:12,160
so if I said what I like about Clojure, all those things that I liked about Lisp,

596
01:10:13,600 --> 01:10:19,520
S expressions, consing engine, macros, garbage collection, functional paradigm, not so much on

597
01:10:19,520 --> 01:10:27,360
the object oriented paradigm or the procedural, the fact that it has such a user base and very

598
01:10:27,360 --> 01:10:37,280
good implementation and runs on practically every platform. I say, I think all Lisp languages are

599
01:10:37,280 --> 01:10:44,960
Lisp family. They're all part of the same family. And to me, if I love one, I love them all. And I

600
01:10:45,840 --> 01:10:52,000
with macros, I could make Clojure do what I want. I'm sure of that. It does take some getting used

601
01:10:52,000 --> 01:10:59,600
to not being able to mutate variables, getting rid of set Q basically. And you could get around it

602
01:10:59,600 --> 01:11:05,360
by just creating a single cell Java arrays and using those for your mutatable variables that

603
01:11:05,360 --> 01:11:10,480
can be shared. You know, if you have to, it's pretty easy to get around. So it's not like,

604
01:11:11,120 --> 01:11:14,880
but of course, it's kind of ugly. The whole Java interface part of it's,

605
01:11:15,600 --> 01:11:19,280
you know, it's, you have to use it too many places, I think. But

606
01:11:23,600 --> 01:11:28,480
and the last thing I had here, I was going to mention is I'm getting into continuations now,

607
01:11:28,480 --> 01:11:33,280
which I never did. You know, all these years of doing common Lisp, I never used continuations.

608
01:11:34,240 --> 01:11:38,640
And I, all I thought was like, I'd never wanted to try to implement them because it seemed too

609
01:11:38,640 --> 01:11:45,440
hard or too inefficient to be saving and restoring the stack all the time. And so

610
01:11:46,640 --> 01:11:52,160
now I have a language I'm implementing and this uses fuzzy logic new version of Arden 2.9.

611
01:11:52,960 --> 01:11:58,320
And the control flow is fuzzy. So if you have an if statement and the condition is

612
01:11:59,680 --> 01:12:08,080
somewhere between true and false, it splits into two paths of execution. And so this kind of an

613
01:12:08,080 --> 01:12:15,200
execution model requires backtracking and something that continuations can do. And I don't know what

614
01:12:15,200 --> 01:12:23,520
else could, you know, and the only other alternative that I've come up with is to do in continuations

615
01:12:23,520 --> 01:12:30,160
is to use continuation passing style, you know, where you, every function gets a continuation

616
01:12:30,160 --> 01:12:35,840
passed in and returns a continuation. And then you use a trampoline, which is just a little loop

617
01:12:35,840 --> 01:12:41,040
that just keeps calls, gets a continuation back, calls that continuation back, gets a

618
01:12:41,040 --> 01:12:45,840
continuation back. In the end, you have no stack. So your continuations don't have to worry about

619
01:12:45,840 --> 01:12:51,920
saving and restoring the stack. I mean, you, you, you avoid that problem, which is what's hard about

620
01:12:51,920 --> 01:12:57,040
continuations, saving and restoring the stack. And you cannot do them on the, you cannot do that on

621
01:12:57,040 --> 01:13:01,920
Java VM or CLR to my knowledge. It doesn't, doesn't support that.

622
01:13:02,880 --> 01:13:11,360
Have you considered rewriting some of those algorithms and say using a star or some other

623
01:13:12,240 --> 01:13:19,840
form other than continuation? You know, I don't know exactly the details of the problem you're

624
01:13:19,840 --> 01:13:25,120
trying to solve, but maybe you're out with the wrong algorithm. Yeah, and I bet you, you could

625
01:13:25,120 --> 01:13:29,920
help me with that. It's actually one of the first problems I've ever bumped into that I didn't,

626
01:13:30,720 --> 01:13:34,640
you know, I still haven't solved. I mean, it was very, I'm having a tough time with it.

627
01:13:35,600 --> 01:13:46,160
So I'm open to suggestions and advice. Okay, so I know all of you have like great stories about

628
01:13:46,160 --> 01:13:52,160
what you've done with Lisp. And I'd love to know more about them. And I'm really, really happy. I

629
01:13:52,160 --> 01:13:58,400
got to be the one up here today, talking about my story, not that it's any better than anybody else's

630
01:13:58,400 --> 01:14:04,240
story. But I'm thankful that I had the chance because normally I never find anybody that wants to

631
01:14:04,240 --> 01:14:10,800
talk about this stuff or hear about it, right? In my regular life, right? So getting to meet,

632
01:14:10,800 --> 01:14:17,360
you know, be with this many Lisp programmers at once is, is really unusual and just great for me.

633
01:14:18,080 --> 01:14:23,760
So thanks a lot. And I hope you've learned something, something of value tonight.

634
01:14:23,760 --> 01:14:31,620
Thank you.

