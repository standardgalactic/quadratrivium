1
00:00:00,000 --> 00:00:07,680
My name is Jason Yelik, and I'd like to talk with you about the Hyperledger Fabric Lifecycle

2
00:00:07,680 --> 00:00:17,520
today. In particular, the new distributed chain code lifecycle introduced in version 2.0 of Hyperledger

3
00:00:17,520 --> 00:00:25,600
Fabric. Today, we'll be starting by talking about an overview of the version 1.x lifecycle,

4
00:00:25,600 --> 00:00:31,680
so basically how chain code lifecycle has worked up until version 2.0. Then we'll do a similar

5
00:00:31,680 --> 00:00:38,160
discussion of the version 2.0 lifecycle, sort of a high level, including a workflow for that,

6
00:00:38,720 --> 00:00:45,600
and then some permutations around that workflow. Finally, we'll move on to details about the

7
00:00:45,600 --> 00:00:52,320
version 2.0 lifecycle, and then finally some other notes and considerations that you should keep in

8
00:00:52,320 --> 00:01:01,840
mind when dealing with the v2 lifecycle. Starting out with how chain code lifecycle worked in

9
00:01:01,840 --> 00:01:09,040
Fabric 1.x. This should be a pretty familiar picture. You have a couple organizations,

10
00:01:09,840 --> 00:01:15,920
their respective admins, and an ordering service, and we would like to get chain code installed

11
00:01:15,920 --> 00:01:25,120
and instantiated so that we can begin transacting on the blockchain. So step one, each org admin

12
00:01:25,120 --> 00:01:35,440
installs the chain code to one or more of their peers. Step two, one of the admins goes out and

13
00:01:35,440 --> 00:01:44,480
does a LSCC deploy or upgrade transaction to instantiate that chain code, gets the result,

14
00:01:44,480 --> 00:01:50,240
submits it to ordering, commits it all the peers, and now the chain code is up and running.

15
00:01:52,240 --> 00:01:57,040
It's basically a two-step process, which is nice because it's a small number of steps,

16
00:01:58,240 --> 00:02:05,920
but it has a lot of drawbacks. To begin with, installing a chain code

17
00:02:06,880 --> 00:02:15,520
sort of grants this unconditional agreement to run that chain code on any channel that your

18
00:02:16,240 --> 00:02:20,960
peer is joined to, whether or not you agree that that chain code should run on that channel,

19
00:02:21,600 --> 00:02:27,520
or whether you agree to the assorted parameters to that instantiation. So for instance,

20
00:02:28,800 --> 00:02:33,760
you might want a certain endorsement policy associated with that chain code.

21
00:02:34,640 --> 00:02:40,400
You might want to have control over when that chain code is upgraded and downgraded,

22
00:02:42,160 --> 00:02:48,320
and you might simply not want to execute that chain code. So that's sort of one of the first big

23
00:02:48,320 --> 00:02:58,880
problems, and this is where we talk about this sort of distributed chain code life cycle,

24
00:02:59,760 --> 00:03:06,320
or sort of distributed government, the governance distributed agreement. So continuing,

25
00:03:07,040 --> 00:03:12,800
so when we say that the new life cycle is decentralized, that's what we're talking

26
00:03:12,800 --> 00:03:19,040
about, that it's not just one admin making the decisions, that that's a problem we had in the

27
00:03:19,040 --> 00:03:22,960
previous life cycle, and that's something the new life cycle is here to address.

28
00:03:23,920 --> 00:03:32,720
Now, the second problem, which is a little less obvious, is that the instantiation, i.e. that deploy

29
00:03:32,720 --> 00:03:39,120
or that upgrade transaction, that includes invoking a knit of the deployed chain code.

30
00:03:40,160 --> 00:03:46,080
But if we look at our picture here, you can see that that transaction actually only executes on

31
00:03:46,080 --> 00:03:54,080
Ord1's peer. So even though we may have set an endorsement policy for this chain code,

32
00:03:54,080 --> 00:04:00,160
that initial invocation of a knit doesn't respect that endorsement policy. And you know,

33
00:04:00,960 --> 00:04:05,280
in a lot of ways that's fine because it's being invoked by a trusted user and some other things,

34
00:04:05,280 --> 00:04:12,640
but it's still an asymmetry, and it's something that we wanted to fix. And then finally,

35
00:04:13,600 --> 00:04:20,560
this is more of an operational one. If you've ever tried to operate a fabric network and you've

36
00:04:20,560 --> 00:04:25,920
tried onboarding new orgs and that sort of thing, what you'll quickly realize is that

37
00:04:26,560 --> 00:04:31,200
even though you don't want to change anything about the code of your chain code, any of the

38
00:04:31,200 --> 00:04:36,320
chain code logic, if you want to modify, say, the endorsement policy to include a new org,

39
00:04:36,880 --> 00:04:41,440
well, you actually have to go through this whole process of installing the chain code

40
00:04:41,520 --> 00:04:50,160
and performing an upgrade across the network, which is really unnecessary and causes a lot of churn

41
00:04:50,160 --> 00:04:56,480
that's a bit of a pain, operationally speaking. So these are sort of the three big problems that

42
00:04:58,080 --> 00:05:04,160
we encountered in the original chain code lifecycle, which sort of leads to the three

43
00:05:04,960 --> 00:05:14,400
principles for the new v2 decentralized lifecycle. So first one is that peers only participate in a

44
00:05:14,400 --> 00:05:23,040
chain code. If the org admin explicitly agrees, yes, I like this configuration for the chain code.

45
00:05:24,000 --> 00:05:36,400
So until the orgs admin agrees, that peer will not endorse the definition, the instantiation,

46
00:05:37,440 --> 00:05:42,640
and further it will not endorse any invocation of that chain code, including its init function.

47
00:05:43,920 --> 00:05:48,880
So this basically, if we go back to our previous slide, we said that the

48
00:05:49,840 --> 00:05:53,840
installing agrees to instantiate unconditionally, this fixes that problem.

49
00:05:55,440 --> 00:06:01,520
Secondly, no exceptions to endorsement policies. This corresponds to our second problem we

50
00:06:01,520 --> 00:06:07,360
enumerated, which is the chain code init should be subject to the same endorsement policy as the

51
00:06:07,440 --> 00:06:18,960
rest of the invocations. So we enforce that chain code init abides by the

52
00:06:19,840 --> 00:06:26,400
endorsement policy as defined for the chain code, just like every other transaction.

53
00:06:27,440 --> 00:06:34,720
But secondly, and this one is a little more subtle, in the v1.x lifecycle,

54
00:06:34,800 --> 00:06:43,840
lscc really didn't have an endorsement policy. So in the v2 distributed lifecycle, we also

55
00:06:43,840 --> 00:06:49,120
enforce that the lifecycle at chain code itself is governed by an endorsement policy

56
00:06:49,120 --> 00:06:51,840
and decisions are validated based on that endorsement policy.

57
00:06:53,840 --> 00:06:58,960
So finally, the third parameter, which comes back to our operational problems,

58
00:06:59,920 --> 00:07:05,360
is that you should be able to modify your chain code definition, you should be able to change

59
00:07:05,360 --> 00:07:12,560
the endorsement policy, add collections, etc., without requiring an upgrade of the code across

60
00:07:12,560 --> 00:07:20,240
the network. So those three things are sort of the guiding principles behind the design of the

61
00:07:20,960 --> 00:07:27,840
v2 decentralized lifecycle, and you'll be able to see that reflected in

62
00:07:29,520 --> 00:07:34,080
just a moment when we do an overview of how the decentralized lifecycle works.

63
00:07:35,840 --> 00:07:45,200
Now, before we go into the overview of how the lifecycle works, it's important to mention

64
00:07:45,280 --> 00:07:52,880
sort of an implementation detail. And that's that v2 lifecycle is very much

65
00:07:53,600 --> 00:07:58,720
powered by a new v2 concept, and that is organization implicit collections.

66
00:07:59,600 --> 00:08:06,560
Now, if you're at all familiar with private data collections from v1.2 or 3 onwards,

67
00:08:07,920 --> 00:08:12,640
you'll know that the basic idea is that it's a namespace that's reserved

68
00:08:12,640 --> 00:08:18,160
that only certain members can read. So on v2, we've sort of extended that concept,

69
00:08:18,720 --> 00:08:26,560
and you can now associate which members can write to that namespace. And there's the set of

70
00:08:26,560 --> 00:08:32,880
implicit collections, which are defined implicitly, i.e. they're there without you having to do

71
00:08:32,880 --> 00:08:40,000
anything to define them. And you get one implicit collection per organization in your channel,

72
00:08:40,640 --> 00:08:45,120
and only peers from that organization may write to it, and only peers from that

73
00:08:45,120 --> 00:08:50,560
organization may read from it. So this allows you to implement a lot of interesting things

74
00:08:50,560 --> 00:08:55,840
in your chain code that weren't previously possible, notably things like voting schemes,

75
00:08:56,720 --> 00:09:02,960
and ways for a chain code of one org to make a different decision than a chain code of another.

76
00:09:03,920 --> 00:09:09,920
So that's a bit of a side note, and I don't want to get too off topic here, but

77
00:09:10,960 --> 00:09:13,920
implicit collections are sort of the underpinning

78
00:09:16,400 --> 00:09:22,000
technology behind the new v2 lifecycle, and you can use this in your own chain codes as well.

79
00:09:24,240 --> 00:09:31,520
So back to that overview. Just like with the v1.x lifecycle and the v2 lifecycle,

80
00:09:31,600 --> 00:09:36,640
the first thing we do is an install. Now the packaging format has been changed,

81
00:09:37,200 --> 00:09:42,080
there are some different things about the install, but conceptually, it's still just an install,

82
00:09:42,080 --> 00:09:45,040
you're putting the chain code's code package onto the file system,

83
00:09:46,320 --> 00:09:51,200
and that takes place as your first step performed by each admin, respectively.

84
00:09:52,640 --> 00:09:55,600
Secondly, and this is where things start to differ a little bit,

85
00:09:56,560 --> 00:10:04,080
um, org one's admin, in this case, is going to execute an approve for my org function against

86
00:10:04,080 --> 00:10:10,640
his peer, send that to ordering, and it commits. Now this is modifying the implicit collection

87
00:10:10,640 --> 00:10:17,840
for org one, indicating that org one agrees with this particular chain code definition

88
00:10:17,840 --> 00:10:25,680
that org one's admin is approving. Now org two's admin is going to do the very same thing,

89
00:10:26,560 --> 00:10:31,280
sends to his own peer, his approval, submits that to ordering, it commits,

90
00:10:32,080 --> 00:10:37,600
and now we have an entry in the implicit collection for each org, indicating agreement to some

91
00:10:37,600 --> 00:10:44,560
chain code definition. At this point, org one's admin, or it could be org two's,

92
00:10:44,560 --> 00:10:51,600
but we'll use org one's in this case, invokes the lifecycle chain code on one of his peers,

93
00:10:52,240 --> 00:10:59,280
and one of org two's peers, saying let's go ahead and commit this definition,

94
00:10:59,920 --> 00:11:03,760
submits that to the ordering service, it commits in the public namespace,

95
00:11:04,400 --> 00:11:10,160
and now the chain code is defined. The definition that was approved by the two

96
00:11:10,160 --> 00:11:15,920
org admins have committed, and the chain code was ready to execute. At this point,

97
00:11:16,960 --> 00:11:24,640
typically the same user who did the commit of the definition would be the one who invokes

98
00:11:24,640 --> 00:11:35,600
init, and init can execute just like any other chain code invocation. The peer will track whether

99
00:11:35,840 --> 00:11:39,360
or not init has been called and enforce that it's the first function called,

100
00:11:40,640 --> 00:11:46,480
but I think as people get used to this new decentralized lifecycle,

101
00:11:49,840 --> 00:11:56,400
you'll realize more and more that init usually isn't necessary, and it's actually a whole lot

102
00:11:56,400 --> 00:12:02,480
easier and more flexible to implement init logic inside the chain code itself if needed.

103
00:12:03,440 --> 00:12:11,040
You know, a couple examples for this could be, first off, if you implement init inside a chain

104
00:12:11,040 --> 00:12:18,480
code, you can require each org to perform some action before the chain code is initialized,

105
00:12:19,120 --> 00:12:27,280
or if you're doing something like upgrading your key schema, you can require a series of transactions

106
00:12:28,080 --> 00:12:32,640
that modify your database layout before you allow normal transactions to begin,

107
00:12:33,360 --> 00:12:39,360
because a single transaction would be too large. And really, to implement init logic,

108
00:12:40,000 --> 00:12:46,240
it's really very simple. You just pick a reserved key, perform a read against that key, and see

109
00:12:46,240 --> 00:12:52,480
whether it says the chain code has been initialized or not. If it's not, enforce init, otherwise,

110
00:12:53,040 --> 00:12:58,640
allow things through as usual. And in fact, that's all fabric does for you

111
00:12:59,520 --> 00:13:12,000
when in your definition you require init. So, with the new lifecycle, not only

112
00:13:14,160 --> 00:13:19,680
are the semantics a little different, we had to pick a new name for lifecycle. Now, if you're

113
00:13:22,480 --> 00:13:29,280
familiar with operating a fabric v1.x network, you'll know that lifecycle operations were done

114
00:13:29,280 --> 00:13:36,720
through a system chain code called lscc. So, lscc is no longer the chain code used for

115
00:13:36,720 --> 00:13:43,120
lifecycle operations. Instead, there's a new system chain code called underscore lifecycle.

116
00:13:44,640 --> 00:13:51,920
And the underscore in the front is a prefix to indicate that it's a system name space,

117
00:13:52,720 --> 00:13:57,840
the suffix of ending chain codes in scc to indicate system name spaces was

118
00:13:59,760 --> 00:14:07,200
not one of the better ideas in fabric v1.x. So, underscore is now a reserve system name space,

119
00:14:07,200 --> 00:14:17,200
underscore lifecycle is the lifecycle system chain code. And in fabric v2, both the underscore

120
00:14:17,200 --> 00:14:26,080
lifecycle and the lscc chain codes exist. Both are functional. And in the event that

121
00:14:26,880 --> 00:14:32,080
the distributed lifecycle has been enabled, first we'll check definitions done in the new

122
00:14:32,080 --> 00:14:38,320
lifecycle. And if there's nothing there, we fall back to the old lifecycle. But it is important

123
00:14:38,320 --> 00:14:47,040
to note that eventually fabric will be removing support for the legacy lscc. So, it's a good

124
00:14:47,040 --> 00:14:51,920
idea to go ahead and migrate onto this new lifecycle as soon as possible because

125
00:14:52,880 --> 00:15:01,280
at a later fabric version, lscc will be removed. And you'll be forced to move there eventually.

126
00:15:04,720 --> 00:15:10,240
So, let's talk about how lifecycle works sort of from a user perspective.

127
00:15:10,960 --> 00:15:18,240
Let's say you have three organizations, org one, org two, and org three. And everyone wants to

128
00:15:18,880 --> 00:15:27,840
run chain code mycc. And we've agreed that two out of three orgs must agree that's the endorsement

129
00:15:27,840 --> 00:15:36,480
policy we want to go with. So, what would this look like implemented? Someone's got to take the

130
00:15:37,040 --> 00:15:43,360
lead. Someone has to sort of administrate the process. And for here, we've chosen org one,

131
00:15:43,360 --> 00:15:48,880
but it could be really any admin. And what they would do is they would package this chain code

132
00:15:49,920 --> 00:15:59,440
using the pure CLI into what is now just a standard tar GZ. And disseminate that package to

133
00:15:59,440 --> 00:16:06,080
the other orgs. Now, the other orgs, they can take a look at this package. And unlike in fabric

134
00:16:06,160 --> 00:16:12,640
v1.x, where the package format was sort of a fabric specific thing, a CDS file,

135
00:16:14,320 --> 00:16:22,080
in the v2 lifecycle, these packages are standard tar GZs. So, an admin can simply

136
00:16:22,080 --> 00:16:26,960
use whatever commodity tooling they would like to take a look at that package, make sure it is,

137
00:16:26,960 --> 00:16:34,320
in fact, the chain code that they want to install. Now, everyone goes and installs this

138
00:16:34,320 --> 00:16:43,200
chain code package and commits that approval, sends that approve for my org transaction through,

139
00:16:44,240 --> 00:16:51,360
according to the parameters that we sort of agreed out of band. So, this is my cc, it's version one,

140
00:16:52,320 --> 00:16:57,840
the endorsement policy is two out of three and so forth. Once everyone's done their approval,

141
00:16:57,920 --> 00:17:03,920
and again, typically we would wait for everyone, then the administrative org one

142
00:17:04,880 --> 00:17:08,640
sends the transaction to commit the chain code definition for that channel,

143
00:17:09,280 --> 00:17:18,000
and the chain code is now operational. So, let's look at this visually. We have three peers.

144
00:17:19,440 --> 00:17:23,440
The administrators install the chain code on each of those three peers.

145
00:17:24,000 --> 00:17:29,840
They approve the chain code with all of the same parameters,

146
00:17:31,920 --> 00:17:38,080
and then they commit that chain code definition, and now the chain code is defined,

147
00:17:38,800 --> 00:17:46,000
all three peers are ready to execute it. This is the standard workflow and, you know, what you

148
00:17:46,000 --> 00:17:52,800
can expect to happen in most production fabric networks. You know, everyone is in sync, everyone

149
00:17:52,880 --> 00:17:59,200
is in agreement, everyone does the same approval, and once everyone is ready, the definition commits.

150
00:18:00,160 --> 00:18:06,560
But, you know, we don't want to require unanimous agreement for everything. So,

151
00:18:08,720 --> 00:18:15,440
here are some permutations. Let's say one of the admins doesn't install the chain code. One of

152
00:18:15,440 --> 00:18:21,840
the admins, you know, either they forget to or they simply don't want to execute this chain code.

153
00:18:22,400 --> 00:18:29,440
Well, things still proceed just fine because all three ORGs have agreed on this chain code

154
00:18:29,440 --> 00:18:37,760
definition, and that definition commits as normal, but only ORG1 and ORG2's peers

155
00:18:38,480 --> 00:18:44,640
will service invocations for that chain code because, of course, the chain code is not installed

156
00:18:44,640 --> 00:18:50,720
on ORG3's peer. Hopefully, that's unsurprising and what everyone would expect.

157
00:18:52,160 --> 00:18:58,080
Now, the second one. Now, this is sort of the crux of the difference between

158
00:18:58,960 --> 00:19:07,360
the v1.x and the decentralized lifecycle, and that's if ORG3's admin does not approve that

159
00:19:07,360 --> 00:19:14,640
definition. If ORG3's admin does nothing, well, it's still possible for the chain code to get

160
00:19:14,640 --> 00:19:20,320
defined on the channel because ORG1 and ORG2 agree, and we'll talk a little bit more about that later.

161
00:19:21,840 --> 00:19:26,960
But here, the chain code gets defined, and even though ORG3's peer has the chain code installed,

162
00:19:27,680 --> 00:19:35,440
ORG3's peer will not execute that chain code, and that's because ORG3's admin never agreed to

163
00:19:35,440 --> 00:19:43,200
this particular definition. Well, what if they did agree that they wanted to run this chain code,

164
00:19:43,200 --> 00:19:49,120
but, you know, in a slightly different way? So in this case, you know, you can see in bold here

165
00:19:50,080 --> 00:19:57,680
that for ORG3, their admin said, I want a policy of three out of three for the endorsement policy.

166
00:19:57,680 --> 00:20:03,600
All three ORGs must execute. While ORG1 and ORG2 said, no, two out of three is just fine.

167
00:20:04,320 --> 00:20:08,880
Well, in this case, even though ORG3 has said, yes, I want to run this chain code,

168
00:20:09,520 --> 00:20:14,160
because ORG3's agreement doesn't match what's actually committed in the channel,

169
00:20:14,800 --> 00:20:19,920
ORG3 will still refuse to execute the chain code. So you get the same effect as if the

170
00:20:19,920 --> 00:20:28,160
ORG3's admin had done nothing. And so finally, this is sort of the worst case.

171
00:20:29,920 --> 00:20:37,440
Communications broke down. People couldn't agree on the parameters. Here we have ORG1's

172
00:20:38,000 --> 00:20:45,520
admin picked version 1.1, ORG3 picked a policy of three out of three. We simply don't have enough

173
00:20:45,520 --> 00:20:51,760
agreement here on how this chain code should be instantiated. So in this case, the chain code

174
00:20:51,760 --> 00:20:55,920
could not be defined because we wouldn't be able to gather sufficient endorsements

175
00:20:56,720 --> 00:21:01,440
from the lifecycle chain code to actually get this definition committed.

176
00:21:01,440 --> 00:21:09,040
So I've been sort of avoiding the topic and alluding to it a little bit,

177
00:21:09,920 --> 00:21:20,560
but lifecycle is governed by endorsement policies. In the v1.x lifecycle, there were

178
00:21:20,560 --> 00:21:29,600
a few things going on. There were some sort of hard-coded validation rules in the validation

179
00:21:29,600 --> 00:21:36,400
plugin logic, or vscc, as it used to be called, that treated lifecycle invocation specially.

180
00:21:43,200 --> 00:21:50,880
The endorsement policy was also hard-coded there. In the new lifecycle, everything is

181
00:21:50,880 --> 00:22:02,400
based off of endorsement policies. In particular, to commit a definition into the lifecycle chain

182
00:22:02,400 --> 00:22:10,240
code namespace, you need to satisfy the channel application lifecycle endorsement policy.

183
00:22:11,200 --> 00:22:17,280
So this is a channel configuration policy, much like the channel readers or channel writers

184
00:22:17,280 --> 00:22:24,720
policies, but this one defaults to requiring that a majority of the application orgs

185
00:22:25,920 --> 00:22:33,440
must endorse. So what this means is in the default configuration, so long as a majority

186
00:22:33,440 --> 00:22:40,240
of the organizations in the network can agree on a change, then that change will be permitted.

187
00:22:40,560 --> 00:22:47,520
Now, note, just like we saw back here, just because the network agrees on a definition

188
00:22:48,400 --> 00:22:55,120
doesn't force an org to participate in that chain code, but what it does do is it allows

189
00:22:55,120 --> 00:23:04,560
the network to make changes even if one of the actors is not participating. And so this could be

190
00:23:05,520 --> 00:23:15,120
maybe there's an urgent security bug or other reason that the chain code needs to change,

191
00:23:15,760 --> 00:23:21,360
and one of the organizations, they can't be contacted. They're administrators on vacation,

192
00:23:22,320 --> 00:23:28,640
something like that. We basically didn't want to default to requiring unanimous agreement,

193
00:23:29,600 --> 00:23:38,480
although, of course, this is a configurable policy in the channel config. So for those users who

194
00:23:38,480 --> 00:23:44,160
don't like the default of a majority, this can be modified to be any policy that you like.

195
00:23:44,720 --> 00:23:51,120
In a more dictatorial network, you could require that a single specific org is the only org

196
00:23:51,200 --> 00:24:00,800
authorized to make life cycle changes. Now, secondly, there's another new endorsement

197
00:24:00,800 --> 00:24:06,880
policy, which is simply channel application endorsement, and this serves as the new

198
00:24:07,840 --> 00:24:15,360
default endorsement policy for chain codes when users fail to provide one. In v1.x,

199
00:24:15,360 --> 00:24:20,320
if you failed to provide an endorsement policy for your chain code, the default you got was

200
00:24:21,520 --> 00:24:30,720
any member of any org is an adequate endorsement, which makes for a very convenient development

201
00:24:30,720 --> 00:24:38,960
default. It makes it very easy to get up and going, but we saw confusion from users who maybe

202
00:24:38,960 --> 00:24:46,480
they didn't understand what an endorsement policy was, and they ended up with a default that didn't

203
00:24:46,480 --> 00:24:51,680
give them the security guarantees they were hoping for. So again, we think that this

204
00:24:52,560 --> 00:24:58,880
default of a majority of organizations must endorse, that that's a pretty reasonable default,

205
00:24:58,880 --> 00:25:07,520
but it's just a channel policy. It can be changed to whatever the specifics that a channel requires.

206
00:25:10,000 --> 00:25:15,360
Now, here's another point that sort of was deliberately omitted in the previous slides.

207
00:25:17,120 --> 00:25:25,040
We talk a lot about these sort of sequences of events that org ones admin does something,

208
00:25:25,040 --> 00:25:33,760
and org twos admin does something, and the problem we always have when we have workflows like this

209
00:25:33,760 --> 00:25:41,200
is how do we know that what org one agreed to is still valid and current?

210
00:25:42,160 --> 00:25:45,760
And so you can sort of think of a sequence number as being sort of like

211
00:25:46,800 --> 00:25:57,600
an election year or something like that, that in sequence one, we're all voting on the definition,

212
00:25:57,600 --> 00:26:04,000
on the first definition of a chain code. For sequence two, we're talking about the first

213
00:26:04,000 --> 00:26:11,440
change to that definition. For sequence three, we're talking about the change to the changed

214
00:26:11,440 --> 00:26:20,560
definition and so forth. And so what that allows us to do is we can approve a chain code and commit

215
00:26:20,560 --> 00:26:26,480
its definition at sequence one. And then while that chain code is operating, we can now begin

216
00:26:26,480 --> 00:26:32,240
approving a new definition at sequence two. And once the entire network has, you know,

217
00:26:32,240 --> 00:26:37,040
agreed to that definition, installed that chain code, so on and so forth,

218
00:26:37,040 --> 00:26:42,320
then we can sort of atomically move up to sequence two. And then you have a process

219
00:26:42,320 --> 00:26:48,560
repeats for sequence three, so on and so forth. So this is just a new concept that you need to

220
00:26:48,560 --> 00:26:55,600
be aware of that each incarnation of the chain code definition is assigned to sequence.

221
00:26:56,480 --> 00:26:59,840
And when we want to talk about this version or the next version,

222
00:27:00,560 --> 00:27:06,160
we talk relative to that sequence number. So let's go ahead and look at how this might,

223
00:27:06,160 --> 00:27:10,720
you know, actually manifest. If we go back to our three org example,

224
00:27:11,840 --> 00:27:16,800
you know, if we have org one and org two, they approve a chain code definition at sequence one.

225
00:27:17,440 --> 00:27:23,200
And because org threes administrator is on vacation, they go ahead and commit this chain

226
00:27:23,200 --> 00:27:29,200
code definition. And we end up back in that scenario where org one and org two will,

227
00:27:30,320 --> 00:27:34,480
you know, endorse invocations of that chain code, but org three will not.

228
00:27:35,840 --> 00:27:41,360
Well, org threes admin gets back from vacation, sees what the network did, says, oh, great,

229
00:27:41,360 --> 00:27:47,040
I agree. Now org three can go ahead and approve the definition at sequence one.

230
00:27:48,000 --> 00:27:52,640
And org threes peers will now begin endorsing just like org one and org twos.

231
00:27:54,160 --> 00:28:00,960
The important thing to note here is that without this sequence number, if org three simply sent

232
00:28:00,960 --> 00:28:07,680
a new approval in, it would be unclear whether org three was attempting to, you know, approve

233
00:28:08,240 --> 00:28:12,640
the current definition or whether org three wanted to, you know, maybe make some changes

234
00:28:12,720 --> 00:28:17,280
to the definition. So, and that's what we see in this next step here.

235
00:28:18,640 --> 00:28:23,760
org one, org two and org three, they want some sort of change. So they approve a new definition

236
00:28:23,760 --> 00:28:29,920
at sequence two. Once they've all approved at sequence two, we can commit. And that chain

237
00:28:29,920 --> 00:28:34,640
code definition now goes to sequence two. Of course, if you wanted to make another change to

238
00:28:34,640 --> 00:28:39,520
the chain code, you would make that change at sequence three, so on and so forth.

239
00:28:39,600 --> 00:28:49,600
Now, all of this has corresponding peer CLI commands, and they're not all listed here, in

240
00:28:49,600 --> 00:28:57,760
particular, there's a lot of query ability that you won't see here. But the big, you know, four

241
00:28:57,760 --> 00:29:03,440
you want to be aware of, there's a new packaging command, a pure life cycle chain code package.

242
00:29:04,720 --> 00:29:09,280
That will generate that tar GZ we talked about earlier. There's an install command,

243
00:29:09,840 --> 00:29:17,200
and install it to the peers, and approve command, which will, you know, approve a particular

244
00:29:18,160 --> 00:29:24,080
chain code definition for your org. Note that there is the sequence number attached to this,

245
00:29:24,800 --> 00:29:32,320
whether an it is required and so on and so forth. And then finally, a way to commit that chain code

246
00:29:32,320 --> 00:29:44,560
definition. So a few other notes and considerations. One thing that is either a feature or a,

247
00:29:47,440 --> 00:29:52,080
I won't say a bug, but a problem for operators that you may have run into

248
00:29:53,200 --> 00:29:59,120
is this notion of chain code fingerprint matching. If you've ever tried to package the same chain

249
00:29:59,120 --> 00:30:07,200
code multiple times, and install it on different peers, what you'll often find in your logs is

250
00:30:07,200 --> 00:30:13,280
this chain code fingerprint mismatch error. And essentially, this comes down to the fact that

251
00:30:13,280 --> 00:30:19,200
even if you have the same set of files, getting them to package into exactly the same set of

252
00:30:19,200 --> 00:30:26,000
bytes is a little tricky. That you have things like file timestamps, you have execute bits,

253
00:30:26,000 --> 00:30:31,040
you have different file systems that support different attributes, and so on and so forth.

254
00:30:31,840 --> 00:30:38,160
So in particular, if you tried to package a chain code with the node SDK, and then you tried to

255
00:30:38,160 --> 00:30:44,160
package that same chain code with the peer CLI, you know, you would basically end up with different

256
00:30:44,160 --> 00:30:51,040
package fingerprints. And at your execution time, you would encounter this mismatch,

257
00:30:51,680 --> 00:30:57,760
which is not something that you wanted. Your chain code would otherwise execute just fine,

258
00:30:57,760 --> 00:31:04,400
but you would have these fingerprint mismatches that prevented things from working. So

259
00:31:05,440 --> 00:31:14,160
that exists no more. That's gone, which means actually that your chain codes can even differ

260
00:31:14,880 --> 00:31:21,840
slightly from peer to peer. That if, you know, org one installs a chain code package,

261
00:31:22,560 --> 00:31:27,600
and org two installs a chain code package, those can actually be different chain codes.

262
00:31:27,600 --> 00:31:32,960
Now, they must implement the same logic. And by and large, you know, we would usually expect

263
00:31:32,960 --> 00:31:38,080
them to be the same chain code. But going back to one of our examples from earlier,

264
00:31:38,720 --> 00:31:47,840
let's say that there's a bug in the chain code that the chain code forgot to check if the third

265
00:31:47,840 --> 00:31:54,320
argument was nil before dereferencing it. So if someone sends in bad input, it can crash the

266
00:31:54,320 --> 00:31:59,760
chain code. Well, you know, this doesn't actually have any impact on the chain code read write

267
00:31:59,760 --> 00:32:05,440
set. It just causes the chain code to crash sometimes. So it would be perfectly possible

268
00:32:06,400 --> 00:32:12,560
for org one to recognize this bug, fix it and push a patched version of the chain code to their

269
00:32:12,560 --> 00:32:18,640
peers. And instantly this chain code will no longer crash on their peers on this bad input.

270
00:32:20,000 --> 00:32:27,440
Now, or two, you know, they get the email from org one saying, you know, there's this bug and

271
00:32:27,440 --> 00:32:33,200
we need to fix it. Here's my patch. They can take a look at that patch. They can evaluate it.

272
00:32:33,200 --> 00:32:38,160
In this case, it should be, you know, an obvious we'll accept it. You know, but basically,

273
00:32:39,520 --> 00:32:45,440
organizations can roll out minor fixes to the chain codes, independently of each other,

274
00:32:45,440 --> 00:32:50,880
and we no longer require that coordination. Of course, if you wanted to change the, you know,

275
00:32:50,880 --> 00:32:58,480
the DB layout or, you know, what keys functions are accessing, you know, we still have those

276
00:32:58,480 --> 00:33:04,560
same chain code execution guarantees via the endorsement policy that basically checks to make

277
00:33:04,560 --> 00:33:10,880
sure that the chain codes read exactly the same thing, the same versions and wrote the same things

278
00:33:10,880 --> 00:33:19,200
at the same versions. But, you know, slight variations in chain code logic, in particular

279
00:33:19,200 --> 00:33:26,320
around things like air checking, you know, that's something that can differ. Secondly,

280
00:33:27,280 --> 00:33:35,200
using the new life cycle, you must enable the V2 application capability before any of these

281
00:33:35,200 --> 00:33:42,800
life cycle commands will work. And this is a bit of a double-edged sword. When you flip that

282
00:33:42,800 --> 00:33:49,360
application capability on, the old life cycle, the old LSEC namespace becomes read-only.

283
00:33:50,320 --> 00:33:57,200
So, essentially, if you are using the new life cycle, you know, all of your old chain codes

284
00:33:57,200 --> 00:34:06,800
continue working until they've been redefined in the new life cycle. But, you know, basically,

285
00:34:06,800 --> 00:34:15,200
you can't change them anymore. So, if you needed to, you know, for some emergency reason, go in

286
00:34:15,280 --> 00:34:20,160
and upgrade your version of the chain code, you would need to do that in the new life cycle,

287
00:34:20,160 --> 00:34:25,040
not in the old life cycle. You know, it shouldn't be a problem operationally,

288
00:34:26,560 --> 00:34:33,760
but it's just something to be aware of, you know, make sure that you've thoroughly tested and

289
00:34:33,760 --> 00:34:39,600
you're ready to migrate your chain codes as soon as the application capability is enabled.

290
00:34:40,320 --> 00:34:42,720
You should be able to do this, essentially, without downtime,

291
00:34:43,840 --> 00:34:50,240
you know, because the old chain codes do continue to work. But, you know, once this capability is on,

292
00:34:50,960 --> 00:34:57,280
the old life cycle is no longer an option for modifications. And finally, you know, just in

293
00:34:57,280 --> 00:35:02,800
case, you know, anyone's immediate thought was, oh, let's turn off the capability to get the

294
00:35:02,800 --> 00:35:10,480
old life cycle writable again. You know, that might work. But, like all capabilities,

295
00:35:11,440 --> 00:35:20,240
once you disable or once you enable a capability, disabling it is not supported. It's simply nothing

296
00:35:20,240 --> 00:35:30,160
that's tested and things could go wrong in odd ways. So, even if it might work, this is not

297
00:35:30,160 --> 00:35:34,240
a supported configuration. And there are lots of good reasons for this.

298
00:35:35,280 --> 00:35:40,080
In particular, once you've upgraded or once you've enabled a channel capability,

299
00:35:41,680 --> 00:35:47,440
that's part of the blockchain, which means other peers need to parse this capability.

300
00:35:48,480 --> 00:35:55,760
So, there's really no going back. You know, we have an immutable ledger. And, you know, if you were

301
00:35:55,760 --> 00:36:02,160
to disable the capability, it's still enabled in that section of the blockchain. So, we really

302
00:36:02,160 --> 00:36:14,000
don't want to deal with disabling capabilities. And that's it. So, hopefully, this has been

303
00:36:14,000 --> 00:36:22,640
informative. And, you know, I'm always active out on the paper ledger rocket chat. And,

304
00:36:23,520 --> 00:36:25,360
yeah, thank you.

305
00:36:28,160 --> 00:36:33,440
Great. Thanks, Jason. And there are several questions people might be interested in.

306
00:36:34,000 --> 00:36:40,480
As you mentioned, it's currently possible to run different code for the same chain code across

307
00:36:40,480 --> 00:36:46,880
different organizations. And could you give some examples like how that could be useful,

308
00:36:46,880 --> 00:36:55,520
some use cases or scenarios? Sure. So, you know, we, you know, I touched a little bit on this that,

309
00:36:55,520 --> 00:37:02,960
you know, we now have these, for instance, org implicit collections. So, for those org implicit

310
00:37:02,960 --> 00:37:12,720
collections, the rights to them are only performed by my peers, right? I can execute a transaction

311
00:37:12,720 --> 00:37:18,960
only on my peers and write to this, this implicit collection. So, I don't really need agreement

312
00:37:18,960 --> 00:37:25,920
from other organizations. So, you know, let's go ahead and say that I wanted to implement some sort

313
00:37:25,920 --> 00:37:35,120
of, you know, a bidding chain code. When, you know, my peer gets this, this invocation,

314
00:37:35,520 --> 00:37:43,040
my peer is going to, to write the bid into its implicit collection. But it wants to validate

315
00:37:43,040 --> 00:37:49,360
this bid according to rules that make sense for my organization. So, maybe my chain code

316
00:37:50,000 --> 00:37:57,200
implements some, you know, proprietary logic, or maybe my chain code, you know, looks up,

317
00:37:57,520 --> 00:38:04,000
you know, makes an API call to a user database. Basically, something that's specific to my organization

318
00:38:06,000 --> 00:38:12,320
to decide whether or not it's going to endorse or to enforce some validation on parameters.

319
00:38:14,560 --> 00:38:18,960
So, that's, that's really where, you know, different chain codes start to make sense.

320
00:38:19,680 --> 00:38:27,040
When different orgs require different logic, specifically around rights that aren't coordinated,

321
00:38:27,040 --> 00:38:33,520
things like implicit collections. Now, you can always do sort of, you know, additional

322
00:38:33,520 --> 00:38:40,160
validation and verification, you know, you know, things that, for instance, fail endorsement,

323
00:38:41,120 --> 00:38:49,120
you know, maybe, you know, in the official chain code, it allows arbitrary bids. But,

324
00:38:49,120 --> 00:38:55,600
you know, for you, you want to add some additional air checking saying I will never endorse

325
00:38:56,560 --> 00:39:03,760
a bid for more than, you know, a hundred million dollars or whatever the limit that makes sense

326
00:39:04,560 --> 00:39:10,720
for you is. So, any sort of logic that's going to throw in air and prevent execution

327
00:39:11,760 --> 00:39:17,520
is also a fair game for sort of a difference in a chain code. The things that you want to avoid

328
00:39:18,480 --> 00:39:27,680
are things that read from the state or that write to the state that other orgs are not going to

329
00:39:27,680 --> 00:39:33,440
implement. As I mentioned, the important thing is that the chain code must produce the same reads

330
00:39:33,440 --> 00:39:43,840
and the same rights across all orgs. Okay. The third question is, do you have any

331
00:39:43,840 --> 00:39:49,360
tips or suggestions like people need to pay attention to while migrating to new life cycle?

332
00:39:54,080 --> 00:40:01,120
Sure. So, you know, the new life cycle is really meant to be, you know, very compatible with the

333
00:40:01,120 --> 00:40:08,640
old, you know, the actual instantiation process is a little different, but none of this should require

334
00:40:08,720 --> 00:40:17,040
code changes inside your chain code itself. However, you know, as I had mentioned, I would

335
00:40:17,680 --> 00:40:25,360
encourage everyone to look at their chain codes and, you know, see, is a knit actually being used

336
00:40:26,080 --> 00:40:32,880
to accomplish something useful? Could a knit be, you know, removed from your chain code?

337
00:40:33,760 --> 00:40:41,040
And if so, you know, during this chain code, life cycle migration, if you can drop the

338
00:40:41,040 --> 00:40:47,520
requirement for a knit, you will remove a step from your workflow, which is always a great thing.

339
00:40:49,440 --> 00:40:57,600
You know, otherwise, you know, I think the, you know, sort of the big shocks are really the things

340
00:40:57,600 --> 00:41:07,360
that we, you know, set out to address that you need, you need to know the peer addresses of,

341
00:41:07,360 --> 00:41:12,560
you know, or the addresses of peers and other organizations in order to do your life cycle

342
00:41:12,560 --> 00:41:19,440
operations. You know, you need to coordinate with the other administrators to perform their

343
00:41:19,440 --> 00:41:26,000
approvals. You know, so there's more coordination. There's more knowledge. But, you know, that's

344
00:41:26,000 --> 00:41:32,240
really what was required to get us to this decentralized point. So I guess if I could

345
00:41:32,240 --> 00:41:37,920
leave with a little bit of advice, you know, it would be, you know, sort of to just

346
00:41:40,800 --> 00:41:47,120
take whatever coordination existed within your network before, you know, around making decisions

347
00:41:47,120 --> 00:41:53,840
as to, you know, how and when to upgrade chain codes and sort of just, you know,

348
00:41:55,840 --> 00:42:03,840
codify that into a sort of more formal procedure that, you know, to explicitly enumerate,

349
00:42:03,840 --> 00:42:09,840
this will be the new endorsement policy. This will be the new version. This upgrade will or will not

350
00:42:09,840 --> 00:42:19,520
require init to be executed. And if you can sort of get this, you know, set of data that's required

351
00:42:19,520 --> 00:42:30,960
for this approve for my word command, sort of, you know, down and sort of, if you can get this

352
00:42:31,760 --> 00:42:37,840
into a workflow as a concrete item, then this sort of approve step, the define step,

353
00:42:38,800 --> 00:42:41,520
you know, this should all just follow up very naturally from that.

354
00:42:45,360 --> 00:42:57,520
Okay. Thank you, Jason. Thank you for the great talk. We are now open for questions from audiences.

