WEBVTT

00:00.000 --> 00:07.680
My name is Jason Yelik, and I'd like to talk with you about the Hyperledger Fabric Lifecycle

00:07.680 --> 00:17.520
today. In particular, the new distributed chain code lifecycle introduced in version 2.0 of Hyperledger

00:17.520 --> 00:25.600
Fabric. Today, we'll be starting by talking about an overview of the version 1.x lifecycle,

00:25.600 --> 00:31.680
so basically how chain code lifecycle has worked up until version 2.0. Then we'll do a similar

00:31.680 --> 00:38.160
discussion of the version 2.0 lifecycle, sort of a high level, including a workflow for that,

00:38.720 --> 00:45.600
and then some permutations around that workflow. Finally, we'll move on to details about the

00:45.600 --> 00:52.320
version 2.0 lifecycle, and then finally some other notes and considerations that you should keep in

00:52.320 --> 01:01.840
mind when dealing with the v2 lifecycle. Starting out with how chain code lifecycle worked in

01:01.840 --> 01:09.040
Fabric 1.x. This should be a pretty familiar picture. You have a couple organizations,

01:09.840 --> 01:15.920
their respective admins, and an ordering service, and we would like to get chain code installed

01:15.920 --> 01:25.120
and instantiated so that we can begin transacting on the blockchain. So step one, each org admin

01:25.120 --> 01:35.440
installs the chain code to one or more of their peers. Step two, one of the admins goes out and

01:35.440 --> 01:44.480
does a LSCC deploy or upgrade transaction to instantiate that chain code, gets the result,

01:44.480 --> 01:50.240
submits it to ordering, commits it all the peers, and now the chain code is up and running.

01:52.240 --> 01:57.040
It's basically a two-step process, which is nice because it's a small number of steps,

01:58.240 --> 02:05.920
but it has a lot of drawbacks. To begin with, installing a chain code

02:06.880 --> 02:15.520
sort of grants this unconditional agreement to run that chain code on any channel that your

02:16.240 --> 02:20.960
peer is joined to, whether or not you agree that that chain code should run on that channel,

02:21.600 --> 02:27.520
or whether you agree to the assorted parameters to that instantiation. So for instance,

02:28.800 --> 02:33.760
you might want a certain endorsement policy associated with that chain code.

02:34.640 --> 02:40.400
You might want to have control over when that chain code is upgraded and downgraded,

02:42.160 --> 02:48.320
and you might simply not want to execute that chain code. So that's sort of one of the first big

02:48.320 --> 02:58.880
problems, and this is where we talk about this sort of distributed chain code life cycle,

02:59.760 --> 03:06.320
or sort of distributed government, the governance distributed agreement. So continuing,

03:07.040 --> 03:12.800
so when we say that the new life cycle is decentralized, that's what we're talking

03:12.800 --> 03:19.040
about, that it's not just one admin making the decisions, that that's a problem we had in the

03:19.040 --> 03:22.960
previous life cycle, and that's something the new life cycle is here to address.

03:23.920 --> 03:32.720
Now, the second problem, which is a little less obvious, is that the instantiation, i.e. that deploy

03:32.720 --> 03:39.120
or that upgrade transaction, that includes invoking a knit of the deployed chain code.

03:40.160 --> 03:46.080
But if we look at our picture here, you can see that that transaction actually only executes on

03:46.080 --> 03:54.080
Ord1's peer. So even though we may have set an endorsement policy for this chain code,

03:54.080 --> 04:00.160
that initial invocation of a knit doesn't respect that endorsement policy. And you know,

04:00.960 --> 04:05.280
in a lot of ways that's fine because it's being invoked by a trusted user and some other things,

04:05.280 --> 04:12.640
but it's still an asymmetry, and it's something that we wanted to fix. And then finally,

04:13.600 --> 04:20.560
this is more of an operational one. If you've ever tried to operate a fabric network and you've

04:20.560 --> 04:25.920
tried onboarding new orgs and that sort of thing, what you'll quickly realize is that

04:26.560 --> 04:31.200
even though you don't want to change anything about the code of your chain code, any of the

04:31.200 --> 04:36.320
chain code logic, if you want to modify, say, the endorsement policy to include a new org,

04:36.880 --> 04:41.440
well, you actually have to go through this whole process of installing the chain code

04:41.520 --> 04:50.160
and performing an upgrade across the network, which is really unnecessary and causes a lot of churn

04:50.160 --> 04:56.480
that's a bit of a pain, operationally speaking. So these are sort of the three big problems that

04:58.080 --> 05:04.160
we encountered in the original chain code lifecycle, which sort of leads to the three

05:04.960 --> 05:14.400
principles for the new v2 decentralized lifecycle. So first one is that peers only participate in a

05:14.400 --> 05:23.040
chain code. If the org admin explicitly agrees, yes, I like this configuration for the chain code.

05:24.000 --> 05:36.400
So until the orgs admin agrees, that peer will not endorse the definition, the instantiation,

05:37.440 --> 05:42.640
and further it will not endorse any invocation of that chain code, including its init function.

05:43.920 --> 05:48.880
So this basically, if we go back to our previous slide, we said that the

05:49.840 --> 05:53.840
installing agrees to instantiate unconditionally, this fixes that problem.

05:55.440 --> 06:01.520
Secondly, no exceptions to endorsement policies. This corresponds to our second problem we

06:01.520 --> 06:07.360
enumerated, which is the chain code init should be subject to the same endorsement policy as the

06:07.440 --> 06:18.960
rest of the invocations. So we enforce that chain code init abides by the

06:19.840 --> 06:26.400
endorsement policy as defined for the chain code, just like every other transaction.

06:27.440 --> 06:34.720
But secondly, and this one is a little more subtle, in the v1.x lifecycle,

06:34.800 --> 06:43.840
lscc really didn't have an endorsement policy. So in the v2 distributed lifecycle, we also

06:43.840 --> 06:49.120
enforce that the lifecycle at chain code itself is governed by an endorsement policy

06:49.120 --> 06:51.840
and decisions are validated based on that endorsement policy.

06:53.840 --> 06:58.960
So finally, the third parameter, which comes back to our operational problems,

06:59.920 --> 07:05.360
is that you should be able to modify your chain code definition, you should be able to change

07:05.360 --> 07:12.560
the endorsement policy, add collections, etc., without requiring an upgrade of the code across

07:12.560 --> 07:20.240
the network. So those three things are sort of the guiding principles behind the design of the

07:20.960 --> 07:27.840
v2 decentralized lifecycle, and you'll be able to see that reflected in

07:29.520 --> 07:34.080
just a moment when we do an overview of how the decentralized lifecycle works.

07:35.840 --> 07:45.200
Now, before we go into the overview of how the lifecycle works, it's important to mention

07:45.280 --> 07:52.880
sort of an implementation detail. And that's that v2 lifecycle is very much

07:53.600 --> 07:58.720
powered by a new v2 concept, and that is organization implicit collections.

07:59.600 --> 08:06.560
Now, if you're at all familiar with private data collections from v1.2 or 3 onwards,

08:07.920 --> 08:12.640
you'll know that the basic idea is that it's a namespace that's reserved

08:12.640 --> 08:18.160
that only certain members can read. So on v2, we've sort of extended that concept,

08:18.720 --> 08:26.560
and you can now associate which members can write to that namespace. And there's the set of

08:26.560 --> 08:32.880
implicit collections, which are defined implicitly, i.e. they're there without you having to do

08:32.880 --> 08:40.000
anything to define them. And you get one implicit collection per organization in your channel,

08:40.640 --> 08:45.120
and only peers from that organization may write to it, and only peers from that

08:45.120 --> 08:50.560
organization may read from it. So this allows you to implement a lot of interesting things

08:50.560 --> 08:55.840
in your chain code that weren't previously possible, notably things like voting schemes,

08:56.720 --> 09:02.960
and ways for a chain code of one org to make a different decision than a chain code of another.

09:03.920 --> 09:09.920
So that's a bit of a side note, and I don't want to get too off topic here, but

09:10.960 --> 09:13.920
implicit collections are sort of the underpinning

09:16.400 --> 09:22.000
technology behind the new v2 lifecycle, and you can use this in your own chain codes as well.

09:24.240 --> 09:31.520
So back to that overview. Just like with the v1.x lifecycle and the v2 lifecycle,

09:31.600 --> 09:36.640
the first thing we do is an install. Now the packaging format has been changed,

09:37.200 --> 09:42.080
there are some different things about the install, but conceptually, it's still just an install,

09:42.080 --> 09:45.040
you're putting the chain code's code package onto the file system,

09:46.320 --> 09:51.200
and that takes place as your first step performed by each admin, respectively.

09:52.640 --> 09:55.600
Secondly, and this is where things start to differ a little bit,

09:56.560 --> 10:04.080
um, org one's admin, in this case, is going to execute an approve for my org function against

10:04.080 --> 10:10.640
his peer, send that to ordering, and it commits. Now this is modifying the implicit collection

10:10.640 --> 10:17.840
for org one, indicating that org one agrees with this particular chain code definition

10:17.840 --> 10:25.680
that org one's admin is approving. Now org two's admin is going to do the very same thing,

10:26.560 --> 10:31.280
sends to his own peer, his approval, submits that to ordering, it commits,

10:32.080 --> 10:37.600
and now we have an entry in the implicit collection for each org, indicating agreement to some

10:37.600 --> 10:44.560
chain code definition. At this point, org one's admin, or it could be org two's,

10:44.560 --> 10:51.600
but we'll use org one's in this case, invokes the lifecycle chain code on one of his peers,

10:52.240 --> 10:59.280
and one of org two's peers, saying let's go ahead and commit this definition,

10:59.920 --> 11:03.760
submits that to the ordering service, it commits in the public namespace,

11:04.400 --> 11:10.160
and now the chain code is defined. The definition that was approved by the two

11:10.160 --> 11:15.920
org admins have committed, and the chain code was ready to execute. At this point,

11:16.960 --> 11:24.640
typically the same user who did the commit of the definition would be the one who invokes

11:24.640 --> 11:35.600
init, and init can execute just like any other chain code invocation. The peer will track whether

11:35.840 --> 11:39.360
or not init has been called and enforce that it's the first function called,

11:40.640 --> 11:46.480
but I think as people get used to this new decentralized lifecycle,

11:49.840 --> 11:56.400
you'll realize more and more that init usually isn't necessary, and it's actually a whole lot

11:56.400 --> 12:02.480
easier and more flexible to implement init logic inside the chain code itself if needed.

12:03.440 --> 12:11.040
You know, a couple examples for this could be, first off, if you implement init inside a chain

12:11.040 --> 12:18.480
code, you can require each org to perform some action before the chain code is initialized,

12:19.120 --> 12:27.280
or if you're doing something like upgrading your key schema, you can require a series of transactions

12:28.080 --> 12:32.640
that modify your database layout before you allow normal transactions to begin,

12:33.360 --> 12:39.360
because a single transaction would be too large. And really, to implement init logic,

12:40.000 --> 12:46.240
it's really very simple. You just pick a reserved key, perform a read against that key, and see

12:46.240 --> 12:52.480
whether it says the chain code has been initialized or not. If it's not, enforce init, otherwise,

12:53.040 --> 12:58.640
allow things through as usual. And in fact, that's all fabric does for you

12:59.520 --> 13:12.000
when in your definition you require init. So, with the new lifecycle, not only

13:14.160 --> 13:19.680
are the semantics a little different, we had to pick a new name for lifecycle. Now, if you're

13:22.480 --> 13:29.280
familiar with operating a fabric v1.x network, you'll know that lifecycle operations were done

13:29.280 --> 13:36.720
through a system chain code called lscc. So, lscc is no longer the chain code used for

13:36.720 --> 13:43.120
lifecycle operations. Instead, there's a new system chain code called underscore lifecycle.

13:44.640 --> 13:51.920
And the underscore in the front is a prefix to indicate that it's a system name space,

13:52.720 --> 13:57.840
the suffix of ending chain codes in scc to indicate system name spaces was

13:59.760 --> 14:07.200
not one of the better ideas in fabric v1.x. So, underscore is now a reserve system name space,

14:07.200 --> 14:17.200
underscore lifecycle is the lifecycle system chain code. And in fabric v2, both the underscore

14:17.200 --> 14:26.080
lifecycle and the lscc chain codes exist. Both are functional. And in the event that

14:26.880 --> 14:32.080
the distributed lifecycle has been enabled, first we'll check definitions done in the new

14:32.080 --> 14:38.320
lifecycle. And if there's nothing there, we fall back to the old lifecycle. But it is important

14:38.320 --> 14:47.040
to note that eventually fabric will be removing support for the legacy lscc. So, it's a good

14:47.040 --> 14:51.920
idea to go ahead and migrate onto this new lifecycle as soon as possible because

14:52.880 --> 15:01.280
at a later fabric version, lscc will be removed. And you'll be forced to move there eventually.

15:04.720 --> 15:10.240
So, let's talk about how lifecycle works sort of from a user perspective.

15:10.960 --> 15:18.240
Let's say you have three organizations, org one, org two, and org three. And everyone wants to

15:18.880 --> 15:27.840
run chain code mycc. And we've agreed that two out of three orgs must agree that's the endorsement

15:27.840 --> 15:36.480
policy we want to go with. So, what would this look like implemented? Someone's got to take the

15:37.040 --> 15:43.360
lead. Someone has to sort of administrate the process. And for here, we've chosen org one,

15:43.360 --> 15:48.880
but it could be really any admin. And what they would do is they would package this chain code

15:49.920 --> 15:59.440
using the pure CLI into what is now just a standard tar GZ. And disseminate that package to

15:59.440 --> 16:06.080
the other orgs. Now, the other orgs, they can take a look at this package. And unlike in fabric

16:06.160 --> 16:12.640
v1.x, where the package format was sort of a fabric specific thing, a CDS file,

16:14.320 --> 16:22.080
in the v2 lifecycle, these packages are standard tar GZs. So, an admin can simply

16:22.080 --> 16:26.960
use whatever commodity tooling they would like to take a look at that package, make sure it is,

16:26.960 --> 16:34.320
in fact, the chain code that they want to install. Now, everyone goes and installs this

16:34.320 --> 16:43.200
chain code package and commits that approval, sends that approve for my org transaction through,

16:44.240 --> 16:51.360
according to the parameters that we sort of agreed out of band. So, this is my cc, it's version one,

16:52.320 --> 16:57.840
the endorsement policy is two out of three and so forth. Once everyone's done their approval,

16:57.920 --> 17:03.920
and again, typically we would wait for everyone, then the administrative org one

17:04.880 --> 17:08.640
sends the transaction to commit the chain code definition for that channel,

17:09.280 --> 17:18.000
and the chain code is now operational. So, let's look at this visually. We have three peers.

17:19.440 --> 17:23.440
The administrators install the chain code on each of those three peers.

17:24.000 --> 17:29.840
They approve the chain code with all of the same parameters,

17:31.920 --> 17:38.080
and then they commit that chain code definition, and now the chain code is defined,

17:38.800 --> 17:46.000
all three peers are ready to execute it. This is the standard workflow and, you know, what you

17:46.000 --> 17:52.800
can expect to happen in most production fabric networks. You know, everyone is in sync, everyone

17:52.880 --> 17:59.200
is in agreement, everyone does the same approval, and once everyone is ready, the definition commits.

18:00.160 --> 18:06.560
But, you know, we don't want to require unanimous agreement for everything. So,

18:08.720 --> 18:15.440
here are some permutations. Let's say one of the admins doesn't install the chain code. One of

18:15.440 --> 18:21.840
the admins, you know, either they forget to or they simply don't want to execute this chain code.

18:22.400 --> 18:29.440
Well, things still proceed just fine because all three ORGs have agreed on this chain code

18:29.440 --> 18:37.760
definition, and that definition commits as normal, but only ORG1 and ORG2's peers

18:38.480 --> 18:44.640
will service invocations for that chain code because, of course, the chain code is not installed

18:44.640 --> 18:50.720
on ORG3's peer. Hopefully, that's unsurprising and what everyone would expect.

18:52.160 --> 18:58.080
Now, the second one. Now, this is sort of the crux of the difference between

18:58.960 --> 19:07.360
the v1.x and the decentralized lifecycle, and that's if ORG3's admin does not approve that

19:07.360 --> 19:14.640
definition. If ORG3's admin does nothing, well, it's still possible for the chain code to get

19:14.640 --> 19:20.320
defined on the channel because ORG1 and ORG2 agree, and we'll talk a little bit more about that later.

19:21.840 --> 19:26.960
But here, the chain code gets defined, and even though ORG3's peer has the chain code installed,

19:27.680 --> 19:35.440
ORG3's peer will not execute that chain code, and that's because ORG3's admin never agreed to

19:35.440 --> 19:43.200
this particular definition. Well, what if they did agree that they wanted to run this chain code,

19:43.200 --> 19:49.120
but, you know, in a slightly different way? So in this case, you know, you can see in bold here

19:50.080 --> 19:57.680
that for ORG3, their admin said, I want a policy of three out of three for the endorsement policy.

19:57.680 --> 20:03.600
All three ORGs must execute. While ORG1 and ORG2 said, no, two out of three is just fine.

20:04.320 --> 20:08.880
Well, in this case, even though ORG3 has said, yes, I want to run this chain code,

20:09.520 --> 20:14.160
because ORG3's agreement doesn't match what's actually committed in the channel,

20:14.800 --> 20:19.920
ORG3 will still refuse to execute the chain code. So you get the same effect as if the

20:19.920 --> 20:28.160
ORG3's admin had done nothing. And so finally, this is sort of the worst case.

20:29.920 --> 20:37.440
Communications broke down. People couldn't agree on the parameters. Here we have ORG1's

20:38.000 --> 20:45.520
admin picked version 1.1, ORG3 picked a policy of three out of three. We simply don't have enough

20:45.520 --> 20:51.760
agreement here on how this chain code should be instantiated. So in this case, the chain code

20:51.760 --> 20:55.920
could not be defined because we wouldn't be able to gather sufficient endorsements

20:56.720 --> 21:01.440
from the lifecycle chain code to actually get this definition committed.

21:01.440 --> 21:09.040
So I've been sort of avoiding the topic and alluding to it a little bit,

21:09.920 --> 21:20.560
but lifecycle is governed by endorsement policies. In the v1.x lifecycle, there were

21:20.560 --> 21:29.600
a few things going on. There were some sort of hard-coded validation rules in the validation

21:29.600 --> 21:36.400
plugin logic, or vscc, as it used to be called, that treated lifecycle invocation specially.

21:43.200 --> 21:50.880
The endorsement policy was also hard-coded there. In the new lifecycle, everything is

21:50.880 --> 22:02.400
based off of endorsement policies. In particular, to commit a definition into the lifecycle chain

22:02.400 --> 22:10.240
code namespace, you need to satisfy the channel application lifecycle endorsement policy.

22:11.200 --> 22:17.280
So this is a channel configuration policy, much like the channel readers or channel writers

22:17.280 --> 22:24.720
policies, but this one defaults to requiring that a majority of the application orgs

22:25.920 --> 22:33.440
must endorse. So what this means is in the default configuration, so long as a majority

22:33.440 --> 22:40.240
of the organizations in the network can agree on a change, then that change will be permitted.

22:40.560 --> 22:47.520
Now, note, just like we saw back here, just because the network agrees on a definition

22:48.400 --> 22:55.120
doesn't force an org to participate in that chain code, but what it does do is it allows

22:55.120 --> 23:04.560
the network to make changes even if one of the actors is not participating. And so this could be

23:05.520 --> 23:15.120
maybe there's an urgent security bug or other reason that the chain code needs to change,

23:15.760 --> 23:21.360
and one of the organizations, they can't be contacted. They're administrators on vacation,

23:22.320 --> 23:28.640
something like that. We basically didn't want to default to requiring unanimous agreement,

23:29.600 --> 23:38.480
although, of course, this is a configurable policy in the channel config. So for those users who

23:38.480 --> 23:44.160
don't like the default of a majority, this can be modified to be any policy that you like.

23:44.720 --> 23:51.120
In a more dictatorial network, you could require that a single specific org is the only org

23:51.200 --> 24:00.800
authorized to make life cycle changes. Now, secondly, there's another new endorsement

24:00.800 --> 24:06.880
policy, which is simply channel application endorsement, and this serves as the new

24:07.840 --> 24:15.360
default endorsement policy for chain codes when users fail to provide one. In v1.x,

24:15.360 --> 24:20.320
if you failed to provide an endorsement policy for your chain code, the default you got was

24:21.520 --> 24:30.720
any member of any org is an adequate endorsement, which makes for a very convenient development

24:30.720 --> 24:38.960
default. It makes it very easy to get up and going, but we saw confusion from users who maybe

24:38.960 --> 24:46.480
they didn't understand what an endorsement policy was, and they ended up with a default that didn't

24:46.480 --> 24:51.680
give them the security guarantees they were hoping for. So again, we think that this

24:52.560 --> 24:58.880
default of a majority of organizations must endorse, that that's a pretty reasonable default,

24:58.880 --> 25:07.520
but it's just a channel policy. It can be changed to whatever the specifics that a channel requires.

25:10.000 --> 25:15.360
Now, here's another point that sort of was deliberately omitted in the previous slides.

25:17.120 --> 25:25.040
We talk a lot about these sort of sequences of events that org ones admin does something,

25:25.040 --> 25:33.760
and org twos admin does something, and the problem we always have when we have workflows like this

25:33.760 --> 25:41.200
is how do we know that what org one agreed to is still valid and current?

25:42.160 --> 25:45.760
And so you can sort of think of a sequence number as being sort of like

25:46.800 --> 25:57.600
an election year or something like that, that in sequence one, we're all voting on the definition,

25:57.600 --> 26:04.000
on the first definition of a chain code. For sequence two, we're talking about the first

26:04.000 --> 26:11.440
change to that definition. For sequence three, we're talking about the change to the changed

26:11.440 --> 26:20.560
definition and so forth. And so what that allows us to do is we can approve a chain code and commit

26:20.560 --> 26:26.480
its definition at sequence one. And then while that chain code is operating, we can now begin

26:26.480 --> 26:32.240
approving a new definition at sequence two. And once the entire network has, you know,

26:32.240 --> 26:37.040
agreed to that definition, installed that chain code, so on and so forth,

26:37.040 --> 26:42.320
then we can sort of atomically move up to sequence two. And then you have a process

26:42.320 --> 26:48.560
repeats for sequence three, so on and so forth. So this is just a new concept that you need to

26:48.560 --> 26:55.600
be aware of that each incarnation of the chain code definition is assigned to sequence.

26:56.480 --> 26:59.840
And when we want to talk about this version or the next version,

27:00.560 --> 27:06.160
we talk relative to that sequence number. So let's go ahead and look at how this might,

27:06.160 --> 27:10.720
you know, actually manifest. If we go back to our three org example,

27:11.840 --> 27:16.800
you know, if we have org one and org two, they approve a chain code definition at sequence one.

27:17.440 --> 27:23.200
And because org threes administrator is on vacation, they go ahead and commit this chain

27:23.200 --> 27:29.200
code definition. And we end up back in that scenario where org one and org two will,

27:30.320 --> 27:34.480
you know, endorse invocations of that chain code, but org three will not.

27:35.840 --> 27:41.360
Well, org threes admin gets back from vacation, sees what the network did, says, oh, great,

27:41.360 --> 27:47.040
I agree. Now org three can go ahead and approve the definition at sequence one.

27:48.000 --> 27:52.640
And org threes peers will now begin endorsing just like org one and org twos.

27:54.160 --> 28:00.960
The important thing to note here is that without this sequence number, if org three simply sent

28:00.960 --> 28:07.680
a new approval in, it would be unclear whether org three was attempting to, you know, approve

28:08.240 --> 28:12.640
the current definition or whether org three wanted to, you know, maybe make some changes

28:12.720 --> 28:17.280
to the definition. So, and that's what we see in this next step here.

28:18.640 --> 28:23.760
org one, org two and org three, they want some sort of change. So they approve a new definition

28:23.760 --> 28:29.920
at sequence two. Once they've all approved at sequence two, we can commit. And that chain

28:29.920 --> 28:34.640
code definition now goes to sequence two. Of course, if you wanted to make another change to

28:34.640 --> 28:39.520
the chain code, you would make that change at sequence three, so on and so forth.

28:39.600 --> 28:49.600
Now, all of this has corresponding peer CLI commands, and they're not all listed here, in

28:49.600 --> 28:57.760
particular, there's a lot of query ability that you won't see here. But the big, you know, four

28:57.760 --> 29:03.440
you want to be aware of, there's a new packaging command, a pure life cycle chain code package.

29:04.720 --> 29:09.280
That will generate that tar GZ we talked about earlier. There's an install command,

29:09.840 --> 29:17.200
and install it to the peers, and approve command, which will, you know, approve a particular

29:18.160 --> 29:24.080
chain code definition for your org. Note that there is the sequence number attached to this,

29:24.800 --> 29:32.320
whether an it is required and so on and so forth. And then finally, a way to commit that chain code

29:32.320 --> 29:44.560
definition. So a few other notes and considerations. One thing that is either a feature or a,

29:47.440 --> 29:52.080
I won't say a bug, but a problem for operators that you may have run into

29:53.200 --> 29:59.120
is this notion of chain code fingerprint matching. If you've ever tried to package the same chain

29:59.120 --> 30:07.200
code multiple times, and install it on different peers, what you'll often find in your logs is

30:07.200 --> 30:13.280
this chain code fingerprint mismatch error. And essentially, this comes down to the fact that

30:13.280 --> 30:19.200
even if you have the same set of files, getting them to package into exactly the same set of

30:19.200 --> 30:26.000
bytes is a little tricky. That you have things like file timestamps, you have execute bits,

30:26.000 --> 30:31.040
you have different file systems that support different attributes, and so on and so forth.

30:31.840 --> 30:38.160
So in particular, if you tried to package a chain code with the node SDK, and then you tried to

30:38.160 --> 30:44.160
package that same chain code with the peer CLI, you know, you would basically end up with different

30:44.160 --> 30:51.040
package fingerprints. And at your execution time, you would encounter this mismatch,

30:51.680 --> 30:57.760
which is not something that you wanted. Your chain code would otherwise execute just fine,

30:57.760 --> 31:04.400
but you would have these fingerprint mismatches that prevented things from working. So

31:05.440 --> 31:14.160
that exists no more. That's gone, which means actually that your chain codes can even differ

31:14.880 --> 31:21.840
slightly from peer to peer. That if, you know, org one installs a chain code package,

31:22.560 --> 31:27.600
and org two installs a chain code package, those can actually be different chain codes.

31:27.600 --> 31:32.960
Now, they must implement the same logic. And by and large, you know, we would usually expect

31:32.960 --> 31:38.080
them to be the same chain code. But going back to one of our examples from earlier,

31:38.720 --> 31:47.840
let's say that there's a bug in the chain code that the chain code forgot to check if the third

31:47.840 --> 31:54.320
argument was nil before dereferencing it. So if someone sends in bad input, it can crash the

31:54.320 --> 31:59.760
chain code. Well, you know, this doesn't actually have any impact on the chain code read write

31:59.760 --> 32:05.440
set. It just causes the chain code to crash sometimes. So it would be perfectly possible

32:06.400 --> 32:12.560
for org one to recognize this bug, fix it and push a patched version of the chain code to their

32:12.560 --> 32:18.640
peers. And instantly this chain code will no longer crash on their peers on this bad input.

32:20.000 --> 32:27.440
Now, or two, you know, they get the email from org one saying, you know, there's this bug and

32:27.440 --> 32:33.200
we need to fix it. Here's my patch. They can take a look at that patch. They can evaluate it.

32:33.200 --> 32:38.160
In this case, it should be, you know, an obvious we'll accept it. You know, but basically,

32:39.520 --> 32:45.440
organizations can roll out minor fixes to the chain codes, independently of each other,

32:45.440 --> 32:50.880
and we no longer require that coordination. Of course, if you wanted to change the, you know,

32:50.880 --> 32:58.480
the DB layout or, you know, what keys functions are accessing, you know, we still have those

32:58.480 --> 33:04.560
same chain code execution guarantees via the endorsement policy that basically checks to make

33:04.560 --> 33:10.880
sure that the chain codes read exactly the same thing, the same versions and wrote the same things

33:10.880 --> 33:19.200
at the same versions. But, you know, slight variations in chain code logic, in particular

33:19.200 --> 33:26.320
around things like air checking, you know, that's something that can differ. Secondly,

33:27.280 --> 33:35.200
using the new life cycle, you must enable the V2 application capability before any of these

33:35.200 --> 33:42.800
life cycle commands will work. And this is a bit of a double-edged sword. When you flip that

33:42.800 --> 33:49.360
application capability on, the old life cycle, the old LSEC namespace becomes read-only.

33:50.320 --> 33:57.200
So, essentially, if you are using the new life cycle, you know, all of your old chain codes

33:57.200 --> 34:06.800
continue working until they've been redefined in the new life cycle. But, you know, basically,

34:06.800 --> 34:15.200
you can't change them anymore. So, if you needed to, you know, for some emergency reason, go in

34:15.280 --> 34:20.160
and upgrade your version of the chain code, you would need to do that in the new life cycle,

34:20.160 --> 34:25.040
not in the old life cycle. You know, it shouldn't be a problem operationally,

34:26.560 --> 34:33.760
but it's just something to be aware of, you know, make sure that you've thoroughly tested and

34:33.760 --> 34:39.600
you're ready to migrate your chain codes as soon as the application capability is enabled.

34:40.320 --> 34:42.720
You should be able to do this, essentially, without downtime,

34:43.840 --> 34:50.240
you know, because the old chain codes do continue to work. But, you know, once this capability is on,

34:50.960 --> 34:57.280
the old life cycle is no longer an option for modifications. And finally, you know, just in

34:57.280 --> 35:02.800
case, you know, anyone's immediate thought was, oh, let's turn off the capability to get the

35:02.800 --> 35:10.480
old life cycle writable again. You know, that might work. But, like all capabilities,

35:11.440 --> 35:20.240
once you disable or once you enable a capability, disabling it is not supported. It's simply nothing

35:20.240 --> 35:30.160
that's tested and things could go wrong in odd ways. So, even if it might work, this is not

35:30.160 --> 35:34.240
a supported configuration. And there are lots of good reasons for this.

35:35.280 --> 35:40.080
In particular, once you've upgraded or once you've enabled a channel capability,

35:41.680 --> 35:47.440
that's part of the blockchain, which means other peers need to parse this capability.

35:48.480 --> 35:55.760
So, there's really no going back. You know, we have an immutable ledger. And, you know, if you were

35:55.760 --> 36:02.160
to disable the capability, it's still enabled in that section of the blockchain. So, we really

36:02.160 --> 36:14.000
don't want to deal with disabling capabilities. And that's it. So, hopefully, this has been

36:14.000 --> 36:22.640
informative. And, you know, I'm always active out on the paper ledger rocket chat. And,

36:23.520 --> 36:25.360
yeah, thank you.

36:28.160 --> 36:33.440
Great. Thanks, Jason. And there are several questions people might be interested in.

36:34.000 --> 36:40.480
As you mentioned, it's currently possible to run different code for the same chain code across

36:40.480 --> 36:46.880
different organizations. And could you give some examples like how that could be useful,

36:46.880 --> 36:55.520
some use cases or scenarios? Sure. So, you know, we, you know, I touched a little bit on this that,

36:55.520 --> 37:02.960
you know, we now have these, for instance, org implicit collections. So, for those org implicit

37:02.960 --> 37:12.720
collections, the rights to them are only performed by my peers, right? I can execute a transaction

37:12.720 --> 37:18.960
only on my peers and write to this, this implicit collection. So, I don't really need agreement

37:18.960 --> 37:25.920
from other organizations. So, you know, let's go ahead and say that I wanted to implement some sort

37:25.920 --> 37:35.120
of, you know, a bidding chain code. When, you know, my peer gets this, this invocation,

37:35.520 --> 37:43.040
my peer is going to, to write the bid into its implicit collection. But it wants to validate

37:43.040 --> 37:49.360
this bid according to rules that make sense for my organization. So, maybe my chain code

37:50.000 --> 37:57.200
implements some, you know, proprietary logic, or maybe my chain code, you know, looks up,

37:57.520 --> 38:04.000
you know, makes an API call to a user database. Basically, something that's specific to my organization

38:06.000 --> 38:12.320
to decide whether or not it's going to endorse or to enforce some validation on parameters.

38:14.560 --> 38:18.960
So, that's, that's really where, you know, different chain codes start to make sense.

38:19.680 --> 38:27.040
When different orgs require different logic, specifically around rights that aren't coordinated,

38:27.040 --> 38:33.520
things like implicit collections. Now, you can always do sort of, you know, additional

38:33.520 --> 38:40.160
validation and verification, you know, you know, things that, for instance, fail endorsement,

38:41.120 --> 38:49.120
you know, maybe, you know, in the official chain code, it allows arbitrary bids. But,

38:49.120 --> 38:55.600
you know, for you, you want to add some additional air checking saying I will never endorse

38:56.560 --> 39:03.760
a bid for more than, you know, a hundred million dollars or whatever the limit that makes sense

39:04.560 --> 39:10.720
for you is. So, any sort of logic that's going to throw in air and prevent execution

39:11.760 --> 39:17.520
is also a fair game for sort of a difference in a chain code. The things that you want to avoid

39:18.480 --> 39:27.680
are things that read from the state or that write to the state that other orgs are not going to

39:27.680 --> 39:33.440
implement. As I mentioned, the important thing is that the chain code must produce the same reads

39:33.440 --> 39:43.840
and the same rights across all orgs. Okay. The third question is, do you have any

39:43.840 --> 39:49.360
tips or suggestions like people need to pay attention to while migrating to new life cycle?

39:54.080 --> 40:01.120
Sure. So, you know, the new life cycle is really meant to be, you know, very compatible with the

40:01.120 --> 40:08.640
old, you know, the actual instantiation process is a little different, but none of this should require

40:08.720 --> 40:17.040
code changes inside your chain code itself. However, you know, as I had mentioned, I would

40:17.680 --> 40:25.360
encourage everyone to look at their chain codes and, you know, see, is a knit actually being used

40:26.080 --> 40:32.880
to accomplish something useful? Could a knit be, you know, removed from your chain code?

40:33.760 --> 40:41.040
And if so, you know, during this chain code, life cycle migration, if you can drop the

40:41.040 --> 40:47.520
requirement for a knit, you will remove a step from your workflow, which is always a great thing.

40:49.440 --> 40:57.600
You know, otherwise, you know, I think the, you know, sort of the big shocks are really the things

40:57.600 --> 41:07.360
that we, you know, set out to address that you need, you need to know the peer addresses of,

41:07.360 --> 41:12.560
you know, or the addresses of peers and other organizations in order to do your life cycle

41:12.560 --> 41:19.440
operations. You know, you need to coordinate with the other administrators to perform their

41:19.440 --> 41:26.000
approvals. You know, so there's more coordination. There's more knowledge. But, you know, that's

41:26.000 --> 41:32.240
really what was required to get us to this decentralized point. So I guess if I could

41:32.240 --> 41:37.920
leave with a little bit of advice, you know, it would be, you know, sort of to just

41:40.800 --> 41:47.120
take whatever coordination existed within your network before, you know, around making decisions

41:47.120 --> 41:53.840
as to, you know, how and when to upgrade chain codes and sort of just, you know,

41:55.840 --> 42:03.840
codify that into a sort of more formal procedure that, you know, to explicitly enumerate,

42:03.840 --> 42:09.840
this will be the new endorsement policy. This will be the new version. This upgrade will or will not

42:09.840 --> 42:19.520
require init to be executed. And if you can sort of get this, you know, set of data that's required

42:19.520 --> 42:30.960
for this approve for my word command, sort of, you know, down and sort of, if you can get this

42:31.760 --> 42:37.840
into a workflow as a concrete item, then this sort of approve step, the define step,

42:38.800 --> 42:41.520
you know, this should all just follow up very naturally from that.

42:45.360 --> 42:57.520
Okay. Thank you, Jason. Thank you for the great talk. We are now open for questions from audiences.

