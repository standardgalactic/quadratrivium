start	end	text
0	12440	Okay, hello everybody, thank you.
12440	13680	Really excited to be here.
13680	19200	Quick little about me, I made this talk while I was working at Fullstack Academy as an instructor,
19200	21680	so it's going to hopefully be a little educational.
21680	27520	I currently work at Google, but this talk isn't about that, I'm not representing Google
27520	28520	or anything.
28520	31320	My thoughts and opinions are my own, et cetera.
31320	35160	And this is the smartly version of this talk, so it's been slightly tweaked and improved
35160	36160	in various ways.
36160	39680	And I've got social media accounts and things like that.
39680	44480	There are slides posted online, this will be in the video, slash we'll post it later,
44480	47520	you can go find them, and let's get started.
47520	57080	So I'm going to start off with this combinator called identity, and it looks like this.
57080	65360	It is a function that takes an input A and returns A. It's pretty straightforward, so
65360	66520	let's try it out.
66520	76640	So the identity of one is, yeah, it's interactive, and the identity of identity is identity.
76640	82840	Okay, so right off the bat, we have something cool, which is functions can be arguments
82840	83840	to other functions.
83840	89040	First class functions, and that is a defining characteristic of the lambda calculus slash
89040	91080	combinator logic.
91080	96040	So the identity of any X is X, and we can write that a whole bunch of different ways.
96040	102120	You've got JavaScript arrow functions on the board, we have this I variable that has an
102120	107080	equation that's called combinator logic, and we have this shaded out lambda thing below
107080	112840	it, you'll be able to go see these notes in the slides, you don't necessarily have to
112840	117180	try and read all the actual lambda calculus syntax for this talk.
117180	121320	So I'm not going to be showing it all the time, I'm going to focus on the very high-level
121320	123040	concepts.
123040	127800	And we saw that the identity of identity is itself, so yes, functions can be arguments
127800	131600	to functions and return functions and do all that stuff.
131600	138840	In Haskell, this is built into the base common library that everybody imports usually as
138840	145680	the ID or identity function, and it behaves exactly as shown, the identity of 5 is 5.
145680	148760	So what is up with this lambda notation?
148760	150960	It literally just means function.
150960	156160	If you were writing JavaScript the long way and not with an arrow function, it's the word
156160	157160	function.
157160	163040	If you're writing Python, it's like def function or something like that, I don't know.
163040	165480	And it takes a parameter, it takes an input.
165480	171280	All functions in the actual strict modified lambda calculus take only one argument.
171280	173080	We'll see how that's useful later.
173080	175320	And then finally it returns some expression.
175320	178880	In this case, the identity function returns its input.
178880	183360	And this whole thing together is sometimes called a lambda abstraction, abstraction
183360	188800	because it abstracts away through a parameter, concrete use cases.
188800	193720	So one concrete use case might be if A was 1, this would return 1.
193720	196960	If A was hello, this would return hello.
196960	202920	So by parameterizing those concrete use cases, we end up with an abstraction.
202920	206600	But it's really just a fancy way of saying it's a function.
206600	210360	There's all sorts of syntaxes across programming languages for these things, and you'll probably
210360	216440	have heard about them, and it's like, oh, now Java has lambdas, and why is that exciting?
216440	219560	Turns out there's a lot of different ways of writing these.
219560	223800	This is the worst, unfortunately.
223800	226800	I mean, just compare and contrast, right?
226800	227800	But they are fun.
227800	228800	They are exciting.
228800	232400	And there's a reason they show up a lot in functional programming.
232400	238560	If you're familiar with sort of the COPSI way of showing syntax, this is the grammar
238560	240640	for the lambda calculus.
240640	242400	This is a very tiny language.
242400	244480	It only has really four things.
244480	247120	It has variables, which are just plain old symbols.
247120	253120	It has a function being applied to its argument that's application, and that's just by a space.
253120	256840	A space between two things means function applied to argument.
256840	259640	It has function definitions, which we just saw, and they're called abstractions.
259640	264360	And then it's got parentheses to control what order things are evaluated in.
264360	268680	So this whole talk, I'm going to be comparing and contrasting the way these things look,
268680	271240	but they're really the same concepts.
271240	273200	Variables can hold a value.
273200	274840	Very important difference here.
274840	278680	In the lambda calculus, there's no such thing as a mutable variable.
278680	281360	All variables are immutable.
281360	286320	They have a definition, and you might know that definition, or you might not, but it
286320	287320	never changes.
287320	288320	You never reassign.
288320	289320	All right.
289320	291440	I talked about function applications.
291440	295240	Again, just a space means function called on argument.
295240	300520	We tend to say function applied to argument or function invoked with argument.
300520	302360	And there's little details here.
302360	309840	For example, it's left associative application, so that FAB line right there means first
309840	316480	call F with A, and that returns a function, and call that with B, which we can disambiguate
316480	321960	using those ghosted out parens and say, like, okay, to make this really clear, we're passing
321960	325960	A into F, and then we're passing B into the result of that.
325960	329720	But since it is left associative, we typically just don't write that down.
329720	332400	So you won't see those parens.
332400	337440	In contrast, you'll notice that the last line there, those parens around AB, that does
337440	338600	change the expression.
338600	341040	That is now a different expression.
341040	346280	It means first call the A function with the B argument, and then pass that result into
346280	351080	F. So now we've muddled up the order of things.
351080	353320	Abstractions, these are function definitions.
353320	354960	They're just JavaScript arrows.
354960	359200	That's all they are.
359200	360200	How do they work?
360200	363080	Well, again, you got lambda means function definition.
363080	365160	Dot means return.
365160	370240	So lambda A dot B means taking an A and return B. What do A and B have to do with each other
370240	372120	in this particular example?
372120	373120	Absolutely nothing.
373120	377120	So this throws out the A argument and returns whatever B is.
377120	378320	What is B in this slide?
378320	379760	The answer is we don't know.
379760	380760	We don't know what B is.
380760	382320	It's a free variable.
382320	383980	It's not defined anywhere.
383980	388300	So if you were doing lambda calculus by hand, you would simplify this.
388300	393580	If you called this function on an argument, you'd say it returns B whatever that is.
393580	394660	And that's fine.
394660	397380	You don't have reference errors in lambda calculus.
397380	403660	You end up with a symbol, and that symbol might stand for something or might not.
403660	405300	Anything else of interest on this slide?
405300	407460	Not really.
407460	409820	One maybe perhaps the last thing there.
409820	412980	You'll notice that you can have nested lambdas.
412980	420780	So A returns B returns A is just like if you had serial arrows in a JavaScript expression.
420780	423460	And this is actually right associative.
423460	426820	So associativity goes all over the place of lambda calculus.
426820	429340	That could be one of the confusing things at first.
429340	435260	But that means that bottom function there, if you pass an argument in as A, it doesn't
435260	438060	return the final thing.
438060	442960	It returns a new function that takes a B. And when you call that second function, final
442960	448600	really it returns an A. This is, by the way, known very popularly as curing.
448600	452160	So let's see that again actually.
452160	458880	So that bottom function there, we can see in JavaScript is defined as A takes that, returns
458880	460680	that, and blah, blah, blah.
460680	464120	I didn't bind it as anything, so I can't use it.
464120	468440	But we'll call this example.
468440	472400	That's a classic, right?
472400	479600	So if I call example with some argument, I get back a function, a plain old function.
479600	485520	If I try to call it with two things, this is not going to work exactly the way I expect.
485520	487440	I still get a function back.
487440	489320	So how do I pass in A and B?
489320	494560	Well, since passing in A returns a function, I can immediately invoke that function expression.
494560	497720	Oh my God, if he's there back.
497720	499520	With the second argument.
499520	501780	And now I actually get a result.
501780	507420	So when I say in the Lambda calculus, every Lambda only has one input.
507420	511260	That doesn't mean we can't think in terms of multiple inputs.
511260	515380	We just do so in a kind of funny way where we split up all the inputs into a bunch of
515380	517300	nested return functions.
517300	523660	And that means to actually call a function with multiple inputs, we pass them in successively.
523660	528860	Not all in the same prems, just one after the other.
528860	531380	This gives us all the power that we normally get with JavaScript.
531380	536540	We can pass in both things simultaneously, which I just did.
536540	540980	But it also gives us new capabilities that normal JavaScript function signatures don't
540980	549540	have because I can actually, let's do this, you know what I'm going to do on the next
549540	550540	slide.
550540	556460	I can actually not pass in all my arguments and I get back, instead of nan or garbage
556460	560360	or something, I actually get back like the next step.
560360	563800	Which can await further action.
563800	566640	This is the most mathy complex part of the entire talk.
566640	568040	So get ready.
568040	569920	It's just function evaluation.
569920	572000	What is function evaluation in Lambda calculus?
572000	574240	It's symbol replacement.
574240	578280	So it's called beta reduction, but that just literally means we're going to replace inputs
578280	581280	with their arguments and then rewrite the body.
581280	583680	Example, here's a function in red.
583680	587760	I'm going to underline its argument to make this all very clear.
587760	592760	It comes into this function as its parameter A, and then we go look inside that function
592760	599160	body, find every A parameter, and replace it with the value we're binding.
599160	602920	So this just gets rewritten as its argument.
602920	603920	We just keep doing this.
603920	606080	So we have a function and an argument.
606080	608880	The argument gets bound to the B value here.
608880	609880	So what do we do?
609880	615400	We look at this function body, replace all the Bs with Xs, and that's symbol replacement,
615400	619680	which is all the Lambda calculus is, gives us this expression.
619680	622400	Once again, we have a function and an argument.
622400	625000	This is going to replace the C parameter.
625000	629040	So we go look in the function body for every C value, replace it.
629040	631240	There are no Cs here, so it's easy.
631240	633520	And we end up with a final value.
633520	637560	Now there's no more reducible expressions or red Xs, as they're called.
637560	640280	All these names are ridiculous, I'm sorry.
640280	645360	And so this is in beta normal form, which just means simplified.
645360	647160	There are little caveats here.
647160	655000	If you could do multiple evaluations in different orders, they don't give you different answers
655000	660880	exactly, but one way might give you an answer, and one might be an infinite loop.
660880	663120	So there's little tricks to that.
663120	667280	Another thing is that if you happen to have different functions that coincidentally share
667280	672240	the same variable names, you have to be very careful not to accidentally conflate those
672240	673280	variable names.
673280	675600	And there's algorithms to deal with that.
675600	677680	We're not going to go into them.
677680	683680	Okay, so I promised that I would show, where'd the K comb in there?
683680	686160	I guess I'll do that in a second.
686160	688040	I'm going to show you something after this.
688040	689040	We'll come back to it.
689040	690880	So this is the mockingbird.
690880	692160	What does it do?
692160	693160	It's interesting.
693160	697480	It takes in a value, and then it calls that value on itself.
697480	701480	So if the value is going to be called on itself, it probably should be a function.
701480	704720	So I'm labeling it as f.
704720	706720	Let's try this out.
706720	710960	Takes a function, calls the function on itself.
710960	712880	Weird.
712880	716360	What would the mockingbird of the identity function be?
716360	724920	Well, it takes i, it duplicates i, so this gets simplified to ii, and the identity of
724920	726960	identity we already established is...
726960	727960	Identity.
727960	730640	Yeah, identity.
730640	735720	So it looks immediately very strange, but then we immediately see a really trivial example
735720	738000	of how it can actually work.
738000	742720	The mockingbird of identity is the identity of identity, and the identity of identity
742720	744280	is identity.
744280	747360	Say that three times fast.
747360	749560	What's the mockingbird of mockingbird?
749560	751560	Whoa.
751560	753280	Let's try it out.
753280	754280	Any predictions?
754280	758360	It's a stack overflow.
758360	759920	Why is it a stack overflow?
760560	762600	The mockingbird duplicates things.
762600	768160	So if you duplicate m, we get the mockingbird of mockingbird, but we start it out there.
768160	770160	So this is just an infinite loop.
770160	771160	Yeah.
771160	772840	Too bad.
772840	777680	This actually is too bad because this is what the problem is with Turing completeness
777680	779880	as a concept.
779880	784880	In Turing complete systems, which this is one, you can have infinite loops, and it gets
784880	789080	even worse because you can't even tell if your expression will be an infinite loop.
789080	791280	You just have to try it and see.
791280	792840	Sometimes you can prove it for an individual expression.
792840	797440	You can say, I have a proof that this will loop indefinitely, but there's no machine that
797440	802080	I can feed this lambda calculus string into that will say, oh, be careful, that's an infinite
802080	803080	loop.
803080	805080	You can't do it without running it.
805080	806080	Yeah.
806080	808160	So that's a problem.
808160	812480	This particular expression in lambda calculus is known as omega, and here's the beautiful
812480	817200	thing about doing math and pen and paper instead of with a computer is that I can recognize
817200	821320	I'm entering an infinite loop and say, we'll just name this thing omega and not actually
821320	824920	keep trying to calculate it.
824920	829000	One thing that when I was learning about all this stuff and getting excited about it that
829000	834560	confused me a lot was that there are so many different names for these things.
834560	840320	So here I'm looking at the mockingbird, which is the omega combinator when applied to itself,
840320	844280	which is also written in lambda form.
844280	850160	It's like I was trying to sort all this out, and that's when I started writing this talk.
850160	855040	One little last thing about syntax, and then we get to more juicy stuff, I promise.
855040	860600	We can write things in this curried form, these nested lambdas, but it's hard to read,
860600	861600	right?
861600	864560	Like A returns a function that takes a B, returns a function that takes a C, that returns
864560	867000	B. There's a shorthand.
867000	870840	The shorthand is any nested lambdas, we just squish them all together and put them to the
870840	872040	left of the dot.
872040	877120	So we see that lambda ABC, it's the exact same thing, we haven't changed the meaning
877120	879960	of it, we're just writing it in a shorthand.
879960	884640	And then when you go and do this simplification and evaluation step, you just have to be very
884640	886920	careful to notice that.
886920	893320	So here we have a function that takes a B and C and returns a B. Or is it?
893320	899320	Remember it's that syntax shorthand, so really this is a function that takes B and returns
899320	905520	a new lambda that takes C. So anytime you've got multiple parameters between that lambda
905520	910600	and that dot, just remember there's a bunch of lambdas hidden, sandwiched between them.
910600	915640	And when you do this simplification, they have to pop back out.
915640	917840	Congratulations, you know the lambda calculus.
917840	919840	It talks over.
919840	920840	No.
920840	923600	All right, here's the part I was trying to get to earlier.
923600	926480	The kestrel, this is one of my favorite combinators.
926480	928080	How does it work?
928080	931720	It takes an A and a B and it returns A. So it takes two things and returns the first
931720	932720	one.
932720	938480	Wait, I already did that, but I'll rewrite it.
938480	941000	The k-combinator, let's try it out.
941000	944720	So I'm going to pass in two things, two symbols, arbitrary symbols, they don't mean anything.
944720	945720	You've never seen them before.
945720	949320	And look, it gave me back the first symbol, whatever it was.
949320	953680	I could do this if I really wanted.
953680	958640	So this is JavaScript really being symbolic.
958640	962960	And of course, I can pass in whatever and wait, I'll pass in K. And what should this
962960	963960	give me back?
963960	968080	So the k-combinator takes two things, returns the first one.
968080	972280	So I get back my first symbol and there actually are symbols in JavaScript now, which makes
972280	975240	this even better.
975240	982160	But why do I care about defining it in this one argument only nested lambda way?
982160	984240	This is the reason.
984240	991520	The k-5 function is if I call k with just one of its two arguments, not both of them.
991520	993800	Oh, it's a function.
993800	995880	What the heck is the use of that function?
995880	1001040	Well, if I call it on something else, it gives me back five.
1001040	1002920	What if I call it back on something completely different?
1002920	1004240	It gives me back five.
1004240	1005240	What if I call it on undefined?
1005240	1006560	It gives me back five.
1006560	1013280	The k-5 function or the constant five function is a function that is now stuck on and obsessed
1013280	1015440	with this value.
1015440	1018760	I can't get this function to return anything else.
1018760	1024760	Turns out that's useful for the same reason things like zero in a number system is useful.
1024760	1029320	Sometimes you need a function that does very little because you have an API that's like,
1029320	1030640	you must give me a function here.
1030640	1034200	And like, I don't want to give you a function, you're already doing everything I want.
1034200	1038880	So the identity function and the k-combinator, these things start to form very primitive,
1038880	1044720	almost trivial building blocks that slot into larger, more complicated systems.
1044720	1048280	So k of two things returns the first one.
1048280	1052640	If you swap them around, you still get the first one, whatever that is.
1052640	1057040	And in Haskell, this is called const, which isn't confusing for mainstream imperative
1057040	1059640	programmers at all.
1059640	1060640	It is a function.
1060640	1065400	The k-combinator takes two things, returns the first one.
1065400	1066880	Let's expand on this.
1066880	1074880	If we've got this k-combinator and we pass in two things, we get the first one.
1074880	1076960	You're getting it.
1076960	1078220	But wait a second.
1078220	1079440	This is math.
1079440	1081880	This isn't really programming, quite.
1081880	1083480	So this is a quality sign.
1083480	1085160	It's not an assignment operator.
1085160	1089680	This is a quality in the truest sense of whatever that means in math, which by the way is a
1089680	1093160	very deep topic that we wouldn't touch on.
1093160	1095040	What is the nature of equality?
1095040	1096540	People don't agree.
1096540	1102080	Anyway, so the thing on the left and the thing on the right are in theory the same thing.
1102080	1104120	But the thing on the right is a function.
1104120	1106200	It's the identity function.
1106200	1110720	That means I can call that function on a value.
1110720	1112800	Interesting.
1112800	1114640	But we know the identity of y, right?
1114640	1117360	We already know what that actually evaluates to.
1117360	1118360	That's y.
1118360	1119360	Huh.
1120360	1127160	So this function on the left, k, that I talked about taking two things, I've kind of passed
1127160	1133280	three things to, i, x, and y, and I actually get a result out of that.
1133280	1134280	That's weird.
1134280	1137800	I thought I'd define this function as only taking two inputs, but now I'm using it with
1137800	1139040	three.
1139040	1143920	This is the kind of weird flexibility and power that currying gives you.
1143920	1147440	When your functions are constantly returning other functions that return other functions
1147440	1152880	that return other functions, you can kind of chop things off early or extend them far
1152880	1157800	beyond what they were originally being used for, and they still do things, and those things
1157800	1159400	might end up being useful.
1159400	1160720	Why is this useful?
1160720	1162880	Because check this out.
1162880	1170880	The first two values there, ki, are a function being called on x and y, and they return the
1170880	1173080	second of those two things.
1173080	1175760	I start with k, returns the first of two things.
1175760	1185120	ki is a new function out of the ether that returns the second of two things.
1185120	1188320	I'm not hearing all the amazement I expected out of that.
1188320	1190600	Yeah, thank you.
1190600	1191800	This is called the kite.
1191800	1194040	So it's also easy to define.
1194040	1202120	I could do it the way I've been doing it, and say ki of two things returns a second.
1202120	1203120	There's the proof.
1203120	1210520	I could also define this as calling k on i, and now I can rename it, and it just looks
1210520	1215520	like a normal function, and it passes two things, and it gives me the second.
1215520	1221720	But what's really amazing about this is I never sat down and wrote out, look, ki takes
1221720	1224920	a, and it takes b, and it returns b.
1224920	1229880	I took two existing functions, neither of which talks about the second value of any
1229880	1231240	two inputs.
1231400	1237240	Just by smashing them together in this sort of atom-to-molecule way, it gave birth to
1237240	1243040	a new function with new behavior that I didn't manually specify.
1243040	1250440	So ki of m and k returns the second thing, ki of k and m returns the second thing, and
1250440	1258080	things are behaving more or less as we expect at this point.
1258080	1260600	What's with all the bird names?
1260960	1263880	Where's this coming from?
1263880	1272120	So there is a mathematician who had a brilliant short career, very sad ending to it, named
1272120	1273120	Schoenfinkel.
1273120	1274240	I can't pronounce German.
1274240	1279360	I'm sure many people in this room can pronounce German much better than I am, but he named
1279360	1287560	these things very long German names, like Sutsumetsetsungsfunktion, and then he shortened
1287560	1292160	them because it was annoying to write those down into things like i and k.
1292160	1298160	And then an American mathematician, Haskell B. Curry, studying this stuff, used many of
1298160	1304320	the same letters, switched some of the round just to confuse everyone who came later.
1304320	1311160	And then a logician and puzzle author whose books I really enjoy called Raymond Smullyan
1311160	1314120	wrote this book called To Mock a Mockingbird.
1314160	1320080	And to mock a mockingbird, it is all a extended metaphor of birds in a forest that call the
1320080	1324640	names of other birds, which give birth to birds, and you get where this is going.
1324640	1326040	It's the same thing.
1326040	1332120	He just took all those letters and he expanded them out into bird names for his metaphor.
1332120	1335920	By the way, if you try to learn commentary logic through Smullyan, I mean, you might
1335920	1338640	make some progress, but it is a puzzle book.
1338640	1340360	It's meant to be confusing.
1340360	1343840	So that's just fair warning for anyone who's like, I'm going to go buy the book now.
1343880	1344880	It is a good book.
1344880	1348880	You should check it out, but it's not meant to sort of be easy to follow.
1348880	1351360	Also, he called it the idiot bird.
1351360	1352360	I don't know.
1352360	1353360	It should have been Ibis.
1353360	1357560	Anyway, this was done in tribute to Curry, the other mathematician, because Curry was
1357560	1358960	a bird watcher.
1358960	1362560	And Haskell B. Curry, why do we care about this guy, and oh my god, okay, let's go talk
1362560	1364040	about history.
1364040	1368360	This is going to be the super fast version of this because I'm trying to stay under time.
1368360	1373160	But in the early 20th century, actually even late 19th century, mathematicians were trying
1373160	1375640	to figure out what is math?
1375640	1378960	And there are all these different systems that proceed from different axioms.
1378960	1384400	So what's the one true axiomatic system of math from which all of the things can be proved?
1384400	1388720	And it's nice and simple and intuitive looking and clean.
1388720	1392960	So Peano comes up with this thing called Peano arithmetic, which is like, I'm going to find
1392960	1393960	the numbers.
1393960	1395440	There's a thing called zero.
1395440	1398080	And one is the thing that comes after zero.
1398080	1401560	And two is the thing that comes after the thing that comes after zero.
1401560	1407160	And this sounds super trivial, but it actually forms a really sound foundation for very large
1407160	1410720	and complicated branches of math.
1410720	1418240	Frege, who's unfortunately not as well known as he should be, does amazing work in developing
1418240	1422440	concepts of combinatorial logic and functions and invent its own function notation, which
1422440	1426720	is in an abstract syntax tree, which by the way, it would have been so much easier to
1426720	1430440	simplify for people, but it doesn't type well, obviously, right?
1430440	1433120	Like if you're typesetting, you need a linear system.
1433120	1434120	And his was two-dimensional.
1434120	1438480	And he uses currying, although he doesn't draw attention to it.
1438480	1442640	And he develops a ton of work in axiomatic, quantified logic.
1442640	1447640	Things like for all x's in the real numbers, there exists a y such that y is greater than
1447640	1448640	x.
1448640	1453920	Those things like for all, and there exists, a lot of that originates with Frege.
1453920	1459400	1910, Russell and Whitehead famously published Principia Mathematica, which is another big
1459400	1465040	attempt at unifying all of math, a great grand unified theory of math.
1465040	1472320	Unfortunately, along the way, Russell discovers a paradox, an underlying flaw in set theory,
1472320	1480120	as it was known at the time, where the question of what about the set that contains all sets
1480120	1482360	that do not contain themselves or something like that?
1482360	1483360	I can't remember the details.
1483360	1486520	And he's like, wait a second.
1486520	1488120	Does that set contain itself or not?
1488480	1489640	You can't answer the question.
1489640	1491640	It's a nonsensical question.
1491640	1499280	This was a giant problem because tons of preexisting work was based on that version of set theory,
1499280	1502120	which is now shown to be inconsistent.
1502120	1503960	It didn't actually hold together.
1503960	1508340	So this was like the first big crack in the foundations of math, where people started
1508340	1512360	saying maybe this stuff is harder than we thought it was, because now we're trying to
1512360	1514360	be extra super-duper careful.
1515360	1519360	Schoenfinkel, 1920, does tons of work on combinatorial logic.
1519360	1524800	Now I'm talking about combinatorial logic, lambda calculus, JavaScript arrow functions.
1524800	1526120	What's the difference between all these things?
1526120	1530560	Well, we'll clarify that more throughout, but any time I'm using those letters like
1530560	1536720	k and s and i and m, that's combinatorial logic, and it's the study of functions that
1536720	1537720	act on each other.
1538160	1545320	And any time I'm showing you lambdas with lambda a dot b, et cetera, that is lambda calculus.
1545320	1548160	Turns out they overlap by like 99%.
1548160	1551960	They study functions, first-class, higher-order, anonymous functions.
1551960	1556160	Actually, the combinatorial logic ones are not anonymous, by definition.
1556160	1557960	But that's almost all the differences.
1557960	1561080	One of them, you give them names, and one of them, they're anonymous.
1561080	1564280	Van Neumann also doesn't work on this one.
1564280	1565280	I'm going to skip it.
1566280	1570680	Curry comes along and does a ton of this work, not knowing about Schoenfinkel, and then he
1570680	1572160	discovers all of Schoenfinkel's work.
1572160	1574440	He's like, oops, this guy already did it all.
1574440	1578880	But he keeps going, and he comes up with a lot of really great results as well.
1578880	1583040	By the way, now we know this thing that you split up the parameters as currying.
1583040	1586680	Okay, yeah.
1586680	1589520	But it really should be called Schoenfinkelization.
1589520	1598320	In 1931, Kurt Gerdel, or maybe fragification, I don't know, Gerdel now really upends all
1598320	1603160	math and just destroys all math forever with his incompleteness theorems, which prove that
1603160	1608560	any system that's sufficiently complicated and interesting is either inconsistent, meaning
1608560	1615040	it's flawed and actually nonsensical, or it is incomplete, which is the lesser of two
1615040	1618440	evils but still very disturbing for a mathematician.
1618480	1624320	This means you can talk about some possible thing that might be true or false in math,
1624320	1628800	but there might not ever be a proof of whether it is true or false.
1628800	1630080	But it is true or false.
1630080	1631960	You just can't find out.
1631960	1637520	It sounds like the most horrifyingly impossible thing to a mathematician, especially of that
1637520	1643000	time period, where math was seen as the language and nature of reality, that if you were working
1643000	1648120	on an unsolved problem, surely if you were just smart enough or determined enough or
1648120	1651720	had good enough teammates, you could all figure it out together.
1651720	1656040	Now Gerdel was coming along and saying, nope, you might never find the answer because it
1656040	1658880	might be impossible to find out the answer.
1658880	1659880	That was terrible.
1659880	1660880	It was really terrible.
1660880	1663680	By the way, a fun philosophy point.
1663680	1669320	People use this along with Einstein and general relativity in the 20th century to say that
1669320	1673480	the nature of reality is fluid and abstract and unknowable and things like that.
1673480	1677760	This really upset Gerdel because he viewed the incompleteness theorem as a universally
1677800	1681040	controversial fact about the universe.
1681040	1684680	He was really excited about this result because he's like, I've finally found something that
1684680	1691360	is always true and everyone else is like, oh my God, you've destroyed math.
1691360	1695040	Another thing, he works on general recursion theory, which is another big system trying
1695040	1698240	to unify all of mathematics.
1698240	1701920	Around the same time period, a Hungarian mathematician much less well-known, unfortunately
1701920	1707640	than Gerdel, is Rosa Pater and she is known as the mother of recursion theory.
1707680	1713360	She does a huge amount of recursive function theory development and work in papers for
1713360	1719480	decades, so I'm glad to be able to point that out.
1719480	1722960	Now we get to really what's at the subject of this.
1722960	1727480	The thread here has been all these people, very smart, are trying to figure out what
1727480	1730480	is math, what is the nature of math, how do we define it.
1730480	1735520	Now Alonzo Church comes along and defines this thing we've been looking at called lambda
1735520	1736520	cacons.
1736520	1737520	It's a little tiny language.
1737520	1738520	That's it.
1738520	1741280	It's just a notation system for symbol replacement.
1741280	1743120	That's what a calculus is, by the way.
1743120	1750640	A calculus is any formal system of rewriting symbols on a page and this is one for functions.
1750640	1755920	It turns out that that tiny little language is beautiful because of its simplicity, which
1755920	1761640	makes it easier to prove things about it than competing theories at the time, like
1761640	1766400	general recursive theory, which is more confusing to read, in my opinion.
1767400	1770440	Don't take that as gospel.
1770440	1775240	He's got some grad students, Stephen Claney goes on to invent regular expressions later,
1775240	1779080	but also these grad students help prove various things about lambda cac.
1779080	1783680	Then this is the brilliant shining moment where lambda calculus proved its worth.
1783680	1789400	These tiny little four lines of grammar and syntax were used to solve a giant unsolved
1789400	1795520	problem of the day called the decision problem, David Hilbert's decision problem, which was,
1795520	1799640	is there a machine that you could write, an algorithm you could design, that I could
1799640	1805440	feed into it some math expression and it will tell me if it will run into an infinite loop?
1805440	1809600	The answer to that is no, there is no such machine.
1809600	1811360	We already talked about that.
1811360	1815280	But church, what's interesting about this is that there's no such machine, but rather
1815280	1823080	that church used lambda calculus, which seems so tiny and trivial, to prove that result.
1823080	1828440	He published a paper and about a month later, Turing published another paper solving the
1828440	1832880	same thing with something much more famous called Turing machines.
1832880	1837440	Turing was a little upset that it turned out that the idea that he had been working on
1837440	1843200	for years, I think, he just never got around to publishing, he finally did it and someone
1843200	1849040	else had published a month earlier and yeah, sometimes that's the way it goes.
1849040	1851760	But he goes and looks at this and he's like, wait a second.
1851800	1858200	My Turing machines, which is this like stateful, imperative, sequential program instructions
1858200	1862920	and this lambda calculus thing, which is an expression that you just do simple replacement
1862920	1869440	and it simplifies, even though they look very different, I can write a lambda calculus interpreter
1869440	1877440	in my Turing machine and I can take a lambda calculus and use it to implement a Turing
1877440	1879080	machine simulation.
1879080	1884000	So wait a second, if there's something in a Turing machine, I can do it in lambda calculus
1884000	1888080	because I just use lambda calculus to simulate Turing machines and vice versa, therefore
1888080	1892600	these two systems are really just as powerful.
1892600	1894440	Anything one can do, the other can.
1894440	1898840	So they seem just like amazingly, even though they're completely independent schools of
1898840	1904800	thought and they're both trying to define what math is and all this business, they seem
1904840	1910080	to have accidentally discovered equally powerful systems for computing things.
1910080	1914960	So the church Turing thesis or hypothesis is not a fact.
1914960	1924760	The hypothesis is that these systems define computation in some deep philosophical way
1924760	1925760	that's undefinable.
1925760	1929680	So you can never prove it because it's not well defined.
1929680	1933040	The fact that lambda calculus interpreter machines are equally powerful is not the church Turing
1933040	1937720	thesis that's a common mistake.
1937720	1938720	So he's really excited about this.
1938720	1943640	He actually combs over to Princeton, gets a PhD under Alonzo Church, helps define like
1943640	1947320	new fixed point combinators and things like that.
1947320	1948320	What is a combinator?
1948320	1952840	I've said this word a couple of times, again, it's like all these different names for things.
1952840	1954920	Combinators are just functions with no free variables.
1954920	1960120	Remember I mentioned a free variable is one where you don't know what it's bound to, it's
1960120	1962920	not bound to anything, it's just kind of in space.
1962920	1964560	You end up with it and it's like, what does that mean?
1964560	1969840	I don't know, it's the symbol B. Combinators don't have those.
1969840	1977680	So all of their outputs are bound as inputs somewhere in the expression.
1977680	1981160	So the definition of B will come from somewhere when you use it.
1981160	1982160	It will not be undefined.
1982160	1987240	In other words, combinators can never have reference errors because their values are
1987240	1988240	all based on their inputs.
1988440	1991440	That's all they could do is remix their inputs.
1991440	1997560	And combinatorial logic, full circle now, is the study of those kinds of functions,
1997560	2000920	functions which act on each other in surprising ways.
2000920	2004640	We've seen a bunch, I, M, K, K, I, et cetera.
2004640	2006880	And again, this gets it like there's all these different names.
2006880	2011360	There's the Mockingbird versus Zem versus Lambda F to FF.
2011360	2014360	You can't actually define that one in Haskell, by the way.
2014360	2019360	Not simply because Haskell's type system doesn't like infinite types and the Mockingbird
2019360	2022640	is all about infinity.
2022640	2023640	There's a trick.
2023640	2030280	You can do it in Haskell through like a little type hack, but it's not beautiful.
2030280	2033480	Let's look at this one, the cardinal.
2033480	2037280	The cardinal is a very lovely combinator.
2037280	2040960	Takes three things, spits them back out in different order.
2040960	2046760	So let's say the first thing's a function and the second two things are inputs.
2046760	2056120	C combinator takes a function and A and B inputs and it calls the function with the
2056120	2059040	inputs reversed.
2059040	2061040	It flips the inputs around.
2061040	2062040	That's interesting.
2062040	2063920	What will we use or use that for?
2063920	2067000	Well, let's see examples of it just to make sure we're on the same page.
2067000	2073760	If I feed in a function like K into arguments like I and M, the K combinator returns the
2073760	2079680	first thing, so the flip of the K combinator returns the second thing.
2079680	2083440	Well, that's kind of cool.
2083440	2088320	Sometimes because of this couriering business, your inputs and your arguments don't have
2088320	2094840	quite the order you wish they did to make some of these tricks easier.
2094840	2100280	And so this flip combinator or cardinal or C combinator can rewire things for you so
2100280	2104320	that they take arguments in different orders.
2104320	2108360	And C of K takes two things and returns the second.
2108360	2111000	That sounds super familiar, right?
2111000	2115000	Flipping K gives you Ki.
2115000	2116600	They are the same function.
2116600	2118840	C of K and K of I are the same function.
2118840	2120480	They behave identically.
2120480	2123240	For every input, they give you the same output.
2123240	2127920	And when two functions that have been defined separately have nonetheless identical input
2127920	2132520	output behavior, they're called extensionally equal.
2132520	2137480	Extensional in the sense that from the outside, you can't see the guts of the function or
2137480	2139000	how it came into being.
2139000	2142000	All you can do is throw things in and see what comes out.
2142000	2145560	There's no way to distinguish those functions.
2145560	2149400	There's another kind of equality called intentional equality, which is more squirrely and it has
2149480	2151960	to do more with the internal guts.
2151960	2154640	We're not going to care about it.
2154640	2157520	So there's another beautiful combinator, the C combinator.
2157520	2160280	And in Haskell, it's called flip.
2160280	2164600	And if you've ever played around with Haskell and talked about point-free programming, flip
2164600	2169480	shows up a lot generally in a way that makes things much more confusing than they have
2169480	2170480	to be.
2170480	2176960	There's a cool site out there called pointfree.io that simplifies Haskell expressions, simplifies.
2176960	2178400	It really doesn't.
2178400	2183480	It shortens Haskell expressions to the minimal version that uses the fewest ingredients and
2183480	2190480	you'll just see tons of flip and ID and const and it's completely unreadable for humans.
2190480	2194680	Sometimes you get lucky and you get something that actually is simpler and easier, but flip
2194680	2199680	is one of these things that is very heavy in the rewiring that's possible.
2199680	2204120	Okay, I've talked about this for like 35 minutes.
2204120	2205120	Who cares?
2205120	2206120	What is the point?
2206120	2207120	We don't care about any of this.
2207120	2210880	Well, let's find out.
2210880	2213080	I talked about lambda calculus and Turing machines.
2213080	2215080	Why are Turing machines exciting?
2215080	2216080	Simple.
2216080	2217080	What?
2217080	2218080	Simple.
2218080	2219080	Simple.
2219080	2220480	They are simple.
2220480	2221480	So is lambda calculus.
2221480	2222480	They're both simple.
2222480	2226400	They're both so simple that it's almost hard to do anything with either of them, right?
2226400	2231480	Like if you've ever hand coded a Turing machine to do like anything interesting, it's very
2231480	2232480	complicated.
2232480	2238400	You have to write a one, write a zero, read something, go to memory address.
2238400	2241480	Like that's almost assembly.
2241480	2245600	And that's really why Turing machines are cool is because if a hypothetical machine
2245600	2249200	can calculate whatever you want it to, well, why not build real physical machines that
2249200	2250800	do the same thing?
2250800	2256200	So from Turing machines, we get the idea of let's make actual computers that can do this.
2256200	2261440	And those computers have to be programmed in this very low level on off switch state
2261440	2265320	version of programming called machine code.
2265320	2267280	But that's really hard for humans.
2267280	2274640	So now let's make a text representation called assembly of those very low level machine instructions.
2274640	2278360	But thinking in terms of machine instructions and assembly is still hard.
2278360	2284400	So now let's make high level textual languages that get translated into machine code and
2284400	2289480	aren't one to one correspondence and give you beautiful new human centric concepts.
2289480	2296560	Things like loops and variable assignment and stuff like that, which you don't get in
2296560	2300360	the same way for this low level stuff.
2300360	2305160	But those languages are still maybe saying, like, you tell me what memory to reserve and
2305160	2308960	what blocks and how much of it and how to index into it and things like that.
2308960	2313480	And someone out there is like, I'm sick of saying, you know, pointer to something.
2313480	2317160	Can't we just have a language where I say var x equals object and it'll go figure out
2317160	2319480	all that memory stuff for me?
2319480	2324040	So now we're going even further away from the machine and more towards the concepts
2324040	2329840	humans care about, which are, I've got a domain, I'm modeling something, I have ideas
2329840	2333360	that I want to bandy about.
2333360	2338080	And then we go even further and we say, like, wait, why do we even have state?
2338080	2340240	Why have variable mutation and reassignment?
2340240	2343520	That has to do with the way the machine physically works.
2343520	2345720	But we don't need that.
2345720	2350920	And if we take it out, some of our programs get a lot more typesafe.
2350920	2355760	And this whole time, the layers of languages that have been building up and people have
2355760	2362160	been inventing have been gradually moving away from the super imperative machine-based
2362160	2368560	way of thinking toward a more pure conceptual way of thinking.
2368560	2370280	And someone out there says, wait a second.
2370280	2373480	If lambda, cacos, and trig machines are equivalent, what if we went the opposite
2373480	2374760	direction?
2374760	2379600	What if we started with something that has absolutely no concept of a machine but is
2379600	2385360	still able to compute things and try to make it useful, try to make it work on a Turing
2385360	2386360	machine?
2386360	2388560	We know that it's possible.
2388560	2390240	Now the question is, can we optimize it?
2390240	2391240	Right?
2391240	2397920	Like, can we take this pure stateless functional way of thinking and make it perform well in
2397920	2400160	terms of memory and speed and stuff like that?
2400160	2403600	So we'll write these pure functional languages and we'll have compilers that have been very
2403600	2408640	cleverly written to develop good machine code from them.
2408640	2414280	These things are equivalent, which means everything can be functions, literally everything.
2414280	2416160	But not everything should be.
2416160	2419320	But more than you might think.
2419320	2421040	Such as bullions.
2421040	2423040	We're going to invent bullions from scratch now.
2423040	2424280	Let's do it.
2424280	2426680	Well, it's a problem because we don't have any of those things.
2426680	2428180	We just have parentheses.
2428180	2430180	So far, that's all we've got in our language and our parentheses.
2430180	2431180	We don't have equal signs.
2431180	2433180	We don't have the not operator.
2433180	2434680	We don't have ors.
2434680	2438100	We do have kind of variables, but the variables aren't bullions.
2438100	2441100	Like there's no concept of true-false.
2441100	2443100	Okay.
2443100	2444980	What are bullions used for?
2444980	2446180	A lot of things.
2446180	2448260	One thing they're used for is selection.
2448260	2453580	If some condition, then result, else different result.
2453580	2459380	Well, I've got two possible results and I'm selecting which one I want to use.
2459380	2463420	So if it's the true bullion, give me back the first expression.
2463420	2467300	And if it's the false one, give me back the second expression.
2467300	2468300	Huh.
2468300	2470500	Well, we don't have this syntax.
2470500	2474380	We don't have question marks and colon, so we'll just knock those out.
2474380	2476340	And then we have space.
2476340	2478780	So that means function application, right?
2478780	2480580	So whatever this thing, it has to be a function.
2480580	2483900	And I need two functions, one for true and one for false.
2483900	2488980	The true one will select the first expression and the false function will select the second
2488980	2489980	expression.
2489980	2490980	We've already seen this.
2490980	2493140	It's the k and ki functions.
2493140	2495220	Surprise, I already did it.
2495220	2502260	So we'll just go up in here and we'll now say, so if I log out the k function, by the
2502260	2507020	way, it says function k and node, I cheated ahead of time and I did load one tiny line
2507020	2511460	of functional stuff in here, not functional, but one tiny line of code that's not lambda
2511460	2516220	cacos or combinatorial logic, and that's to rewrite function names in node, which is
2516220	2519420	slightly annoying in node version 12.
2519420	2523140	But let's label this thing k slash true.
2523140	2525100	Ah, reference error.
2525100	2526100	Inspect is not defined.
2526100	2527100	Oh, my God.
2527100	2528100	Okay.
2528100	2529100	I reloaded this.
2529100	2530100	You know what?
2530100	2531100	We'll just not do it.
2531100	2533620	You'll all just remember that k is true.
2533620	2536980	See, this is what happens when you try to do it.
2536980	2539100	You try to go outside of pure math, right?
2539100	2541020	This is just a mess.
2541020	2544100	The ki function, unfortunately, this function is anonymous.
2544100	2548420	It doesn't have a name because I developed it by smushing together k and i.
2548420	2554020	So I'm going to quickly rewrite it manually, even though that's sad.
2554020	2555300	Great.
2555300	2559940	So anytime you see k, you can now think to yourself, oh, that's true.
2559940	2562820	And every time you see ki, you can think to yourself, that's false.
2562820	2567540	It's like if you see 1 and 0, you think true or false, or on and off you see true or false,
2567540	2571780	or true is true and false is false.
2571780	2573900	Now the k function is true and ki is false.
2573900	2577020	It's just a representation.
2577020	2586540	But if I have some condition like unknown bool is, quick, don't look.
2586540	2588260	No one saw that.
2588260	2590540	Well, which one is it?
2590580	2592820	I can find out by passing it two things.
2592820	2595020	If it was true, I get back the first thing.
2595020	2597780	Oh, I guess unknown bool was the true function.
2597780	2603340	So I could do everything I wanted, just like already out of the box.
2603340	2604900	All right, but that's not that interesting, right?
2604900	2607540	What's another thing we do with Boolean logic all the time?
2607540	2608420	We negate.
2608420	2610740	We actually transform things around.
2610740	2612540	The not operator.
2612540	2614940	Well, again, we don't have exclamation points, so we're going to get rid of that.
2614940	2616940	It becomes a function called not.
2616940	2619020	How do we define it?
2619020	2622820	If p is true, return false.
2622820	2626700	And if p is false, return true.
2626700	2630620	Well, we need to select between two possibilities.
2630620	2633820	The flip combinator is going to do this for us.
2633820	2635180	I've already defined not.
2635180	2637260	You didn't even realize at the time.
2637260	2641540	The flip combinator, the flip of k is ki and the flip of ki is k.
2641540	2645620	Which means the flip of true is false and the flip of false is true.
2645620	2649180	So not is just the c combinator.
2649180	2651060	Let's try it.
2651060	2655860	The flip of k is some function, but which one is it?
2655860	2657820	It's the false function.
2657820	2660460	It returns the second thing.
2660460	2666580	And the flip of ki, or false, is the true function.
2666580	2669100	So it returns the first thing.
2669100	2674740	We can also rename these like t is that and f is this.
2674740	2678940	So now we can say things like not true.
2678940	2679860	Which one is that?
2679860	2682700	Is that true or is it false?
2682700	2686540	It turns out not true is false, and it turns out not false is true.
2686540	2689980	And we just invented this out of the ether.
2689980	2691500	These are called church encodings.
2691500	2695620	Alonzo Church was one of the people who helped invent them.
2695620	2698180	And it's like, OK, we'll represent these things as functions.
2698180	2700580	And then we can do functions on them that transform them
2700580	2702140	and move them around.
2702140	2703620	There's other ways of doing them.
2703620	2706540	I've written one up there, like this lambda expression
2706540	2709500	is another way of defining the not function.
2709500	2712340	Let's move on and do and in the interest of time, of which
2712340	2715140	there is very little left.
2715140	2717140	The and function takes two booleans.
2719580	2722260	OK, so how does this work?
2722260	2726500	If both p and q are true, return true.
2726500	2730780	For anything else, the and function return false.
2730820	2733300	So we're taking in two booleans, p and q.
2733300	2734740	And remember, these are functions.
2734740	2738100	p and q are both functions.
2738100	2739740	So what can we do with those functions?
2739740	2742660	Well, we can use them to select things.
2742660	2745300	The first boolean input is going to select
2745300	2747420	between two expressions.
2747420	2752420	If p is false, it's going to return the second thing.
2752420	2755180	That's what the ki function does.
2755180	2760980	But if p is false, what should and return?
2760980	2762540	One of my booles is false.
2762540	2764580	So and should return false.
2764580	2767620	So p should return false.
2767620	2771620	And if p is true, what should and return?
2773980	2776500	Q, exactly.
2776500	2778100	Because it depends what q is, right?
2778100	2780540	If q is false, well, we should return false.
2780540	2783260	But if q is true, p was true and q is true.
2783260	2784500	So return q, which is true.
2784500	2785900	And hey, it all works.
2785900	2787540	And in fact, you could simplify that too.
2787540	2790620	If p is false, return p, which is false.
2790620	2792900	Let's try it.
2792900	2795860	Takes two unknown booleans.
2795860	2800260	And then if p is true, return whatever q is,
2800260	2802020	because we have to check it as well.
2802020	2805900	If p is false, well, we know p is false.
2805900	2809980	So just return p, because they're not both true.
2809980	2810620	And guess what?
2811340	2817020	I have to prove that it's actually, it's some boolean.
2817020	2819100	Oh, it actually worked that time.
2819100	2821940	So and true, true is that.
2821940	2824420	And true false is false.
2824420	2826220	And false false is false.
2826220	2827860	And false true is false.
2827860	2831300	Hey, we invented and boolean logic.
2831300	2832660	You can do the same thing with or.
2832660	2834220	It's just like slightly different order.
2834220	2837860	You say p returns p and q and things like that.
2837860	2840340	What is this?
2840380	2842460	This one's a little bit more dense.
2842460	2844300	And by the way, functional languages,
2844300	2847940	that function application has just a space.
2847940	2850700	Look how much easier it is to read when you don't have
2850700	2853140	all these parens for function evocation.
2853140	2854580	Like, I think that JavaScript is actually
2854580	2857940	harder to understand than the lambda calculus.
2857940	2860460	But if you want a little help, p selects
2860460	2861980	between two different things, depending
2861980	2863500	on whether it's true or false.
2863500	2865060	q selects between two different things,
2865060	2867540	depending on if it's true or false.
2867540	2869660	And the behavior of this unknown function,
2869660	2874140	this anonymous lambda, is if both p and q are true
2874140	2878780	or if both p and q are false, return true.
2878780	2882900	But if they're different from each other, return false.
2882900	2885460	So this is boolean equality.
2885460	2888060	And we can simplify it through some steps
2888060	2890300	that you can go review later in the slides.
2890300	2893940	It actually turns into this, which I'll do right now.
2893940	2897740	Boolean equality takes a p and a q,
2897740	2901740	and it calls p on q and not q.
2902660	2906740	And now I can test, hey, do true and false equal each other?
2906740	2907940	No.
2907940	2909940	Do false and false equal each other?
2909940	2912220	Maybe that's some function that just got
2912220	2915020	birthed out of nothingness, so let's check.
2915020	2916140	Yeah, it's the true function.
2916140	2918700	It's the one that returns the first thing.
2918700	2921980	And I'm gonna keep moving, because I'm almost out of time.
2922020	2923940	So we've got these church encodings, and they're lovely.
2923940	2925740	Hey, here's De Morgan's law.
2925740	2926860	It's a thing from logic.
2926860	2931700	It says not p and q is equal to not p or not q.
2931700	2936340	And now using just a lambda syntax anonymous functions,
2936340	2939340	we have this beautiful, concise, easy to read way
2939340	2941020	of expressing this logic.
2941020	2946020	The equality of not and pq or not p, not q
2946260	2949740	is always gonna be what you expect it to be.
2949740	2951260	Feed two booleans into this thing,
2951260	2953820	and by booleans I mean either k or ki,
2953820	2956820	and you get out what you would expect from boolean logic.
2957820	2960380	What else can we do with this kind of fun stuff?
2960380	2962140	We can invent numbers.
2962140	2964060	And if we got numbers, actually specifically
2964060	2966860	positive integers, actually specifically natural numbers,
2966860	2968020	zero and up.
2968980	2972220	If we've got those, well, a pair of numbers is fractions,
2972220	2975700	but we don't have pairs yet, so we can do arithmetic.
2975700	2977940	And we're gonna need some data structures.
2977940	2981020	So we'll invent those from scratch using just functions.
2981020	2982220	And once we have data structures
2982220	2983300	in arithmetic and things like that,
2983300	2985740	we can do data types and type systems.
2985740	2988060	And once we've invented some of that stuff,
2988060	2990420	we can also invent recursion from scratch.
2990420	2992780	Lambda calculus does not have named functions.
2992780	2995700	The c and k and i, that's commonest very logic.
2995700	2997900	We often refer to these functions by their names
2997900	3000860	because it's way easier than saying lambda, af,
3000860	3002020	ad, et cetera.
3002020	3004980	But lambda calculus itself does not have named functions.
3004980	3007820	In fact, it's deliberately designed without them
3007820	3009820	to make it easier to prove things about math
3009820	3011260	and the way things work.
3012380	3014940	So how do you do recursion in lambda calculus?
3014940	3017260	Well, sorry, you're gonna have to see part two
3017260	3019460	in the video online.
3019460	3020300	Yeah.
3021700	3023220	We're almost done.
3023220	3024100	Question.
3024100	3026100	So some fun little things at the end here.
3026100	3029180	How many combinators like c and k and stuff
3029180	3034180	do you think you need to cover every possible computation
3036260	3037940	to be able to do anything?
3037940	3038940	Because in combinatory logic,
3038940	3041100	you had to define all those functions ahead of time.
3041100	3041940	In lambda calculus,
3041940	3044260	you could define a function manually using syntax
3044260	3046660	whenever you want, but in combinatory logic,
3046660	3049900	you need to pre-define all these named functions.
3049900	3051540	So do you need 20 of them?
3051540	3052380	10, five?
3052380	3053220	Is it even possible?
3053220	3055420	Maybe you need an infinite number.
3055420	3059020	Well, here are two, the s and k combinator.
3060300	3064380	They behave together in all sorts of very clever ways.
3064380	3066460	And for instance, the i-combinator,
3066460	3070180	you can invent it by calling s on k of k.
3071220	3073260	And the v-combinator, which you didn't see,
3073260	3076180	it's in part two, it's a data structure, it's a two-tubble.
3076180	3078180	You can do by this nonsense.
3080180	3081580	But it gets even smaller.
3081580	3084180	You can do everything with a single function.
3084180	3087380	So if you really wanted to go crazy,
3087380	3089820	you could take this iota function
3089820	3092820	and write any other function in existence
3092820	3095380	using just this and parentheses.
3097060	3097900	But why?
3098980	3100740	So what is the point of this entire talk?
3100740	3102740	Like, why am I here talking about this?
3103860	3105580	The short answer is I just really like it,
3105580	3108460	and I hope that you've enjoyed it.
3108460	3110660	It's kind of a game, like I read about this stuff
3110660	3112220	in Smollion's book, which was deliberately
3112220	3113220	supposed to be entertaining.
3113220	3114780	It's logic puzzles and games,
3114780	3118340	and things to exercise your mind and think about.
3118340	3121820	It's also really great practice for thinking functionally,
3121820	3123940	not because in a functional programming language,
3123940	3125980	you have to invent Booleans from scratch,
3125980	3127100	although often you do.
3128540	3129980	Not quite in that way, though.
3131540	3135300	But just the act of doing all these function evaluations
3135300	3137540	with symbol manipulation and substitution
3137540	3139900	and evaluating things and seeing the power
3139900	3142100	of functions operating on each other
3142100	3144460	makes that sort of foundational knowledge
3144460	3146260	of working in a functional language
3146260	3148140	just feel much more comfortable.
3148140	3151580	It's a form of exercise of calisthenics.
3152940	3156540	Programming languages like Haskell and PureScript
3156540	3158860	and Agda, I guess, I don't know,
3158860	3160580	and Elm and other things.
3161580	3165500	Their basis and their core are lambda-calculi,
3165500	3168300	slightly souped up ones like System F and System FC
3168300	3171380	and things which add types and all sorts of stuff.
3171380	3173420	But you know how Haskell actually works?
3173420	3174540	It's great.
3174540	3176700	You write Haskell.
3176700	3179500	The compiler takes that and simplifies it down
3179500	3182100	to a slightly souped up lambda-calculus.
3182100	3185140	And then it pairs that lambda-calculus program
3185140	3187980	that was from what you originally wrote
3187980	3192980	as like a sane thing with a runtime written in C
3193100	3195300	that's a lambda-calculus interpreter.
3195300	3197140	And that's how Haskell works.
3197140	3199100	That's why the minimum size for any Haskell program
3199100	3200780	is like eight megabytes or something
3200780	3202500	because it ships with this lambda-calc interpreter
3202500	3203460	that runs your code.
3204460	3207380	I think personally though, at the end of the day,
3207380	3210420	like I don't wanna have to defend or justify
3210420	3212060	and say like you should all learn lambda-calculi
3212060	3214860	because it'll let you do this thing in your job.
3215900	3217100	It might be able to.
3217100	3220420	There's a couple cool examples I can think of
3220420	3223540	that I've now thought of after the fact.
3223540	3225900	But for me, it's like pure art for art's sake.
3225900	3227420	And I just think that's like a lovely thing
3227420	3229980	to find in programming and computer science.
3231700	3233420	And yeah, there's the Y Combinator.
3233420	3234780	That invents recursion.
3234780	3236500	You can go see about it later.
3236500	3238300	So there's a whole bunch of slides and stuff in here
3238300	3239260	for reference.
3239260	3242020	These are all part two and then yeah, there's resources.
3242020	3246300	And I guess seven minutes over time, that's not too bad.
3246300	3247340	Let's do questions.
3247340	3248180	Thank you.
