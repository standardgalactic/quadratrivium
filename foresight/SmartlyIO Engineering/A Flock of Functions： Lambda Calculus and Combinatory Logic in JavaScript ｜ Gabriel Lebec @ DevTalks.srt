1
00:00:00,000 --> 00:00:12,440
Okay, hello everybody, thank you.

2
00:00:12,440 --> 00:00:13,680
Really excited to be here.

3
00:00:13,680 --> 00:00:19,200
Quick little about me, I made this talk while I was working at Fullstack Academy as an instructor,

4
00:00:19,200 --> 00:00:21,680
so it's going to hopefully be a little educational.

5
00:00:21,680 --> 00:00:27,520
I currently work at Google, but this talk isn't about that, I'm not representing Google

6
00:00:27,520 --> 00:00:28,520
or anything.

7
00:00:28,520 --> 00:00:31,320
My thoughts and opinions are my own, et cetera.

8
00:00:31,320 --> 00:00:35,160
And this is the smartly version of this talk, so it's been slightly tweaked and improved

9
00:00:35,160 --> 00:00:36,160
in various ways.

10
00:00:36,160 --> 00:00:39,680
And I've got social media accounts and things like that.

11
00:00:39,680 --> 00:00:44,480
There are slides posted online, this will be in the video, slash we'll post it later,

12
00:00:44,480 --> 00:00:47,520
you can go find them, and let's get started.

13
00:00:47,520 --> 00:00:57,080
So I'm going to start off with this combinator called identity, and it looks like this.

14
00:00:57,080 --> 00:01:05,360
It is a function that takes an input A and returns A. It's pretty straightforward, so

15
00:01:05,360 --> 00:01:06,520
let's try it out.

16
00:01:06,520 --> 00:01:16,640
So the identity of one is, yeah, it's interactive, and the identity of identity is identity.

17
00:01:16,640 --> 00:01:22,840
Okay, so right off the bat, we have something cool, which is functions can be arguments

18
00:01:22,840 --> 00:01:23,840
to other functions.

19
00:01:23,840 --> 00:01:29,040
First class functions, and that is a defining characteristic of the lambda calculus slash

20
00:01:29,040 --> 00:01:31,080
combinator logic.

21
00:01:31,080 --> 00:01:36,040
So the identity of any X is X, and we can write that a whole bunch of different ways.

22
00:01:36,040 --> 00:01:42,120
You've got JavaScript arrow functions on the board, we have this I variable that has an

23
00:01:42,120 --> 00:01:47,080
equation that's called combinator logic, and we have this shaded out lambda thing below

24
00:01:47,080 --> 00:01:52,840
it, you'll be able to go see these notes in the slides, you don't necessarily have to

25
00:01:52,840 --> 00:01:57,180
try and read all the actual lambda calculus syntax for this talk.

26
00:01:57,180 --> 00:02:01,320
So I'm not going to be showing it all the time, I'm going to focus on the very high-level

27
00:02:01,320 --> 00:02:03,040
concepts.

28
00:02:03,040 --> 00:02:07,800
And we saw that the identity of identity is itself, so yes, functions can be arguments

29
00:02:07,800 --> 00:02:11,600
to functions and return functions and do all that stuff.

30
00:02:11,600 --> 00:02:18,840
In Haskell, this is built into the base common library that everybody imports usually as

31
00:02:18,840 --> 00:02:25,680
the ID or identity function, and it behaves exactly as shown, the identity of 5 is 5.

32
00:02:25,680 --> 00:02:28,760
So what is up with this lambda notation?

33
00:02:28,760 --> 00:02:30,960
It literally just means function.

34
00:02:30,960 --> 00:02:36,160
If you were writing JavaScript the long way and not with an arrow function, it's the word

35
00:02:36,160 --> 00:02:37,160
function.

36
00:02:37,160 --> 00:02:43,040
If you're writing Python, it's like def function or something like that, I don't know.

37
00:02:43,040 --> 00:02:45,480
And it takes a parameter, it takes an input.

38
00:02:45,480 --> 00:02:51,280
All functions in the actual strict modified lambda calculus take only one argument.

39
00:02:51,280 --> 00:02:53,080
We'll see how that's useful later.

40
00:02:53,080 --> 00:02:55,320
And then finally it returns some expression.

41
00:02:55,320 --> 00:02:58,880
In this case, the identity function returns its input.

42
00:02:58,880 --> 00:03:03,360
And this whole thing together is sometimes called a lambda abstraction, abstraction

43
00:03:03,360 --> 00:03:08,800
because it abstracts away through a parameter, concrete use cases.

44
00:03:08,800 --> 00:03:13,720
So one concrete use case might be if A was 1, this would return 1.

45
00:03:13,720 --> 00:03:16,960
If A was hello, this would return hello.

46
00:03:16,960 --> 00:03:22,920
So by parameterizing those concrete use cases, we end up with an abstraction.

47
00:03:22,920 --> 00:03:26,600
But it's really just a fancy way of saying it's a function.

48
00:03:26,600 --> 00:03:30,360
There's all sorts of syntaxes across programming languages for these things, and you'll probably

49
00:03:30,360 --> 00:03:36,440
have heard about them, and it's like, oh, now Java has lambdas, and why is that exciting?

50
00:03:36,440 --> 00:03:39,560
Turns out there's a lot of different ways of writing these.

51
00:03:39,560 --> 00:03:43,800
This is the worst, unfortunately.

52
00:03:43,800 --> 00:03:46,800
I mean, just compare and contrast, right?

53
00:03:46,800 --> 00:03:47,800
But they are fun.

54
00:03:47,800 --> 00:03:48,800
They are exciting.

55
00:03:48,800 --> 00:03:52,400
And there's a reason they show up a lot in functional programming.

56
00:03:52,400 --> 00:03:58,560
If you're familiar with sort of the COPSI way of showing syntax, this is the grammar

57
00:03:58,560 --> 00:04:00,640
for the lambda calculus.

58
00:04:00,640 --> 00:04:02,400
This is a very tiny language.

59
00:04:02,400 --> 00:04:04,480
It only has really four things.

60
00:04:04,480 --> 00:04:07,120
It has variables, which are just plain old symbols.

61
00:04:07,120 --> 00:04:13,120
It has a function being applied to its argument that's application, and that's just by a space.

62
00:04:13,120 --> 00:04:16,840
A space between two things means function applied to argument.

63
00:04:16,840 --> 00:04:19,640
It has function definitions, which we just saw, and they're called abstractions.

64
00:04:19,640 --> 00:04:24,360
And then it's got parentheses to control what order things are evaluated in.

65
00:04:24,360 --> 00:04:28,680
So this whole talk, I'm going to be comparing and contrasting the way these things look,

66
00:04:28,680 --> 00:04:31,240
but they're really the same concepts.

67
00:04:31,240 --> 00:04:33,200
Variables can hold a value.

68
00:04:33,200 --> 00:04:34,840
Very important difference here.

69
00:04:34,840 --> 00:04:38,680
In the lambda calculus, there's no such thing as a mutable variable.

70
00:04:38,680 --> 00:04:41,360
All variables are immutable.

71
00:04:41,360 --> 00:04:46,320
They have a definition, and you might know that definition, or you might not, but it

72
00:04:46,320 --> 00:04:47,320
never changes.

73
00:04:47,320 --> 00:04:48,320
You never reassign.

74
00:04:48,320 --> 00:04:49,320
All right.

75
00:04:49,320 --> 00:04:51,440
I talked about function applications.

76
00:04:51,440 --> 00:04:55,240
Again, just a space means function called on argument.

77
00:04:55,240 --> 00:05:00,520
We tend to say function applied to argument or function invoked with argument.

78
00:05:00,520 --> 00:05:02,360
And there's little details here.

79
00:05:02,360 --> 00:05:09,840
For example, it's left associative application, so that FAB line right there means first

80
00:05:09,840 --> 00:05:16,480
call F with A, and that returns a function, and call that with B, which we can disambiguate

81
00:05:16,480 --> 00:05:21,960
using those ghosted out parens and say, like, okay, to make this really clear, we're passing

82
00:05:21,960 --> 00:05:25,960
A into F, and then we're passing B into the result of that.

83
00:05:25,960 --> 00:05:29,720
But since it is left associative, we typically just don't write that down.

84
00:05:29,720 --> 00:05:32,400
So you won't see those parens.

85
00:05:32,400 --> 00:05:37,440
In contrast, you'll notice that the last line there, those parens around AB, that does

86
00:05:37,440 --> 00:05:38,600
change the expression.

87
00:05:38,600 --> 00:05:41,040
That is now a different expression.

88
00:05:41,040 --> 00:05:46,280
It means first call the A function with the B argument, and then pass that result into

89
00:05:46,280 --> 00:05:51,080
F. So now we've muddled up the order of things.

90
00:05:51,080 --> 00:05:53,320
Abstractions, these are function definitions.

91
00:05:53,320 --> 00:05:54,960
They're just JavaScript arrows.

92
00:05:54,960 --> 00:05:59,200
That's all they are.

93
00:05:59,200 --> 00:06:00,200
How do they work?

94
00:06:00,200 --> 00:06:03,080
Well, again, you got lambda means function definition.

95
00:06:03,080 --> 00:06:05,160
Dot means return.

96
00:06:05,160 --> 00:06:10,240
So lambda A dot B means taking an A and return B. What do A and B have to do with each other

97
00:06:10,240 --> 00:06:12,120
in this particular example?

98
00:06:12,120 --> 00:06:13,120
Absolutely nothing.

99
00:06:13,120 --> 00:06:17,120
So this throws out the A argument and returns whatever B is.

100
00:06:17,120 --> 00:06:18,320
What is B in this slide?

101
00:06:18,320 --> 00:06:19,760
The answer is we don't know.

102
00:06:19,760 --> 00:06:20,760
We don't know what B is.

103
00:06:20,760 --> 00:06:22,320
It's a free variable.

104
00:06:22,320 --> 00:06:23,980
It's not defined anywhere.

105
00:06:23,980 --> 00:06:28,300
So if you were doing lambda calculus by hand, you would simplify this.

106
00:06:28,300 --> 00:06:33,580
If you called this function on an argument, you'd say it returns B whatever that is.

107
00:06:33,580 --> 00:06:34,660
And that's fine.

108
00:06:34,660 --> 00:06:37,380
You don't have reference errors in lambda calculus.

109
00:06:37,380 --> 00:06:43,660
You end up with a symbol, and that symbol might stand for something or might not.

110
00:06:43,660 --> 00:06:45,300
Anything else of interest on this slide?

111
00:06:45,300 --> 00:06:47,460
Not really.

112
00:06:47,460 --> 00:06:49,820
One maybe perhaps the last thing there.

113
00:06:49,820 --> 00:06:52,980
You'll notice that you can have nested lambdas.

114
00:06:52,980 --> 00:07:00,780
So A returns B returns A is just like if you had serial arrows in a JavaScript expression.

115
00:07:00,780 --> 00:07:03,460
And this is actually right associative.

116
00:07:03,460 --> 00:07:06,820
So associativity goes all over the place of lambda calculus.

117
00:07:06,820 --> 00:07:09,340
That could be one of the confusing things at first.

118
00:07:09,340 --> 00:07:15,260
But that means that bottom function there, if you pass an argument in as A, it doesn't

119
00:07:15,260 --> 00:07:18,060
return the final thing.

120
00:07:18,060 --> 00:07:22,960
It returns a new function that takes a B. And when you call that second function, final

121
00:07:22,960 --> 00:07:28,600
really it returns an A. This is, by the way, known very popularly as curing.

122
00:07:28,600 --> 00:07:32,160
So let's see that again actually.

123
00:07:32,160 --> 00:07:38,880
So that bottom function there, we can see in JavaScript is defined as A takes that, returns

124
00:07:38,880 --> 00:07:40,680
that, and blah, blah, blah.

125
00:07:40,680 --> 00:07:44,120
I didn't bind it as anything, so I can't use it.

126
00:07:44,120 --> 00:07:48,440
But we'll call this example.

127
00:07:48,440 --> 00:07:52,400
That's a classic, right?

128
00:07:52,400 --> 00:07:59,600
So if I call example with some argument, I get back a function, a plain old function.

129
00:07:59,600 --> 00:08:05,520
If I try to call it with two things, this is not going to work exactly the way I expect.

130
00:08:05,520 --> 00:08:07,440
I still get a function back.

131
00:08:07,440 --> 00:08:09,320
So how do I pass in A and B?

132
00:08:09,320 --> 00:08:14,560
Well, since passing in A returns a function, I can immediately invoke that function expression.

133
00:08:14,560 --> 00:08:17,720
Oh my God, if he's there back.

134
00:08:17,720 --> 00:08:19,520
With the second argument.

135
00:08:19,520 --> 00:08:21,780
And now I actually get a result.

136
00:08:21,780 --> 00:08:27,420
So when I say in the Lambda calculus, every Lambda only has one input.

137
00:08:27,420 --> 00:08:31,260
That doesn't mean we can't think in terms of multiple inputs.

138
00:08:31,260 --> 00:08:35,380
We just do so in a kind of funny way where we split up all the inputs into a bunch of

139
00:08:35,380 --> 00:08:37,300
nested return functions.

140
00:08:37,300 --> 00:08:43,660
And that means to actually call a function with multiple inputs, we pass them in successively.

141
00:08:43,660 --> 00:08:48,860
Not all in the same prems, just one after the other.

142
00:08:48,860 --> 00:08:51,380
This gives us all the power that we normally get with JavaScript.

143
00:08:51,380 --> 00:08:56,540
We can pass in both things simultaneously, which I just did.

144
00:08:56,540 --> 00:09:00,980
But it also gives us new capabilities that normal JavaScript function signatures don't

145
00:09:00,980 --> 00:09:09,540
have because I can actually, let's do this, you know what I'm going to do on the next

146
00:09:09,540 --> 00:09:10,540
slide.

147
00:09:10,540 --> 00:09:16,460
I can actually not pass in all my arguments and I get back, instead of nan or garbage

148
00:09:16,460 --> 00:09:20,360
or something, I actually get back like the next step.

149
00:09:20,360 --> 00:09:23,800
Which can await further action.

150
00:09:23,800 --> 00:09:26,640
This is the most mathy complex part of the entire talk.

151
00:09:26,640 --> 00:09:28,040
So get ready.

152
00:09:28,040 --> 00:09:29,920
It's just function evaluation.

153
00:09:29,920 --> 00:09:32,000
What is function evaluation in Lambda calculus?

154
00:09:32,000 --> 00:09:34,240
It's symbol replacement.

155
00:09:34,240 --> 00:09:38,280
So it's called beta reduction, but that just literally means we're going to replace inputs

156
00:09:38,280 --> 00:09:41,280
with their arguments and then rewrite the body.

157
00:09:41,280 --> 00:09:43,680
Example, here's a function in red.

158
00:09:43,680 --> 00:09:47,760
I'm going to underline its argument to make this all very clear.

159
00:09:47,760 --> 00:09:52,760
It comes into this function as its parameter A, and then we go look inside that function

160
00:09:52,760 --> 00:09:59,160
body, find every A parameter, and replace it with the value we're binding.

161
00:09:59,160 --> 00:10:02,920
So this just gets rewritten as its argument.

162
00:10:02,920 --> 00:10:03,920
We just keep doing this.

163
00:10:03,920 --> 00:10:06,080
So we have a function and an argument.

164
00:10:06,080 --> 00:10:08,880
The argument gets bound to the B value here.

165
00:10:08,880 --> 00:10:09,880
So what do we do?

166
00:10:09,880 --> 00:10:15,400
We look at this function body, replace all the Bs with Xs, and that's symbol replacement,

167
00:10:15,400 --> 00:10:19,680
which is all the Lambda calculus is, gives us this expression.

168
00:10:19,680 --> 00:10:22,400
Once again, we have a function and an argument.

169
00:10:22,400 --> 00:10:25,000
This is going to replace the C parameter.

170
00:10:25,000 --> 00:10:29,040
So we go look in the function body for every C value, replace it.

171
00:10:29,040 --> 00:10:31,240
There are no Cs here, so it's easy.

172
00:10:31,240 --> 00:10:33,520
And we end up with a final value.

173
00:10:33,520 --> 00:10:37,560
Now there's no more reducible expressions or red Xs, as they're called.

174
00:10:37,560 --> 00:10:40,280
All these names are ridiculous, I'm sorry.

175
00:10:40,280 --> 00:10:45,360
And so this is in beta normal form, which just means simplified.

176
00:10:45,360 --> 00:10:47,160
There are little caveats here.

177
00:10:47,160 --> 00:10:55,000
If you could do multiple evaluations in different orders, they don't give you different answers

178
00:10:55,000 --> 00:11:00,880
exactly, but one way might give you an answer, and one might be an infinite loop.

179
00:11:00,880 --> 00:11:03,120
So there's little tricks to that.

180
00:11:03,120 --> 00:11:07,280
Another thing is that if you happen to have different functions that coincidentally share

181
00:11:07,280 --> 00:11:12,240
the same variable names, you have to be very careful not to accidentally conflate those

182
00:11:12,240 --> 00:11:13,280
variable names.

183
00:11:13,280 --> 00:11:15,600
And there's algorithms to deal with that.

184
00:11:15,600 --> 00:11:17,680
We're not going to go into them.

185
00:11:17,680 --> 00:11:23,680
Okay, so I promised that I would show, where'd the K comb in there?

186
00:11:23,680 --> 00:11:26,160
I guess I'll do that in a second.

187
00:11:26,160 --> 00:11:28,040
I'm going to show you something after this.

188
00:11:28,040 --> 00:11:29,040
We'll come back to it.

189
00:11:29,040 --> 00:11:30,880
So this is the mockingbird.

190
00:11:30,880 --> 00:11:32,160
What does it do?

191
00:11:32,160 --> 00:11:33,160
It's interesting.

192
00:11:33,160 --> 00:11:37,480
It takes in a value, and then it calls that value on itself.

193
00:11:37,480 --> 00:11:41,480
So if the value is going to be called on itself, it probably should be a function.

194
00:11:41,480 --> 00:11:44,720
So I'm labeling it as f.

195
00:11:44,720 --> 00:11:46,720
Let's try this out.

196
00:11:46,720 --> 00:11:50,960
Takes a function, calls the function on itself.

197
00:11:50,960 --> 00:11:52,880
Weird.

198
00:11:52,880 --> 00:11:56,360
What would the mockingbird of the identity function be?

199
00:11:56,360 --> 00:12:04,920
Well, it takes i, it duplicates i, so this gets simplified to ii, and the identity of

200
00:12:04,920 --> 00:12:06,960
identity we already established is...

201
00:12:06,960 --> 00:12:07,960
Identity.

202
00:12:07,960 --> 00:12:10,640
Yeah, identity.

203
00:12:10,640 --> 00:12:15,720
So it looks immediately very strange, but then we immediately see a really trivial example

204
00:12:15,720 --> 00:12:18,000
of how it can actually work.

205
00:12:18,000 --> 00:12:22,720
The mockingbird of identity is the identity of identity, and the identity of identity

206
00:12:22,720 --> 00:12:24,280
is identity.

207
00:12:24,280 --> 00:12:27,360
Say that three times fast.

208
00:12:27,360 --> 00:12:29,560
What's the mockingbird of mockingbird?

209
00:12:29,560 --> 00:12:31,560
Whoa.

210
00:12:31,560 --> 00:12:33,280
Let's try it out.

211
00:12:33,280 --> 00:12:34,280
Any predictions?

212
00:12:34,280 --> 00:12:38,360
It's a stack overflow.

213
00:12:38,360 --> 00:12:39,920
Why is it a stack overflow?

214
00:12:40,560 --> 00:12:42,600
The mockingbird duplicates things.

215
00:12:42,600 --> 00:12:48,160
So if you duplicate m, we get the mockingbird of mockingbird, but we start it out there.

216
00:12:48,160 --> 00:12:50,160
So this is just an infinite loop.

217
00:12:50,160 --> 00:12:51,160
Yeah.

218
00:12:51,160 --> 00:12:52,840
Too bad.

219
00:12:52,840 --> 00:12:57,680
This actually is too bad because this is what the problem is with Turing completeness

220
00:12:57,680 --> 00:12:59,880
as a concept.

221
00:12:59,880 --> 00:13:04,880
In Turing complete systems, which this is one, you can have infinite loops, and it gets

222
00:13:04,880 --> 00:13:09,080
even worse because you can't even tell if your expression will be an infinite loop.

223
00:13:09,080 --> 00:13:11,280
You just have to try it and see.

224
00:13:11,280 --> 00:13:12,840
Sometimes you can prove it for an individual expression.

225
00:13:12,840 --> 00:13:17,440
You can say, I have a proof that this will loop indefinitely, but there's no machine that

226
00:13:17,440 --> 00:13:22,080
I can feed this lambda calculus string into that will say, oh, be careful, that's an infinite

227
00:13:22,080 --> 00:13:23,080
loop.

228
00:13:23,080 --> 00:13:25,080
You can't do it without running it.

229
00:13:25,080 --> 00:13:26,080
Yeah.

230
00:13:26,080 --> 00:13:28,160
So that's a problem.

231
00:13:28,160 --> 00:13:32,480
This particular expression in lambda calculus is known as omega, and here's the beautiful

232
00:13:32,480 --> 00:13:37,200
thing about doing math and pen and paper instead of with a computer is that I can recognize

233
00:13:37,200 --> 00:13:41,320
I'm entering an infinite loop and say, we'll just name this thing omega and not actually

234
00:13:41,320 --> 00:13:44,920
keep trying to calculate it.

235
00:13:44,920 --> 00:13:49,000
One thing that when I was learning about all this stuff and getting excited about it that

236
00:13:49,000 --> 00:13:54,560
confused me a lot was that there are so many different names for these things.

237
00:13:54,560 --> 00:14:00,320
So here I'm looking at the mockingbird, which is the omega combinator when applied to itself,

238
00:14:00,320 --> 00:14:04,280
which is also written in lambda form.

239
00:14:04,280 --> 00:14:10,160
It's like I was trying to sort all this out, and that's when I started writing this talk.

240
00:14:10,160 --> 00:14:15,040
One little last thing about syntax, and then we get to more juicy stuff, I promise.

241
00:14:15,040 --> 00:14:20,600
We can write things in this curried form, these nested lambdas, but it's hard to read,

242
00:14:20,600 --> 00:14:21,600
right?

243
00:14:21,600 --> 00:14:24,560
Like A returns a function that takes a B, returns a function that takes a C, that returns

244
00:14:24,560 --> 00:14:27,000
B. There's a shorthand.

245
00:14:27,000 --> 00:14:30,840
The shorthand is any nested lambdas, we just squish them all together and put them to the

246
00:14:30,840 --> 00:14:32,040
left of the dot.

247
00:14:32,040 --> 00:14:37,120
So we see that lambda ABC, it's the exact same thing, we haven't changed the meaning

248
00:14:37,120 --> 00:14:39,960
of it, we're just writing it in a shorthand.

249
00:14:39,960 --> 00:14:44,640
And then when you go and do this simplification and evaluation step, you just have to be very

250
00:14:44,640 --> 00:14:46,920
careful to notice that.

251
00:14:46,920 --> 00:14:53,320
So here we have a function that takes a B and C and returns a B. Or is it?

252
00:14:53,320 --> 00:14:59,320
Remember it's that syntax shorthand, so really this is a function that takes B and returns

253
00:14:59,320 --> 00:15:05,520
a new lambda that takes C. So anytime you've got multiple parameters between that lambda

254
00:15:05,520 --> 00:15:10,600
and that dot, just remember there's a bunch of lambdas hidden, sandwiched between them.

255
00:15:10,600 --> 00:15:15,640
And when you do this simplification, they have to pop back out.

256
00:15:15,640 --> 00:15:17,840
Congratulations, you know the lambda calculus.

257
00:15:17,840 --> 00:15:19,840
It talks over.

258
00:15:19,840 --> 00:15:20,840
No.

259
00:15:20,840 --> 00:15:23,600
All right, here's the part I was trying to get to earlier.

260
00:15:23,600 --> 00:15:26,480
The kestrel, this is one of my favorite combinators.

261
00:15:26,480 --> 00:15:28,080
How does it work?

262
00:15:28,080 --> 00:15:31,720
It takes an A and a B and it returns A. So it takes two things and returns the first

263
00:15:31,720 --> 00:15:32,720
one.

264
00:15:32,720 --> 00:15:38,480
Wait, I already did that, but I'll rewrite it.

265
00:15:38,480 --> 00:15:41,000
The k-combinator, let's try it out.

266
00:15:41,000 --> 00:15:44,720
So I'm going to pass in two things, two symbols, arbitrary symbols, they don't mean anything.

267
00:15:44,720 --> 00:15:45,720
You've never seen them before.

268
00:15:45,720 --> 00:15:49,320
And look, it gave me back the first symbol, whatever it was.

269
00:15:49,320 --> 00:15:53,680
I could do this if I really wanted.

270
00:15:53,680 --> 00:15:58,640
So this is JavaScript really being symbolic.

271
00:15:58,640 --> 00:16:02,960
And of course, I can pass in whatever and wait, I'll pass in K. And what should this

272
00:16:02,960 --> 00:16:03,960
give me back?

273
00:16:03,960 --> 00:16:08,080
So the k-combinator takes two things, returns the first one.

274
00:16:08,080 --> 00:16:12,280
So I get back my first symbol and there actually are symbols in JavaScript now, which makes

275
00:16:12,280 --> 00:16:15,240
this even better.

276
00:16:15,240 --> 00:16:22,160
But why do I care about defining it in this one argument only nested lambda way?

277
00:16:22,160 --> 00:16:24,240
This is the reason.

278
00:16:24,240 --> 00:16:31,520
The k-5 function is if I call k with just one of its two arguments, not both of them.

279
00:16:31,520 --> 00:16:33,800
Oh, it's a function.

280
00:16:33,800 --> 00:16:35,880
What the heck is the use of that function?

281
00:16:35,880 --> 00:16:41,040
Well, if I call it on something else, it gives me back five.

282
00:16:41,040 --> 00:16:42,920
What if I call it back on something completely different?

283
00:16:42,920 --> 00:16:44,240
It gives me back five.

284
00:16:44,240 --> 00:16:45,240
What if I call it on undefined?

285
00:16:45,240 --> 00:16:46,560
It gives me back five.

286
00:16:46,560 --> 00:16:53,280
The k-5 function or the constant five function is a function that is now stuck on and obsessed

287
00:16:53,280 --> 00:16:55,440
with this value.

288
00:16:55,440 --> 00:16:58,760
I can't get this function to return anything else.

289
00:16:58,760 --> 00:17:04,760
Turns out that's useful for the same reason things like zero in a number system is useful.

290
00:17:04,760 --> 00:17:09,320
Sometimes you need a function that does very little because you have an API that's like,

291
00:17:09,320 --> 00:17:10,640
you must give me a function here.

292
00:17:10,640 --> 00:17:14,200
And like, I don't want to give you a function, you're already doing everything I want.

293
00:17:14,200 --> 00:17:18,880
So the identity function and the k-combinator, these things start to form very primitive,

294
00:17:18,880 --> 00:17:24,720
almost trivial building blocks that slot into larger, more complicated systems.

295
00:17:24,720 --> 00:17:28,280
So k of two things returns the first one.

296
00:17:28,280 --> 00:17:32,640
If you swap them around, you still get the first one, whatever that is.

297
00:17:32,640 --> 00:17:37,040
And in Haskell, this is called const, which isn't confusing for mainstream imperative

298
00:17:37,040 --> 00:17:39,640
programmers at all.

299
00:17:39,640 --> 00:17:40,640
It is a function.

300
00:17:40,640 --> 00:17:45,400
The k-combinator takes two things, returns the first one.

301
00:17:45,400 --> 00:17:46,880
Let's expand on this.

302
00:17:46,880 --> 00:17:54,880
If we've got this k-combinator and we pass in two things, we get the first one.

303
00:17:54,880 --> 00:17:56,960
You're getting it.

304
00:17:56,960 --> 00:17:58,220
But wait a second.

305
00:17:58,220 --> 00:17:59,440
This is math.

306
00:17:59,440 --> 00:18:01,880
This isn't really programming, quite.

307
00:18:01,880 --> 00:18:03,480
So this is a quality sign.

308
00:18:03,480 --> 00:18:05,160
It's not an assignment operator.

309
00:18:05,160 --> 00:18:09,680
This is a quality in the truest sense of whatever that means in math, which by the way is a

310
00:18:09,680 --> 00:18:13,160
very deep topic that we wouldn't touch on.

311
00:18:13,160 --> 00:18:15,040
What is the nature of equality?

312
00:18:15,040 --> 00:18:16,540
People don't agree.

313
00:18:16,540 --> 00:18:22,080
Anyway, so the thing on the left and the thing on the right are in theory the same thing.

314
00:18:22,080 --> 00:18:24,120
But the thing on the right is a function.

315
00:18:24,120 --> 00:18:26,200
It's the identity function.

316
00:18:26,200 --> 00:18:30,720
That means I can call that function on a value.

317
00:18:30,720 --> 00:18:32,800
Interesting.

318
00:18:32,800 --> 00:18:34,640
But we know the identity of y, right?

319
00:18:34,640 --> 00:18:37,360
We already know what that actually evaluates to.

320
00:18:37,360 --> 00:18:38,360
That's y.

321
00:18:38,360 --> 00:18:39,360
Huh.

322
00:18:40,360 --> 00:18:47,160
So this function on the left, k, that I talked about taking two things, I've kind of passed

323
00:18:47,160 --> 00:18:53,280
three things to, i, x, and y, and I actually get a result out of that.

324
00:18:53,280 --> 00:18:54,280
That's weird.

325
00:18:54,280 --> 00:18:57,800
I thought I'd define this function as only taking two inputs, but now I'm using it with

326
00:18:57,800 --> 00:18:59,040
three.

327
00:18:59,040 --> 00:19:03,920
This is the kind of weird flexibility and power that currying gives you.

328
00:19:03,920 --> 00:19:07,440
When your functions are constantly returning other functions that return other functions

329
00:19:07,440 --> 00:19:12,880
that return other functions, you can kind of chop things off early or extend them far

330
00:19:12,880 --> 00:19:17,800
beyond what they were originally being used for, and they still do things, and those things

331
00:19:17,800 --> 00:19:19,400
might end up being useful.

332
00:19:19,400 --> 00:19:20,720
Why is this useful?

333
00:19:20,720 --> 00:19:22,880
Because check this out.

334
00:19:22,880 --> 00:19:30,880
The first two values there, ki, are a function being called on x and y, and they return the

335
00:19:30,880 --> 00:19:33,080
second of those two things.

336
00:19:33,080 --> 00:19:35,760
I start with k, returns the first of two things.

337
00:19:35,760 --> 00:19:45,120
ki is a new function out of the ether that returns the second of two things.

338
00:19:45,120 --> 00:19:48,320
I'm not hearing all the amazement I expected out of that.

339
00:19:48,320 --> 00:19:50,600
Yeah, thank you.

340
00:19:50,600 --> 00:19:51,800
This is called the kite.

341
00:19:51,800 --> 00:19:54,040
So it's also easy to define.

342
00:19:54,040 --> 00:20:02,120
I could do it the way I've been doing it, and say ki of two things returns a second.

343
00:20:02,120 --> 00:20:03,120
There's the proof.

344
00:20:03,120 --> 00:20:10,520
I could also define this as calling k on i, and now I can rename it, and it just looks

345
00:20:10,520 --> 00:20:15,520
like a normal function, and it passes two things, and it gives me the second.

346
00:20:15,520 --> 00:20:21,720
But what's really amazing about this is I never sat down and wrote out, look, ki takes

347
00:20:21,720 --> 00:20:24,920
a, and it takes b, and it returns b.

348
00:20:24,920 --> 00:20:29,880
I took two existing functions, neither of which talks about the second value of any

349
00:20:29,880 --> 00:20:31,240
two inputs.

350
00:20:31,400 --> 00:20:37,240
Just by smashing them together in this sort of atom-to-molecule way, it gave birth to

351
00:20:37,240 --> 00:20:43,040
a new function with new behavior that I didn't manually specify.

352
00:20:43,040 --> 00:20:50,440
So ki of m and k returns the second thing, ki of k and m returns the second thing, and

353
00:20:50,440 --> 00:20:58,080
things are behaving more or less as we expect at this point.

354
00:20:58,080 --> 00:21:00,600
What's with all the bird names?

355
00:21:00,960 --> 00:21:03,880
Where's this coming from?

356
00:21:03,880 --> 00:21:12,120
So there is a mathematician who had a brilliant short career, very sad ending to it, named

357
00:21:12,120 --> 00:21:13,120
Schoenfinkel.

358
00:21:13,120 --> 00:21:14,240
I can't pronounce German.

359
00:21:14,240 --> 00:21:19,360
I'm sure many people in this room can pronounce German much better than I am, but he named

360
00:21:19,360 --> 00:21:27,560
these things very long German names, like Sutsumetsetsungsfunktion, and then he shortened

361
00:21:27,560 --> 00:21:32,160
them because it was annoying to write those down into things like i and k.

362
00:21:32,160 --> 00:21:38,160
And then an American mathematician, Haskell B. Curry, studying this stuff, used many of

363
00:21:38,160 --> 00:21:44,320
the same letters, switched some of the round just to confuse everyone who came later.

364
00:21:44,320 --> 00:21:51,160
And then a logician and puzzle author whose books I really enjoy called Raymond Smullyan

365
00:21:51,160 --> 00:21:54,120
wrote this book called To Mock a Mockingbird.

366
00:21:54,160 --> 00:22:00,080
And to mock a mockingbird, it is all a extended metaphor of birds in a forest that call the

367
00:22:00,080 --> 00:22:04,640
names of other birds, which give birth to birds, and you get where this is going.

368
00:22:04,640 --> 00:22:06,040
It's the same thing.

369
00:22:06,040 --> 00:22:12,120
He just took all those letters and he expanded them out into bird names for his metaphor.

370
00:22:12,120 --> 00:22:15,920
By the way, if you try to learn commentary logic through Smullyan, I mean, you might

371
00:22:15,920 --> 00:22:18,640
make some progress, but it is a puzzle book.

372
00:22:18,640 --> 00:22:20,360
It's meant to be confusing.

373
00:22:20,360 --> 00:22:23,840
So that's just fair warning for anyone who's like, I'm going to go buy the book now.

374
00:22:23,880 --> 00:22:24,880
It is a good book.

375
00:22:24,880 --> 00:22:28,880
You should check it out, but it's not meant to sort of be easy to follow.

376
00:22:28,880 --> 00:22:31,360
Also, he called it the idiot bird.

377
00:22:31,360 --> 00:22:32,360
I don't know.

378
00:22:32,360 --> 00:22:33,360
It should have been Ibis.

379
00:22:33,360 --> 00:22:37,560
Anyway, this was done in tribute to Curry, the other mathematician, because Curry was

380
00:22:37,560 --> 00:22:38,960
a bird watcher.

381
00:22:38,960 --> 00:22:42,560
And Haskell B. Curry, why do we care about this guy, and oh my god, okay, let's go talk

382
00:22:42,560 --> 00:22:44,040
about history.

383
00:22:44,040 --> 00:22:48,360
This is going to be the super fast version of this because I'm trying to stay under time.

384
00:22:48,360 --> 00:22:53,160
But in the early 20th century, actually even late 19th century, mathematicians were trying

385
00:22:53,160 --> 00:22:55,640
to figure out what is math?

386
00:22:55,640 --> 00:22:58,960
And there are all these different systems that proceed from different axioms.

387
00:22:58,960 --> 00:23:04,400
So what's the one true axiomatic system of math from which all of the things can be proved?

388
00:23:04,400 --> 00:23:08,720
And it's nice and simple and intuitive looking and clean.

389
00:23:08,720 --> 00:23:12,960
So Peano comes up with this thing called Peano arithmetic, which is like, I'm going to find

390
00:23:12,960 --> 00:23:13,960
the numbers.

391
00:23:13,960 --> 00:23:15,440
There's a thing called zero.

392
00:23:15,440 --> 00:23:18,080
And one is the thing that comes after zero.

393
00:23:18,080 --> 00:23:21,560
And two is the thing that comes after the thing that comes after zero.

394
00:23:21,560 --> 00:23:27,160
And this sounds super trivial, but it actually forms a really sound foundation for very large

395
00:23:27,160 --> 00:23:30,720
and complicated branches of math.

396
00:23:30,720 --> 00:23:38,240
Frege, who's unfortunately not as well known as he should be, does amazing work in developing

397
00:23:38,240 --> 00:23:42,440
concepts of combinatorial logic and functions and invent its own function notation, which

398
00:23:42,440 --> 00:23:46,720
is in an abstract syntax tree, which by the way, it would have been so much easier to

399
00:23:46,720 --> 00:23:50,440
simplify for people, but it doesn't type well, obviously, right?

400
00:23:50,440 --> 00:23:53,120
Like if you're typesetting, you need a linear system.

401
00:23:53,120 --> 00:23:54,120
And his was two-dimensional.

402
00:23:54,120 --> 00:23:58,480
And he uses currying, although he doesn't draw attention to it.

403
00:23:58,480 --> 00:24:02,640
And he develops a ton of work in axiomatic, quantified logic.

404
00:24:02,640 --> 00:24:07,640
Things like for all x's in the real numbers, there exists a y such that y is greater than

405
00:24:07,640 --> 00:24:08,640
x.

406
00:24:08,640 --> 00:24:13,920
Those things like for all, and there exists, a lot of that originates with Frege.

407
00:24:13,920 --> 00:24:19,400
1910, Russell and Whitehead famously published Principia Mathematica, which is another big

408
00:24:19,400 --> 00:24:25,040
attempt at unifying all of math, a great grand unified theory of math.

409
00:24:25,040 --> 00:24:32,320
Unfortunately, along the way, Russell discovers a paradox, an underlying flaw in set theory,

410
00:24:32,320 --> 00:24:40,120
as it was known at the time, where the question of what about the set that contains all sets

411
00:24:40,120 --> 00:24:42,360
that do not contain themselves or something like that?

412
00:24:42,360 --> 00:24:43,360
I can't remember the details.

413
00:24:43,360 --> 00:24:46,520
And he's like, wait a second.

414
00:24:46,520 --> 00:24:48,120
Does that set contain itself or not?

415
00:24:48,480 --> 00:24:49,640
You can't answer the question.

416
00:24:49,640 --> 00:24:51,640
It's a nonsensical question.

417
00:24:51,640 --> 00:24:59,280
This was a giant problem because tons of preexisting work was based on that version of set theory,

418
00:24:59,280 --> 00:25:02,120
which is now shown to be inconsistent.

419
00:25:02,120 --> 00:25:03,960
It didn't actually hold together.

420
00:25:03,960 --> 00:25:08,340
So this was like the first big crack in the foundations of math, where people started

421
00:25:08,340 --> 00:25:12,360
saying maybe this stuff is harder than we thought it was, because now we're trying to

422
00:25:12,360 --> 00:25:14,360
be extra super-duper careful.

423
00:25:15,360 --> 00:25:19,360
Schoenfinkel, 1920, does tons of work on combinatorial logic.

424
00:25:19,360 --> 00:25:24,800
Now I'm talking about combinatorial logic, lambda calculus, JavaScript arrow functions.

425
00:25:24,800 --> 00:25:26,120
What's the difference between all these things?

426
00:25:26,120 --> 00:25:30,560
Well, we'll clarify that more throughout, but any time I'm using those letters like

427
00:25:30,560 --> 00:25:36,720
k and s and i and m, that's combinatorial logic, and it's the study of functions that

428
00:25:36,720 --> 00:25:37,720
act on each other.

429
00:25:38,160 --> 00:25:45,320
And any time I'm showing you lambdas with lambda a dot b, et cetera, that is lambda calculus.

430
00:25:45,320 --> 00:25:48,160
Turns out they overlap by like 99%.

431
00:25:48,160 --> 00:25:51,960
They study functions, first-class, higher-order, anonymous functions.

432
00:25:51,960 --> 00:25:56,160
Actually, the combinatorial logic ones are not anonymous, by definition.

433
00:25:56,160 --> 00:25:57,960
But that's almost all the differences.

434
00:25:57,960 --> 00:26:01,080
One of them, you give them names, and one of them, they're anonymous.

435
00:26:01,080 --> 00:26:04,280
Van Neumann also doesn't work on this one.

436
00:26:04,280 --> 00:26:05,280
I'm going to skip it.

437
00:26:06,280 --> 00:26:10,680
Curry comes along and does a ton of this work, not knowing about Schoenfinkel, and then he

438
00:26:10,680 --> 00:26:12,160
discovers all of Schoenfinkel's work.

439
00:26:12,160 --> 00:26:14,440
He's like, oops, this guy already did it all.

440
00:26:14,440 --> 00:26:18,880
But he keeps going, and he comes up with a lot of really great results as well.

441
00:26:18,880 --> 00:26:23,040
By the way, now we know this thing that you split up the parameters as currying.

442
00:26:23,040 --> 00:26:26,680
Okay, yeah.

443
00:26:26,680 --> 00:26:29,520
But it really should be called Schoenfinkelization.

444
00:26:29,520 --> 00:26:38,320
In 1931, Kurt Gerdel, or maybe fragification, I don't know, Gerdel now really upends all

445
00:26:38,320 --> 00:26:43,160
math and just destroys all math forever with his incompleteness theorems, which prove that

446
00:26:43,160 --> 00:26:48,560
any system that's sufficiently complicated and interesting is either inconsistent, meaning

447
00:26:48,560 --> 00:26:55,040
it's flawed and actually nonsensical, or it is incomplete, which is the lesser of two

448
00:26:55,040 --> 00:26:58,440
evils but still very disturbing for a mathematician.

449
00:26:58,480 --> 00:27:04,320
This means you can talk about some possible thing that might be true or false in math,

450
00:27:04,320 --> 00:27:08,800
but there might not ever be a proof of whether it is true or false.

451
00:27:08,800 --> 00:27:10,080
But it is true or false.

452
00:27:10,080 --> 00:27:11,960
You just can't find out.

453
00:27:11,960 --> 00:27:17,520
It sounds like the most horrifyingly impossible thing to a mathematician, especially of that

454
00:27:17,520 --> 00:27:23,000
time period, where math was seen as the language and nature of reality, that if you were working

455
00:27:23,000 --> 00:27:28,120
on an unsolved problem, surely if you were just smart enough or determined enough or

456
00:27:28,120 --> 00:27:31,720
had good enough teammates, you could all figure it out together.

457
00:27:31,720 --> 00:27:36,040
Now Gerdel was coming along and saying, nope, you might never find the answer because it

458
00:27:36,040 --> 00:27:38,880
might be impossible to find out the answer.

459
00:27:38,880 --> 00:27:39,880
That was terrible.

460
00:27:39,880 --> 00:27:40,880
It was really terrible.

461
00:27:40,880 --> 00:27:43,680
By the way, a fun philosophy point.

462
00:27:43,680 --> 00:27:49,320
People use this along with Einstein and general relativity in the 20th century to say that

463
00:27:49,320 --> 00:27:53,480
the nature of reality is fluid and abstract and unknowable and things like that.

464
00:27:53,480 --> 00:27:57,760
This really upset Gerdel because he viewed the incompleteness theorem as a universally

465
00:27:57,800 --> 00:28:01,040
controversial fact about the universe.

466
00:28:01,040 --> 00:28:04,680
He was really excited about this result because he's like, I've finally found something that

467
00:28:04,680 --> 00:28:11,360
is always true and everyone else is like, oh my God, you've destroyed math.

468
00:28:11,360 --> 00:28:15,040
Another thing, he works on general recursion theory, which is another big system trying

469
00:28:15,040 --> 00:28:18,240
to unify all of mathematics.

470
00:28:18,240 --> 00:28:21,920
Around the same time period, a Hungarian mathematician much less well-known, unfortunately

471
00:28:21,920 --> 00:28:27,640
than Gerdel, is Rosa Pater and she is known as the mother of recursion theory.

472
00:28:27,680 --> 00:28:33,360
She does a huge amount of recursive function theory development and work in papers for

473
00:28:33,360 --> 00:28:39,480
decades, so I'm glad to be able to point that out.

474
00:28:39,480 --> 00:28:42,960
Now we get to really what's at the subject of this.

475
00:28:42,960 --> 00:28:47,480
The thread here has been all these people, very smart, are trying to figure out what

476
00:28:47,480 --> 00:28:50,480
is math, what is the nature of math, how do we define it.

477
00:28:50,480 --> 00:28:55,520
Now Alonzo Church comes along and defines this thing we've been looking at called lambda

478
00:28:55,520 --> 00:28:56,520
cacons.

479
00:28:56,520 --> 00:28:57,520
It's a little tiny language.

480
00:28:57,520 --> 00:28:58,520
That's it.

481
00:28:58,520 --> 00:29:01,280
It's just a notation system for symbol replacement.

482
00:29:01,280 --> 00:29:03,120
That's what a calculus is, by the way.

483
00:29:03,120 --> 00:29:10,640
A calculus is any formal system of rewriting symbols on a page and this is one for functions.

484
00:29:10,640 --> 00:29:15,920
It turns out that that tiny little language is beautiful because of its simplicity, which

485
00:29:15,920 --> 00:29:21,640
makes it easier to prove things about it than competing theories at the time, like

486
00:29:21,640 --> 00:29:26,400
general recursive theory, which is more confusing to read, in my opinion.

487
00:29:27,400 --> 00:29:30,440
Don't take that as gospel.

488
00:29:30,440 --> 00:29:35,240
He's got some grad students, Stephen Claney goes on to invent regular expressions later,

489
00:29:35,240 --> 00:29:39,080
but also these grad students help prove various things about lambda cac.

490
00:29:39,080 --> 00:29:43,680
Then this is the brilliant shining moment where lambda calculus proved its worth.

491
00:29:43,680 --> 00:29:49,400
These tiny little four lines of grammar and syntax were used to solve a giant unsolved

492
00:29:49,400 --> 00:29:55,520
problem of the day called the decision problem, David Hilbert's decision problem, which was,

493
00:29:55,520 --> 00:29:59,640
is there a machine that you could write, an algorithm you could design, that I could

494
00:29:59,640 --> 00:30:05,440
feed into it some math expression and it will tell me if it will run into an infinite loop?

495
00:30:05,440 --> 00:30:09,600
The answer to that is no, there is no such machine.

496
00:30:09,600 --> 00:30:11,360
We already talked about that.

497
00:30:11,360 --> 00:30:15,280
But church, what's interesting about this is that there's no such machine, but rather

498
00:30:15,280 --> 00:30:23,080
that church used lambda calculus, which seems so tiny and trivial, to prove that result.

499
00:30:23,080 --> 00:30:28,440
He published a paper and about a month later, Turing published another paper solving the

500
00:30:28,440 --> 00:30:32,880
same thing with something much more famous called Turing machines.

501
00:30:32,880 --> 00:30:37,440
Turing was a little upset that it turned out that the idea that he had been working on

502
00:30:37,440 --> 00:30:43,200
for years, I think, he just never got around to publishing, he finally did it and someone

503
00:30:43,200 --> 00:30:49,040
else had published a month earlier and yeah, sometimes that's the way it goes.

504
00:30:49,040 --> 00:30:51,760
But he goes and looks at this and he's like, wait a second.

505
00:30:51,800 --> 00:30:58,200
My Turing machines, which is this like stateful, imperative, sequential program instructions

506
00:30:58,200 --> 00:31:02,920
and this lambda calculus thing, which is an expression that you just do simple replacement

507
00:31:02,920 --> 00:31:09,440
and it simplifies, even though they look very different, I can write a lambda calculus interpreter

508
00:31:09,440 --> 00:31:17,440
in my Turing machine and I can take a lambda calculus and use it to implement a Turing

509
00:31:17,440 --> 00:31:19,080
machine simulation.

510
00:31:19,080 --> 00:31:24,000
So wait a second, if there's something in a Turing machine, I can do it in lambda calculus

511
00:31:24,000 --> 00:31:28,080
because I just use lambda calculus to simulate Turing machines and vice versa, therefore

512
00:31:28,080 --> 00:31:32,600
these two systems are really just as powerful.

513
00:31:32,600 --> 00:31:34,440
Anything one can do, the other can.

514
00:31:34,440 --> 00:31:38,840
So they seem just like amazingly, even though they're completely independent schools of

515
00:31:38,840 --> 00:31:44,800
thought and they're both trying to define what math is and all this business, they seem

516
00:31:44,840 --> 00:31:50,080
to have accidentally discovered equally powerful systems for computing things.

517
00:31:50,080 --> 00:31:54,960
So the church Turing thesis or hypothesis is not a fact.

518
00:31:54,960 --> 00:32:04,760
The hypothesis is that these systems define computation in some deep philosophical way

519
00:32:04,760 --> 00:32:05,760
that's undefinable.

520
00:32:05,760 --> 00:32:09,680
So you can never prove it because it's not well defined.

521
00:32:09,680 --> 00:32:13,040
The fact that lambda calculus interpreter machines are equally powerful is not the church Turing

522
00:32:13,040 --> 00:32:17,720
thesis that's a common mistake.

523
00:32:17,720 --> 00:32:18,720
So he's really excited about this.

524
00:32:18,720 --> 00:32:23,640
He actually combs over to Princeton, gets a PhD under Alonzo Church, helps define like

525
00:32:23,640 --> 00:32:27,320
new fixed point combinators and things like that.

526
00:32:27,320 --> 00:32:28,320
What is a combinator?

527
00:32:28,320 --> 00:32:32,840
I've said this word a couple of times, again, it's like all these different names for things.

528
00:32:32,840 --> 00:32:34,920
Combinators are just functions with no free variables.

529
00:32:34,920 --> 00:32:40,120
Remember I mentioned a free variable is one where you don't know what it's bound to, it's

530
00:32:40,120 --> 00:32:42,920
not bound to anything, it's just kind of in space.

531
00:32:42,920 --> 00:32:44,560
You end up with it and it's like, what does that mean?

532
00:32:44,560 --> 00:32:49,840
I don't know, it's the symbol B. Combinators don't have those.

533
00:32:49,840 --> 00:32:57,680
So all of their outputs are bound as inputs somewhere in the expression.

534
00:32:57,680 --> 00:33:01,160
So the definition of B will come from somewhere when you use it.

535
00:33:01,160 --> 00:33:02,160
It will not be undefined.

536
00:33:02,160 --> 00:33:07,240
In other words, combinators can never have reference errors because their values are

537
00:33:07,240 --> 00:33:08,240
all based on their inputs.

538
00:33:08,440 --> 00:33:11,440
That's all they could do is remix their inputs.

539
00:33:11,440 --> 00:33:17,560
And combinatorial logic, full circle now, is the study of those kinds of functions,

540
00:33:17,560 --> 00:33:20,920
functions which act on each other in surprising ways.

541
00:33:20,920 --> 00:33:24,640
We've seen a bunch, I, M, K, K, I, et cetera.

542
00:33:24,640 --> 00:33:26,880
And again, this gets it like there's all these different names.

543
00:33:26,880 --> 00:33:31,360
There's the Mockingbird versus Zem versus Lambda F to FF.

544
00:33:31,360 --> 00:33:34,360
You can't actually define that one in Haskell, by the way.

545
00:33:34,360 --> 00:33:39,360
Not simply because Haskell's type system doesn't like infinite types and the Mockingbird

546
00:33:39,360 --> 00:33:42,640
is all about infinity.

547
00:33:42,640 --> 00:33:43,640
There's a trick.

548
00:33:43,640 --> 00:33:50,280
You can do it in Haskell through like a little type hack, but it's not beautiful.

549
00:33:50,280 --> 00:33:53,480
Let's look at this one, the cardinal.

550
00:33:53,480 --> 00:33:57,280
The cardinal is a very lovely combinator.

551
00:33:57,280 --> 00:34:00,960
Takes three things, spits them back out in different order.

552
00:34:00,960 --> 00:34:06,760
So let's say the first thing's a function and the second two things are inputs.

553
00:34:06,760 --> 00:34:16,120
C combinator takes a function and A and B inputs and it calls the function with the

554
00:34:16,120 --> 00:34:19,040
inputs reversed.

555
00:34:19,040 --> 00:34:21,040
It flips the inputs around.

556
00:34:21,040 --> 00:34:22,040
That's interesting.

557
00:34:22,040 --> 00:34:23,920
What will we use or use that for?

558
00:34:23,920 --> 00:34:27,000
Well, let's see examples of it just to make sure we're on the same page.

559
00:34:27,000 --> 00:34:33,760
If I feed in a function like K into arguments like I and M, the K combinator returns the

560
00:34:33,760 --> 00:34:39,680
first thing, so the flip of the K combinator returns the second thing.

561
00:34:39,680 --> 00:34:43,440
Well, that's kind of cool.

562
00:34:43,440 --> 00:34:48,320
Sometimes because of this couriering business, your inputs and your arguments don't have

563
00:34:48,320 --> 00:34:54,840
quite the order you wish they did to make some of these tricks easier.

564
00:34:54,840 --> 00:35:00,280
And so this flip combinator or cardinal or C combinator can rewire things for you so

565
00:35:00,280 --> 00:35:04,320
that they take arguments in different orders.

566
00:35:04,320 --> 00:35:08,360
And C of K takes two things and returns the second.

567
00:35:08,360 --> 00:35:11,000
That sounds super familiar, right?

568
00:35:11,000 --> 00:35:15,000
Flipping K gives you Ki.

569
00:35:15,000 --> 00:35:16,600
They are the same function.

570
00:35:16,600 --> 00:35:18,840
C of K and K of I are the same function.

571
00:35:18,840 --> 00:35:20,480
They behave identically.

572
00:35:20,480 --> 00:35:23,240
For every input, they give you the same output.

573
00:35:23,240 --> 00:35:27,920
And when two functions that have been defined separately have nonetheless identical input

574
00:35:27,920 --> 00:35:32,520
output behavior, they're called extensionally equal.

575
00:35:32,520 --> 00:35:37,480
Extensional in the sense that from the outside, you can't see the guts of the function or

576
00:35:37,480 --> 00:35:39,000
how it came into being.

577
00:35:39,000 --> 00:35:42,000
All you can do is throw things in and see what comes out.

578
00:35:42,000 --> 00:35:45,560
There's no way to distinguish those functions.

579
00:35:45,560 --> 00:35:49,400
There's another kind of equality called intentional equality, which is more squirrely and it has

580
00:35:49,480 --> 00:35:51,960
to do more with the internal guts.

581
00:35:51,960 --> 00:35:54,640
We're not going to care about it.

582
00:35:54,640 --> 00:35:57,520
So there's another beautiful combinator, the C combinator.

583
00:35:57,520 --> 00:36:00,280
And in Haskell, it's called flip.

584
00:36:00,280 --> 00:36:04,600
And if you've ever played around with Haskell and talked about point-free programming, flip

585
00:36:04,600 --> 00:36:09,480
shows up a lot generally in a way that makes things much more confusing than they have

586
00:36:09,480 --> 00:36:10,480
to be.

587
00:36:10,480 --> 00:36:16,960
There's a cool site out there called pointfree.io that simplifies Haskell expressions, simplifies.

588
00:36:16,960 --> 00:36:18,400
It really doesn't.

589
00:36:18,400 --> 00:36:23,480
It shortens Haskell expressions to the minimal version that uses the fewest ingredients and

590
00:36:23,480 --> 00:36:30,480
you'll just see tons of flip and ID and const and it's completely unreadable for humans.

591
00:36:30,480 --> 00:36:34,680
Sometimes you get lucky and you get something that actually is simpler and easier, but flip

592
00:36:34,680 --> 00:36:39,680
is one of these things that is very heavy in the rewiring that's possible.

593
00:36:39,680 --> 00:36:44,120
Okay, I've talked about this for like 35 minutes.

594
00:36:44,120 --> 00:36:45,120
Who cares?

595
00:36:45,120 --> 00:36:46,120
What is the point?

596
00:36:46,120 --> 00:36:47,120
We don't care about any of this.

597
00:36:47,120 --> 00:36:50,880
Well, let's find out.

598
00:36:50,880 --> 00:36:53,080
I talked about lambda calculus and Turing machines.

599
00:36:53,080 --> 00:36:55,080
Why are Turing machines exciting?

600
00:36:55,080 --> 00:36:56,080
Simple.

601
00:36:56,080 --> 00:36:57,080
What?

602
00:36:57,080 --> 00:36:58,080
Simple.

603
00:36:58,080 --> 00:36:59,080
Simple.

604
00:36:59,080 --> 00:37:00,480
They are simple.

605
00:37:00,480 --> 00:37:01,480
So is lambda calculus.

606
00:37:01,480 --> 00:37:02,480
They're both simple.

607
00:37:02,480 --> 00:37:06,400
They're both so simple that it's almost hard to do anything with either of them, right?

608
00:37:06,400 --> 00:37:11,480
Like if you've ever hand coded a Turing machine to do like anything interesting, it's very

609
00:37:11,480 --> 00:37:12,480
complicated.

610
00:37:12,480 --> 00:37:18,400
You have to write a one, write a zero, read something, go to memory address.

611
00:37:18,400 --> 00:37:21,480
Like that's almost assembly.

612
00:37:21,480 --> 00:37:25,600
And that's really why Turing machines are cool is because if a hypothetical machine

613
00:37:25,600 --> 00:37:29,200
can calculate whatever you want it to, well, why not build real physical machines that

614
00:37:29,200 --> 00:37:30,800
do the same thing?

615
00:37:30,800 --> 00:37:36,200
So from Turing machines, we get the idea of let's make actual computers that can do this.

616
00:37:36,200 --> 00:37:41,440
And those computers have to be programmed in this very low level on off switch state

617
00:37:41,440 --> 00:37:45,320
version of programming called machine code.

618
00:37:45,320 --> 00:37:47,280
But that's really hard for humans.

619
00:37:47,280 --> 00:37:54,640
So now let's make a text representation called assembly of those very low level machine instructions.

620
00:37:54,640 --> 00:37:58,360
But thinking in terms of machine instructions and assembly is still hard.

621
00:37:58,360 --> 00:38:04,400
So now let's make high level textual languages that get translated into machine code and

622
00:38:04,400 --> 00:38:09,480
aren't one to one correspondence and give you beautiful new human centric concepts.

623
00:38:09,480 --> 00:38:16,560
Things like loops and variable assignment and stuff like that, which you don't get in

624
00:38:16,560 --> 00:38:20,360
the same way for this low level stuff.

625
00:38:20,360 --> 00:38:25,160
But those languages are still maybe saying, like, you tell me what memory to reserve and

626
00:38:25,160 --> 00:38:28,960
what blocks and how much of it and how to index into it and things like that.

627
00:38:28,960 --> 00:38:33,480
And someone out there is like, I'm sick of saying, you know, pointer to something.

628
00:38:33,480 --> 00:38:37,160
Can't we just have a language where I say var x equals object and it'll go figure out

629
00:38:37,160 --> 00:38:39,480
all that memory stuff for me?

630
00:38:39,480 --> 00:38:44,040
So now we're going even further away from the machine and more towards the concepts

631
00:38:44,040 --> 00:38:49,840
humans care about, which are, I've got a domain, I'm modeling something, I have ideas

632
00:38:49,840 --> 00:38:53,360
that I want to bandy about.

633
00:38:53,360 --> 00:38:58,080
And then we go even further and we say, like, wait, why do we even have state?

634
00:38:58,080 --> 00:39:00,240
Why have variable mutation and reassignment?

635
00:39:00,240 --> 00:39:03,520
That has to do with the way the machine physically works.

636
00:39:03,520 --> 00:39:05,720
But we don't need that.

637
00:39:05,720 --> 00:39:10,920
And if we take it out, some of our programs get a lot more typesafe.

638
00:39:10,920 --> 00:39:15,760
And this whole time, the layers of languages that have been building up and people have

639
00:39:15,760 --> 00:39:22,160
been inventing have been gradually moving away from the super imperative machine-based

640
00:39:22,160 --> 00:39:28,560
way of thinking toward a more pure conceptual way of thinking.

641
00:39:28,560 --> 00:39:30,280
And someone out there says, wait a second.

642
00:39:30,280 --> 00:39:33,480
If lambda, cacos, and trig machines are equivalent, what if we went the opposite

643
00:39:33,480 --> 00:39:34,760
direction?

644
00:39:34,760 --> 00:39:39,600
What if we started with something that has absolutely no concept of a machine but is

645
00:39:39,600 --> 00:39:45,360
still able to compute things and try to make it useful, try to make it work on a Turing

646
00:39:45,360 --> 00:39:46,360
machine?

647
00:39:46,360 --> 00:39:48,560
We know that it's possible.

648
00:39:48,560 --> 00:39:50,240
Now the question is, can we optimize it?

649
00:39:50,240 --> 00:39:51,240
Right?

650
00:39:51,240 --> 00:39:57,920
Like, can we take this pure stateless functional way of thinking and make it perform well in

651
00:39:57,920 --> 00:40:00,160
terms of memory and speed and stuff like that?

652
00:40:00,160 --> 00:40:03,600
So we'll write these pure functional languages and we'll have compilers that have been very

653
00:40:03,600 --> 00:40:08,640
cleverly written to develop good machine code from them.

654
00:40:08,640 --> 00:40:14,280
These things are equivalent, which means everything can be functions, literally everything.

655
00:40:14,280 --> 00:40:16,160
But not everything should be.

656
00:40:16,160 --> 00:40:19,320
But more than you might think.

657
00:40:19,320 --> 00:40:21,040
Such as bullions.

658
00:40:21,040 --> 00:40:23,040
We're going to invent bullions from scratch now.

659
00:40:23,040 --> 00:40:24,280
Let's do it.

660
00:40:24,280 --> 00:40:26,680
Well, it's a problem because we don't have any of those things.

661
00:40:26,680 --> 00:40:28,180
We just have parentheses.

662
00:40:28,180 --> 00:40:30,180
So far, that's all we've got in our language and our parentheses.

663
00:40:30,180 --> 00:40:31,180
We don't have equal signs.

664
00:40:31,180 --> 00:40:33,180
We don't have the not operator.

665
00:40:33,180 --> 00:40:34,680
We don't have ors.

666
00:40:34,680 --> 00:40:38,100
We do have kind of variables, but the variables aren't bullions.

667
00:40:38,100 --> 00:40:41,100
Like there's no concept of true-false.

668
00:40:41,100 --> 00:40:43,100
Okay.

669
00:40:43,100 --> 00:40:44,980
What are bullions used for?

670
00:40:44,980 --> 00:40:46,180
A lot of things.

671
00:40:46,180 --> 00:40:48,260
One thing they're used for is selection.

672
00:40:48,260 --> 00:40:53,580
If some condition, then result, else different result.

673
00:40:53,580 --> 00:40:59,380
Well, I've got two possible results and I'm selecting which one I want to use.

674
00:40:59,380 --> 00:41:03,420
So if it's the true bullion, give me back the first expression.

675
00:41:03,420 --> 00:41:07,300
And if it's the false one, give me back the second expression.

676
00:41:07,300 --> 00:41:08,300
Huh.

677
00:41:08,300 --> 00:41:10,500
Well, we don't have this syntax.

678
00:41:10,500 --> 00:41:14,380
We don't have question marks and colon, so we'll just knock those out.

679
00:41:14,380 --> 00:41:16,340
And then we have space.

680
00:41:16,340 --> 00:41:18,780
So that means function application, right?

681
00:41:18,780 --> 00:41:20,580
So whatever this thing, it has to be a function.

682
00:41:20,580 --> 00:41:23,900
And I need two functions, one for true and one for false.

683
00:41:23,900 --> 00:41:28,980
The true one will select the first expression and the false function will select the second

684
00:41:28,980 --> 00:41:29,980
expression.

685
00:41:29,980 --> 00:41:30,980
We've already seen this.

686
00:41:30,980 --> 00:41:33,140
It's the k and ki functions.

687
00:41:33,140 --> 00:41:35,220
Surprise, I already did it.

688
00:41:35,220 --> 00:41:42,260
So we'll just go up in here and we'll now say, so if I log out the k function, by the

689
00:41:42,260 --> 00:41:47,020
way, it says function k and node, I cheated ahead of time and I did load one tiny line

690
00:41:47,020 --> 00:41:51,460
of functional stuff in here, not functional, but one tiny line of code that's not lambda

691
00:41:51,460 --> 00:41:56,220
cacos or combinatorial logic, and that's to rewrite function names in node, which is

692
00:41:56,220 --> 00:41:59,420
slightly annoying in node version 12.

693
00:41:59,420 --> 00:42:03,140
But let's label this thing k slash true.

694
00:42:03,140 --> 00:42:05,100
Ah, reference error.

695
00:42:05,100 --> 00:42:06,100
Inspect is not defined.

696
00:42:06,100 --> 00:42:07,100
Oh, my God.

697
00:42:07,100 --> 00:42:08,100
Okay.

698
00:42:08,100 --> 00:42:09,100
I reloaded this.

699
00:42:09,100 --> 00:42:10,100
You know what?

700
00:42:10,100 --> 00:42:11,100
We'll just not do it.

701
00:42:11,100 --> 00:42:13,620
You'll all just remember that k is true.

702
00:42:13,620 --> 00:42:16,980
See, this is what happens when you try to do it.

703
00:42:16,980 --> 00:42:19,100
You try to go outside of pure math, right?

704
00:42:19,100 --> 00:42:21,020
This is just a mess.

705
00:42:21,020 --> 00:42:24,100
The ki function, unfortunately, this function is anonymous.

706
00:42:24,100 --> 00:42:28,420
It doesn't have a name because I developed it by smushing together k and i.

707
00:42:28,420 --> 00:42:34,020
So I'm going to quickly rewrite it manually, even though that's sad.

708
00:42:34,020 --> 00:42:35,300
Great.

709
00:42:35,300 --> 00:42:39,940
So anytime you see k, you can now think to yourself, oh, that's true.

710
00:42:39,940 --> 00:42:42,820
And every time you see ki, you can think to yourself, that's false.

711
00:42:42,820 --> 00:42:47,540
It's like if you see 1 and 0, you think true or false, or on and off you see true or false,

712
00:42:47,540 --> 00:42:51,780
or true is true and false is false.

713
00:42:51,780 --> 00:42:53,900
Now the k function is true and ki is false.

714
00:42:53,900 --> 00:42:57,020
It's just a representation.

715
00:42:57,020 --> 00:43:06,540
But if I have some condition like unknown bool is, quick, don't look.

716
00:43:06,540 --> 00:43:08,260
No one saw that.

717
00:43:08,260 --> 00:43:10,540
Well, which one is it?

718
00:43:10,580 --> 00:43:12,820
I can find out by passing it two things.

719
00:43:12,820 --> 00:43:15,020
If it was true, I get back the first thing.

720
00:43:15,020 --> 00:43:17,780
Oh, I guess unknown bool was the true function.

721
00:43:17,780 --> 00:43:23,340
So I could do everything I wanted, just like already out of the box.

722
00:43:23,340 --> 00:43:24,900
All right, but that's not that interesting, right?

723
00:43:24,900 --> 00:43:27,540
What's another thing we do with Boolean logic all the time?

724
00:43:27,540 --> 00:43:28,420
We negate.

725
00:43:28,420 --> 00:43:30,740
We actually transform things around.

726
00:43:30,740 --> 00:43:32,540
The not operator.

727
00:43:32,540 --> 00:43:34,940
Well, again, we don't have exclamation points, so we're going to get rid of that.

728
00:43:34,940 --> 00:43:36,940
It becomes a function called not.

729
00:43:36,940 --> 00:43:39,020
How do we define it?

730
00:43:39,020 --> 00:43:42,820
If p is true, return false.

731
00:43:42,820 --> 00:43:46,700
And if p is false, return true.

732
00:43:46,700 --> 00:43:50,620
Well, we need to select between two possibilities.

733
00:43:50,620 --> 00:43:53,820
The flip combinator is going to do this for us.

734
00:43:53,820 --> 00:43:55,180
I've already defined not.

735
00:43:55,180 --> 00:43:57,260
You didn't even realize at the time.

736
00:43:57,260 --> 00:44:01,540
The flip combinator, the flip of k is ki and the flip of ki is k.

737
00:44:01,540 --> 00:44:05,620
Which means the flip of true is false and the flip of false is true.

738
00:44:05,620 --> 00:44:09,180
So not is just the c combinator.

739
00:44:09,180 --> 00:44:11,060
Let's try it.

740
00:44:11,060 --> 00:44:15,860
The flip of k is some function, but which one is it?

741
00:44:15,860 --> 00:44:17,820
It's the false function.

742
00:44:17,820 --> 00:44:20,460
It returns the second thing.

743
00:44:20,460 --> 00:44:26,580
And the flip of ki, or false, is the true function.

744
00:44:26,580 --> 00:44:29,100
So it returns the first thing.

745
00:44:29,100 --> 00:44:34,740
We can also rename these like t is that and f is this.

746
00:44:34,740 --> 00:44:38,940
So now we can say things like not true.

747
00:44:38,940 --> 00:44:39,860
Which one is that?

748
00:44:39,860 --> 00:44:42,700
Is that true or is it false?

749
00:44:42,700 --> 00:44:46,540
It turns out not true is false, and it turns out not false is true.

750
00:44:46,540 --> 00:44:49,980
And we just invented this out of the ether.

751
00:44:49,980 --> 00:44:51,500
These are called church encodings.

752
00:44:51,500 --> 00:44:55,620
Alonzo Church was one of the people who helped invent them.

753
00:44:55,620 --> 00:44:58,180
And it's like, OK, we'll represent these things as functions.

754
00:44:58,180 --> 00:45:00,580
And then we can do functions on them that transform them

755
00:45:00,580 --> 00:45:02,140
and move them around.

756
00:45:02,140 --> 00:45:03,620
There's other ways of doing them.

757
00:45:03,620 --> 00:45:06,540
I've written one up there, like this lambda expression

758
00:45:06,540 --> 00:45:09,500
is another way of defining the not function.

759
00:45:09,500 --> 00:45:12,340
Let's move on and do and in the interest of time, of which

760
00:45:12,340 --> 00:45:15,140
there is very little left.

761
00:45:15,140 --> 00:45:17,140
The and function takes two booleans.

762
00:45:19,580 --> 00:45:22,260
OK, so how does this work?

763
00:45:22,260 --> 00:45:26,500
If both p and q are true, return true.

764
00:45:26,500 --> 00:45:30,780
For anything else, the and function return false.

765
00:45:30,820 --> 00:45:33,300
So we're taking in two booleans, p and q.

766
00:45:33,300 --> 00:45:34,740
And remember, these are functions.

767
00:45:34,740 --> 00:45:38,100
p and q are both functions.

768
00:45:38,100 --> 00:45:39,740
So what can we do with those functions?

769
00:45:39,740 --> 00:45:42,660
Well, we can use them to select things.

770
00:45:42,660 --> 00:45:45,300
The first boolean input is going to select

771
00:45:45,300 --> 00:45:47,420
between two expressions.

772
00:45:47,420 --> 00:45:52,420
If p is false, it's going to return the second thing.

773
00:45:52,420 --> 00:45:55,180
That's what the ki function does.

774
00:45:55,180 --> 00:46:00,980
But if p is false, what should and return?

775
00:46:00,980 --> 00:46:02,540
One of my booles is false.

776
00:46:02,540 --> 00:46:04,580
So and should return false.

777
00:46:04,580 --> 00:46:07,620
So p should return false.

778
00:46:07,620 --> 00:46:11,620
And if p is true, what should and return?

779
00:46:13,980 --> 00:46:16,500
Q, exactly.

780
00:46:16,500 --> 00:46:18,100
Because it depends what q is, right?

781
00:46:18,100 --> 00:46:20,540
If q is false, well, we should return false.

782
00:46:20,540 --> 00:46:23,260
But if q is true, p was true and q is true.

783
00:46:23,260 --> 00:46:24,500
So return q, which is true.

784
00:46:24,500 --> 00:46:25,900
And hey, it all works.

785
00:46:25,900 --> 00:46:27,540
And in fact, you could simplify that too.

786
00:46:27,540 --> 00:46:30,620
If p is false, return p, which is false.

787
00:46:30,620 --> 00:46:32,900
Let's try it.

788
00:46:32,900 --> 00:46:35,860
Takes two unknown booleans.

789
00:46:35,860 --> 00:46:40,260
And then if p is true, return whatever q is,

790
00:46:40,260 --> 00:46:42,020
because we have to check it as well.

791
00:46:42,020 --> 00:46:45,900
If p is false, well, we know p is false.

792
00:46:45,900 --> 00:46:49,980
So just return p, because they're not both true.

793
00:46:49,980 --> 00:46:50,620
And guess what?

794
00:46:51,340 --> 00:46:57,020
I have to prove that it's actually, it's some boolean.

795
00:46:57,020 --> 00:46:59,100
Oh, it actually worked that time.

796
00:46:59,100 --> 00:47:01,940
So and true, true is that.

797
00:47:01,940 --> 00:47:04,420
And true false is false.

798
00:47:04,420 --> 00:47:06,220
And false false is false.

799
00:47:06,220 --> 00:47:07,860
And false true is false.

800
00:47:07,860 --> 00:47:11,300
Hey, we invented and boolean logic.

801
00:47:11,300 --> 00:47:12,660
You can do the same thing with or.

802
00:47:12,660 --> 00:47:14,220
It's just like slightly different order.

803
00:47:14,220 --> 00:47:17,860
You say p returns p and q and things like that.

804
00:47:17,860 --> 00:47:20,340
What is this?

805
00:47:20,380 --> 00:47:22,460
This one's a little bit more dense.

806
00:47:22,460 --> 00:47:24,300
And by the way, functional languages,

807
00:47:24,300 --> 00:47:27,940
that function application has just a space.

808
00:47:27,940 --> 00:47:30,700
Look how much easier it is to read when you don't have

809
00:47:30,700 --> 00:47:33,140
all these parens for function evocation.

810
00:47:33,140 --> 00:47:34,580
Like, I think that JavaScript is actually

811
00:47:34,580 --> 00:47:37,940
harder to understand than the lambda calculus.

812
00:47:37,940 --> 00:47:40,460
But if you want a little help, p selects

813
00:47:40,460 --> 00:47:41,980
between two different things, depending

814
00:47:41,980 --> 00:47:43,500
on whether it's true or false.

815
00:47:43,500 --> 00:47:45,060
q selects between two different things,

816
00:47:45,060 --> 00:47:47,540
depending on if it's true or false.

817
00:47:47,540 --> 00:47:49,660
And the behavior of this unknown function,

818
00:47:49,660 --> 00:47:54,140
this anonymous lambda, is if both p and q are true

819
00:47:54,140 --> 00:47:58,780
or if both p and q are false, return true.

820
00:47:58,780 --> 00:48:02,900
But if they're different from each other, return false.

821
00:48:02,900 --> 00:48:05,460
So this is boolean equality.

822
00:48:05,460 --> 00:48:08,060
And we can simplify it through some steps

823
00:48:08,060 --> 00:48:10,300
that you can go review later in the slides.

824
00:48:10,300 --> 00:48:13,940
It actually turns into this, which I'll do right now.

825
00:48:13,940 --> 00:48:17,740
Boolean equality takes a p and a q,

826
00:48:17,740 --> 00:48:21,740
and it calls p on q and not q.

827
00:48:22,660 --> 00:48:26,740
And now I can test, hey, do true and false equal each other?

828
00:48:26,740 --> 00:48:27,940
No.

829
00:48:27,940 --> 00:48:29,940
Do false and false equal each other?

830
00:48:29,940 --> 00:48:32,220
Maybe that's some function that just got

831
00:48:32,220 --> 00:48:35,020
birthed out of nothingness, so let's check.

832
00:48:35,020 --> 00:48:36,140
Yeah, it's the true function.

833
00:48:36,140 --> 00:48:38,700
It's the one that returns the first thing.

834
00:48:38,700 --> 00:48:41,980
And I'm gonna keep moving, because I'm almost out of time.

835
00:48:42,020 --> 00:48:43,940
So we've got these church encodings, and they're lovely.

836
00:48:43,940 --> 00:48:45,740
Hey, here's De Morgan's law.

837
00:48:45,740 --> 00:48:46,860
It's a thing from logic.

838
00:48:46,860 --> 00:48:51,700
It says not p and q is equal to not p or not q.

839
00:48:51,700 --> 00:48:56,340
And now using just a lambda syntax anonymous functions,

840
00:48:56,340 --> 00:48:59,340
we have this beautiful, concise, easy to read way

841
00:48:59,340 --> 00:49:01,020
of expressing this logic.

842
00:49:01,020 --> 00:49:06,020
The equality of not and pq or not p, not q

843
00:49:06,260 --> 00:49:09,740
is always gonna be what you expect it to be.

844
00:49:09,740 --> 00:49:11,260
Feed two booleans into this thing,

845
00:49:11,260 --> 00:49:13,820
and by booleans I mean either k or ki,

846
00:49:13,820 --> 00:49:16,820
and you get out what you would expect from boolean logic.

847
00:49:17,820 --> 00:49:20,380
What else can we do with this kind of fun stuff?

848
00:49:20,380 --> 00:49:22,140
We can invent numbers.

849
00:49:22,140 --> 00:49:24,060
And if we got numbers, actually specifically

850
00:49:24,060 --> 00:49:26,860
positive integers, actually specifically natural numbers,

851
00:49:26,860 --> 00:49:28,020
zero and up.

852
00:49:28,980 --> 00:49:32,220
If we've got those, well, a pair of numbers is fractions,

853
00:49:32,220 --> 00:49:35,700
but we don't have pairs yet, so we can do arithmetic.

854
00:49:35,700 --> 00:49:37,940
And we're gonna need some data structures.

855
00:49:37,940 --> 00:49:41,020
So we'll invent those from scratch using just functions.

856
00:49:41,020 --> 00:49:42,220
And once we have data structures

857
00:49:42,220 --> 00:49:43,300
in arithmetic and things like that,

858
00:49:43,300 --> 00:49:45,740
we can do data types and type systems.

859
00:49:45,740 --> 00:49:48,060
And once we've invented some of that stuff,

860
00:49:48,060 --> 00:49:50,420
we can also invent recursion from scratch.

861
00:49:50,420 --> 00:49:52,780
Lambda calculus does not have named functions.

862
00:49:52,780 --> 00:49:55,700
The c and k and i, that's commonest very logic.

863
00:49:55,700 --> 00:49:57,900
We often refer to these functions by their names

864
00:49:57,900 --> 00:50:00,860
because it's way easier than saying lambda, af,

865
00:50:00,860 --> 00:50:02,020
ad, et cetera.

866
00:50:02,020 --> 00:50:04,980
But lambda calculus itself does not have named functions.

867
00:50:04,980 --> 00:50:07,820
In fact, it's deliberately designed without them

868
00:50:07,820 --> 00:50:09,820
to make it easier to prove things about math

869
00:50:09,820 --> 00:50:11,260
and the way things work.

870
00:50:12,380 --> 00:50:14,940
So how do you do recursion in lambda calculus?

871
00:50:14,940 --> 00:50:17,260
Well, sorry, you're gonna have to see part two

872
00:50:17,260 --> 00:50:19,460
in the video online.

873
00:50:19,460 --> 00:50:20,300
Yeah.

874
00:50:21,700 --> 00:50:23,220
We're almost done.

875
00:50:23,220 --> 00:50:24,100
Question.

876
00:50:24,100 --> 00:50:26,100
So some fun little things at the end here.

877
00:50:26,100 --> 00:50:29,180
How many combinators like c and k and stuff

878
00:50:29,180 --> 00:50:34,180
do you think you need to cover every possible computation

879
00:50:36,260 --> 00:50:37,940
to be able to do anything?

880
00:50:37,940 --> 00:50:38,940
Because in combinatory logic,

881
00:50:38,940 --> 00:50:41,100
you had to define all those functions ahead of time.

882
00:50:41,100 --> 00:50:41,940
In lambda calculus,

883
00:50:41,940 --> 00:50:44,260
you could define a function manually using syntax

884
00:50:44,260 --> 00:50:46,660
whenever you want, but in combinatory logic,

885
00:50:46,660 --> 00:50:49,900
you need to pre-define all these named functions.

886
00:50:49,900 --> 00:50:51,540
So do you need 20 of them?

887
00:50:51,540 --> 00:50:52,380
10, five?

888
00:50:52,380 --> 00:50:53,220
Is it even possible?

889
00:50:53,220 --> 00:50:55,420
Maybe you need an infinite number.

890
00:50:55,420 --> 00:50:59,020
Well, here are two, the s and k combinator.

891
00:51:00,300 --> 00:51:04,380
They behave together in all sorts of very clever ways.

892
00:51:04,380 --> 00:51:06,460
And for instance, the i-combinator,

893
00:51:06,460 --> 00:51:10,180
you can invent it by calling s on k of k.

894
00:51:11,220 --> 00:51:13,260
And the v-combinator, which you didn't see,

895
00:51:13,260 --> 00:51:16,180
it's in part two, it's a data structure, it's a two-tubble.

896
00:51:16,180 --> 00:51:18,180
You can do by this nonsense.

897
00:51:20,180 --> 00:51:21,580
But it gets even smaller.

898
00:51:21,580 --> 00:51:24,180
You can do everything with a single function.

899
00:51:24,180 --> 00:51:27,380
So if you really wanted to go crazy,

900
00:51:27,380 --> 00:51:29,820
you could take this iota function

901
00:51:29,820 --> 00:51:32,820
and write any other function in existence

902
00:51:32,820 --> 00:51:35,380
using just this and parentheses.

903
00:51:37,060 --> 00:51:37,900
But why?

904
00:51:38,980 --> 00:51:40,740
So what is the point of this entire talk?

905
00:51:40,740 --> 00:51:42,740
Like, why am I here talking about this?

906
00:51:43,860 --> 00:51:45,580
The short answer is I just really like it,

907
00:51:45,580 --> 00:51:48,460
and I hope that you've enjoyed it.

908
00:51:48,460 --> 00:51:50,660
It's kind of a game, like I read about this stuff

909
00:51:50,660 --> 00:51:52,220
in Smollion's book, which was deliberately

910
00:51:52,220 --> 00:51:53,220
supposed to be entertaining.

911
00:51:53,220 --> 00:51:54,780
It's logic puzzles and games,

912
00:51:54,780 --> 00:51:58,340
and things to exercise your mind and think about.

913
00:51:58,340 --> 00:52:01,820
It's also really great practice for thinking functionally,

914
00:52:01,820 --> 00:52:03,940
not because in a functional programming language,

915
00:52:03,940 --> 00:52:05,980
you have to invent Booleans from scratch,

916
00:52:05,980 --> 00:52:07,100
although often you do.

917
00:52:08,540 --> 00:52:09,980
Not quite in that way, though.

918
00:52:11,540 --> 00:52:15,300
But just the act of doing all these function evaluations

919
00:52:15,300 --> 00:52:17,540
with symbol manipulation and substitution

920
00:52:17,540 --> 00:52:19,900
and evaluating things and seeing the power

921
00:52:19,900 --> 00:52:22,100
of functions operating on each other

922
00:52:22,100 --> 00:52:24,460
makes that sort of foundational knowledge

923
00:52:24,460 --> 00:52:26,260
of working in a functional language

924
00:52:26,260 --> 00:52:28,140
just feel much more comfortable.

925
00:52:28,140 --> 00:52:31,580
It's a form of exercise of calisthenics.

926
00:52:32,940 --> 00:52:36,540
Programming languages like Haskell and PureScript

927
00:52:36,540 --> 00:52:38,860
and Agda, I guess, I don't know,

928
00:52:38,860 --> 00:52:40,580
and Elm and other things.

929
00:52:41,580 --> 00:52:45,500
Their basis and their core are lambda-calculi,

930
00:52:45,500 --> 00:52:48,300
slightly souped up ones like System F and System FC

931
00:52:48,300 --> 00:52:51,380
and things which add types and all sorts of stuff.

932
00:52:51,380 --> 00:52:53,420
But you know how Haskell actually works?

933
00:52:53,420 --> 00:52:54,540
It's great.

934
00:52:54,540 --> 00:52:56,700
You write Haskell.

935
00:52:56,700 --> 00:52:59,500
The compiler takes that and simplifies it down

936
00:52:59,500 --> 00:53:02,100
to a slightly souped up lambda-calculus.

937
00:53:02,100 --> 00:53:05,140
And then it pairs that lambda-calculus program

938
00:53:05,140 --> 00:53:07,980
that was from what you originally wrote

939
00:53:07,980 --> 00:53:12,980
as like a sane thing with a runtime written in C

940
00:53:13,100 --> 00:53:15,300
that's a lambda-calculus interpreter.

941
00:53:15,300 --> 00:53:17,140
And that's how Haskell works.

942
00:53:17,140 --> 00:53:19,100
That's why the minimum size for any Haskell program

943
00:53:19,100 --> 00:53:20,780
is like eight megabytes or something

944
00:53:20,780 --> 00:53:22,500
because it ships with this lambda-calc interpreter

945
00:53:22,500 --> 00:53:23,460
that runs your code.

946
00:53:24,460 --> 00:53:27,380
I think personally though, at the end of the day,

947
00:53:27,380 --> 00:53:30,420
like I don't wanna have to defend or justify

948
00:53:30,420 --> 00:53:32,060
and say like you should all learn lambda-calculi

949
00:53:32,060 --> 00:53:34,860
because it'll let you do this thing in your job.

950
00:53:35,900 --> 00:53:37,100
It might be able to.

951
00:53:37,100 --> 00:53:40,420
There's a couple cool examples I can think of

952
00:53:40,420 --> 00:53:43,540
that I've now thought of after the fact.

953
00:53:43,540 --> 00:53:45,900
But for me, it's like pure art for art's sake.

954
00:53:45,900 --> 00:53:47,420
And I just think that's like a lovely thing

955
00:53:47,420 --> 00:53:49,980
to find in programming and computer science.

956
00:53:51,700 --> 00:53:53,420
And yeah, there's the Y Combinator.

957
00:53:53,420 --> 00:53:54,780
That invents recursion.

958
00:53:54,780 --> 00:53:56,500
You can go see about it later.

959
00:53:56,500 --> 00:53:58,300
So there's a whole bunch of slides and stuff in here

960
00:53:58,300 --> 00:53:59,260
for reference.

961
00:53:59,260 --> 00:54:02,020
These are all part two and then yeah, there's resources.

962
00:54:02,020 --> 00:54:06,300
And I guess seven minutes over time, that's not too bad.

963
00:54:06,300 --> 00:54:07,340
Let's do questions.

964
00:54:07,340 --> 00:54:08,180
Thank you.

