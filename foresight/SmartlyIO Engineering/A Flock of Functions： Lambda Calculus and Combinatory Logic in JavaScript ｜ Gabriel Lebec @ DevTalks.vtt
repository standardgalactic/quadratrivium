WEBVTT

00:00.000 --> 00:12.440
Okay, hello everybody, thank you.

00:12.440 --> 00:13.680
Really excited to be here.

00:13.680 --> 00:19.200
Quick little about me, I made this talk while I was working at Fullstack Academy as an instructor,

00:19.200 --> 00:21.680
so it's going to hopefully be a little educational.

00:21.680 --> 00:27.520
I currently work at Google, but this talk isn't about that, I'm not representing Google

00:27.520 --> 00:28.520
or anything.

00:28.520 --> 00:31.320
My thoughts and opinions are my own, et cetera.

00:31.320 --> 00:35.160
And this is the smartly version of this talk, so it's been slightly tweaked and improved

00:35.160 --> 00:36.160
in various ways.

00:36.160 --> 00:39.680
And I've got social media accounts and things like that.

00:39.680 --> 00:44.480
There are slides posted online, this will be in the video, slash we'll post it later,

00:44.480 --> 00:47.520
you can go find them, and let's get started.

00:47.520 --> 00:57.080
So I'm going to start off with this combinator called identity, and it looks like this.

00:57.080 --> 01:05.360
It is a function that takes an input A and returns A. It's pretty straightforward, so

01:05.360 --> 01:06.520
let's try it out.

01:06.520 --> 01:16.640
So the identity of one is, yeah, it's interactive, and the identity of identity is identity.

01:16.640 --> 01:22.840
Okay, so right off the bat, we have something cool, which is functions can be arguments

01:22.840 --> 01:23.840
to other functions.

01:23.840 --> 01:29.040
First class functions, and that is a defining characteristic of the lambda calculus slash

01:29.040 --> 01:31.080
combinator logic.

01:31.080 --> 01:36.040
So the identity of any X is X, and we can write that a whole bunch of different ways.

01:36.040 --> 01:42.120
You've got JavaScript arrow functions on the board, we have this I variable that has an

01:42.120 --> 01:47.080
equation that's called combinator logic, and we have this shaded out lambda thing below

01:47.080 --> 01:52.840
it, you'll be able to go see these notes in the slides, you don't necessarily have to

01:52.840 --> 01:57.180
try and read all the actual lambda calculus syntax for this talk.

01:57.180 --> 02:01.320
So I'm not going to be showing it all the time, I'm going to focus on the very high-level

02:01.320 --> 02:03.040
concepts.

02:03.040 --> 02:07.800
And we saw that the identity of identity is itself, so yes, functions can be arguments

02:07.800 --> 02:11.600
to functions and return functions and do all that stuff.

02:11.600 --> 02:18.840
In Haskell, this is built into the base common library that everybody imports usually as

02:18.840 --> 02:25.680
the ID or identity function, and it behaves exactly as shown, the identity of 5 is 5.

02:25.680 --> 02:28.760
So what is up with this lambda notation?

02:28.760 --> 02:30.960
It literally just means function.

02:30.960 --> 02:36.160
If you were writing JavaScript the long way and not with an arrow function, it's the word

02:36.160 --> 02:37.160
function.

02:37.160 --> 02:43.040
If you're writing Python, it's like def function or something like that, I don't know.

02:43.040 --> 02:45.480
And it takes a parameter, it takes an input.

02:45.480 --> 02:51.280
All functions in the actual strict modified lambda calculus take only one argument.

02:51.280 --> 02:53.080
We'll see how that's useful later.

02:53.080 --> 02:55.320
And then finally it returns some expression.

02:55.320 --> 02:58.880
In this case, the identity function returns its input.

02:58.880 --> 03:03.360
And this whole thing together is sometimes called a lambda abstraction, abstraction

03:03.360 --> 03:08.800
because it abstracts away through a parameter, concrete use cases.

03:08.800 --> 03:13.720
So one concrete use case might be if A was 1, this would return 1.

03:13.720 --> 03:16.960
If A was hello, this would return hello.

03:16.960 --> 03:22.920
So by parameterizing those concrete use cases, we end up with an abstraction.

03:22.920 --> 03:26.600
But it's really just a fancy way of saying it's a function.

03:26.600 --> 03:30.360
There's all sorts of syntaxes across programming languages for these things, and you'll probably

03:30.360 --> 03:36.440
have heard about them, and it's like, oh, now Java has lambdas, and why is that exciting?

03:36.440 --> 03:39.560
Turns out there's a lot of different ways of writing these.

03:39.560 --> 03:43.800
This is the worst, unfortunately.

03:43.800 --> 03:46.800
I mean, just compare and contrast, right?

03:46.800 --> 03:47.800
But they are fun.

03:47.800 --> 03:48.800
They are exciting.

03:48.800 --> 03:52.400
And there's a reason they show up a lot in functional programming.

03:52.400 --> 03:58.560
If you're familiar with sort of the COPSI way of showing syntax, this is the grammar

03:58.560 --> 04:00.640
for the lambda calculus.

04:00.640 --> 04:02.400
This is a very tiny language.

04:02.400 --> 04:04.480
It only has really four things.

04:04.480 --> 04:07.120
It has variables, which are just plain old symbols.

04:07.120 --> 04:13.120
It has a function being applied to its argument that's application, and that's just by a space.

04:13.120 --> 04:16.840
A space between two things means function applied to argument.

04:16.840 --> 04:19.640
It has function definitions, which we just saw, and they're called abstractions.

04:19.640 --> 04:24.360
And then it's got parentheses to control what order things are evaluated in.

04:24.360 --> 04:28.680
So this whole talk, I'm going to be comparing and contrasting the way these things look,

04:28.680 --> 04:31.240
but they're really the same concepts.

04:31.240 --> 04:33.200
Variables can hold a value.

04:33.200 --> 04:34.840
Very important difference here.

04:34.840 --> 04:38.680
In the lambda calculus, there's no such thing as a mutable variable.

04:38.680 --> 04:41.360
All variables are immutable.

04:41.360 --> 04:46.320
They have a definition, and you might know that definition, or you might not, but it

04:46.320 --> 04:47.320
never changes.

04:47.320 --> 04:48.320
You never reassign.

04:48.320 --> 04:49.320
All right.

04:49.320 --> 04:51.440
I talked about function applications.

04:51.440 --> 04:55.240
Again, just a space means function called on argument.

04:55.240 --> 05:00.520
We tend to say function applied to argument or function invoked with argument.

05:00.520 --> 05:02.360
And there's little details here.

05:02.360 --> 05:09.840
For example, it's left associative application, so that FAB line right there means first

05:09.840 --> 05:16.480
call F with A, and that returns a function, and call that with B, which we can disambiguate

05:16.480 --> 05:21.960
using those ghosted out parens and say, like, okay, to make this really clear, we're passing

05:21.960 --> 05:25.960
A into F, and then we're passing B into the result of that.

05:25.960 --> 05:29.720
But since it is left associative, we typically just don't write that down.

05:29.720 --> 05:32.400
So you won't see those parens.

05:32.400 --> 05:37.440
In contrast, you'll notice that the last line there, those parens around AB, that does

05:37.440 --> 05:38.600
change the expression.

05:38.600 --> 05:41.040
That is now a different expression.

05:41.040 --> 05:46.280
It means first call the A function with the B argument, and then pass that result into

05:46.280 --> 05:51.080
F. So now we've muddled up the order of things.

05:51.080 --> 05:53.320
Abstractions, these are function definitions.

05:53.320 --> 05:54.960
They're just JavaScript arrows.

05:54.960 --> 05:59.200
That's all they are.

05:59.200 --> 06:00.200
How do they work?

06:00.200 --> 06:03.080
Well, again, you got lambda means function definition.

06:03.080 --> 06:05.160
Dot means return.

06:05.160 --> 06:10.240
So lambda A dot B means taking an A and return B. What do A and B have to do with each other

06:10.240 --> 06:12.120
in this particular example?

06:12.120 --> 06:13.120
Absolutely nothing.

06:13.120 --> 06:17.120
So this throws out the A argument and returns whatever B is.

06:17.120 --> 06:18.320
What is B in this slide?

06:18.320 --> 06:19.760
The answer is we don't know.

06:19.760 --> 06:20.760
We don't know what B is.

06:20.760 --> 06:22.320
It's a free variable.

06:22.320 --> 06:23.980
It's not defined anywhere.

06:23.980 --> 06:28.300
So if you were doing lambda calculus by hand, you would simplify this.

06:28.300 --> 06:33.580
If you called this function on an argument, you'd say it returns B whatever that is.

06:33.580 --> 06:34.660
And that's fine.

06:34.660 --> 06:37.380
You don't have reference errors in lambda calculus.

06:37.380 --> 06:43.660
You end up with a symbol, and that symbol might stand for something or might not.

06:43.660 --> 06:45.300
Anything else of interest on this slide?

06:45.300 --> 06:47.460
Not really.

06:47.460 --> 06:49.820
One maybe perhaps the last thing there.

06:49.820 --> 06:52.980
You'll notice that you can have nested lambdas.

06:52.980 --> 07:00.780
So A returns B returns A is just like if you had serial arrows in a JavaScript expression.

07:00.780 --> 07:03.460
And this is actually right associative.

07:03.460 --> 07:06.820
So associativity goes all over the place of lambda calculus.

07:06.820 --> 07:09.340
That could be one of the confusing things at first.

07:09.340 --> 07:15.260
But that means that bottom function there, if you pass an argument in as A, it doesn't

07:15.260 --> 07:18.060
return the final thing.

07:18.060 --> 07:22.960
It returns a new function that takes a B. And when you call that second function, final

07:22.960 --> 07:28.600
really it returns an A. This is, by the way, known very popularly as curing.

07:28.600 --> 07:32.160
So let's see that again actually.

07:32.160 --> 07:38.880
So that bottom function there, we can see in JavaScript is defined as A takes that, returns

07:38.880 --> 07:40.680
that, and blah, blah, blah.

07:40.680 --> 07:44.120
I didn't bind it as anything, so I can't use it.

07:44.120 --> 07:48.440
But we'll call this example.

07:48.440 --> 07:52.400
That's a classic, right?

07:52.400 --> 07:59.600
So if I call example with some argument, I get back a function, a plain old function.

07:59.600 --> 08:05.520
If I try to call it with two things, this is not going to work exactly the way I expect.

08:05.520 --> 08:07.440
I still get a function back.

08:07.440 --> 08:09.320
So how do I pass in A and B?

08:09.320 --> 08:14.560
Well, since passing in A returns a function, I can immediately invoke that function expression.

08:14.560 --> 08:17.720
Oh my God, if he's there back.

08:17.720 --> 08:19.520
With the second argument.

08:19.520 --> 08:21.780
And now I actually get a result.

08:21.780 --> 08:27.420
So when I say in the Lambda calculus, every Lambda only has one input.

08:27.420 --> 08:31.260
That doesn't mean we can't think in terms of multiple inputs.

08:31.260 --> 08:35.380
We just do so in a kind of funny way where we split up all the inputs into a bunch of

08:35.380 --> 08:37.300
nested return functions.

08:37.300 --> 08:43.660
And that means to actually call a function with multiple inputs, we pass them in successively.

08:43.660 --> 08:48.860
Not all in the same prems, just one after the other.

08:48.860 --> 08:51.380
This gives us all the power that we normally get with JavaScript.

08:51.380 --> 08:56.540
We can pass in both things simultaneously, which I just did.

08:56.540 --> 09:00.980
But it also gives us new capabilities that normal JavaScript function signatures don't

09:00.980 --> 09:09.540
have because I can actually, let's do this, you know what I'm going to do on the next

09:09.540 --> 09:10.540
slide.

09:10.540 --> 09:16.460
I can actually not pass in all my arguments and I get back, instead of nan or garbage

09:16.460 --> 09:20.360
or something, I actually get back like the next step.

09:20.360 --> 09:23.800
Which can await further action.

09:23.800 --> 09:26.640
This is the most mathy complex part of the entire talk.

09:26.640 --> 09:28.040
So get ready.

09:28.040 --> 09:29.920
It's just function evaluation.

09:29.920 --> 09:32.000
What is function evaluation in Lambda calculus?

09:32.000 --> 09:34.240
It's symbol replacement.

09:34.240 --> 09:38.280
So it's called beta reduction, but that just literally means we're going to replace inputs

09:38.280 --> 09:41.280
with their arguments and then rewrite the body.

09:41.280 --> 09:43.680
Example, here's a function in red.

09:43.680 --> 09:47.760
I'm going to underline its argument to make this all very clear.

09:47.760 --> 09:52.760
It comes into this function as its parameter A, and then we go look inside that function

09:52.760 --> 09:59.160
body, find every A parameter, and replace it with the value we're binding.

09:59.160 --> 10:02.920
So this just gets rewritten as its argument.

10:02.920 --> 10:03.920
We just keep doing this.

10:03.920 --> 10:06.080
So we have a function and an argument.

10:06.080 --> 10:08.880
The argument gets bound to the B value here.

10:08.880 --> 10:09.880
So what do we do?

10:09.880 --> 10:15.400
We look at this function body, replace all the Bs with Xs, and that's symbol replacement,

10:15.400 --> 10:19.680
which is all the Lambda calculus is, gives us this expression.

10:19.680 --> 10:22.400
Once again, we have a function and an argument.

10:22.400 --> 10:25.000
This is going to replace the C parameter.

10:25.000 --> 10:29.040
So we go look in the function body for every C value, replace it.

10:29.040 --> 10:31.240
There are no Cs here, so it's easy.

10:31.240 --> 10:33.520
And we end up with a final value.

10:33.520 --> 10:37.560
Now there's no more reducible expressions or red Xs, as they're called.

10:37.560 --> 10:40.280
All these names are ridiculous, I'm sorry.

10:40.280 --> 10:45.360
And so this is in beta normal form, which just means simplified.

10:45.360 --> 10:47.160
There are little caveats here.

10:47.160 --> 10:55.000
If you could do multiple evaluations in different orders, they don't give you different answers

10:55.000 --> 11:00.880
exactly, but one way might give you an answer, and one might be an infinite loop.

11:00.880 --> 11:03.120
So there's little tricks to that.

11:03.120 --> 11:07.280
Another thing is that if you happen to have different functions that coincidentally share

11:07.280 --> 11:12.240
the same variable names, you have to be very careful not to accidentally conflate those

11:12.240 --> 11:13.280
variable names.

11:13.280 --> 11:15.600
And there's algorithms to deal with that.

11:15.600 --> 11:17.680
We're not going to go into them.

11:17.680 --> 11:23.680
Okay, so I promised that I would show, where'd the K comb in there?

11:23.680 --> 11:26.160
I guess I'll do that in a second.

11:26.160 --> 11:28.040
I'm going to show you something after this.

11:28.040 --> 11:29.040
We'll come back to it.

11:29.040 --> 11:30.880
So this is the mockingbird.

11:30.880 --> 11:32.160
What does it do?

11:32.160 --> 11:33.160
It's interesting.

11:33.160 --> 11:37.480
It takes in a value, and then it calls that value on itself.

11:37.480 --> 11:41.480
So if the value is going to be called on itself, it probably should be a function.

11:41.480 --> 11:44.720
So I'm labeling it as f.

11:44.720 --> 11:46.720
Let's try this out.

11:46.720 --> 11:50.960
Takes a function, calls the function on itself.

11:50.960 --> 11:52.880
Weird.

11:52.880 --> 11:56.360
What would the mockingbird of the identity function be?

11:56.360 --> 12:04.920
Well, it takes i, it duplicates i, so this gets simplified to ii, and the identity of

12:04.920 --> 12:06.960
identity we already established is...

12:06.960 --> 12:07.960
Identity.

12:07.960 --> 12:10.640
Yeah, identity.

12:10.640 --> 12:15.720
So it looks immediately very strange, but then we immediately see a really trivial example

12:15.720 --> 12:18.000
of how it can actually work.

12:18.000 --> 12:22.720
The mockingbird of identity is the identity of identity, and the identity of identity

12:22.720 --> 12:24.280
is identity.

12:24.280 --> 12:27.360
Say that three times fast.

12:27.360 --> 12:29.560
What's the mockingbird of mockingbird?

12:29.560 --> 12:31.560
Whoa.

12:31.560 --> 12:33.280
Let's try it out.

12:33.280 --> 12:34.280
Any predictions?

12:34.280 --> 12:38.360
It's a stack overflow.

12:38.360 --> 12:39.920
Why is it a stack overflow?

12:40.560 --> 12:42.600
The mockingbird duplicates things.

12:42.600 --> 12:48.160
So if you duplicate m, we get the mockingbird of mockingbird, but we start it out there.

12:48.160 --> 12:50.160
So this is just an infinite loop.

12:50.160 --> 12:51.160
Yeah.

12:51.160 --> 12:52.840
Too bad.

12:52.840 --> 12:57.680
This actually is too bad because this is what the problem is with Turing completeness

12:57.680 --> 12:59.880
as a concept.

12:59.880 --> 13:04.880
In Turing complete systems, which this is one, you can have infinite loops, and it gets

13:04.880 --> 13:09.080
even worse because you can't even tell if your expression will be an infinite loop.

13:09.080 --> 13:11.280
You just have to try it and see.

13:11.280 --> 13:12.840
Sometimes you can prove it for an individual expression.

13:12.840 --> 13:17.440
You can say, I have a proof that this will loop indefinitely, but there's no machine that

13:17.440 --> 13:22.080
I can feed this lambda calculus string into that will say, oh, be careful, that's an infinite

13:22.080 --> 13:23.080
loop.

13:23.080 --> 13:25.080
You can't do it without running it.

13:25.080 --> 13:26.080
Yeah.

13:26.080 --> 13:28.160
So that's a problem.

13:28.160 --> 13:32.480
This particular expression in lambda calculus is known as omega, and here's the beautiful

13:32.480 --> 13:37.200
thing about doing math and pen and paper instead of with a computer is that I can recognize

13:37.200 --> 13:41.320
I'm entering an infinite loop and say, we'll just name this thing omega and not actually

13:41.320 --> 13:44.920
keep trying to calculate it.

13:44.920 --> 13:49.000
One thing that when I was learning about all this stuff and getting excited about it that

13:49.000 --> 13:54.560
confused me a lot was that there are so many different names for these things.

13:54.560 --> 14:00.320
So here I'm looking at the mockingbird, which is the omega combinator when applied to itself,

14:00.320 --> 14:04.280
which is also written in lambda form.

14:04.280 --> 14:10.160
It's like I was trying to sort all this out, and that's when I started writing this talk.

14:10.160 --> 14:15.040
One little last thing about syntax, and then we get to more juicy stuff, I promise.

14:15.040 --> 14:20.600
We can write things in this curried form, these nested lambdas, but it's hard to read,

14:20.600 --> 14:21.600
right?

14:21.600 --> 14:24.560
Like A returns a function that takes a B, returns a function that takes a C, that returns

14:24.560 --> 14:27.000
B. There's a shorthand.

14:27.000 --> 14:30.840
The shorthand is any nested lambdas, we just squish them all together and put them to the

14:30.840 --> 14:32.040
left of the dot.

14:32.040 --> 14:37.120
So we see that lambda ABC, it's the exact same thing, we haven't changed the meaning

14:37.120 --> 14:39.960
of it, we're just writing it in a shorthand.

14:39.960 --> 14:44.640
And then when you go and do this simplification and evaluation step, you just have to be very

14:44.640 --> 14:46.920
careful to notice that.

14:46.920 --> 14:53.320
So here we have a function that takes a B and C and returns a B. Or is it?

14:53.320 --> 14:59.320
Remember it's that syntax shorthand, so really this is a function that takes B and returns

14:59.320 --> 15:05.520
a new lambda that takes C. So anytime you've got multiple parameters between that lambda

15:05.520 --> 15:10.600
and that dot, just remember there's a bunch of lambdas hidden, sandwiched between them.

15:10.600 --> 15:15.640
And when you do this simplification, they have to pop back out.

15:15.640 --> 15:17.840
Congratulations, you know the lambda calculus.

15:17.840 --> 15:19.840
It talks over.

15:19.840 --> 15:20.840
No.

15:20.840 --> 15:23.600
All right, here's the part I was trying to get to earlier.

15:23.600 --> 15:26.480
The kestrel, this is one of my favorite combinators.

15:26.480 --> 15:28.080
How does it work?

15:28.080 --> 15:31.720
It takes an A and a B and it returns A. So it takes two things and returns the first

15:31.720 --> 15:32.720
one.

15:32.720 --> 15:38.480
Wait, I already did that, but I'll rewrite it.

15:38.480 --> 15:41.000
The k-combinator, let's try it out.

15:41.000 --> 15:44.720
So I'm going to pass in two things, two symbols, arbitrary symbols, they don't mean anything.

15:44.720 --> 15:45.720
You've never seen them before.

15:45.720 --> 15:49.320
And look, it gave me back the first symbol, whatever it was.

15:49.320 --> 15:53.680
I could do this if I really wanted.

15:53.680 --> 15:58.640
So this is JavaScript really being symbolic.

15:58.640 --> 16:02.960
And of course, I can pass in whatever and wait, I'll pass in K. And what should this

16:02.960 --> 16:03.960
give me back?

16:03.960 --> 16:08.080
So the k-combinator takes two things, returns the first one.

16:08.080 --> 16:12.280
So I get back my first symbol and there actually are symbols in JavaScript now, which makes

16:12.280 --> 16:15.240
this even better.

16:15.240 --> 16:22.160
But why do I care about defining it in this one argument only nested lambda way?

16:22.160 --> 16:24.240
This is the reason.

16:24.240 --> 16:31.520
The k-5 function is if I call k with just one of its two arguments, not both of them.

16:31.520 --> 16:33.800
Oh, it's a function.

16:33.800 --> 16:35.880
What the heck is the use of that function?

16:35.880 --> 16:41.040
Well, if I call it on something else, it gives me back five.

16:41.040 --> 16:42.920
What if I call it back on something completely different?

16:42.920 --> 16:44.240
It gives me back five.

16:44.240 --> 16:45.240
What if I call it on undefined?

16:45.240 --> 16:46.560
It gives me back five.

16:46.560 --> 16:53.280
The k-5 function or the constant five function is a function that is now stuck on and obsessed

16:53.280 --> 16:55.440
with this value.

16:55.440 --> 16:58.760
I can't get this function to return anything else.

16:58.760 --> 17:04.760
Turns out that's useful for the same reason things like zero in a number system is useful.

17:04.760 --> 17:09.320
Sometimes you need a function that does very little because you have an API that's like,

17:09.320 --> 17:10.640
you must give me a function here.

17:10.640 --> 17:14.200
And like, I don't want to give you a function, you're already doing everything I want.

17:14.200 --> 17:18.880
So the identity function and the k-combinator, these things start to form very primitive,

17:18.880 --> 17:24.720
almost trivial building blocks that slot into larger, more complicated systems.

17:24.720 --> 17:28.280
So k of two things returns the first one.

17:28.280 --> 17:32.640
If you swap them around, you still get the first one, whatever that is.

17:32.640 --> 17:37.040
And in Haskell, this is called const, which isn't confusing for mainstream imperative

17:37.040 --> 17:39.640
programmers at all.

17:39.640 --> 17:40.640
It is a function.

17:40.640 --> 17:45.400
The k-combinator takes two things, returns the first one.

17:45.400 --> 17:46.880
Let's expand on this.

17:46.880 --> 17:54.880
If we've got this k-combinator and we pass in two things, we get the first one.

17:54.880 --> 17:56.960
You're getting it.

17:56.960 --> 17:58.220
But wait a second.

17:58.220 --> 17:59.440
This is math.

17:59.440 --> 18:01.880
This isn't really programming, quite.

18:01.880 --> 18:03.480
So this is a quality sign.

18:03.480 --> 18:05.160
It's not an assignment operator.

18:05.160 --> 18:09.680
This is a quality in the truest sense of whatever that means in math, which by the way is a

18:09.680 --> 18:13.160
very deep topic that we wouldn't touch on.

18:13.160 --> 18:15.040
What is the nature of equality?

18:15.040 --> 18:16.540
People don't agree.

18:16.540 --> 18:22.080
Anyway, so the thing on the left and the thing on the right are in theory the same thing.

18:22.080 --> 18:24.120
But the thing on the right is a function.

18:24.120 --> 18:26.200
It's the identity function.

18:26.200 --> 18:30.720
That means I can call that function on a value.

18:30.720 --> 18:32.800
Interesting.

18:32.800 --> 18:34.640
But we know the identity of y, right?

18:34.640 --> 18:37.360
We already know what that actually evaluates to.

18:37.360 --> 18:38.360
That's y.

18:38.360 --> 18:39.360
Huh.

18:40.360 --> 18:47.160
So this function on the left, k, that I talked about taking two things, I've kind of passed

18:47.160 --> 18:53.280
three things to, i, x, and y, and I actually get a result out of that.

18:53.280 --> 18:54.280
That's weird.

18:54.280 --> 18:57.800
I thought I'd define this function as only taking two inputs, but now I'm using it with

18:57.800 --> 18:59.040
three.

18:59.040 --> 19:03.920
This is the kind of weird flexibility and power that currying gives you.

19:03.920 --> 19:07.440
When your functions are constantly returning other functions that return other functions

19:07.440 --> 19:12.880
that return other functions, you can kind of chop things off early or extend them far

19:12.880 --> 19:17.800
beyond what they were originally being used for, and they still do things, and those things

19:17.800 --> 19:19.400
might end up being useful.

19:19.400 --> 19:20.720
Why is this useful?

19:20.720 --> 19:22.880
Because check this out.

19:22.880 --> 19:30.880
The first two values there, ki, are a function being called on x and y, and they return the

19:30.880 --> 19:33.080
second of those two things.

19:33.080 --> 19:35.760
I start with k, returns the first of two things.

19:35.760 --> 19:45.120
ki is a new function out of the ether that returns the second of two things.

19:45.120 --> 19:48.320
I'm not hearing all the amazement I expected out of that.

19:48.320 --> 19:50.600
Yeah, thank you.

19:50.600 --> 19:51.800
This is called the kite.

19:51.800 --> 19:54.040
So it's also easy to define.

19:54.040 --> 20:02.120
I could do it the way I've been doing it, and say ki of two things returns a second.

20:02.120 --> 20:03.120
There's the proof.

20:03.120 --> 20:10.520
I could also define this as calling k on i, and now I can rename it, and it just looks

20:10.520 --> 20:15.520
like a normal function, and it passes two things, and it gives me the second.

20:15.520 --> 20:21.720
But what's really amazing about this is I never sat down and wrote out, look, ki takes

20:21.720 --> 20:24.920
a, and it takes b, and it returns b.

20:24.920 --> 20:29.880
I took two existing functions, neither of which talks about the second value of any

20:29.880 --> 20:31.240
two inputs.

20:31.400 --> 20:37.240
Just by smashing them together in this sort of atom-to-molecule way, it gave birth to

20:37.240 --> 20:43.040
a new function with new behavior that I didn't manually specify.

20:43.040 --> 20:50.440
So ki of m and k returns the second thing, ki of k and m returns the second thing, and

20:50.440 --> 20:58.080
things are behaving more or less as we expect at this point.

20:58.080 --> 21:00.600
What's with all the bird names?

21:00.960 --> 21:03.880
Where's this coming from?

21:03.880 --> 21:12.120
So there is a mathematician who had a brilliant short career, very sad ending to it, named

21:12.120 --> 21:13.120
Schoenfinkel.

21:13.120 --> 21:14.240
I can't pronounce German.

21:14.240 --> 21:19.360
I'm sure many people in this room can pronounce German much better than I am, but he named

21:19.360 --> 21:27.560
these things very long German names, like Sutsumetsetsungsfunktion, and then he shortened

21:27.560 --> 21:32.160
them because it was annoying to write those down into things like i and k.

21:32.160 --> 21:38.160
And then an American mathematician, Haskell B. Curry, studying this stuff, used many of

21:38.160 --> 21:44.320
the same letters, switched some of the round just to confuse everyone who came later.

21:44.320 --> 21:51.160
And then a logician and puzzle author whose books I really enjoy called Raymond Smullyan

21:51.160 --> 21:54.120
wrote this book called To Mock a Mockingbird.

21:54.160 --> 22:00.080
And to mock a mockingbird, it is all a extended metaphor of birds in a forest that call the

22:00.080 --> 22:04.640
names of other birds, which give birth to birds, and you get where this is going.

22:04.640 --> 22:06.040
It's the same thing.

22:06.040 --> 22:12.120
He just took all those letters and he expanded them out into bird names for his metaphor.

22:12.120 --> 22:15.920
By the way, if you try to learn commentary logic through Smullyan, I mean, you might

22:15.920 --> 22:18.640
make some progress, but it is a puzzle book.

22:18.640 --> 22:20.360
It's meant to be confusing.

22:20.360 --> 22:23.840
So that's just fair warning for anyone who's like, I'm going to go buy the book now.

22:23.880 --> 22:24.880
It is a good book.

22:24.880 --> 22:28.880
You should check it out, but it's not meant to sort of be easy to follow.

22:28.880 --> 22:31.360
Also, he called it the idiot bird.

22:31.360 --> 22:32.360
I don't know.

22:32.360 --> 22:33.360
It should have been Ibis.

22:33.360 --> 22:37.560
Anyway, this was done in tribute to Curry, the other mathematician, because Curry was

22:37.560 --> 22:38.960
a bird watcher.

22:38.960 --> 22:42.560
And Haskell B. Curry, why do we care about this guy, and oh my god, okay, let's go talk

22:42.560 --> 22:44.040
about history.

22:44.040 --> 22:48.360
This is going to be the super fast version of this because I'm trying to stay under time.

22:48.360 --> 22:53.160
But in the early 20th century, actually even late 19th century, mathematicians were trying

22:53.160 --> 22:55.640
to figure out what is math?

22:55.640 --> 22:58.960
And there are all these different systems that proceed from different axioms.

22:58.960 --> 23:04.400
So what's the one true axiomatic system of math from which all of the things can be proved?

23:04.400 --> 23:08.720
And it's nice and simple and intuitive looking and clean.

23:08.720 --> 23:12.960
So Peano comes up with this thing called Peano arithmetic, which is like, I'm going to find

23:12.960 --> 23:13.960
the numbers.

23:13.960 --> 23:15.440
There's a thing called zero.

23:15.440 --> 23:18.080
And one is the thing that comes after zero.

23:18.080 --> 23:21.560
And two is the thing that comes after the thing that comes after zero.

23:21.560 --> 23:27.160
And this sounds super trivial, but it actually forms a really sound foundation for very large

23:27.160 --> 23:30.720
and complicated branches of math.

23:30.720 --> 23:38.240
Frege, who's unfortunately not as well known as he should be, does amazing work in developing

23:38.240 --> 23:42.440
concepts of combinatorial logic and functions and invent its own function notation, which

23:42.440 --> 23:46.720
is in an abstract syntax tree, which by the way, it would have been so much easier to

23:46.720 --> 23:50.440
simplify for people, but it doesn't type well, obviously, right?

23:50.440 --> 23:53.120
Like if you're typesetting, you need a linear system.

23:53.120 --> 23:54.120
And his was two-dimensional.

23:54.120 --> 23:58.480
And he uses currying, although he doesn't draw attention to it.

23:58.480 --> 24:02.640
And he develops a ton of work in axiomatic, quantified logic.

24:02.640 --> 24:07.640
Things like for all x's in the real numbers, there exists a y such that y is greater than

24:07.640 --> 24:08.640
x.

24:08.640 --> 24:13.920
Those things like for all, and there exists, a lot of that originates with Frege.

24:13.920 --> 24:19.400
1910, Russell and Whitehead famously published Principia Mathematica, which is another big

24:19.400 --> 24:25.040
attempt at unifying all of math, a great grand unified theory of math.

24:25.040 --> 24:32.320
Unfortunately, along the way, Russell discovers a paradox, an underlying flaw in set theory,

24:32.320 --> 24:40.120
as it was known at the time, where the question of what about the set that contains all sets

24:40.120 --> 24:42.360
that do not contain themselves or something like that?

24:42.360 --> 24:43.360
I can't remember the details.

24:43.360 --> 24:46.520
And he's like, wait a second.

24:46.520 --> 24:48.120
Does that set contain itself or not?

24:48.480 --> 24:49.640
You can't answer the question.

24:49.640 --> 24:51.640
It's a nonsensical question.

24:51.640 --> 24:59.280
This was a giant problem because tons of preexisting work was based on that version of set theory,

24:59.280 --> 25:02.120
which is now shown to be inconsistent.

25:02.120 --> 25:03.960
It didn't actually hold together.

25:03.960 --> 25:08.340
So this was like the first big crack in the foundations of math, where people started

25:08.340 --> 25:12.360
saying maybe this stuff is harder than we thought it was, because now we're trying to

25:12.360 --> 25:14.360
be extra super-duper careful.

25:15.360 --> 25:19.360
Schoenfinkel, 1920, does tons of work on combinatorial logic.

25:19.360 --> 25:24.800
Now I'm talking about combinatorial logic, lambda calculus, JavaScript arrow functions.

25:24.800 --> 25:26.120
What's the difference between all these things?

25:26.120 --> 25:30.560
Well, we'll clarify that more throughout, but any time I'm using those letters like

25:30.560 --> 25:36.720
k and s and i and m, that's combinatorial logic, and it's the study of functions that

25:36.720 --> 25:37.720
act on each other.

25:38.160 --> 25:45.320
And any time I'm showing you lambdas with lambda a dot b, et cetera, that is lambda calculus.

25:45.320 --> 25:48.160
Turns out they overlap by like 99%.

25:48.160 --> 25:51.960
They study functions, first-class, higher-order, anonymous functions.

25:51.960 --> 25:56.160
Actually, the combinatorial logic ones are not anonymous, by definition.

25:56.160 --> 25:57.960
But that's almost all the differences.

25:57.960 --> 26:01.080
One of them, you give them names, and one of them, they're anonymous.

26:01.080 --> 26:04.280
Van Neumann also doesn't work on this one.

26:04.280 --> 26:05.280
I'm going to skip it.

26:06.280 --> 26:10.680
Curry comes along and does a ton of this work, not knowing about Schoenfinkel, and then he

26:10.680 --> 26:12.160
discovers all of Schoenfinkel's work.

26:12.160 --> 26:14.440
He's like, oops, this guy already did it all.

26:14.440 --> 26:18.880
But he keeps going, and he comes up with a lot of really great results as well.

26:18.880 --> 26:23.040
By the way, now we know this thing that you split up the parameters as currying.

26:23.040 --> 26:26.680
Okay, yeah.

26:26.680 --> 26:29.520
But it really should be called Schoenfinkelization.

26:29.520 --> 26:38.320
In 1931, Kurt Gerdel, or maybe fragification, I don't know, Gerdel now really upends all

26:38.320 --> 26:43.160
math and just destroys all math forever with his incompleteness theorems, which prove that

26:43.160 --> 26:48.560
any system that's sufficiently complicated and interesting is either inconsistent, meaning

26:48.560 --> 26:55.040
it's flawed and actually nonsensical, or it is incomplete, which is the lesser of two

26:55.040 --> 26:58.440
evils but still very disturbing for a mathematician.

26:58.480 --> 27:04.320
This means you can talk about some possible thing that might be true or false in math,

27:04.320 --> 27:08.800
but there might not ever be a proof of whether it is true or false.

27:08.800 --> 27:10.080
But it is true or false.

27:10.080 --> 27:11.960
You just can't find out.

27:11.960 --> 27:17.520
It sounds like the most horrifyingly impossible thing to a mathematician, especially of that

27:17.520 --> 27:23.000
time period, where math was seen as the language and nature of reality, that if you were working

27:23.000 --> 27:28.120
on an unsolved problem, surely if you were just smart enough or determined enough or

27:28.120 --> 27:31.720
had good enough teammates, you could all figure it out together.

27:31.720 --> 27:36.040
Now Gerdel was coming along and saying, nope, you might never find the answer because it

27:36.040 --> 27:38.880
might be impossible to find out the answer.

27:38.880 --> 27:39.880
That was terrible.

27:39.880 --> 27:40.880
It was really terrible.

27:40.880 --> 27:43.680
By the way, a fun philosophy point.

27:43.680 --> 27:49.320
People use this along with Einstein and general relativity in the 20th century to say that

27:49.320 --> 27:53.480
the nature of reality is fluid and abstract and unknowable and things like that.

27:53.480 --> 27:57.760
This really upset Gerdel because he viewed the incompleteness theorem as a universally

27:57.800 --> 28:01.040
controversial fact about the universe.

28:01.040 --> 28:04.680
He was really excited about this result because he's like, I've finally found something that

28:04.680 --> 28:11.360
is always true and everyone else is like, oh my God, you've destroyed math.

28:11.360 --> 28:15.040
Another thing, he works on general recursion theory, which is another big system trying

28:15.040 --> 28:18.240
to unify all of mathematics.

28:18.240 --> 28:21.920
Around the same time period, a Hungarian mathematician much less well-known, unfortunately

28:21.920 --> 28:27.640
than Gerdel, is Rosa Pater and she is known as the mother of recursion theory.

28:27.680 --> 28:33.360
She does a huge amount of recursive function theory development and work in papers for

28:33.360 --> 28:39.480
decades, so I'm glad to be able to point that out.

28:39.480 --> 28:42.960
Now we get to really what's at the subject of this.

28:42.960 --> 28:47.480
The thread here has been all these people, very smart, are trying to figure out what

28:47.480 --> 28:50.480
is math, what is the nature of math, how do we define it.

28:50.480 --> 28:55.520
Now Alonzo Church comes along and defines this thing we've been looking at called lambda

28:55.520 --> 28:56.520
cacons.

28:56.520 --> 28:57.520
It's a little tiny language.

28:57.520 --> 28:58.520
That's it.

28:58.520 --> 29:01.280
It's just a notation system for symbol replacement.

29:01.280 --> 29:03.120
That's what a calculus is, by the way.

29:03.120 --> 29:10.640
A calculus is any formal system of rewriting symbols on a page and this is one for functions.

29:10.640 --> 29:15.920
It turns out that that tiny little language is beautiful because of its simplicity, which

29:15.920 --> 29:21.640
makes it easier to prove things about it than competing theories at the time, like

29:21.640 --> 29:26.400
general recursive theory, which is more confusing to read, in my opinion.

29:27.400 --> 29:30.440
Don't take that as gospel.

29:30.440 --> 29:35.240
He's got some grad students, Stephen Claney goes on to invent regular expressions later,

29:35.240 --> 29:39.080
but also these grad students help prove various things about lambda cac.

29:39.080 --> 29:43.680
Then this is the brilliant shining moment where lambda calculus proved its worth.

29:43.680 --> 29:49.400
These tiny little four lines of grammar and syntax were used to solve a giant unsolved

29:49.400 --> 29:55.520
problem of the day called the decision problem, David Hilbert's decision problem, which was,

29:55.520 --> 29:59.640
is there a machine that you could write, an algorithm you could design, that I could

29:59.640 --> 30:05.440
feed into it some math expression and it will tell me if it will run into an infinite loop?

30:05.440 --> 30:09.600
The answer to that is no, there is no such machine.

30:09.600 --> 30:11.360
We already talked about that.

30:11.360 --> 30:15.280
But church, what's interesting about this is that there's no such machine, but rather

30:15.280 --> 30:23.080
that church used lambda calculus, which seems so tiny and trivial, to prove that result.

30:23.080 --> 30:28.440
He published a paper and about a month later, Turing published another paper solving the

30:28.440 --> 30:32.880
same thing with something much more famous called Turing machines.

30:32.880 --> 30:37.440
Turing was a little upset that it turned out that the idea that he had been working on

30:37.440 --> 30:43.200
for years, I think, he just never got around to publishing, he finally did it and someone

30:43.200 --> 30:49.040
else had published a month earlier and yeah, sometimes that's the way it goes.

30:49.040 --> 30:51.760
But he goes and looks at this and he's like, wait a second.

30:51.800 --> 30:58.200
My Turing machines, which is this like stateful, imperative, sequential program instructions

30:58.200 --> 31:02.920
and this lambda calculus thing, which is an expression that you just do simple replacement

31:02.920 --> 31:09.440
and it simplifies, even though they look very different, I can write a lambda calculus interpreter

31:09.440 --> 31:17.440
in my Turing machine and I can take a lambda calculus and use it to implement a Turing

31:17.440 --> 31:19.080
machine simulation.

31:19.080 --> 31:24.000
So wait a second, if there's something in a Turing machine, I can do it in lambda calculus

31:24.000 --> 31:28.080
because I just use lambda calculus to simulate Turing machines and vice versa, therefore

31:28.080 --> 31:32.600
these two systems are really just as powerful.

31:32.600 --> 31:34.440
Anything one can do, the other can.

31:34.440 --> 31:38.840
So they seem just like amazingly, even though they're completely independent schools of

31:38.840 --> 31:44.800
thought and they're both trying to define what math is and all this business, they seem

31:44.840 --> 31:50.080
to have accidentally discovered equally powerful systems for computing things.

31:50.080 --> 31:54.960
So the church Turing thesis or hypothesis is not a fact.

31:54.960 --> 32:04.760
The hypothesis is that these systems define computation in some deep philosophical way

32:04.760 --> 32:05.760
that's undefinable.

32:05.760 --> 32:09.680
So you can never prove it because it's not well defined.

32:09.680 --> 32:13.040
The fact that lambda calculus interpreter machines are equally powerful is not the church Turing

32:13.040 --> 32:17.720
thesis that's a common mistake.

32:17.720 --> 32:18.720
So he's really excited about this.

32:18.720 --> 32:23.640
He actually combs over to Princeton, gets a PhD under Alonzo Church, helps define like

32:23.640 --> 32:27.320
new fixed point combinators and things like that.

32:27.320 --> 32:28.320
What is a combinator?

32:28.320 --> 32:32.840
I've said this word a couple of times, again, it's like all these different names for things.

32:32.840 --> 32:34.920
Combinators are just functions with no free variables.

32:34.920 --> 32:40.120
Remember I mentioned a free variable is one where you don't know what it's bound to, it's

32:40.120 --> 32:42.920
not bound to anything, it's just kind of in space.

32:42.920 --> 32:44.560
You end up with it and it's like, what does that mean?

32:44.560 --> 32:49.840
I don't know, it's the symbol B. Combinators don't have those.

32:49.840 --> 32:57.680
So all of their outputs are bound as inputs somewhere in the expression.

32:57.680 --> 33:01.160
So the definition of B will come from somewhere when you use it.

33:01.160 --> 33:02.160
It will not be undefined.

33:02.160 --> 33:07.240
In other words, combinators can never have reference errors because their values are

33:07.240 --> 33:08.240
all based on their inputs.

33:08.440 --> 33:11.440
That's all they could do is remix their inputs.

33:11.440 --> 33:17.560
And combinatorial logic, full circle now, is the study of those kinds of functions,

33:17.560 --> 33:20.920
functions which act on each other in surprising ways.

33:20.920 --> 33:24.640
We've seen a bunch, I, M, K, K, I, et cetera.

33:24.640 --> 33:26.880
And again, this gets it like there's all these different names.

33:26.880 --> 33:31.360
There's the Mockingbird versus Zem versus Lambda F to FF.

33:31.360 --> 33:34.360
You can't actually define that one in Haskell, by the way.

33:34.360 --> 33:39.360
Not simply because Haskell's type system doesn't like infinite types and the Mockingbird

33:39.360 --> 33:42.640
is all about infinity.

33:42.640 --> 33:43.640
There's a trick.

33:43.640 --> 33:50.280
You can do it in Haskell through like a little type hack, but it's not beautiful.

33:50.280 --> 33:53.480
Let's look at this one, the cardinal.

33:53.480 --> 33:57.280
The cardinal is a very lovely combinator.

33:57.280 --> 34:00.960
Takes three things, spits them back out in different order.

34:00.960 --> 34:06.760
So let's say the first thing's a function and the second two things are inputs.

34:06.760 --> 34:16.120
C combinator takes a function and A and B inputs and it calls the function with the

34:16.120 --> 34:19.040
inputs reversed.

34:19.040 --> 34:21.040
It flips the inputs around.

34:21.040 --> 34:22.040
That's interesting.

34:22.040 --> 34:23.920
What will we use or use that for?

34:23.920 --> 34:27.000
Well, let's see examples of it just to make sure we're on the same page.

34:27.000 --> 34:33.760
If I feed in a function like K into arguments like I and M, the K combinator returns the

34:33.760 --> 34:39.680
first thing, so the flip of the K combinator returns the second thing.

34:39.680 --> 34:43.440
Well, that's kind of cool.

34:43.440 --> 34:48.320
Sometimes because of this couriering business, your inputs and your arguments don't have

34:48.320 --> 34:54.840
quite the order you wish they did to make some of these tricks easier.

34:54.840 --> 35:00.280
And so this flip combinator or cardinal or C combinator can rewire things for you so

35:00.280 --> 35:04.320
that they take arguments in different orders.

35:04.320 --> 35:08.360
And C of K takes two things and returns the second.

35:08.360 --> 35:11.000
That sounds super familiar, right?

35:11.000 --> 35:15.000
Flipping K gives you Ki.

35:15.000 --> 35:16.600
They are the same function.

35:16.600 --> 35:18.840
C of K and K of I are the same function.

35:18.840 --> 35:20.480
They behave identically.

35:20.480 --> 35:23.240
For every input, they give you the same output.

35:23.240 --> 35:27.920
And when two functions that have been defined separately have nonetheless identical input

35:27.920 --> 35:32.520
output behavior, they're called extensionally equal.

35:32.520 --> 35:37.480
Extensional in the sense that from the outside, you can't see the guts of the function or

35:37.480 --> 35:39.000
how it came into being.

35:39.000 --> 35:42.000
All you can do is throw things in and see what comes out.

35:42.000 --> 35:45.560
There's no way to distinguish those functions.

35:45.560 --> 35:49.400
There's another kind of equality called intentional equality, which is more squirrely and it has

35:49.480 --> 35:51.960
to do more with the internal guts.

35:51.960 --> 35:54.640
We're not going to care about it.

35:54.640 --> 35:57.520
So there's another beautiful combinator, the C combinator.

35:57.520 --> 36:00.280
And in Haskell, it's called flip.

36:00.280 --> 36:04.600
And if you've ever played around with Haskell and talked about point-free programming, flip

36:04.600 --> 36:09.480
shows up a lot generally in a way that makes things much more confusing than they have

36:09.480 --> 36:10.480
to be.

36:10.480 --> 36:16.960
There's a cool site out there called pointfree.io that simplifies Haskell expressions, simplifies.

36:16.960 --> 36:18.400
It really doesn't.

36:18.400 --> 36:23.480
It shortens Haskell expressions to the minimal version that uses the fewest ingredients and

36:23.480 --> 36:30.480
you'll just see tons of flip and ID and const and it's completely unreadable for humans.

36:30.480 --> 36:34.680
Sometimes you get lucky and you get something that actually is simpler and easier, but flip

36:34.680 --> 36:39.680
is one of these things that is very heavy in the rewiring that's possible.

36:39.680 --> 36:44.120
Okay, I've talked about this for like 35 minutes.

36:44.120 --> 36:45.120
Who cares?

36:45.120 --> 36:46.120
What is the point?

36:46.120 --> 36:47.120
We don't care about any of this.

36:47.120 --> 36:50.880
Well, let's find out.

36:50.880 --> 36:53.080
I talked about lambda calculus and Turing machines.

36:53.080 --> 36:55.080
Why are Turing machines exciting?

36:55.080 --> 36:56.080
Simple.

36:56.080 --> 36:57.080
What?

36:57.080 --> 36:58.080
Simple.

36:58.080 --> 36:59.080
Simple.

36:59.080 --> 37:00.480
They are simple.

37:00.480 --> 37:01.480
So is lambda calculus.

37:01.480 --> 37:02.480
They're both simple.

37:02.480 --> 37:06.400
They're both so simple that it's almost hard to do anything with either of them, right?

37:06.400 --> 37:11.480
Like if you've ever hand coded a Turing machine to do like anything interesting, it's very

37:11.480 --> 37:12.480
complicated.

37:12.480 --> 37:18.400
You have to write a one, write a zero, read something, go to memory address.

37:18.400 --> 37:21.480
Like that's almost assembly.

37:21.480 --> 37:25.600
And that's really why Turing machines are cool is because if a hypothetical machine

37:25.600 --> 37:29.200
can calculate whatever you want it to, well, why not build real physical machines that

37:29.200 --> 37:30.800
do the same thing?

37:30.800 --> 37:36.200
So from Turing machines, we get the idea of let's make actual computers that can do this.

37:36.200 --> 37:41.440
And those computers have to be programmed in this very low level on off switch state

37:41.440 --> 37:45.320
version of programming called machine code.

37:45.320 --> 37:47.280
But that's really hard for humans.

37:47.280 --> 37:54.640
So now let's make a text representation called assembly of those very low level machine instructions.

37:54.640 --> 37:58.360
But thinking in terms of machine instructions and assembly is still hard.

37:58.360 --> 38:04.400
So now let's make high level textual languages that get translated into machine code and

38:04.400 --> 38:09.480
aren't one to one correspondence and give you beautiful new human centric concepts.

38:09.480 --> 38:16.560
Things like loops and variable assignment and stuff like that, which you don't get in

38:16.560 --> 38:20.360
the same way for this low level stuff.

38:20.360 --> 38:25.160
But those languages are still maybe saying, like, you tell me what memory to reserve and

38:25.160 --> 38:28.960
what blocks and how much of it and how to index into it and things like that.

38:28.960 --> 38:33.480
And someone out there is like, I'm sick of saying, you know, pointer to something.

38:33.480 --> 38:37.160
Can't we just have a language where I say var x equals object and it'll go figure out

38:37.160 --> 38:39.480
all that memory stuff for me?

38:39.480 --> 38:44.040
So now we're going even further away from the machine and more towards the concepts

38:44.040 --> 38:49.840
humans care about, which are, I've got a domain, I'm modeling something, I have ideas

38:49.840 --> 38:53.360
that I want to bandy about.

38:53.360 --> 38:58.080
And then we go even further and we say, like, wait, why do we even have state?

38:58.080 --> 39:00.240
Why have variable mutation and reassignment?

39:00.240 --> 39:03.520
That has to do with the way the machine physically works.

39:03.520 --> 39:05.720
But we don't need that.

39:05.720 --> 39:10.920
And if we take it out, some of our programs get a lot more typesafe.

39:10.920 --> 39:15.760
And this whole time, the layers of languages that have been building up and people have

39:15.760 --> 39:22.160
been inventing have been gradually moving away from the super imperative machine-based

39:22.160 --> 39:28.560
way of thinking toward a more pure conceptual way of thinking.

39:28.560 --> 39:30.280
And someone out there says, wait a second.

39:30.280 --> 39:33.480
If lambda, cacos, and trig machines are equivalent, what if we went the opposite

39:33.480 --> 39:34.760
direction?

39:34.760 --> 39:39.600
What if we started with something that has absolutely no concept of a machine but is

39:39.600 --> 39:45.360
still able to compute things and try to make it useful, try to make it work on a Turing

39:45.360 --> 39:46.360
machine?

39:46.360 --> 39:48.560
We know that it's possible.

39:48.560 --> 39:50.240
Now the question is, can we optimize it?

39:50.240 --> 39:51.240
Right?

39:51.240 --> 39:57.920
Like, can we take this pure stateless functional way of thinking and make it perform well in

39:57.920 --> 40:00.160
terms of memory and speed and stuff like that?

40:00.160 --> 40:03.600
So we'll write these pure functional languages and we'll have compilers that have been very

40:03.600 --> 40:08.640
cleverly written to develop good machine code from them.

40:08.640 --> 40:14.280
These things are equivalent, which means everything can be functions, literally everything.

40:14.280 --> 40:16.160
But not everything should be.

40:16.160 --> 40:19.320
But more than you might think.

40:19.320 --> 40:21.040
Such as bullions.

40:21.040 --> 40:23.040
We're going to invent bullions from scratch now.

40:23.040 --> 40:24.280
Let's do it.

40:24.280 --> 40:26.680
Well, it's a problem because we don't have any of those things.

40:26.680 --> 40:28.180
We just have parentheses.

40:28.180 --> 40:30.180
So far, that's all we've got in our language and our parentheses.

40:30.180 --> 40:31.180
We don't have equal signs.

40:31.180 --> 40:33.180
We don't have the not operator.

40:33.180 --> 40:34.680
We don't have ors.

40:34.680 --> 40:38.100
We do have kind of variables, but the variables aren't bullions.

40:38.100 --> 40:41.100
Like there's no concept of true-false.

40:41.100 --> 40:43.100
Okay.

40:43.100 --> 40:44.980
What are bullions used for?

40:44.980 --> 40:46.180
A lot of things.

40:46.180 --> 40:48.260
One thing they're used for is selection.

40:48.260 --> 40:53.580
If some condition, then result, else different result.

40:53.580 --> 40:59.380
Well, I've got two possible results and I'm selecting which one I want to use.

40:59.380 --> 41:03.420
So if it's the true bullion, give me back the first expression.

41:03.420 --> 41:07.300
And if it's the false one, give me back the second expression.

41:07.300 --> 41:08.300
Huh.

41:08.300 --> 41:10.500
Well, we don't have this syntax.

41:10.500 --> 41:14.380
We don't have question marks and colon, so we'll just knock those out.

41:14.380 --> 41:16.340
And then we have space.

41:16.340 --> 41:18.780
So that means function application, right?

41:18.780 --> 41:20.580
So whatever this thing, it has to be a function.

41:20.580 --> 41:23.900
And I need two functions, one for true and one for false.

41:23.900 --> 41:28.980
The true one will select the first expression and the false function will select the second

41:28.980 --> 41:29.980
expression.

41:29.980 --> 41:30.980
We've already seen this.

41:30.980 --> 41:33.140
It's the k and ki functions.

41:33.140 --> 41:35.220
Surprise, I already did it.

41:35.220 --> 41:42.260
So we'll just go up in here and we'll now say, so if I log out the k function, by the

41:42.260 --> 41:47.020
way, it says function k and node, I cheated ahead of time and I did load one tiny line

41:47.020 --> 41:51.460
of functional stuff in here, not functional, but one tiny line of code that's not lambda

41:51.460 --> 41:56.220
cacos or combinatorial logic, and that's to rewrite function names in node, which is

41:56.220 --> 41:59.420
slightly annoying in node version 12.

41:59.420 --> 42:03.140
But let's label this thing k slash true.

42:03.140 --> 42:05.100
Ah, reference error.

42:05.100 --> 42:06.100
Inspect is not defined.

42:06.100 --> 42:07.100
Oh, my God.

42:07.100 --> 42:08.100
Okay.

42:08.100 --> 42:09.100
I reloaded this.

42:09.100 --> 42:10.100
You know what?

42:10.100 --> 42:11.100
We'll just not do it.

42:11.100 --> 42:13.620
You'll all just remember that k is true.

42:13.620 --> 42:16.980
See, this is what happens when you try to do it.

42:16.980 --> 42:19.100
You try to go outside of pure math, right?

42:19.100 --> 42:21.020
This is just a mess.

42:21.020 --> 42:24.100
The ki function, unfortunately, this function is anonymous.

42:24.100 --> 42:28.420
It doesn't have a name because I developed it by smushing together k and i.

42:28.420 --> 42:34.020
So I'm going to quickly rewrite it manually, even though that's sad.

42:34.020 --> 42:35.300
Great.

42:35.300 --> 42:39.940
So anytime you see k, you can now think to yourself, oh, that's true.

42:39.940 --> 42:42.820
And every time you see ki, you can think to yourself, that's false.

42:42.820 --> 42:47.540
It's like if you see 1 and 0, you think true or false, or on and off you see true or false,

42:47.540 --> 42:51.780
or true is true and false is false.

42:51.780 --> 42:53.900
Now the k function is true and ki is false.

42:53.900 --> 42:57.020
It's just a representation.

42:57.020 --> 43:06.540
But if I have some condition like unknown bool is, quick, don't look.

43:06.540 --> 43:08.260
No one saw that.

43:08.260 --> 43:10.540
Well, which one is it?

43:10.580 --> 43:12.820
I can find out by passing it two things.

43:12.820 --> 43:15.020
If it was true, I get back the first thing.

43:15.020 --> 43:17.780
Oh, I guess unknown bool was the true function.

43:17.780 --> 43:23.340
So I could do everything I wanted, just like already out of the box.

43:23.340 --> 43:24.900
All right, but that's not that interesting, right?

43:24.900 --> 43:27.540
What's another thing we do with Boolean logic all the time?

43:27.540 --> 43:28.420
We negate.

43:28.420 --> 43:30.740
We actually transform things around.

43:30.740 --> 43:32.540
The not operator.

43:32.540 --> 43:34.940
Well, again, we don't have exclamation points, so we're going to get rid of that.

43:34.940 --> 43:36.940
It becomes a function called not.

43:36.940 --> 43:39.020
How do we define it?

43:39.020 --> 43:42.820
If p is true, return false.

43:42.820 --> 43:46.700
And if p is false, return true.

43:46.700 --> 43:50.620
Well, we need to select between two possibilities.

43:50.620 --> 43:53.820
The flip combinator is going to do this for us.

43:53.820 --> 43:55.180
I've already defined not.

43:55.180 --> 43:57.260
You didn't even realize at the time.

43:57.260 --> 44:01.540
The flip combinator, the flip of k is ki and the flip of ki is k.

44:01.540 --> 44:05.620
Which means the flip of true is false and the flip of false is true.

44:05.620 --> 44:09.180
So not is just the c combinator.

44:09.180 --> 44:11.060
Let's try it.

44:11.060 --> 44:15.860
The flip of k is some function, but which one is it?

44:15.860 --> 44:17.820
It's the false function.

44:17.820 --> 44:20.460
It returns the second thing.

44:20.460 --> 44:26.580
And the flip of ki, or false, is the true function.

44:26.580 --> 44:29.100
So it returns the first thing.

44:29.100 --> 44:34.740
We can also rename these like t is that and f is this.

44:34.740 --> 44:38.940
So now we can say things like not true.

44:38.940 --> 44:39.860
Which one is that?

44:39.860 --> 44:42.700
Is that true or is it false?

44:42.700 --> 44:46.540
It turns out not true is false, and it turns out not false is true.

44:46.540 --> 44:49.980
And we just invented this out of the ether.

44:49.980 --> 44:51.500
These are called church encodings.

44:51.500 --> 44:55.620
Alonzo Church was one of the people who helped invent them.

44:55.620 --> 44:58.180
And it's like, OK, we'll represent these things as functions.

44:58.180 --> 45:00.580
And then we can do functions on them that transform them

45:00.580 --> 45:02.140
and move them around.

45:02.140 --> 45:03.620
There's other ways of doing them.

45:03.620 --> 45:06.540
I've written one up there, like this lambda expression

45:06.540 --> 45:09.500
is another way of defining the not function.

45:09.500 --> 45:12.340
Let's move on and do and in the interest of time, of which

45:12.340 --> 45:15.140
there is very little left.

45:15.140 --> 45:17.140
The and function takes two booleans.

45:19.580 --> 45:22.260
OK, so how does this work?

45:22.260 --> 45:26.500
If both p and q are true, return true.

45:26.500 --> 45:30.780
For anything else, the and function return false.

45:30.820 --> 45:33.300
So we're taking in two booleans, p and q.

45:33.300 --> 45:34.740
And remember, these are functions.

45:34.740 --> 45:38.100
p and q are both functions.

45:38.100 --> 45:39.740
So what can we do with those functions?

45:39.740 --> 45:42.660
Well, we can use them to select things.

45:42.660 --> 45:45.300
The first boolean input is going to select

45:45.300 --> 45:47.420
between two expressions.

45:47.420 --> 45:52.420
If p is false, it's going to return the second thing.

45:52.420 --> 45:55.180
That's what the ki function does.

45:55.180 --> 46:00.980
But if p is false, what should and return?

46:00.980 --> 46:02.540
One of my booles is false.

46:02.540 --> 46:04.580
So and should return false.

46:04.580 --> 46:07.620
So p should return false.

46:07.620 --> 46:11.620
And if p is true, what should and return?

46:13.980 --> 46:16.500
Q, exactly.

46:16.500 --> 46:18.100
Because it depends what q is, right?

46:18.100 --> 46:20.540
If q is false, well, we should return false.

46:20.540 --> 46:23.260
But if q is true, p was true and q is true.

46:23.260 --> 46:24.500
So return q, which is true.

46:24.500 --> 46:25.900
And hey, it all works.

46:25.900 --> 46:27.540
And in fact, you could simplify that too.

46:27.540 --> 46:30.620
If p is false, return p, which is false.

46:30.620 --> 46:32.900
Let's try it.

46:32.900 --> 46:35.860
Takes two unknown booleans.

46:35.860 --> 46:40.260
And then if p is true, return whatever q is,

46:40.260 --> 46:42.020
because we have to check it as well.

46:42.020 --> 46:45.900
If p is false, well, we know p is false.

46:45.900 --> 46:49.980
So just return p, because they're not both true.

46:49.980 --> 46:50.620
And guess what?

46:51.340 --> 46:57.020
I have to prove that it's actually, it's some boolean.

46:57.020 --> 46:59.100
Oh, it actually worked that time.

46:59.100 --> 47:01.940
So and true, true is that.

47:01.940 --> 47:04.420
And true false is false.

47:04.420 --> 47:06.220
And false false is false.

47:06.220 --> 47:07.860
And false true is false.

47:07.860 --> 47:11.300
Hey, we invented and boolean logic.

47:11.300 --> 47:12.660
You can do the same thing with or.

47:12.660 --> 47:14.220
It's just like slightly different order.

47:14.220 --> 47:17.860
You say p returns p and q and things like that.

47:17.860 --> 47:20.340
What is this?

47:20.380 --> 47:22.460
This one's a little bit more dense.

47:22.460 --> 47:24.300
And by the way, functional languages,

47:24.300 --> 47:27.940
that function application has just a space.

47:27.940 --> 47:30.700
Look how much easier it is to read when you don't have

47:30.700 --> 47:33.140
all these parens for function evocation.

47:33.140 --> 47:34.580
Like, I think that JavaScript is actually

47:34.580 --> 47:37.940
harder to understand than the lambda calculus.

47:37.940 --> 47:40.460
But if you want a little help, p selects

47:40.460 --> 47:41.980
between two different things, depending

47:41.980 --> 47:43.500
on whether it's true or false.

47:43.500 --> 47:45.060
q selects between two different things,

47:45.060 --> 47:47.540
depending on if it's true or false.

47:47.540 --> 47:49.660
And the behavior of this unknown function,

47:49.660 --> 47:54.140
this anonymous lambda, is if both p and q are true

47:54.140 --> 47:58.780
or if both p and q are false, return true.

47:58.780 --> 48:02.900
But if they're different from each other, return false.

48:02.900 --> 48:05.460
So this is boolean equality.

48:05.460 --> 48:08.060
And we can simplify it through some steps

48:08.060 --> 48:10.300
that you can go review later in the slides.

48:10.300 --> 48:13.940
It actually turns into this, which I'll do right now.

48:13.940 --> 48:17.740
Boolean equality takes a p and a q,

48:17.740 --> 48:21.740
and it calls p on q and not q.

48:22.660 --> 48:26.740
And now I can test, hey, do true and false equal each other?

48:26.740 --> 48:27.940
No.

48:27.940 --> 48:29.940
Do false and false equal each other?

48:29.940 --> 48:32.220
Maybe that's some function that just got

48:32.220 --> 48:35.020
birthed out of nothingness, so let's check.

48:35.020 --> 48:36.140
Yeah, it's the true function.

48:36.140 --> 48:38.700
It's the one that returns the first thing.

48:38.700 --> 48:41.980
And I'm gonna keep moving, because I'm almost out of time.

48:42.020 --> 48:43.940
So we've got these church encodings, and they're lovely.

48:43.940 --> 48:45.740
Hey, here's De Morgan's law.

48:45.740 --> 48:46.860
It's a thing from logic.

48:46.860 --> 48:51.700
It says not p and q is equal to not p or not q.

48:51.700 --> 48:56.340
And now using just a lambda syntax anonymous functions,

48:56.340 --> 48:59.340
we have this beautiful, concise, easy to read way

48:59.340 --> 49:01.020
of expressing this logic.

49:01.020 --> 49:06.020
The equality of not and pq or not p, not q

49:06.260 --> 49:09.740
is always gonna be what you expect it to be.

49:09.740 --> 49:11.260
Feed two booleans into this thing,

49:11.260 --> 49:13.820
and by booleans I mean either k or ki,

49:13.820 --> 49:16.820
and you get out what you would expect from boolean logic.

49:17.820 --> 49:20.380
What else can we do with this kind of fun stuff?

49:20.380 --> 49:22.140
We can invent numbers.

49:22.140 --> 49:24.060
And if we got numbers, actually specifically

49:24.060 --> 49:26.860
positive integers, actually specifically natural numbers,

49:26.860 --> 49:28.020
zero and up.

49:28.980 --> 49:32.220
If we've got those, well, a pair of numbers is fractions,

49:32.220 --> 49:35.700
but we don't have pairs yet, so we can do arithmetic.

49:35.700 --> 49:37.940
And we're gonna need some data structures.

49:37.940 --> 49:41.020
So we'll invent those from scratch using just functions.

49:41.020 --> 49:42.220
And once we have data structures

49:42.220 --> 49:43.300
in arithmetic and things like that,

49:43.300 --> 49:45.740
we can do data types and type systems.

49:45.740 --> 49:48.060
And once we've invented some of that stuff,

49:48.060 --> 49:50.420
we can also invent recursion from scratch.

49:50.420 --> 49:52.780
Lambda calculus does not have named functions.

49:52.780 --> 49:55.700
The c and k and i, that's commonest very logic.

49:55.700 --> 49:57.900
We often refer to these functions by their names

49:57.900 --> 50:00.860
because it's way easier than saying lambda, af,

50:00.860 --> 50:02.020
ad, et cetera.

50:02.020 --> 50:04.980
But lambda calculus itself does not have named functions.

50:04.980 --> 50:07.820
In fact, it's deliberately designed without them

50:07.820 --> 50:09.820
to make it easier to prove things about math

50:09.820 --> 50:11.260
and the way things work.

50:12.380 --> 50:14.940
So how do you do recursion in lambda calculus?

50:14.940 --> 50:17.260
Well, sorry, you're gonna have to see part two

50:17.260 --> 50:19.460
in the video online.

50:19.460 --> 50:20.300
Yeah.

50:21.700 --> 50:23.220
We're almost done.

50:23.220 --> 50:24.100
Question.

50:24.100 --> 50:26.100
So some fun little things at the end here.

50:26.100 --> 50:29.180
How many combinators like c and k and stuff

50:29.180 --> 50:34.180
do you think you need to cover every possible computation

50:36.260 --> 50:37.940
to be able to do anything?

50:37.940 --> 50:38.940
Because in combinatory logic,

50:38.940 --> 50:41.100
you had to define all those functions ahead of time.

50:41.100 --> 50:41.940
In lambda calculus,

50:41.940 --> 50:44.260
you could define a function manually using syntax

50:44.260 --> 50:46.660
whenever you want, but in combinatory logic,

50:46.660 --> 50:49.900
you need to pre-define all these named functions.

50:49.900 --> 50:51.540
So do you need 20 of them?

50:51.540 --> 50:52.380
10, five?

50:52.380 --> 50:53.220
Is it even possible?

50:53.220 --> 50:55.420
Maybe you need an infinite number.

50:55.420 --> 50:59.020
Well, here are two, the s and k combinator.

51:00.300 --> 51:04.380
They behave together in all sorts of very clever ways.

51:04.380 --> 51:06.460
And for instance, the i-combinator,

51:06.460 --> 51:10.180
you can invent it by calling s on k of k.

51:11.220 --> 51:13.260
And the v-combinator, which you didn't see,

51:13.260 --> 51:16.180
it's in part two, it's a data structure, it's a two-tubble.

51:16.180 --> 51:18.180
You can do by this nonsense.

51:20.180 --> 51:21.580
But it gets even smaller.

51:21.580 --> 51:24.180
You can do everything with a single function.

51:24.180 --> 51:27.380
So if you really wanted to go crazy,

51:27.380 --> 51:29.820
you could take this iota function

51:29.820 --> 51:32.820
and write any other function in existence

51:32.820 --> 51:35.380
using just this and parentheses.

51:37.060 --> 51:37.900
But why?

51:38.980 --> 51:40.740
So what is the point of this entire talk?

51:40.740 --> 51:42.740
Like, why am I here talking about this?

51:43.860 --> 51:45.580
The short answer is I just really like it,

51:45.580 --> 51:48.460
and I hope that you've enjoyed it.

51:48.460 --> 51:50.660
It's kind of a game, like I read about this stuff

51:50.660 --> 51:52.220
in Smollion's book, which was deliberately

51:52.220 --> 51:53.220
supposed to be entertaining.

51:53.220 --> 51:54.780
It's logic puzzles and games,

51:54.780 --> 51:58.340
and things to exercise your mind and think about.

51:58.340 --> 52:01.820
It's also really great practice for thinking functionally,

52:01.820 --> 52:03.940
not because in a functional programming language,

52:03.940 --> 52:05.980
you have to invent Booleans from scratch,

52:05.980 --> 52:07.100
although often you do.

52:08.540 --> 52:09.980
Not quite in that way, though.

52:11.540 --> 52:15.300
But just the act of doing all these function evaluations

52:15.300 --> 52:17.540
with symbol manipulation and substitution

52:17.540 --> 52:19.900
and evaluating things and seeing the power

52:19.900 --> 52:22.100
of functions operating on each other

52:22.100 --> 52:24.460
makes that sort of foundational knowledge

52:24.460 --> 52:26.260
of working in a functional language

52:26.260 --> 52:28.140
just feel much more comfortable.

52:28.140 --> 52:31.580
It's a form of exercise of calisthenics.

52:32.940 --> 52:36.540
Programming languages like Haskell and PureScript

52:36.540 --> 52:38.860
and Agda, I guess, I don't know,

52:38.860 --> 52:40.580
and Elm and other things.

52:41.580 --> 52:45.500
Their basis and their core are lambda-calculi,

52:45.500 --> 52:48.300
slightly souped up ones like System F and System FC

52:48.300 --> 52:51.380
and things which add types and all sorts of stuff.

52:51.380 --> 52:53.420
But you know how Haskell actually works?

52:53.420 --> 52:54.540
It's great.

52:54.540 --> 52:56.700
You write Haskell.

52:56.700 --> 52:59.500
The compiler takes that and simplifies it down

52:59.500 --> 53:02.100
to a slightly souped up lambda-calculus.

53:02.100 --> 53:05.140
And then it pairs that lambda-calculus program

53:05.140 --> 53:07.980
that was from what you originally wrote

53:07.980 --> 53:12.980
as like a sane thing with a runtime written in C

53:13.100 --> 53:15.300
that's a lambda-calculus interpreter.

53:15.300 --> 53:17.140
And that's how Haskell works.

53:17.140 --> 53:19.100
That's why the minimum size for any Haskell program

53:19.100 --> 53:20.780
is like eight megabytes or something

53:20.780 --> 53:22.500
because it ships with this lambda-calc interpreter

53:22.500 --> 53:23.460
that runs your code.

53:24.460 --> 53:27.380
I think personally though, at the end of the day,

53:27.380 --> 53:30.420
like I don't wanna have to defend or justify

53:30.420 --> 53:32.060
and say like you should all learn lambda-calculi

53:32.060 --> 53:34.860
because it'll let you do this thing in your job.

53:35.900 --> 53:37.100
It might be able to.

53:37.100 --> 53:40.420
There's a couple cool examples I can think of

53:40.420 --> 53:43.540
that I've now thought of after the fact.

53:43.540 --> 53:45.900
But for me, it's like pure art for art's sake.

53:45.900 --> 53:47.420
And I just think that's like a lovely thing

53:47.420 --> 53:49.980
to find in programming and computer science.

53:51.700 --> 53:53.420
And yeah, there's the Y Combinator.

53:53.420 --> 53:54.780
That invents recursion.

53:54.780 --> 53:56.500
You can go see about it later.

53:56.500 --> 53:58.300
So there's a whole bunch of slides and stuff in here

53:58.300 --> 53:59.260
for reference.

53:59.260 --> 54:02.020
These are all part two and then yeah, there's resources.

54:02.020 --> 54:06.300
And I guess seven minutes over time, that's not too bad.

54:06.300 --> 54:07.340
Let's do questions.

54:07.340 --> 54:08.180
Thank you.

