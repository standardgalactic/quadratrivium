1
00:00:00,000 --> 00:00:03,600
Hey there, how's it going everybody? In this video, we're going to learn about unit testing in

2
00:00:03,600 --> 00:00:08,160
Python. So we'll go over how to write tests, how to set up and tear down your tests, and also

3
00:00:08,160 --> 00:00:12,160
some best practices. So if you're not currently testing your code, then it's definitely something

4
00:00:12,160 --> 00:00:16,080
that you're going to want to learn and start adding to your projects. So a lot of you have

5
00:00:16,080 --> 00:00:20,960
probably heard of testing, but you might not know exactly what it is. Testing your code is the most

6
00:00:20,960 --> 00:00:25,200
exciting thing to do. But there's a reason that most companies and teams require their code to be

7
00:00:25,200 --> 00:00:29,520
thoroughly tested. And if you're going to get a job working on any large projects, then you're going

8
00:00:29,520 --> 00:00:33,600
to need to know how to properly write tests. And the reason for that is that it's going to save you

9
00:00:33,600 --> 00:00:38,400
a lot of time and headache down the road. So when you write good tests for your code, it gives you

10
00:00:38,400 --> 00:00:42,960
more confidence that your updates and refactoring don't have any unintended consequences or break

11
00:00:42,960 --> 00:00:48,160
your code in any way. So for example, if you update a function in your project, those changes may

12
00:00:48,160 --> 00:00:53,200
have actually broken several sections of your code, even if that function itself is still working.

13
00:00:53,200 --> 00:00:58,000
And good unit tests will make sure that everything is still working as it should. And if it's not,

14
00:00:58,000 --> 00:01:02,240
then it'll show you exactly what's broken. So in this video, we're going to be going over everything

15
00:01:02,240 --> 00:01:06,560
that you need to know to get started with the built in unit testing module. So with that said,

16
00:01:06,560 --> 00:01:10,800
let's go ahead and get started. So right now I have a basic script pulled up here that has some

17
00:01:10,800 --> 00:01:15,040
simple functions. And I want to start off using these really simple functions so that we can just

18
00:01:15,040 --> 00:01:21,040
focus on what the tests look like. Now, what a lot of us start doing to test our code is just put

19
00:01:21,040 --> 00:01:25,680
in print statements and occasionally run the code. So for example, down here at the bottom,

20
00:01:25,760 --> 00:01:32,000
if I wanted to test that my add function was working, I could just say print add and add together

21
00:01:32,000 --> 00:01:37,840
10 and five. And if I run that, then we can see that the output that we got looks right. But

22
00:01:37,840 --> 00:01:43,440
testing your code this way isn't easy to automate. And it's also hard to maintain. So also if we're

23
00:01:43,440 --> 00:01:48,640
testing a lot of different functions, then there's no way for us to see at a glance what failed and

24
00:01:48,640 --> 00:01:54,240
what succeeded. So that's where unit testing comes in. So we're going to go ahead and just remove

25
00:01:54,240 --> 00:01:59,440
this print statement and actually start adding some unit tests. So to do this, first we need to

26
00:01:59,440 --> 00:02:05,280
create a test module. So I'm going to create a new file here in this current directory. And I'm going

27
00:02:05,280 --> 00:02:12,400
to call this test underscore calc dot py. Now that's the naming convention when writing tests is to

28
00:02:12,400 --> 00:02:18,240
start with test underscore, and then what you're testing. So in this case, it was test underscore

29
00:02:18,240 --> 00:02:23,920
calc. And that's actually going to be required within our tests. So now we have this test

30
00:02:23,920 --> 00:02:28,960
underscore calc module pulled up. And we're currently working with an empty file. So first

31
00:02:28,960 --> 00:02:34,080
let's import the unit test module. Now this module was in the standard library. So there's no need

32
00:02:34,080 --> 00:02:39,680
to install anything. You can just say import unit tests. And now we're also going to want to import

33
00:02:39,680 --> 00:02:45,440
the module that we want to test. So I'm going to import that calc module. And we can import calc

34
00:02:45,440 --> 00:02:49,600
from here since it's in the same directory. Now if you're testing code from a different directory

35
00:02:49,600 --> 00:02:54,080
and can't get your imports to work, then you can watch my video on importing modules. And it

36
00:02:54,080 --> 00:02:59,120
should help you figure out how to properly get that set up. So now we need to create some test

37
00:02:59,120 --> 00:03:04,240
cases for the functions that we want to test. And in order to create those test cases, we first need

38
00:03:04,240 --> 00:03:10,560
to create a test class that inherits from unit test dot test case. So to do this, we're first going

39
00:03:10,560 --> 00:03:17,920
to create a class. And we will call this test calc. Now you can call that class whatever you like,

40
00:03:17,920 --> 00:03:22,720
but try to keep it descriptive as to what you're testing. And we're going to want to inherit

41
00:03:22,720 --> 00:03:31,680
from unit test dot test case. So inheriting from unit test dot test case is going to give us access

42
00:03:31,680 --> 00:03:38,080
to a lot of different testing capabilities within that class. So let's write our first test. So

43
00:03:38,080 --> 00:03:45,280
to do this, we'll write a method. And the method needs to start with test underscore. Now that

44
00:03:45,280 --> 00:03:50,080
naming convention is actually required so that when we run this, it actually knows which methods

45
00:03:50,080 --> 00:03:55,440
represent tests. So if the method doesn't start with the word test, then they won't be run. And

46
00:03:55,440 --> 00:04:00,480
we'll see what that looks like in just a minute. So ours will be test underscore, and then what

47
00:04:00,480 --> 00:04:06,720
we're testing. So first, we'll just test the add function of our calc module. So we'll call this

48
00:04:06,720 --> 00:04:13,200
test underscore add. And just like any method in a class, this takes self as the first argument.

49
00:04:13,280 --> 00:04:19,200
And now within our method, we can write our test. So since we inherited from unit test test case,

50
00:04:19,200 --> 00:04:24,640
we have have access to all these assert methods. And I have them all pulled up in the documentation

51
00:04:24,640 --> 00:04:30,320
here over in Chrome. So we can see that we can assert whether two values are equal with assert

52
00:04:30,320 --> 00:04:37,040
equals, not equal with assert not equal, assert true, assert false. And the documentation shows

53
00:04:37,040 --> 00:04:44,560
you exactly what all of these check for. So for example, assert is not none checks whether a

54
00:04:44,560 --> 00:04:50,000
variable is not none. So the documentation has a good overview of all these asserts. And then over

55
00:04:50,000 --> 00:04:55,280
here, what it actually checks for. And I'll also leave a link to this in the description section

56
00:04:55,280 --> 00:05:01,440
below. So now let's switch back to writing our test. So we're going to use assert equals to test

57
00:05:01,440 --> 00:05:08,880
our add function. So I can run our add function from here by saying something like result is

58
00:05:08,880 --> 00:05:15,120
equal to calc dot add. And we'll just add those same values 10 and five. And we would expect this

59
00:05:15,120 --> 00:05:22,880
to equal 15. So to test this, we can say self dot assert equals. And now we want to assert that

60
00:05:22,880 --> 00:05:29,760
that result is equal to 15. Okay, so now how do we run this test? So we could do it from the command

61
00:05:29,840 --> 00:05:35,760
line. So I have my command line here pulled up and I am navigated to the directory where our

62
00:05:35,760 --> 00:05:42,000
module is currently located. Now you might think that we could just run the test by saying, you

63
00:05:42,000 --> 00:05:47,680
know, Python test underscore calc dot pi. But if I run that you can see it doesn't actually return

64
00:05:47,680 --> 00:05:55,040
anything. So instead, we need to run unit test as our main module and pass in test underscore calc.

65
00:05:55,040 --> 00:06:04,480
And we can do that by saying Python dash m and then unit test. And now the test underscore calc

66
00:06:04,480 --> 00:06:12,480
dot pi module. And we can see that when we run that it puts a dot here. And it says one ran one

67
00:06:12,480 --> 00:06:17,680
test. And at the bottom, it says okay, so that means that everything passed. Now it would be

68
00:06:17,680 --> 00:06:24,720
nice if we could just run our tests using this first method here by saying Python test underscore

69
00:06:24,720 --> 00:06:29,840
calc and just running the module instead of using this longer command here and setting it up to run

70
00:06:29,840 --> 00:06:35,680
that way would also allow us to run our tests from directly within our editor. So to do this,

71
00:06:35,680 --> 00:06:42,880
we can just come down here to the bottom and we can say if name double underscore name is equal to

72
00:06:43,280 --> 00:06:49,840
in quotes here, double underscore main, and then within this conditional, we can just say

73
00:06:50,400 --> 00:06:57,520
unit test dot main and run that. Now if you don't know what this double underscore name equals

74
00:06:57,520 --> 00:07:03,760
double underscore main is doing, this actually isn't related to unit testing at all. I do have a

75
00:07:03,760 --> 00:07:08,560
separate video specifically what that is about. But basically, it's just saying that if we run

76
00:07:08,560 --> 00:07:14,160
this module directly, then run the code within the conditional. And that code within our conditional

77
00:07:14,160 --> 00:07:20,720
is this unit test dot main, and that unit test dot main will run all of our tests. So now if we go

78
00:07:20,720 --> 00:07:26,960
back here, this is now saved, if we go back here to our terminal, and I will clear this out. So now

79
00:07:26,960 --> 00:07:32,640
let's rerun that using that first method of just Python and our test module. And if we run that,

80
00:07:32,640 --> 00:07:37,760
you can see that now we can run it directly. And it runs our unit tests and says that it passed.

81
00:07:37,760 --> 00:07:43,120
And since we can run it this way within the terminal, that should mean that it can also run

82
00:07:43,120 --> 00:07:48,640
within our editor. So if I run this, then you can see that within our editor, we can now run

83
00:07:48,640 --> 00:07:53,520
these tests also. Okay, so that's good. So we're running our first test. So it's saying that we're

84
00:07:53,520 --> 00:07:58,400
only running one test. Now, do you remember earlier when I said that your tests have to start with

85
00:07:58,400 --> 00:08:04,960
the word test? Well, let me show you what it does if it doesn't. So instead of test underscore add

86
00:08:04,960 --> 00:08:11,360
here as our test, let's call this add underscore test and save this and run it. So when we run this,

87
00:08:11,360 --> 00:08:15,840
it might not be obvious right off the bat that anything is wrong because we didn't get any errors

88
00:08:15,840 --> 00:08:22,160
or any warnings. But if we look at how many tests ran, it says zero. So this test was just skipped.

89
00:08:22,160 --> 00:08:26,880
So you have to be careful that all of your tests are named properly and start with the word test.

90
00:08:26,880 --> 00:08:32,800
So let's go ahead and change that back and rerun it. Okay, so now what happens if our test fails?

91
00:08:32,800 --> 00:08:38,720
So let's change this value here with the assert equals, the result is equal to 15,

92
00:08:38,720 --> 00:08:45,280
let's change this to a 14, so that our test of adding 10 and five fails. So let's save that and

93
00:08:45,280 --> 00:08:53,200
run it. So now if I pull this up a little bit here to where we can see, we can see that instead of a

94
00:08:53,200 --> 00:08:59,440
dot, we got an F for fail. And it also shows us that the test failed with an assertion error

95
00:08:59,440 --> 00:09:05,200
that 15 is not equal to 14. Okay, so now let me pull this down just a little further here.

96
00:09:05,200 --> 00:09:12,000
And now let's change this test back and also add in a few more tests. So first of all, instead of

97
00:09:12,000 --> 00:09:17,680
setting this result variable and testing that, I'm just going to instead drop our function directly

98
00:09:17,680 --> 00:09:23,840
into the assert statement. So I'm going to copy this and replace that result variable actually

99
00:09:23,840 --> 00:09:30,160
with our add function. And then I can just get rid of that result variable there. So you usually

100
00:09:30,160 --> 00:09:36,160
want to also check some edge cases. So let's copy and paste this line here a couple of times

101
00:09:36,160 --> 00:09:41,760
and test a couple of edge cases. So one edge case might be one negative number and one positive

102
00:09:41,760 --> 00:09:49,760
number. So let's make sure that negative one plus one is equal to zero. And two negative numbers

103
00:09:49,760 --> 00:09:56,800
would also be another edge case. So let's make sure that negative one plus negative one is equal

104
00:09:56,800 --> 00:10:02,800
to negative two. So now if we save this and run it, then it's saying that it passed, but it also

105
00:10:02,800 --> 00:10:08,000
says that it ran one test. Now you may have been expecting this to say that it ran three tests.

106
00:10:08,000 --> 00:10:14,640
But really, these three assert methods here are just within this single test called test underscore

107
00:10:14,720 --> 00:10:20,320
add. But even though it still says that there's only one test, we still made this test better

108
00:10:20,320 --> 00:10:26,240
by adding in these additional checks. So it's not our goal to write as many tests as possible,

109
00:10:26,240 --> 00:10:30,320
but just make sure that we write good tests. So that's something that a lot of people get

110
00:10:30,320 --> 00:10:35,760
tripped up on. They just shoot for, you know, full coverage without making sure their tests are

111
00:10:35,760 --> 00:10:40,480
actually good enough to catch mistakes. So try to be mindful of that when writing tests. And in

112
00:10:40,480 --> 00:10:46,240
order to add more tests, we just add in more test methods. So let's test the rest of our calc

113
00:10:46,240 --> 00:10:54,400
functions. So I will just copy and paste this test add function here three more times. And I'm

114
00:10:54,400 --> 00:10:59,520
going to get rid of our output here so we can see a little bit better. And now I'll change these to

115
00:10:59,520 --> 00:11:06,240
test all of our calc functions. So I'll test our subtraction function by changing all of these ones

116
00:11:06,320 --> 00:11:13,440
here to subtract. And now let's change our assert equals. So 10 minus five will be five,

117
00:11:13,440 --> 00:11:21,280
negative one minus one will be negative two, and negative one minus negative one should be zero.

118
00:11:21,280 --> 00:11:27,600
And now moving down the line here, let's change this next test to be multiply. So now for our

119
00:11:27,600 --> 00:11:35,520
assert equals, we want to test that 10 multiplied by five is 50, negative one multiplied by one

120
00:11:35,520 --> 00:11:40,720
is negative one, negative one multiplied by negative one is one. And then let's change

121
00:11:40,720 --> 00:11:47,360
this last method here to test our divide function. So we want to test divide. So now in our assert

122
00:11:47,360 --> 00:11:52,800
statements here, we want to make sure that 10 divided by five is equal to two, negative one

123
00:11:52,800 --> 00:11:59,680
divided by one is negative one, and negative one divided by negative one will just be one.

124
00:11:59,680 --> 00:12:05,120
So now if I run this code with all four of these tests, then you can see that we got four dots,

125
00:12:05,120 --> 00:12:10,080
and it says that we ran four tests. And all of those tests pass with all of those assert

126
00:12:10,080 --> 00:12:15,680
equal statements. So you can imagine how useful this is. So if you have a module with some complicated

127
00:12:15,680 --> 00:12:20,480
functions, then once you put in the work to write good tests like this, then you can just come back

128
00:12:20,480 --> 00:12:25,280
and rerun these tests to make sure that everything still works. So if you change something in your

129
00:12:25,280 --> 00:12:29,840
program that you think will work, but it actually broke some stuff, then your test should catch

130
00:12:29,840 --> 00:12:36,960
that. So for example, let's say that I came in here to our calc function, and we just made a typo

131
00:12:36,960 --> 00:12:42,080
in this multiply function. And instead of one asterisk there, we put two. Now this is actually

132
00:12:42,080 --> 00:12:48,080
going to return x to the power of y. So if we come back here to our tests and rerun this,

133
00:12:48,080 --> 00:12:54,160
then we can see that if we look here at our output, that we have two dots, and then an f,

134
00:12:54,160 --> 00:12:59,440
and then a dot. So that means that three of our tests pass and one test failed. And the one that

135
00:12:59,440 --> 00:13:06,320
failed, it says that we have an assertion error that the 10 times five should actually be equal to

136
00:13:06,320 --> 00:13:12,000
50. And it's not instead we got this value here. So that gives us an idea of exactly where the problem

137
00:13:12,000 --> 00:13:17,040
is, and where we can make that change to get these tests to pass again. So let's go ahead and go back

138
00:13:17,040 --> 00:13:22,080
here and change this back. Now, sometimes you might make a change that doesn't actually break

139
00:13:22,080 --> 00:13:28,320
your test, but will actually unexpectedly break your code. So for example, let's say that we

140
00:13:28,320 --> 00:13:34,240
came in here and changed our divide function to be floor division instead of regular division.

141
00:13:34,240 --> 00:13:38,720
And we can do this by changing this to two division signs. Now if you don't know what floor

142
00:13:38,720 --> 00:13:44,240
division is, basically, it just doesn't give you the remainder. Now our current test won't catch

143
00:13:44,240 --> 00:13:50,960
this because right now all of our and let me save this here. So right now, all of our divisions

144
00:13:50,960 --> 00:13:55,360
currently come out to whole numbers anyway. So it doesn't matter if we're using floor division

145
00:13:55,360 --> 00:14:00,640
or regular division. So if we run our test, then we can see that currently all of these tests are

146
00:14:00,640 --> 00:14:05,600
passing. So let's say that at some point that floor division broke our program. And after some

147
00:14:05,600 --> 00:14:11,920
debugging, we traced it back to that and found the problem. Now in that case, it's always a good

148
00:14:12,000 --> 00:14:17,120
practice to go update your test with a test that would have caught the problem that you just found.

149
00:14:17,680 --> 00:14:23,040
That way, we can know that we don't revisit the same bugs over and over. So for example,

150
00:14:23,040 --> 00:14:29,760
a test that would have caught this, I'm going to copy and assert equals statement here. Now a test

151
00:14:29,760 --> 00:14:36,560
that would have caught this is if we would say, you know, five divided by two, we want that to

152
00:14:36,560 --> 00:14:42,720
actually equal 2.5. But with floor division, that's actually just going to equal two. So now

153
00:14:42,720 --> 00:14:47,600
if we run this, then we can see that we got our error because we're using that floor division.

154
00:14:47,600 --> 00:14:55,120
And we can see that it is an assertion error that two is not equal to 2.5. So that should point us

155
00:14:55,120 --> 00:14:59,600
in the right direction. And then we can go and see why that would be the case. And then we can find

156
00:14:59,600 --> 00:15:04,480
out that we're using floor division there instead of regular revision and fix that go back to our

157
00:15:04,480 --> 00:15:10,080
test and run it. And now they're all passing. Okay, so now there's one more thing within our

158
00:15:10,080 --> 00:15:16,640
calc.py file here that we can see. We can see here that we are checking if the number that we're

159
00:15:16,640 --> 00:15:24,160
dividing by is zero. And if so, then we're raising a value error with the message that we can't divide

160
00:15:24,160 --> 00:15:30,480
by zero. So we'll likely want to test that our expectations are working on that as well. So,

161
00:15:31,200 --> 00:15:36,800
but this is done a little differently than the other assertions. So let's go back to our test

162
00:15:36,800 --> 00:15:42,720
and show how we can test that dividing by zero raises this correct error. So there's actually

163
00:15:42,720 --> 00:15:52,320
two ways that we can do this. So first we could say self dot assert raises. And within assert raises,

164
00:15:52,320 --> 00:16:00,000
first we want to pass in the exception that we expect and that is a value error. And now the

165
00:16:00,000 --> 00:16:05,760
function that we want to test, and that is calc divide, now we're not putting parentheses or any

166
00:16:05,760 --> 00:16:11,520
arguments there, we're putting the arguments as arguments to this assert raises method. So let's

167
00:16:11,520 --> 00:16:18,240
look at this one more time. So our first argument is the exception that we expect. The second argument

168
00:16:18,240 --> 00:16:23,760
is the function that we want to run, but we aren't passing arguments to the function. So leave off

169
00:16:23,760 --> 00:16:29,520
the parentheses. And then we pass in each argument that we want to pass into the divide function

170
00:16:29,520 --> 00:16:34,560
separately. So now the reason that we have to do it this way, instead of just running the function

171
00:16:34,560 --> 00:16:39,760
normally, is because our function would actually throw that value error. And our test will think

172
00:16:39,760 --> 00:16:45,440
that something failed. But we'll look at a way that we can do this right after this test. So

173
00:16:45,440 --> 00:16:50,560
right now, if we run this, then we can see that this is currently passing. And that's because the

174
00:16:50,560 --> 00:16:58,160
10 divided by zero did throw this value error. So if I was to change this zero to a two, then it's

175
00:16:58,160 --> 00:17:03,520
not going to throw that value error. So if I run that, then it failed. And we can see that the

176
00:17:03,520 --> 00:17:11,200
assertion error is that value error not raised by divide. So which makes sense if we divided by two.

177
00:17:11,200 --> 00:17:16,160
So if we divide by zero, that test passes. Now, I've never preferred this method of testing

178
00:17:16,160 --> 00:17:21,680
exceptions, because I just like to call the function that I want to test normally, instead

179
00:17:21,680 --> 00:17:27,520
of passing in all of the arguments separately, like we're doing here. And we can do this if we test

180
00:17:28,240 --> 00:17:35,520
the exceptions using a context manager. Now that will allow us to handle and check the exception

181
00:17:35,520 --> 00:17:41,600
properly. And also call our function normally. So to do this, I'm actually going to get rid

182
00:17:41,600 --> 00:17:49,200
of everything here. And to do this, we say with self dot assert raises value error. And that's

183
00:17:49,200 --> 00:17:55,440
using the context manager. And within this context manager, we can just call our function normally

184
00:17:55,440 --> 00:18:02,160
like we normally would. So calc divide, and we'll divide 10 by zero and save that and run it. Then

185
00:18:02,160 --> 00:18:07,280
you can see that by using this context manager, that all of those tests still pass. So you can

186
00:18:07,280 --> 00:18:12,160
choose either method that you prefer. But I've always preferred to use the context manager when

187
00:18:12,160 --> 00:18:19,520
testing exceptions. Okay, so now let's look at writing slightly more difficult tests. So I have

188
00:18:19,520 --> 00:18:25,040
a simple employee class here. And this is the employee class from the object oriented series.

189
00:18:25,040 --> 00:18:30,320
And if you don't know exactly what this class is doing, then it's not really important. We're just

190
00:18:30,320 --> 00:18:35,600
going to see how this affects some testing strategies. So basically what this code is doing

191
00:18:35,600 --> 00:18:42,240
is it allows us to create employee instances, where it will set the employee's first name,

192
00:18:42,240 --> 00:18:49,120
last name and pay. And then we have some methods that return the employee's email address, which

193
00:18:49,120 --> 00:18:55,360
is their first name and last name at email.com. Then we have a method that returns the employee's

194
00:18:55,360 --> 00:19:00,720
full name, which is just their first name and last name combined. And we also have a regular

195
00:19:00,720 --> 00:19:06,320
method here where we can apply a raise, and it will set their pay to the current pay times the

196
00:19:06,320 --> 00:19:13,920
raise amount, which by default is 5% up here. Now the way that this code is set up, if an employee's

197
00:19:13,920 --> 00:19:19,360
first name or last name changes, then that should automatically be reflected in the email and first

198
00:19:19,360 --> 00:19:23,920
name. Okay, so let's say that we wanted to write some tests for this. So first, what we would do is

199
00:19:23,920 --> 00:19:31,360
we would create a new file, and I'm going to call this test underscore employee dot pi. And to save

200
00:19:31,360 --> 00:19:36,880
time from you watching me type all of these tests, I'm instead going to grab them out of my snippets

201
00:19:36,880 --> 00:19:43,440
file here, and we'll explain exactly what we're testing. So I'm going to copy all of these down

202
00:19:43,440 --> 00:19:50,240
to this point, and paste these in here. Okay, so if we scroll up to the top here, then first we're

203
00:19:50,320 --> 00:19:56,800
importing unit test, and also importing our employee class from the employee module. And then we're

204
00:19:56,800 --> 00:20:04,160
creating our test case that inherits from unit test test case. And then we have three different

205
00:20:04,160 --> 00:20:11,040
tests here. So our first test is called test underscore email. And this creates two employees

206
00:20:11,040 --> 00:20:15,760
here. And when these employees are created, we should immediately be able to access the email

207
00:20:15,760 --> 00:20:21,520
property. So we test both of their emails to check if we're getting the expected values.

208
00:20:21,520 --> 00:20:28,560
And then we are changing their first names, and then checking the emails again here, because

209
00:20:28,560 --> 00:20:33,840
their email should change with when their name changes. So this test email is just testing to

210
00:20:33,840 --> 00:20:38,720
make sure that all that functionality is working properly. And then when we test the full name,

211
00:20:38,720 --> 00:20:44,000
it's basically the same thing, we're creating two employees, and then we're checking their full

212
00:20:44,000 --> 00:20:48,800
names to make sure they were created correctly. Then we're changing their first names. And then

213
00:20:48,800 --> 00:20:54,400
we are rechecking to make sure that the full names were changed as well. And lastly, we have a test

214
00:20:54,400 --> 00:21:00,960
for testing the apply raise function here. And again, we are creating two employees. And then we

215
00:21:00,960 --> 00:21:07,520
are applying arrays. And by default, that's 5%. So we just test to make sure that the pay was raised

216
00:21:07,520 --> 00:21:13,840
by 5%. So this is basically just a slightly more complicated test than our simple calculator test,

217
00:21:13,840 --> 00:21:18,800
but there isn't anything here that we haven't seen yet. So we just have three different tests

218
00:21:18,800 --> 00:21:25,680
and have some assert equals in here to make sure that things have the values that we expect. So

219
00:21:25,680 --> 00:21:31,360
if we run this, then we can see that all of those tests pass. Now, one thing that you might notice

220
00:21:31,360 --> 00:21:38,320
is that at the beginning of every one of these tests, we are creating two employees. Now anytime

221
00:21:38,320 --> 00:21:42,960
you see the same code over and over, that should be something that pops out to you that there might

222
00:21:42,960 --> 00:21:48,320
be a better way of doing this. Because usually programmers try to make their code dry, which

223
00:21:48,320 --> 00:21:53,360
stands for don't repeat yourself. Now the reason for that is because if anything ever changes with

224
00:21:53,360 --> 00:21:58,880
these two setup employees here, then we'll need to make changes to every single test where we

225
00:21:58,880 --> 00:22:04,320
created these employees. Now this might not be a big deal when we just have three tests like this.

226
00:22:04,320 --> 00:22:09,920
But if you have hundreds, then it could be a pain to maintain. So it would be nice if we could create

227
00:22:09,920 --> 00:22:16,480
these from scratch in one place and reuse them for every test. And there is a way to do that.

228
00:22:16,480 --> 00:22:23,280
So that's what the setup and tear down methods are for. So at the top of our test class here,

229
00:22:23,280 --> 00:22:30,480
let's create two new methods. And one of these is going to be called a setup and then self as

230
00:22:30,480 --> 00:22:35,760
the first argument. And for now, we'll just put in a past statement there. And the second method

231
00:22:35,760 --> 00:22:41,760
here will be tear down with self as the first argument and another past statement. Now these

232
00:22:41,760 --> 00:22:48,320
are camel case with the uppercase U and the uppercase D. So be sure that you type those correctly.

233
00:22:48,320 --> 00:22:53,920
Python usually doesn't do that. But I think this is carried over from some older code. So the setup

234
00:22:53,920 --> 00:22:59,920
method will run its code before every single test. And the tear down method will run its code

235
00:22:59,920 --> 00:23:06,480
after every single test. So for example, we wanted to create these two employees before

236
00:23:06,480 --> 00:23:12,160
every single test. So we can come down here and grab where we're creating these employees. And

237
00:23:12,160 --> 00:23:17,280
I'm just going to copy that and paste it here within the setup. Now in order to access these

238
00:23:17,280 --> 00:23:23,840
from within our other test, we're actually going to have to set these as instance attributes by

239
00:23:23,920 --> 00:23:30,880
putting self dot employee one and self dot employee two. Now if you don't understand how these

240
00:23:30,880 --> 00:23:37,280
instance attributes work, then I do have a video in my object oriented series where I go over

241
00:23:37,280 --> 00:23:42,800
exactly how those work. But now that we have these within our setup method, now we can delete the

242
00:23:42,800 --> 00:23:49,120
creation of these employees from the beginning of every test. So I'm going to go down and remove

243
00:23:49,120 --> 00:23:57,120
these from the beginning of all three of these tests. And now since those are instance attributes,

244
00:23:57,120 --> 00:24:02,960
everywhere that we reference employee one and employee two, we need to add self to the beginning.

245
00:24:02,960 --> 00:24:08,240
So I'm going to do this with the multi cursor functionality here within sublime text. But in

246
00:24:08,240 --> 00:24:14,800
your ID or editor, you could just use a simple find and replace. So I'm going to grab all of these

247
00:24:14,800 --> 00:24:23,680
employee ones here. And just add a self dot before that. And then I'll grab these employee

248
00:24:23,680 --> 00:24:31,280
twos here. And add a self dot before that. So now one more time, let's go ahead and just look

249
00:24:31,280 --> 00:24:36,400
at this one more time here. So within our setup, we're creating these two employees, and it's

250
00:24:36,400 --> 00:24:42,000
going to create these before every single test. So now here within our test, we're saying, okay,

251
00:24:42,000 --> 00:24:47,360
self dot assert equals, and make sure that this employee that we created up here in the setup

252
00:24:48,000 --> 00:24:53,920
is equal to this email. And this employee twos email is equal to this email. And we can reuse

253
00:24:53,920 --> 00:24:58,960
those same employees for every single one of these tests. And they get created a new for every

254
00:24:58,960 --> 00:25:03,920
single one of these tests. So let's go ahead and rerun this and make sure that this is still working.

255
00:25:03,920 --> 00:25:08,720
And it does look like all three of these tests are still passing. Now we're currently not using our

256
00:25:09,520 --> 00:25:14,560
tear down method for anything. But I still wanted to show you that it exists just in case

257
00:25:14,560 --> 00:25:19,360
you have a use case for it. So let's say, for example, that you had some functions that you

258
00:25:19,360 --> 00:25:25,360
wanted to test that added files to a directory or to a database, then in your setup method,

259
00:25:25,360 --> 00:25:30,320
you could create the test directory or the test database to hold those files. And in the tear

260
00:25:30,320 --> 00:25:35,360
down method, you could delete all of those so that you have a clean slate for the next test.

261
00:25:35,360 --> 00:25:40,560
Now, just to be more clear where all of this code is being run, let me grab some

262
00:25:40,560 --> 00:25:46,480
code here from my snippets that has print statements included throughout all of our tests.

263
00:25:46,480 --> 00:25:56,080
So I'm going to grab from here down and replace this employee test here. Now this code is exactly

264
00:25:56,080 --> 00:26:01,840
what we just had. But now we have print statements throughout our code. So we have a print statement

265
00:26:01,840 --> 00:26:09,840
in the setup and in the tear down and also within every single test case. So now if I go ahead and

266
00:26:09,840 --> 00:26:16,800
run this and scroll up here to the top, then we can see that we have the setup and then the test

267
00:26:16,800 --> 00:26:22,880
and then the tear down. And it does this for every single test set up the test and tear down set

268
00:26:22,880 --> 00:26:28,000
up test tear down. Now another thing to notice here is that the test don't necessarily run in

269
00:26:28,000 --> 00:26:33,280
order. So you should never assume that the test run straight down through the script. Now that's

270
00:26:33,280 --> 00:26:38,480
why we need to keep all of our tests isolated from one another. Now sometimes it's also useful to have

271
00:26:38,480 --> 00:26:44,880
some code run at the very beginning of the test file and then have some cleanup code that runs

272
00:26:44,880 --> 00:26:50,640
after all of the tests has have been run. So unlike the setup and tear down that runs before

273
00:26:50,640 --> 00:26:56,640
and after every single test, it would be nice if we had something that ran once before anything

274
00:26:56,640 --> 00:27:02,880
and then once after everything. Now we can do this with two class methods called setup class

275
00:27:02,880 --> 00:27:09,200
and tear down class. Now I have these in my snippets also. So let me grab these so we can see

276
00:27:09,200 --> 00:27:17,600
what these look like. And I'll paste these here at the top of our test. And let me fix the indentation

277
00:27:17,600 --> 00:27:22,800
there. Okay, so we can see that these are class methods. And if you don't know what that means,

278
00:27:22,800 --> 00:27:28,400
basically it means that we're working with the class rather than the instance of the class like

279
00:27:28,400 --> 00:27:34,080
we were with self. Now I have an object oriented video on this as well where I go into this concept

280
00:27:34,080 --> 00:27:38,560
more in depth. And I'll leave a link to that in the description section below. But once we have

281
00:27:38,560 --> 00:27:44,000
these class methods in place with these naming conventions of setup class and tear down class

282
00:27:44,000 --> 00:27:49,600
with that camel case, if we run this code, then if we scroll up here to the top, then we can see

283
00:27:49,600 --> 00:27:57,200
that it runs setup class first. And then the setups tests and tear downs for each test. And then at

284
00:27:57,200 --> 00:28:03,040
the very end here, it runs that tear down class. Now the print buffering is a little strange with

285
00:28:03,040 --> 00:28:09,760
that. So it ran after this line here. But it ran tear down class at the end of all those tests.

286
00:28:09,760 --> 00:28:15,120
Now this setup class and tear down class can be useful if you just want to do something once

287
00:28:15,120 --> 00:28:21,600
and is too costly to do before each test. So for example, maybe you want to populate a database

288
00:28:21,600 --> 00:28:26,880
to run test against now as long as you're just reading from the database, then it might be

289
00:28:26,880 --> 00:28:32,640
appropriate to just set this up once in the setup class method. And then you can tear it down in the

290
00:28:32,640 --> 00:28:37,920
tear down class method. Okay, now I know that this video is getting a bit long. But there's one more

291
00:28:37,920 --> 00:28:43,040
thing that I wanted to show you about unit testing that I think is important for most people to know.

292
00:28:43,040 --> 00:28:48,320
So sometimes our code relies on certain things that we have no control over. So for example,

293
00:28:48,320 --> 00:28:53,600
let's say that you have a function that goes to a website and pulls down some information. Now if

294
00:28:53,600 --> 00:28:59,200
that website is down, then your function is going to fail, which will also make your tests fail.

295
00:28:59,200 --> 00:29:05,360
But this isn't what we want, because we only want our test to fail if something is wrong with our

296
00:29:05,360 --> 00:29:10,320
code. So if a website is down, then there's nothing that we can actually do about that. So

297
00:29:10,320 --> 00:29:14,240
we're going to get around this with something called mocking. Now there's a lot that we could

298
00:29:14,240 --> 00:29:19,600
look at in terms of mocking, and it could probably be a video all on its own. But let's take a look

299
00:29:19,600 --> 00:29:26,000
at an example of some basic usage. So one more time, I'm going to go over here to my snippets and

300
00:29:26,000 --> 00:29:33,280
grab a little bit of code here. And this is going to be a new method in our employee class. So I'm

301
00:29:33,280 --> 00:29:40,800
going to paste this at the bottom of our employee class, and then fix these indentations. So this

302
00:29:40,800 --> 00:29:47,200
is a sample method that we're going to pretend that goes to a company's website, this line here

303
00:29:47,200 --> 00:29:55,040
using request dot get and pulls down an employee's schedule for a given month. And real quick, I also

304
00:29:55,120 --> 00:30:04,000
have to import the request library here at the top. So import requests and back down here in our

305
00:30:04,000 --> 00:30:11,040
method. So we do the request dot get for this website for this employee and for this month to

306
00:30:11,040 --> 00:30:17,200
get their schedule. And if the response is okay, then we want to return the text of that response.

307
00:30:17,200 --> 00:30:23,440
And if the response is not okay, then we want to return the text bad response. So the information

308
00:30:23,440 --> 00:30:28,640
from that website is something that we would want to mock because we don't want the success of our

309
00:30:28,640 --> 00:30:36,000
test to depend on that website being up. We only care that the get method was called with the correct

310
00:30:36,000 --> 00:30:42,240
URL, and that our code behaves correctly, whether the response is okay, and whether the response

311
00:30:42,240 --> 00:30:51,360
is not okay. So to do this, let's import something from mock called patch. So up here at the top of

312
00:30:51,360 --> 00:30:59,840
our test employee module, I will say from unit test dot mock import patch. Now there are a couple

313
00:30:59,840 --> 00:31:05,520
of different ways that we can use patch. So we can use patch either as a decorator or as a context

314
00:31:05,520 --> 00:31:12,000
manager. And it will allow us to mock an object during a test. And then that object is automatically

315
00:31:12,000 --> 00:31:19,680
restored after the test is run. So let's create a new test down here at the bottom for that monthly

316
00:31:19,680 --> 00:31:27,120
schedule method. And we'll just call this test underscore monthly. Oops, and I wanted to call

317
00:31:27,120 --> 00:31:33,440
that monthly schedule not monthly method. And then we'll pass in self. And so in this example,

318
00:31:33,440 --> 00:31:37,200
we'll use patch as a context manager. So we'll just say

319
00:31:37,440 --> 00:31:51,440
So what we said here was with patch, and then within patch, we pass what we want to mock,

320
00:31:51,440 --> 00:31:59,200
and we want to mock request dot get of the employee module. And then we're setting that equal to

321
00:31:59,200 --> 00:32:06,240
mocked get. Now you may wonder why we didn't just import requests into our test and just mock that

322
00:32:06,240 --> 00:32:12,000
instead of the employee request. But we want to mock these objects where they're actually

323
00:32:12,000 --> 00:32:17,760
used. So it's actually used in this employee module. So that is the request dot get that we

324
00:32:17,760 --> 00:32:24,160
want to mock. Okay, so now when request dot get is run in the employee module, it's actually going

325
00:32:24,160 --> 00:32:32,080
to use our mocked get variable here instead of the regular get method. And we can just assign

326
00:32:32,080 --> 00:32:38,400
the return value instead of actually going out to the website. So we can test a successful call

327
00:32:38,400 --> 00:32:47,120
by saying mocked get dot return value. And if we look back at our employee module,

328
00:32:47,120 --> 00:32:56,320
we want that return value to have an okay of true. So I can say return value dot okay is equal to

329
00:32:56,320 --> 00:33:06,480
true. And let's also set the text of that return value so we can set the text equal to, you know,

330
00:33:06,480 --> 00:33:13,200
something like success. So if you look here in our employee module, if it returns okay as true,

331
00:33:13,200 --> 00:33:20,640
then we should get our response text back. So now within our context manager here, let's just run

332
00:33:20,640 --> 00:33:26,960
our monthly schedule method just like we're testing it. So we can say schedule is equal to

333
00:33:26,960 --> 00:33:40,240
self dot employee one dot monthly schedule. And we'll just pass in a value of May to get the May

334
00:33:40,240 --> 00:33:46,000
schedule. Now one more awesome thing about these mock objects is that they actually record when

335
00:33:46,000 --> 00:33:51,600
they were called and with what values. So we want to make sure that the get method was called

336
00:33:51,600 --> 00:34:01,120
with the correct URL. So to do this, we can say mocked get dot assert called with. And this is

337
00:34:01,120 --> 00:34:07,760
just a method of that mocked object. And now we can test that it got called with the correct URL.

338
00:34:07,760 --> 00:34:17,040
So since this is employee one here, the last name is Schaefer right here. So this should have been

339
00:34:17,040 --> 00:34:25,920
called with the URL HTTP company dot com slash Schaefer and the month that we passed in was May.

340
00:34:25,920 --> 00:34:31,680
And if you're wondering where I get that here in our employee class, this is where it creates the

341
00:34:31,680 --> 00:34:38,320
URL here. So it's saying HTTP company dot com and then the employee's last name and then the

342
00:34:38,320 --> 00:34:43,440
month that we passed in. So that's the URL that it should have called that get method with. Now

343
00:34:43,440 --> 00:34:48,640
after we know that the method was called with the correct URL, let's make sure that it returned the

344
00:34:48,640 --> 00:34:58,320
correct text, which we set to success. So let's say self dot assert equal. And we want to assert

345
00:34:58,320 --> 00:35:06,240
that our schedule, which is the response is equal to success. Okay, so now if we run this code,

346
00:35:06,240 --> 00:35:10,080
then we still have our print statements in here. But we can see down here at the bottom

347
00:35:10,080 --> 00:35:16,800
that it ran for tests, and that they all passed. Okay, now last thing is that we want to test a

348
00:35:16,800 --> 00:35:24,240
failed response. So to do this, we can just do the exact same thing. So I'll just copy all of this

349
00:35:24,320 --> 00:35:31,520
here and paste it in down below. But instead of this okay value being true, I'm going to set this

350
00:35:31,520 --> 00:35:38,560
to false. So that'll test a bad response from the website. And if that okay value isn't true,

351
00:35:38,560 --> 00:35:44,240
then our monthly schedule function should just return the string bad response. So we actually

352
00:35:44,240 --> 00:35:49,600
don't need this text value here at all. So we can just remove that. And just to switch this

353
00:35:49,600 --> 00:35:56,560
second test up a bit, let's change our employee here to employee two, and we'll use the month

354
00:35:56,560 --> 00:36:02,080
of June just to make these tests a little better. So now the get method should be called with the

355
00:36:02,080 --> 00:36:08,480
URL of Smith, which is our employee to if I scroll up here to the top, you can see our employee two

356
00:36:08,480 --> 00:36:14,560
is Smith. And then that month that we used is June. So I'll save that. And lastly, instead of our

357
00:36:14,560 --> 00:36:22,000
result equaling success, it should instead return the text bad response with an exclamation point.

358
00:36:22,000 --> 00:36:27,680
So now if we run this, then we can see that all of our tests are still passing. So I know that

359
00:36:27,680 --> 00:36:32,240
this mocking can be a little confusing when you first see it. And like I said, it could probably

360
00:36:32,240 --> 00:36:38,160
be a video all on its own. But you don't use it a whole lot unless you're, you know, accessing

361
00:36:38,160 --> 00:36:43,840
things like URLs and things that are basically out of your control. So you don't use it a lot.

362
00:36:43,840 --> 00:36:49,040
But whenever you do need it, it is definitely nice to know. Okay, so I think that's going to

363
00:36:49,040 --> 00:36:54,880
about do it for this video. But before we finish up here, let me mention a few things about best

364
00:36:54,880 --> 00:37:00,720
practices. So first of all, like we saw in this video, tests should be isolated. So if you're

365
00:37:00,720 --> 00:37:06,400
still unclear what that means, basically, this just means that your test shouldn't rely on other

366
00:37:06,400 --> 00:37:13,440
test or affect other tests. So you should be able to run any test by itself, independent of the other

367
00:37:13,440 --> 00:37:18,720
tests. And one more thing that I wanted to mention is that you'll notice that in this video, I was

368
00:37:18,720 --> 00:37:24,560
adding tests to existing code. Now you may have heard something called test driven development.

369
00:37:24,560 --> 00:37:29,840
And basically what test driven development means is that you write the test before you write the

370
00:37:29,840 --> 00:37:34,960
code. And I know that that might sound a little strange. But sometimes I've found it useful.

371
00:37:34,960 --> 00:37:39,680
I don't strictly follow test driven development to where it's something that I always do. But

372
00:37:39,680 --> 00:37:45,200
basically, the concept is that you should think about what you want your code to do, and then

373
00:37:45,200 --> 00:37:51,600
write a test implementing that behavior, then watch the test fail, since it doesn't actually have any

374
00:37:51,600 --> 00:37:57,040
code to run against, and then to write the code in a way that gets the test to pass. So if you

375
00:37:57,040 --> 00:38:01,600
ever hear someone talking about test driven development, then that's what they're talking about.

376
00:38:01,600 --> 00:38:05,840
Okay, so I think that is going to do it for this video. I hope that everyone now has a good idea

377
00:38:05,840 --> 00:38:11,360
for how they can get started with unit testing. Now any testing is better than no testing. So don't

378
00:38:11,360 --> 00:38:16,640
feel like you have to be an expert with mocks and things like that before you start writing any tests.

379
00:38:16,640 --> 00:38:21,600
Even if you just write some basic assertions, then it's better than not having anything. Now

380
00:38:21,600 --> 00:38:26,880
there is another test framework out there called Pi test that a lot of people like to use more than

381
00:38:26,880 --> 00:38:31,920
this built in unit test library. And I'll be doing a video on that in the near future so that you

382
00:38:31,920 --> 00:38:36,160
can compare the two and see which one you like better. Now if anyone has any questions about

383
00:38:36,160 --> 00:38:40,240
what we covered in this video, then feel free to ask in the comment section below and I'll do my best

384
00:38:40,240 --> 00:38:44,080
to answer those. And if you enjoy these tutorials and would like to support them, then there are

385
00:38:44,080 --> 00:38:48,080
several ways you can do that. The easiest way is to simply like the video and give it a thumbs up.

386
00:38:48,080 --> 00:38:52,000
And also it's a huge help to share these videos with anyone who you think would find them useful.

387
00:38:52,000 --> 00:38:55,360
And if you have the means you can contribute through Patreon and there's a link to that page

388
00:38:55,360 --> 00:39:00,000
in the description section below. Be sure to subscribe for future videos and thank you all for watching.

