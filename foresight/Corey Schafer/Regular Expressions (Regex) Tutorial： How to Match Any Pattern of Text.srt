1
00:00:00,000 --> 00:00:03,040
Hey there, how's it going everybody? In this video we're going to be learning how to use

2
00:00:03,040 --> 00:00:07,280
regular expressions. So we're actually going to look at regular expressions as a standalone

3
00:00:07,280 --> 00:00:11,360
topic because they aren't specific to any one programming language. Now there are some slightly

4
00:00:11,360 --> 00:00:15,760
different flavors here and there, but for the most part, whether you're programming in Python or

5
00:00:15,760 --> 00:00:21,200
JavaScript or Java or whatever, if you learn how to use general regular expressions, then it should

6
00:00:21,200 --> 00:00:25,840
mostly carry over into your language of choice. And it will also allow you to use them in text

7
00:00:25,840 --> 00:00:30,320
editors and the command line and things like that. Now I am going to do a follow up video where I

8
00:00:30,320 --> 00:00:34,640
show how to use regular expressions specifically in Python since that's a language that I cover

9
00:00:34,640 --> 00:00:39,360
most on this channel. But for this video, we're going to be learning how to use regular expressions

10
00:00:39,360 --> 00:00:43,920
by themselves so that you can apply these to other areas. So with that said, let's go ahead and get

11
00:00:43,920 --> 00:00:49,200
started. So regular expressions basically allow us to search for specific patterns of text. And

12
00:00:49,200 --> 00:00:53,600
they can look extremely complicated. But that's mainly because there's just so much that you

13
00:00:53,600 --> 00:00:57,680
can do with them. You can create a regular expression for just about any pattern of text that

14
00:00:57,680 --> 00:01:02,560
you can think of. So let's see what some of these look like. So I have a test file open here that

15
00:01:02,560 --> 00:01:07,680
we're going to use to search for specific patterns. And I'm going to be using the regular expression

16
00:01:07,680 --> 00:01:13,280
tool in the atom text editor to write these regular expressions and find what text matches our patterns.

17
00:01:13,280 --> 00:01:18,000
Now in order to open up this regular expression search tool, I'm just going to go to find and

18
00:01:18,000 --> 00:01:23,280
then find in buffer. Now you could have also opened this up with command F on a Mac. And I believe

19
00:01:23,280 --> 00:01:30,320
that's control F on Windows. Now within the options here, make sure that you have the dot

20
00:01:30,320 --> 00:01:35,680
asterisk selected over here because that's going to tell our search tool to use regular expressions.

21
00:01:35,680 --> 00:01:41,200
And also select this match case option here as well. That's just going to give us behavior that

22
00:01:41,200 --> 00:01:46,000
is more common to how regular expressions usually behave. Okay, so let's start writing some regular

23
00:01:46,000 --> 00:01:51,040
expressions. And first we'll start off kind of simple. So first of all, we can just search for

24
00:01:51,040 --> 00:01:57,120
literal characters. So if I was to search for ABC, then we can see here at the top that it

25
00:01:57,120 --> 00:02:03,920
highlighted ABC because it matched the ABC and our lowercase alphabet. Now it didn't match the

26
00:02:03,920 --> 00:02:10,320
capital ABC here because it's case sensitive. Now this search right now is looking specifically

27
00:02:10,320 --> 00:02:16,720
for A, B, and C. But if I was to type in something like BCA, then we can see that there were no

28
00:02:16,720 --> 00:02:23,280
results found because the order does matter. Now if we look at this meta character section here,

29
00:02:23,280 --> 00:02:28,560
I have some examples of characters that I say need to be escaped. So for example,

30
00:02:28,560 --> 00:02:35,920
if you wanted to search for a literal period, now if I was to just type in a period here and

31
00:02:35,920 --> 00:02:40,720
hit enter for my search, then we can see that it does this weird thing where it matches everything.

32
00:02:40,720 --> 00:02:46,320
And that is because the dot is a special character in regular expressions. And we'll see more of this

33
00:02:46,320 --> 00:02:52,160
in just a second. But for now, if we just wanted to actually search for a period or a dot, then we

34
00:02:52,160 --> 00:02:58,480
have to escape it. And to escape characters, we can use the backslash. So if I do a backslash and

35
00:02:58,480 --> 00:03:05,040
search, then now we can see that it only matches the actual literal dot or period within our document

36
00:03:05,040 --> 00:03:09,760
here. And that goes for any of these meta characters that I've listed here. So for example,

37
00:03:09,760 --> 00:03:14,560
we can see that the backslash is a special character also. So if you wanted to search

38
00:03:14,560 --> 00:03:20,240
specifically for a backslash, then you have to escape itself. So a backslash to escape,

39
00:03:20,240 --> 00:03:24,560
and then a backslash for the search. And if I search for that, then we can see that we matched

40
00:03:24,560 --> 00:03:30,240
a literal backslash. So a practical example of this might be trying to match this URL right here.

41
00:03:30,240 --> 00:03:36,000
So if we wanted to match that literal URL, exactly, then we could just say corey Ms.

42
00:03:36,000 --> 00:03:41,680
And then for the dot on the dot com, we have to escape that with a backslash and then a period,

43
00:03:41,680 --> 00:03:46,320
and then a com. And we can see that it matches our URL. Okay, so that's how you match literal

44
00:03:46,320 --> 00:03:50,800
characters. But a literal search isn't too exciting, because we're used to that already.

45
00:03:50,800 --> 00:03:55,040
Really, we want to use regular expressions to search for patterns. And to do this, we're going

46
00:03:55,040 --> 00:04:00,480
to be using some of these meta characters that we were just escaping. So I have a snippets file

47
00:04:00,480 --> 00:04:05,920
open here. So I'm going to switch over to this. And in here, I have a list of values where we can

48
00:04:05,920 --> 00:04:10,640
see the types of characters that we can match. Now just for now, I'm going to try to make this

49
00:04:10,640 --> 00:04:17,360
into a split screen here, as we're walking down this list. So the first one I have listed here

50
00:04:17,360 --> 00:04:23,440
is this dot or period. And we can see that this matches any character except a new line. Now we've

51
00:04:23,440 --> 00:04:28,880
already seen this, but let's take a look again. If we just do a dot and search for that, then we

52
00:04:28,880 --> 00:04:33,920
can see that it matches any character except it does not match the new lines. Okay, so next on

53
00:04:33,920 --> 00:04:41,520
the list is backslash D. And that matches any digit zero through nine. So if I was to do a backslash

54
00:04:41,520 --> 00:04:46,640
D here and search for that, then you can see that this matches all of our digits. So anything

55
00:04:46,640 --> 00:04:51,760
zero through nine, it matches. Now we also have an uppercase D here. And that matches anything

56
00:04:51,760 --> 00:04:57,840
that is not a digit. So if I search for an uppercase D, then we can see that our digits are not

57
00:04:57,840 --> 00:05:03,120
matched. But everything else is highlighted. So it matched everything except for the digit. Now

58
00:05:03,120 --> 00:05:08,400
you'll notice that this is a common theme here that the uppercase versions of all of these are the

59
00:05:08,400 --> 00:05:15,200
ones that kind of negate the search. So moving on down here, we have backslash w that searches for

60
00:05:15,200 --> 00:05:21,840
any word character and a word character is lowercase a through z uppercase a through z zero through

61
00:05:21,840 --> 00:05:28,080
nine and an underscore. So let's search for the word character. And we can see that it matches,

62
00:05:28,080 --> 00:05:32,480
you know, all these lowercase uppercase numbers and things like that. It doesn't match these

63
00:05:32,480 --> 00:05:38,720
special meta characters here. And just like with the digit, the uppercase w will match anything that

64
00:05:38,720 --> 00:05:44,720
is not a word character. So anything that is not in this list here. So let's go ahead and search

65
00:05:44,720 --> 00:05:50,160
for that uppercase w. And we can see that, you know, it picks up the spaces and these special

66
00:05:50,160 --> 00:05:55,520
punctuations and things like that. But it does not match the word characters that we saw before.

67
00:05:55,520 --> 00:05:59,200
Now, if you're not quite getting this just yet, we are going to look at a lot of examples to where

68
00:05:59,200 --> 00:06:04,720
it'll start to sink in. So moving down the list here, we have backslash s, which will match any

69
00:06:04,720 --> 00:06:12,080
white space. And white space is a space tab or a new line. So if we search for backslash s,

70
00:06:12,080 --> 00:06:17,280
then we can see that it matches our new lines here and our spaces, but it doesn't match any of these

71
00:06:17,280 --> 00:06:22,800
characters in here. So it's mainly white space. And just like with the others, the capital s

72
00:06:22,800 --> 00:06:27,600
will search for anything that is not white space. So now you can see that we have, you know, all

73
00:06:27,600 --> 00:06:33,200
these lowercase uppercase digits and then also this punctuation, anything that isn't a new line

74
00:06:33,200 --> 00:06:38,640
or a space or anything like that. Now these bottom ones over here, the backslash b, the

75
00:06:38,640 --> 00:06:43,760
carrot and the dollar sign, these ones are a little bit different. So these are called anchors.

76
00:06:43,760 --> 00:06:50,880
And they don't actually match any characters, but rather they match invisible positions before or

77
00:06:50,880 --> 00:06:57,200
after characters. So let's see what I mean by this. So for a word boundary, if I search for a

78
00:06:57,200 --> 00:07:04,240
word boundary here. So now let's search for where we have this ha ha ha here. Let's search for a

79
00:07:04,240 --> 00:07:11,120
word boundary and then ha and match that. So we can see that that matched because there is a word

80
00:07:11,120 --> 00:07:17,760
boundary here at the start of this line before this first one here. And this space here is also

81
00:07:17,760 --> 00:07:23,920
word boundary. So this one gets matched as well. But this last one does not get matched because

82
00:07:23,920 --> 00:07:29,520
there's no word boundary between these two ha's here. Now just to show what this would look like

83
00:07:29,520 --> 00:07:33,920
without the word boundary. If I was to search for that, then you can see that it highlights all three

84
00:07:33,920 --> 00:07:40,000
of those. Now just like with the other ones, if I do a an uppercase b, then that matches anything

85
00:07:40,000 --> 00:07:45,760
that is not a word boundary. So if I do an uppercase b, then we can see that we match the one that it

86
00:07:45,760 --> 00:07:51,040
didn't match before, because there is no word boundary between these two here. So it doesn't

87
00:07:51,040 --> 00:07:57,840
match these first two. Now if I was to put word boundaries on both sides of these, then it should

88
00:07:57,840 --> 00:08:04,640
only match this first one, because this is the only one that has a word boundary at the beginning,

89
00:08:04,640 --> 00:08:11,040
which we're matching here, and at the end. So this one has a word boundary at the beginning,

90
00:08:11,040 --> 00:08:16,720
but not at the end because it's in the middle of this word. And this one has a word boundary at

91
00:08:16,720 --> 00:08:22,000
the end, but not at the beginning. Okay, so our other two anchors here are pretty similar. So the

92
00:08:22,000 --> 00:08:28,080
carrot matches the position at the beginning of a string, and the dollar sign matches the position

93
00:08:28,080 --> 00:08:34,880
at the end of a string. So let's say for example, that we only wanted to match a ha if it was at

94
00:08:34,880 --> 00:08:42,160
the beginning of a string. So for example, if I was to do a carrot and then a ha and match that,

95
00:08:42,160 --> 00:08:45,760
then we can see that it only matched this one, because it's the only one

96
00:08:45,760 --> 00:08:51,440
that is at the beginning of a line. Now if we wanted to only match it if it was at the end,

97
00:08:51,440 --> 00:08:57,120
then we could put that dollar sign at the end. And what we're saying here is that we only want

98
00:08:57,120 --> 00:09:03,600
to match this if the end of the string is the is in the following position. So we can see that it

99
00:09:03,600 --> 00:09:08,960
not only matches this last one, because the end of the string is the next position in line. Okay,

100
00:09:08,960 --> 00:09:14,320
so now that we've seen what we can match with these special characters here, now let's go ahead

101
00:09:14,320 --> 00:09:19,520
and take a look at some practical examples. So I'm going to move my snippets file back here,

102
00:09:19,520 --> 00:09:24,960
and we will keep referencing that later on. But for now, let's go ahead and say that we wanted

103
00:09:24,960 --> 00:09:29,120
to match a couple of phone numbers. And let's write some regular expressions to do this. Now

104
00:09:29,120 --> 00:09:34,160
with a phone number, we can't just type in a literal search like we did before, because all of these

105
00:09:34,160 --> 00:09:40,400
are different. So they have a similar pattern, but they're not all the same digits. So in this case,

106
00:09:40,400 --> 00:09:46,800
we need to use the meta characters instead of literal characters. So we just have a pattern here

107
00:09:46,800 --> 00:09:53,440
of three digits, and then a dash or a period, and then three more digits, and then a dash

108
00:09:53,440 --> 00:09:59,920
or a period, and then four digits at the end. So we saw before that we can match a digit with a

109
00:10:00,000 --> 00:10:06,480
backslash d. And that is going to match all of the digits in our file. So we want to match

110
00:10:06,480 --> 00:10:12,400
this phone number here. So we want to match first three digits in a row. So we can just put in

111
00:10:12,400 --> 00:10:17,920
three backslash d's, and that will match any three digits in a row. So now that we're matching

112
00:10:17,920 --> 00:10:22,400
those first three digits, now we're getting to where we can see that we're either going to match

113
00:10:22,400 --> 00:10:28,960
a dash or a dot in our phone number. So for now, let's just match any character that's in this

114
00:10:28,960 --> 00:10:34,640
position. So from our snippets file, we saw that if we want to match any character that we can use

115
00:10:34,640 --> 00:10:40,080
a dot. So we can see that for now, our pattern is still matching some other stuff as well. But

116
00:10:40,080 --> 00:10:46,320
let's just continue on. So now that we're matching this hyphen or this dot, now let's go ahead and

117
00:10:46,320 --> 00:10:52,880
add in the next three digits. So we want to search for three more digits. So I'll do three backslash

118
00:10:52,880 --> 00:10:58,800
d's. And now we're going to want a dot to match any character, which should match that dash or

119
00:10:58,800 --> 00:11:05,440
that dot. And now we want four digits. So we can just do four backslash d's. So now we can see that

120
00:11:05,440 --> 00:11:10,320
this regular expression highlights both of our phone numbers and matches both of those. So now

121
00:11:10,320 --> 00:11:16,080
we're starting to see how this could be pretty useful. So for example, I have a data file here.

122
00:11:16,080 --> 00:11:21,920
Now if I pull this up, then I have a bunch of fake names and numbers and addresses and emails.

123
00:11:21,920 --> 00:11:26,320
But if I wanted to match all of the phone numbers in this file, then you can see that the regular

124
00:11:26,320 --> 00:11:32,080
expression that we just wrote matches all of the phone numbers here. So now we're starting to kind

125
00:11:32,080 --> 00:11:36,880
of get a sense of how this could be more useful than just a literal search, because now we're

126
00:11:36,880 --> 00:11:43,360
actually searching for a specific pattern. So now let me go back to our simple text file here.

127
00:11:43,360 --> 00:11:47,600
So now let's get a little bit more specific. So let's say that we only wanted to match a phone

128
00:11:47,600 --> 00:11:53,840
number if it had a dash or a dot. Now right now, this pattern will match any separator,

129
00:11:53,840 --> 00:11:59,280
because we're using the period down here, which will match any character. So if I was to put in

130
00:11:59,280 --> 00:12:06,560
a another number here that doesn't have a regular separator, let's just say it's an asterisk,

131
00:12:06,560 --> 00:12:11,120
then we can see that it matches this number as well, even though the asterisk isn't really a

132
00:12:11,120 --> 00:12:17,360
phone number separator. So to only match the dash or the dot, we're going to have to use a character

133
00:12:17,360 --> 00:12:23,680
set. And a character set uses square brackets with the characters that we want to match. So to

134
00:12:23,680 --> 00:12:28,640
create a character set, I'm going to replace our first dot here. And this is going to be square

135
00:12:28,640 --> 00:12:34,240
brackets. Now this is a character set. Now within this character set, we want to put the characters

136
00:12:34,240 --> 00:12:41,040
that we want to match. So we want to match either a dash or a dot. And I will just copy that and

137
00:12:41,040 --> 00:12:46,880
we'll replace this second dot here, which was matching any character. And we will put that

138
00:12:46,880 --> 00:12:52,880
in for that as well. And now you can see that it only matches our phone numbers here that have a

139
00:12:52,880 --> 00:12:58,480
dash or a dot separator. And it does not match this one with the weird asterisk there. Now you

140
00:12:58,480 --> 00:13:04,000
probably also notice that we didn't need to escape our dot character within our character set. And

141
00:13:04,000 --> 00:13:08,880
that's because character sets have some slightly different rules. Now you can escape these characters

142
00:13:08,880 --> 00:13:13,600
if you'd like. But it just makes it a lot more difficult to read if you do that. Now even though

143
00:13:13,600 --> 00:13:19,760
the character set has multiple characters here in the set, it's still only matching one character

144
00:13:19,760 --> 00:13:26,080
in our text. It's matching one character that is either a dash or a period. But if I was to put in,

145
00:13:26,080 --> 00:13:31,600
let's say two dashes here into one of these numbers, then you can see now it doesn't match that number

146
00:13:31,600 --> 00:13:38,080
because it's only matching the first dash or a dot. And then it moves right on to looking for a

147
00:13:38,080 --> 00:13:42,480
digit. So it's looking for a digit in this position. So that's something that can kind of throw

148
00:13:42,480 --> 00:13:46,560
people off when they first start working with regular expressions. So even though, you know,

149
00:13:46,560 --> 00:13:50,880
we have four characters total here in this character set with these square brackets,

150
00:13:50,880 --> 00:13:56,720
and all of the characters in this set, it's still only searching for one literal character up here,

151
00:13:56,720 --> 00:14:02,080
which is either a dash or a dot. Now to show another example of this, let's say that we only

152
00:14:02,080 --> 00:14:08,640
wanted to match 800 and 900 numbers. So I'm going to create two different numbers here. I'll do an

153
00:14:08,640 --> 00:14:16,720
800 number and a 900 number here. So if we only wanted to match 800 and 900 numbers, then our first

154
00:14:16,720 --> 00:14:22,160
three digits here, we have to do something different. So first, we want the first digit that we're

155
00:14:22,160 --> 00:14:27,680
going to match to either be an eight or a nine. So we can do a character set. And we can say that

156
00:14:27,680 --> 00:14:34,480
we're looking to either start with an eight or a nine. Now the following two numbers are going to be

157
00:14:34,480 --> 00:14:40,480
zero zero. And that's just a literal search. So now you can see that we're finding the 800 and 900

158
00:14:40,480 --> 00:14:46,960
numbers here. Now within our character set, the dash is actually a special character as well.

159
00:14:46,960 --> 00:14:52,400
So when it's put at the beginning or the end of the character set, then it will just match the

160
00:14:52,480 --> 00:14:58,960
literal dash. But when it's placed between values that can actually specify a range of values. So

161
00:14:58,960 --> 00:15:05,520
for example, we know that the backslash D matches any digit. But what if we only wanted to match

162
00:15:05,520 --> 00:15:11,840
digits between let's say one and seven. So to do that, we can use a character set. And we can just

163
00:15:11,840 --> 00:15:19,040
say instead of typing out 1234567, if we wanted to specify a range of those values, then we can

164
00:15:19,120 --> 00:15:24,880
just say one dash seven. So now we can see that we're matching all of the digits between one and

165
00:15:24,880 --> 00:15:30,800
seven, but the eight, nine and the zero aren't getting matched up here. Now you can do this with

166
00:15:30,800 --> 00:15:36,880
letters as well. So if we only wanted to match the lowercase letters a through Z, then we could just

167
00:15:36,880 --> 00:15:42,560
do a character set of a through Z. Now you can see all of the capital letters aren't getting matched,

168
00:15:42,560 --> 00:15:47,920
but the lowercase ones are. Now if we wanted to match the uppercase and lowercase numbers,

169
00:15:47,920 --> 00:15:54,400
then we could just put our ranges back to back. So I could say a through Z and then just add on

170
00:15:54,400 --> 00:16:00,960
to this character set and say capital A through capital Z. And now we're matching all letters,

171
00:16:00,960 --> 00:16:05,840
regardless of whether they are uppercase or lowercase. And you could keep adding to those ranges.

172
00:16:05,840 --> 00:16:10,960
If you wanted to, you could do a zero through nine there as well, to add in all digits. Now

173
00:16:10,960 --> 00:16:17,440
another special character in our character set is the carrot. Now we saw before that outside of the

174
00:16:17,440 --> 00:16:22,880
character set, it matches the beginning of a string, but within the character set, it negates

175
00:16:22,880 --> 00:16:28,720
the set and matches everything that is not in the set. So for example, if we wanted to match every

176
00:16:29,520 --> 00:16:36,720
character that is not a lowercase letter, then we could say this carrot and then A through Z.

177
00:16:36,720 --> 00:16:41,360
So we can see that it matches everything on our screen that isn't a lowercase letter. It's not

178
00:16:41,360 --> 00:16:46,720
matching these lowercase letters here. So it's even matching these new lines and the spaces and

179
00:16:46,800 --> 00:16:53,520
everything. So just to show another example of this, let's say that we had some words here,

180
00:16:53,520 --> 00:17:01,280
cat, mat, pat, and bat. So let's say that we wanted to match every word that ends in A-T,

181
00:17:01,280 --> 00:17:08,400
except bat. We don't want to match bat. So to do this, we can just say that we want a character

182
00:17:08,400 --> 00:17:15,680
set of everything that is not B, followed by A-T. So now we can see that it matches all of these

183
00:17:15,680 --> 00:17:22,480
three letter words that end in A-T, except for bat, because our character set here negated that B.

184
00:17:22,480 --> 00:17:28,160
So everything that we've looked at so far has involved single characters. So in this example

185
00:17:28,160 --> 00:17:35,200
right here, we're matching any single character that is not a B, then followed by an A, and then

186
00:17:35,200 --> 00:17:40,640
followed by a T. But we can actually use these things called quantifiers to match more than one

187
00:17:40,640 --> 00:17:46,720
character at a time. So let's go back to our original phone number example from earlier,

188
00:17:46,720 --> 00:17:53,040
and we'll just match any character like we did before. So I will do three digits and then a

189
00:17:53,040 --> 00:17:59,120
period for any character, and then three digits again, and a period for any character, and then

190
00:17:59,120 --> 00:18:04,160
four digits at the end. And I'm just going to remove what we had there for an example

191
00:18:04,160 --> 00:18:10,320
and scroll those back up. So to see what quantifiers we have available, I'm going to make my snippets

192
00:18:10,400 --> 00:18:16,400
half of my screen here again, and then scroll down to my quantifiers section. So the asterisk will

193
00:18:16,400 --> 00:18:23,440
match zero or more of what we're searching for. The plus sign will match one or more. The question

194
00:18:23,440 --> 00:18:29,600
mark will match zero or one. And to match exact numbers, we can use these curly braces with a

195
00:18:29,600 --> 00:18:34,560
number on the inside. So in this example, this would match exactly three of what it is we're

196
00:18:34,560 --> 00:18:40,560
looking for. And we can also specify a range of numbers as well, with the first number being the

197
00:18:40,560 --> 00:18:46,720
minimum, and the last number being the max. So this would search for whatever our pattern is. It

198
00:18:46,720 --> 00:18:51,920
would look for three or four of those. So let's take a look at an example of this to see how this

199
00:18:51,920 --> 00:18:57,920
works. So you can see that with our phone number, we are searching for one digit at a time. But we

200
00:18:57,920 --> 00:19:05,120
could change this. If I erase my digits here, then we could say that I'm searching for a digit.

201
00:19:05,120 --> 00:19:12,080
And then we could put in our quantifier for exactly three digits. And we could do this

202
00:19:12,080 --> 00:19:18,720
after our separator as well. So we're searching for three digits, and then any character. And then

203
00:19:18,720 --> 00:19:24,800
here at the end, we want to match four digits. So instead of writing out the same characters over

204
00:19:24,800 --> 00:19:31,040
and over, we can see how these quantifiers allow us to specify exactly how much we want. Now here

205
00:19:31,040 --> 00:19:36,480
we're matching exact numbers. But sometimes we don't know the exact number. And we'll need to use one

206
00:19:36,480 --> 00:19:42,560
of these other quantifiers. So for example, here at the bottom of this test file here, we have some

207
00:19:42,560 --> 00:19:49,680
lines where each starts with a prefix of mister, or miss, or misses. So let's say that we wanted to

208
00:19:49,760 --> 00:19:57,280
match these prefixes, as well as the names after. So just to start, let's start by matching the names

209
00:19:57,280 --> 00:20:04,000
that start with mister. Now we can see that some of these have a period after the prefix, and some

210
00:20:04,000 --> 00:20:11,440
do not. Some of them just have a space. So let's start our regular expression by searching for

211
00:20:11,440 --> 00:20:16,560
lines that start with mister. And then we're going to put a backslash period to search for that

212
00:20:17,440 --> 00:20:23,840
literal period. And right now it isn't matching this mister Smith, which doesn't have a period

213
00:20:23,840 --> 00:20:31,280
after the prefix. Now to match that also, we can use this question mark quantifier, which tells our

214
00:20:31,280 --> 00:20:38,000
pattern that we want to match zero or one of that character. So if I put a question mark after that

215
00:20:38,000 --> 00:20:44,480
literal period, then it's saying that there can be zero periods there, or there can be one. So we

216
00:20:44,480 --> 00:20:49,680
can see that now it's matching the ones with one period there, and it's also matching the one with

217
00:20:49,680 --> 00:20:58,160
no period. So now to continue and match the entire line. Now we want to match a space after that.

218
00:20:58,160 --> 00:21:04,960
And after the space, we want to match any uppercase letter. And to do that, we can use

219
00:21:04,960 --> 00:21:10,880
our character class, and we can match any uppercase letter by doing a range of uppercase letters

220
00:21:10,880 --> 00:21:16,400
there. So at this point, after that first uppercase letter that we match, we've completely matched the

221
00:21:16,400 --> 00:21:22,160
name for Mr. T down here at the bottom. But we still need to match the rest of our other names.

222
00:21:22,160 --> 00:21:29,600
So we could say that we will match any word character after that uppercase. So let's put in

223
00:21:29,600 --> 00:21:34,480
a backslash w to match any word character. And now we don't know how many more characters are

224
00:21:34,480 --> 00:21:40,240
going to be in our name. So we'll have to use a quantifier here. Now if we look over here,

225
00:21:40,240 --> 00:21:45,760
we could use the asterisk or the plus sign. And the plus sign will match one or more of

226
00:21:45,760 --> 00:21:52,400
these word characters. And the asterisk will match zero or more. So if we used the plus sign,

227
00:21:52,400 --> 00:21:59,040
then we can see that it matches our two top names here. But now it's not matching this Mr. T because

228
00:21:59,040 --> 00:22:04,880
after our word character, it's searching for one or more word characters after our uppercase

229
00:22:04,880 --> 00:22:10,800
character. So a better solution in this case, maybe to use the asterisk, which matches zero or

230
00:22:10,800 --> 00:22:17,120
more word characters. And if we use that asterisk, then we can see that it matches all three of our

231
00:22:17,120 --> 00:22:22,320
names that begin with Mr. Now I know that we've covered a lot so far, but we've got a couple

232
00:22:22,320 --> 00:22:27,200
of more concepts to go. And then we'll look at some examples that wrap everything together.

233
00:22:27,200 --> 00:22:34,160
So we still haven't matched our miss or misses names here. So how would we do that? So you might

234
00:22:34,160 --> 00:22:41,280
think that we could use a character set that matches either an r or an s. And there are maybe

235
00:22:41,280 --> 00:22:46,400
some ways that we could get that to work. But it probably would be a bit ugly, since we'd have to

236
00:22:46,400 --> 00:22:53,360
match either an r or an s as the second character and then the optional s after that. So that could

237
00:22:53,360 --> 00:22:58,160
get kind of ugly. But I think a better solution here would be to use a group. Now we haven't looked

238
00:22:58,240 --> 00:23:04,480
at groups yet. But groups allow us to match several different patterns. And to create a group, we use

239
00:23:04,480 --> 00:23:11,840
parentheses. So after the m here, instead of just searching for Mr, I'm going to create a group

240
00:23:11,840 --> 00:23:18,560
with open and closed parentheses here. And now within our group, we can specify different

241
00:23:18,560 --> 00:23:24,960
matches. So I can say that we want to match either an r and then or and we use this character here

242
00:23:24,960 --> 00:23:31,360
to specify an or. And that is just the vertical bar character to specify an or. So we can say that

243
00:23:31,360 --> 00:23:37,840
we want to match an r or an s. And whenever we add that in, we can see that now we're matching the

244
00:23:37,840 --> 00:23:44,640
miss name here. But we're still not matching this misses. So to match the misses, we can put in

245
00:23:44,640 --> 00:23:50,560
another or and say that we want to match an RS. Okay, so now we can see that we are matching

246
00:23:50,560 --> 00:23:54,960
all of our names here. So let's do a quick walkthrough of this one more time to make sure

247
00:23:54,960 --> 00:24:01,680
we know what's going on. So we have a capital M to start. And then that capital M is followed by

248
00:24:01,680 --> 00:24:11,520
either an r and s or an RS. And then we are looking for a literal period. And this question mark says

249
00:24:11,520 --> 00:24:17,040
that we can have zero or one of those. So that is optional. So it's matching the ones that do have

250
00:24:17,040 --> 00:24:22,800
that period and the ones that don't. And then after that, we are matching a space. Then after

251
00:24:22,800 --> 00:24:28,720
that space, we the first letter of the last name, we're looking for any capital letter. So we have

252
00:24:28,720 --> 00:24:34,800
a character set here that is a through Z of capital letters. And then for the rest of the last name,

253
00:24:34,800 --> 00:24:41,920
we are matching zero or more word characters. Now these groups can actually be used to capture

254
00:24:41,920 --> 00:24:46,320
sections of your matched regular expression. And that's something that we'll look at in just a

255
00:24:46,320 --> 00:24:51,600
minute. But for now, let's do a quick recap of everything that we've learned so far. And look

256
00:24:51,600 --> 00:24:56,720
at some examples that incorporates all of these things together. So I have a file here and I'm

257
00:24:56,720 --> 00:25:03,840
going to move my snippets back into the group here and open up this file emails.txt. So I've got a

258
00:25:03,840 --> 00:25:08,560
file here with three fairly different email addresses. So let's try to write a regular

259
00:25:08,560 --> 00:25:14,640
expression that will match all of these emails. So let's just match the first email address first

260
00:25:14,640 --> 00:25:20,240
and see what that looks like. So the first email address, we have a mix of upper and lowercase

261
00:25:20,240 --> 00:25:26,960
letters here before we hit this at symbol. So let's go ahead and match those first. So to match

262
00:25:26,960 --> 00:25:33,520
any upper or lowercase letters, we can do a character set. And we can do a lowercase a through

263
00:25:33,520 --> 00:25:40,000
Z or an uppercase a through uppercase Z. Now right now, this is only matching those single

264
00:25:40,000 --> 00:25:46,720
characters. So we can use the plus quantifier to say that we want one or more of these upper or

265
00:25:46,720 --> 00:25:51,760
lowercase letters. So we're still working on the first email address here, we have our upper and

266
00:25:51,760 --> 00:25:56,560
lowercase letters here. And now we want to match that at symbol. So I'll just put in a literal

267
00:25:56,560 --> 00:26:03,120
at symbol. And now for the domain name here, I'll just do a another search for any upper or lowercase

268
00:26:03,120 --> 00:26:09,920
letters. So I'll do the same as we did before. And then I will do a plus sign for a quantifier to

269
00:26:09,920 --> 00:26:16,000
match any upper lowercase letters after that at symbol. And then that's when we hit the end with

270
00:26:16,000 --> 00:26:22,640
the dot com. So to match the dot com, we can do a backslash period for the dot. And then we can

271
00:26:22,640 --> 00:26:28,320
just fill in a literal com. So now we've successfully matched that first address. Now it looks like

272
00:26:28,320 --> 00:26:34,240
it's not matching the second address. So let's see why and see if we can mold this to match the

273
00:26:34,240 --> 00:26:40,240
second address as well. So we can see that the second address has a dot in the first part of

274
00:26:40,240 --> 00:26:47,680
the name here. So let's add a dot to our first character set, so that dots are included in

275
00:26:47,680 --> 00:26:54,080
that character set. So now it's still not matching that second address. And it's because at the end

276
00:26:54,080 --> 00:27:01,200
here, we don't have a dot com but a dot edu. So in order to search for both, we can use a group

277
00:27:01,200 --> 00:27:09,360
like we saw before using open and close parentheses. And we can search for either com or edu. Okay, so

278
00:27:09,360 --> 00:27:14,640
now we are building this up a little bit at a time. And we can see that we are now matching our

279
00:27:14,640 --> 00:27:19,680
second email address. Okay, so now let's see if we can change this to match our third email address

280
00:27:19,680 --> 00:27:27,440
here. So in our third email address, it looks like before the at symbol, we also have some hyphens

281
00:27:27,440 --> 00:27:33,280
and some numbers in the first part here. So let's add those to the character set as well.

282
00:27:33,280 --> 00:27:41,520
So back here after our capital letters, I'm also going to add in digits by doing zero through nine.

283
00:27:41,520 --> 00:27:48,800
And we also want to add a dash in there as well. So that should match everything before the at symbol.

284
00:27:48,800 --> 00:27:54,400
Now it looks like we also have a dash in our domain here. So we'll have to add that in as well.

285
00:27:54,400 --> 00:28:00,400
So after the at symbol, we're matching any characters right now, it's just lowercase and uppercase,

286
00:28:00,400 --> 00:28:06,560
but we can put a dash in there as well. And lastly, it's still not matching because just like the

287
00:28:06,560 --> 00:28:13,600
other two instead, we have a dot net here instead. So we can just add in a second or at the end and

288
00:28:13,600 --> 00:28:19,760
also include dot net. So we can see that we built that up a little bit at a time to match all three

289
00:28:19,760 --> 00:28:24,720
of our email addresses. Now with something like email addresses, it can be pretty tough writing

290
00:28:24,720 --> 00:28:29,920
your own regular expressions from scratch. But there are a lot of these available online. And

291
00:28:29,920 --> 00:28:34,960
once we learn how to write regular expressions, then we should be able to read them and figure out

292
00:28:34,960 --> 00:28:40,320
how they're matching as well. Now, I've always found that reading other people's regular expressions

293
00:28:40,320 --> 00:28:45,680
to be a lot harder than writing them. But let's take a look at one and see if we can do this.

294
00:28:45,680 --> 00:28:51,680
So I have an expression here that I pulled offline that matches email addresses. And let's

295
00:28:51,680 --> 00:28:57,520
paste this in here and see if we can read through and see what this is matching. So we can see that

296
00:28:57,520 --> 00:29:02,880
the one that I got offline does match all three of my email addresses here. Now let's look through

297
00:29:02,880 --> 00:29:08,640
this. So we can see that it's somewhat similar to what we had before. But first we have a character

298
00:29:08,640 --> 00:29:16,400
set here and it's a pretty large character set. And it matches lowercase, uppercase, any number,

299
00:29:17,120 --> 00:29:24,240
an underscore, a period, a plus sign, or a hyphen. And then the plus sign here says that we want to

300
00:29:24,240 --> 00:29:30,000
match one or more of any of those characters. And we match one or more of those characters

301
00:29:30,000 --> 00:29:35,680
all the way up until we hit an at sign. And then after the at sign, we have another character set

302
00:29:35,680 --> 00:29:43,120
here. And in this character set, we have lowercase letters, uppercase letters, any digits, and also

303
00:29:43,120 --> 00:29:48,720
a hyphen. Now I don't know a lot about email addresses, but I'm assuming that since they left out the

304
00:29:48,720 --> 00:29:53,920
underscore, the period, and the plus sign that were in the first part of the email address,

305
00:29:53,920 --> 00:29:58,560
I'm assuming that those aren't allowed in the domain. So then we have a plus sign after that

306
00:29:58,560 --> 00:30:03,680
character set, which means that we're matching one or more of any of those characters all the way

307
00:30:03,680 --> 00:30:10,240
up until we reach this literal dot. And that literal dot is escaped with a backslash. And then

308
00:30:10,240 --> 00:30:15,760
after the dot, we have another character set here. And this character set is any lowercase letter,

309
00:30:15,760 --> 00:30:23,280
any uppercase letter, any digits, any hyphen, or a period. And then that is followed by a plus sign,

310
00:30:23,280 --> 00:30:28,320
which matches one or more of anything in that character set. So just like I did with the phone

311
00:30:28,320 --> 00:30:34,080
numbers, if we open up our data file here, with this regular expression that we've typed in,

312
00:30:34,080 --> 00:30:40,400
then we can see that it does match all of the email addresses in this data file as well. So we've

313
00:30:41,200 --> 00:30:46,480
got an expression that will match email addresses fairly well. So doing what we just did and reading

314
00:30:46,480 --> 00:30:51,920
through a regular expression written by other people is probably the hardest part of all this.

315
00:30:51,920 --> 00:30:57,120
But if you walk through it bit by bit, then you should be able to break down just about any pattern.

316
00:30:57,120 --> 00:31:01,920
Okay, so the last thing that I'd like to look at in this video is how to capture information

317
00:31:01,920 --> 00:31:08,080
from groups. Now, we've already seen how to match groups, but we can actually use the information

318
00:31:08,080 --> 00:31:13,760
captured from those groups. So to show an example of this, I'm going to open up a file here with

319
00:31:13,760 --> 00:31:22,640
some URLs. Okay, so we can see here that some of the URLs are HTTP, some are HTTPS. Also, some of

320
00:31:22,640 --> 00:31:28,960
these have WWW before the domain name, and some do not. So let's say that you had a list of a lot

321
00:31:28,960 --> 00:31:35,200
of different URLs within your document, and you only wanted to grab the domain name and the top

322
00:31:35,200 --> 00:31:41,200
level domain, which is .com or .gov. So for example, out of all these domains, you only wanted to grab

323
00:31:41,200 --> 00:31:48,800
google.com or coreyms.com or youtube.com or nasa.gov. And you just wanted to ignore everything else.

324
00:31:48,800 --> 00:31:54,080
So let's see how we can do this. So first, let's write an expression that actually matches these

325
00:31:54,080 --> 00:32:01,840
URLs. So let me get rid of the one that we currently have. Now, first, to match this, we can say

326
00:32:01,840 --> 00:32:09,360
all of these start with with HTTP. And then the s is optional. So we can say s and then put in a

327
00:32:09,360 --> 00:32:15,520
question mark to say that we want to match zero or one for the s. And then after that optional s,

328
00:32:15,520 --> 00:32:20,960
we want a colon forward slash forward slash. So at this point, some of these domains have a

329
00:32:20,960 --> 00:32:30,240
WWW dot before the domain name and some do not. So that WWW dot is optional. So since this isn't

330
00:32:30,240 --> 00:32:38,160
one character, we're actually going to create a group here and say this group of WWW and then a

331
00:32:38,160 --> 00:32:44,560
literal dot, which is a backslash dot. Now, all of that group is optional. So now you can see on

332
00:32:44,560 --> 00:32:49,920
all of our URLs, we've matched up to the domain name. So now to complete this, I'm just going to say

333
00:32:50,720 --> 00:32:58,640
any word character, so backslash w, and I will put in a plus sign to say one or more of those word

334
00:32:58,640 --> 00:33:04,960
characters. And then we get here to the top level domain. So we want to match a literal dot. So we'll

335
00:33:04,960 --> 00:33:10,400
do a backslash dot. And then for the rest of that top level domain, I will just do any word

336
00:33:10,400 --> 00:33:16,960
character one or more times so we can do a word character with a plus sign to do one or more.

337
00:33:16,960 --> 00:33:23,600
Okay, so we can see that this matches all of our URLs. But the point here was to use our groups

338
00:33:23,600 --> 00:33:30,640
to capture some information from our URLs. So let's capture the domain name and the top level

339
00:33:30,640 --> 00:33:36,560
domain, which is the dot com or the dot gov and things like that. So to capture these sections,

340
00:33:36,640 --> 00:33:43,440
we can just put them in a group by surrounding them in parentheses. So what we want to group here

341
00:33:43,440 --> 00:33:50,400
is our domain name. And the domain name is this part right here, this string of one or more word

342
00:33:50,400 --> 00:33:55,360
characters. So I'm just going to wrap those in parentheses and create a group. And we've seen

343
00:33:55,360 --> 00:34:00,400
that before. And now we also want to put the top level domain in a group as well. That is the dot

344
00:34:00,720 --> 00:34:07,920
com or the dot gov. So we can put a parentheses around that dot, and then also around the ending

345
00:34:07,920 --> 00:34:12,400
there that is the string of one or more word characters. Okay, so we can see that we're

346
00:34:12,400 --> 00:34:17,840
still matching all of our URLs here. But now we have three different groups. So our first group

347
00:34:17,840 --> 00:34:25,120
is just that optional www dot. Our second group is the word characters that make up our domain name.

348
00:34:25,120 --> 00:34:31,200
And the third group is that top level domain. Now there's also an implicit group zero. And

349
00:34:31,200 --> 00:34:37,920
group zero is everything that we captured. So in this case, it's the entire URL. So now let's get

350
00:34:37,920 --> 00:34:42,560
to the cool part about this. So let me show you what we can do now that we've captured these.

351
00:34:42,560 --> 00:34:48,560
So we can use something called a back reference to reference our captured group. So for example,

352
00:34:48,560 --> 00:34:54,720
here in Adam, we have the ability to replace our matches, we can see down here that we can replace.

353
00:34:54,720 --> 00:35:02,320
So let's replace all of our matches with just the literal text group one, and then a colon,

354
00:35:02,320 --> 00:35:09,280
and then a dollar sign one. Now this dollar sign one is a reference to our first group. Now sometimes

355
00:35:09,280 --> 00:35:16,080
this is a backslash. But for some reason in Adam, they use a dollar sign. So if I do a replace all

356
00:35:16,080 --> 00:35:22,800
here, then we can see that it replaced our matches with this literal text group one. But then it

357
00:35:22,800 --> 00:35:28,880
also replaced the dollar sign one with our first captured group. And the first capture group is that

358
00:35:28,880 --> 00:35:36,080
optional www dot. So for the ones for the domains that had that www, we can see that it shows up.

359
00:35:36,080 --> 00:35:42,320
And for ones that didn't, it doesn't have anything. So let me undo this. And now let's replace our

360
00:35:42,320 --> 00:35:48,720
matches with the second group. And now the second group should be the domain name. So now if I do

361
00:35:48,720 --> 00:35:55,680
a replace all now, then we can see that now it says group two is Google, CoreMS, YouTube,

362
00:35:55,680 --> 00:36:02,960
and NASA. And if I undo that, and replace this with the group three, then the group three should

363
00:36:02,960 --> 00:36:09,200
give us our top level domain. So our group three is the dot com dot com dot gov things like that.

364
00:36:09,200 --> 00:36:13,760
So let me undo this one more time. So now that we know how to use those back references,

365
00:36:13,760 --> 00:36:19,520
then we can actually take our regular URLs and clean them up like we meant to from before.

366
00:36:20,320 --> 00:36:27,680
So we could convert these to a cleaned up version without the HTTP or the www just by replacing

367
00:36:27,680 --> 00:36:34,400
our matches with the domain name, which is group two, followed by the top level domain,

368
00:36:34,400 --> 00:36:39,840
which is group three. So now if I replace all of our selections with those two,

369
00:36:39,840 --> 00:36:44,880
then we can see that replaced all of our URLs with just the domain name and the top level domain.

370
00:36:44,880 --> 00:36:49,760
So you can imagine if you had a lot of information like this that you needed to clean up or modify

371
00:36:49,760 --> 00:36:54,800
in some way, then knowing how to match these groups with regular expressions could save you

372
00:36:54,800 --> 00:36:59,120
a ton of time with doing things like this. Okay, so I think that's going to do it for this video.

373
00:36:59,120 --> 00:37:03,360
Now there's a lot of advanced features that we could go over with regular expressions as well.

374
00:37:03,360 --> 00:37:07,920
So if anyone is interested in learning more, then I could put together an advanced video

375
00:37:07,920 --> 00:37:12,400
covering those topics in the near future. But hopefully now you feel comfortable with being

376
00:37:12,400 --> 00:37:17,280
able to read and write these regular expressions that we went over in this video. But if anyone

377
00:37:17,280 --> 00:37:21,360
does have any questions about what we covered in this video, then feel free to ask in the comment

378
00:37:21,360 --> 00:37:25,520
section below and I'll do my best to answer those. And if you enjoy these tutorials and would like to

379
00:37:25,520 --> 00:37:29,600
support them, then there are several ways you can do that. The easiest ways to simply like the video

380
00:37:29,600 --> 00:37:33,440
and give it a thumbs up. And also it's a huge help to share these videos with anyone who you think

381
00:37:33,440 --> 00:37:37,280
would find them useful. And if you have the means you can contribute your Patreon and there's a link

382
00:37:37,280 --> 00:37:41,280
to that page in the description section below. Be sure to subscribe for future videos and thank

383
00:37:41,280 --> 00:37:45,280
you all for watching.

