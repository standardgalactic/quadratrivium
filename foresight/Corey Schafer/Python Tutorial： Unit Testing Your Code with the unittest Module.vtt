WEBVTT

00:00.000 --> 00:03.600
Hey there, how's it going everybody? In this video, we're going to learn about unit testing in

00:03.600 --> 00:08.160
Python. So we'll go over how to write tests, how to set up and tear down your tests, and also

00:08.160 --> 00:12.160
some best practices. So if you're not currently testing your code, then it's definitely something

00:12.160 --> 00:16.080
that you're going to want to learn and start adding to your projects. So a lot of you have

00:16.080 --> 00:20.960
probably heard of testing, but you might not know exactly what it is. Testing your code is the most

00:20.960 --> 00:25.200
exciting thing to do. But there's a reason that most companies and teams require their code to be

00:25.200 --> 00:29.520
thoroughly tested. And if you're going to get a job working on any large projects, then you're going

00:29.520 --> 00:33.600
to need to know how to properly write tests. And the reason for that is that it's going to save you

00:33.600 --> 00:38.400
a lot of time and headache down the road. So when you write good tests for your code, it gives you

00:38.400 --> 00:42.960
more confidence that your updates and refactoring don't have any unintended consequences or break

00:42.960 --> 00:48.160
your code in any way. So for example, if you update a function in your project, those changes may

00:48.160 --> 00:53.200
have actually broken several sections of your code, even if that function itself is still working.

00:53.200 --> 00:58.000
And good unit tests will make sure that everything is still working as it should. And if it's not,

00:58.000 --> 01:02.240
then it'll show you exactly what's broken. So in this video, we're going to be going over everything

01:02.240 --> 01:06.560
that you need to know to get started with the built in unit testing module. So with that said,

01:06.560 --> 01:10.800
let's go ahead and get started. So right now I have a basic script pulled up here that has some

01:10.800 --> 01:15.040
simple functions. And I want to start off using these really simple functions so that we can just

01:15.040 --> 01:21.040
focus on what the tests look like. Now, what a lot of us start doing to test our code is just put

01:21.040 --> 01:25.680
in print statements and occasionally run the code. So for example, down here at the bottom,

01:25.760 --> 01:32.000
if I wanted to test that my add function was working, I could just say print add and add together

01:32.000 --> 01:37.840
10 and five. And if I run that, then we can see that the output that we got looks right. But

01:37.840 --> 01:43.440
testing your code this way isn't easy to automate. And it's also hard to maintain. So also if we're

01:43.440 --> 01:48.640
testing a lot of different functions, then there's no way for us to see at a glance what failed and

01:48.640 --> 01:54.240
what succeeded. So that's where unit testing comes in. So we're going to go ahead and just remove

01:54.240 --> 01:59.440
this print statement and actually start adding some unit tests. So to do this, first we need to

01:59.440 --> 02:05.280
create a test module. So I'm going to create a new file here in this current directory. And I'm going

02:05.280 --> 02:12.400
to call this test underscore calc dot py. Now that's the naming convention when writing tests is to

02:12.400 --> 02:18.240
start with test underscore, and then what you're testing. So in this case, it was test underscore

02:18.240 --> 02:23.920
calc. And that's actually going to be required within our tests. So now we have this test

02:23.920 --> 02:28.960
underscore calc module pulled up. And we're currently working with an empty file. So first

02:28.960 --> 02:34.080
let's import the unit test module. Now this module was in the standard library. So there's no need

02:34.080 --> 02:39.680
to install anything. You can just say import unit tests. And now we're also going to want to import

02:39.680 --> 02:45.440
the module that we want to test. So I'm going to import that calc module. And we can import calc

02:45.440 --> 02:49.600
from here since it's in the same directory. Now if you're testing code from a different directory

02:49.600 --> 02:54.080
and can't get your imports to work, then you can watch my video on importing modules. And it

02:54.080 --> 02:59.120
should help you figure out how to properly get that set up. So now we need to create some test

02:59.120 --> 03:04.240
cases for the functions that we want to test. And in order to create those test cases, we first need

03:04.240 --> 03:10.560
to create a test class that inherits from unit test dot test case. So to do this, we're first going

03:10.560 --> 03:17.920
to create a class. And we will call this test calc. Now you can call that class whatever you like,

03:17.920 --> 03:22.720
but try to keep it descriptive as to what you're testing. And we're going to want to inherit

03:22.720 --> 03:31.680
from unit test dot test case. So inheriting from unit test dot test case is going to give us access

03:31.680 --> 03:38.080
to a lot of different testing capabilities within that class. So let's write our first test. So

03:38.080 --> 03:45.280
to do this, we'll write a method. And the method needs to start with test underscore. Now that

03:45.280 --> 03:50.080
naming convention is actually required so that when we run this, it actually knows which methods

03:50.080 --> 03:55.440
represent tests. So if the method doesn't start with the word test, then they won't be run. And

03:55.440 --> 04:00.480
we'll see what that looks like in just a minute. So ours will be test underscore, and then what

04:00.480 --> 04:06.720
we're testing. So first, we'll just test the add function of our calc module. So we'll call this

04:06.720 --> 04:13.200
test underscore add. And just like any method in a class, this takes self as the first argument.

04:13.280 --> 04:19.200
And now within our method, we can write our test. So since we inherited from unit test test case,

04:19.200 --> 04:24.640
we have have access to all these assert methods. And I have them all pulled up in the documentation

04:24.640 --> 04:30.320
here over in Chrome. So we can see that we can assert whether two values are equal with assert

04:30.320 --> 04:37.040
equals, not equal with assert not equal, assert true, assert false. And the documentation shows

04:37.040 --> 04:44.560
you exactly what all of these check for. So for example, assert is not none checks whether a

04:44.560 --> 04:50.000
variable is not none. So the documentation has a good overview of all these asserts. And then over

04:50.000 --> 04:55.280
here, what it actually checks for. And I'll also leave a link to this in the description section

04:55.280 --> 05:01.440
below. So now let's switch back to writing our test. So we're going to use assert equals to test

05:01.440 --> 05:08.880
our add function. So I can run our add function from here by saying something like result is

05:08.880 --> 05:15.120
equal to calc dot add. And we'll just add those same values 10 and five. And we would expect this

05:15.120 --> 05:22.880
to equal 15. So to test this, we can say self dot assert equals. And now we want to assert that

05:22.880 --> 05:29.760
that result is equal to 15. Okay, so now how do we run this test? So we could do it from the command

05:29.840 --> 05:35.760
line. So I have my command line here pulled up and I am navigated to the directory where our

05:35.760 --> 05:42.000
module is currently located. Now you might think that we could just run the test by saying, you

05:42.000 --> 05:47.680
know, Python test underscore calc dot pi. But if I run that you can see it doesn't actually return

05:47.680 --> 05:55.040
anything. So instead, we need to run unit test as our main module and pass in test underscore calc.

05:55.040 --> 06:04.480
And we can do that by saying Python dash m and then unit test. And now the test underscore calc

06:04.480 --> 06:12.480
dot pi module. And we can see that when we run that it puts a dot here. And it says one ran one

06:12.480 --> 06:17.680
test. And at the bottom, it says okay, so that means that everything passed. Now it would be

06:17.680 --> 06:24.720
nice if we could just run our tests using this first method here by saying Python test underscore

06:24.720 --> 06:29.840
calc and just running the module instead of using this longer command here and setting it up to run

06:29.840 --> 06:35.680
that way would also allow us to run our tests from directly within our editor. So to do this,

06:35.680 --> 06:42.880
we can just come down here to the bottom and we can say if name double underscore name is equal to

06:43.280 --> 06:49.840
in quotes here, double underscore main, and then within this conditional, we can just say

06:50.400 --> 06:57.520
unit test dot main and run that. Now if you don't know what this double underscore name equals

06:57.520 --> 07:03.760
double underscore main is doing, this actually isn't related to unit testing at all. I do have a

07:03.760 --> 07:08.560
separate video specifically what that is about. But basically, it's just saying that if we run

07:08.560 --> 07:14.160
this module directly, then run the code within the conditional. And that code within our conditional

07:14.160 --> 07:20.720
is this unit test dot main, and that unit test dot main will run all of our tests. So now if we go

07:20.720 --> 07:26.960
back here, this is now saved, if we go back here to our terminal, and I will clear this out. So now

07:26.960 --> 07:32.640
let's rerun that using that first method of just Python and our test module. And if we run that,

07:32.640 --> 07:37.760
you can see that now we can run it directly. And it runs our unit tests and says that it passed.

07:37.760 --> 07:43.120
And since we can run it this way within the terminal, that should mean that it can also run

07:43.120 --> 07:48.640
within our editor. So if I run this, then you can see that within our editor, we can now run

07:48.640 --> 07:53.520
these tests also. Okay, so that's good. So we're running our first test. So it's saying that we're

07:53.520 --> 07:58.400
only running one test. Now, do you remember earlier when I said that your tests have to start with

07:58.400 --> 08:04.960
the word test? Well, let me show you what it does if it doesn't. So instead of test underscore add

08:04.960 --> 08:11.360
here as our test, let's call this add underscore test and save this and run it. So when we run this,

08:11.360 --> 08:15.840
it might not be obvious right off the bat that anything is wrong because we didn't get any errors

08:15.840 --> 08:22.160
or any warnings. But if we look at how many tests ran, it says zero. So this test was just skipped.

08:22.160 --> 08:26.880
So you have to be careful that all of your tests are named properly and start with the word test.

08:26.880 --> 08:32.800
So let's go ahead and change that back and rerun it. Okay, so now what happens if our test fails?

08:32.800 --> 08:38.720
So let's change this value here with the assert equals, the result is equal to 15,

08:38.720 --> 08:45.280
let's change this to a 14, so that our test of adding 10 and five fails. So let's save that and

08:45.280 --> 08:53.200
run it. So now if I pull this up a little bit here to where we can see, we can see that instead of a

08:53.200 --> 08:59.440
dot, we got an F for fail. And it also shows us that the test failed with an assertion error

08:59.440 --> 09:05.200
that 15 is not equal to 14. Okay, so now let me pull this down just a little further here.

09:05.200 --> 09:12.000
And now let's change this test back and also add in a few more tests. So first of all, instead of

09:12.000 --> 09:17.680
setting this result variable and testing that, I'm just going to instead drop our function directly

09:17.680 --> 09:23.840
into the assert statement. So I'm going to copy this and replace that result variable actually

09:23.840 --> 09:30.160
with our add function. And then I can just get rid of that result variable there. So you usually

09:30.160 --> 09:36.160
want to also check some edge cases. So let's copy and paste this line here a couple of times

09:36.160 --> 09:41.760
and test a couple of edge cases. So one edge case might be one negative number and one positive

09:41.760 --> 09:49.760
number. So let's make sure that negative one plus one is equal to zero. And two negative numbers

09:49.760 --> 09:56.800
would also be another edge case. So let's make sure that negative one plus negative one is equal

09:56.800 --> 10:02.800
to negative two. So now if we save this and run it, then it's saying that it passed, but it also

10:02.800 --> 10:08.000
says that it ran one test. Now you may have been expecting this to say that it ran three tests.

10:08.000 --> 10:14.640
But really, these three assert methods here are just within this single test called test underscore

10:14.720 --> 10:20.320
add. But even though it still says that there's only one test, we still made this test better

10:20.320 --> 10:26.240
by adding in these additional checks. So it's not our goal to write as many tests as possible,

10:26.240 --> 10:30.320
but just make sure that we write good tests. So that's something that a lot of people get

10:30.320 --> 10:35.760
tripped up on. They just shoot for, you know, full coverage without making sure their tests are

10:35.760 --> 10:40.480
actually good enough to catch mistakes. So try to be mindful of that when writing tests. And in

10:40.480 --> 10:46.240
order to add more tests, we just add in more test methods. So let's test the rest of our calc

10:46.240 --> 10:54.400
functions. So I will just copy and paste this test add function here three more times. And I'm

10:54.400 --> 10:59.520
going to get rid of our output here so we can see a little bit better. And now I'll change these to

10:59.520 --> 11:06.240
test all of our calc functions. So I'll test our subtraction function by changing all of these ones

11:06.320 --> 11:13.440
here to subtract. And now let's change our assert equals. So 10 minus five will be five,

11:13.440 --> 11:21.280
negative one minus one will be negative two, and negative one minus negative one should be zero.

11:21.280 --> 11:27.600
And now moving down the line here, let's change this next test to be multiply. So now for our

11:27.600 --> 11:35.520
assert equals, we want to test that 10 multiplied by five is 50, negative one multiplied by one

11:35.520 --> 11:40.720
is negative one, negative one multiplied by negative one is one. And then let's change

11:40.720 --> 11:47.360
this last method here to test our divide function. So we want to test divide. So now in our assert

11:47.360 --> 11:52.800
statements here, we want to make sure that 10 divided by five is equal to two, negative one

11:52.800 --> 11:59.680
divided by one is negative one, and negative one divided by negative one will just be one.

11:59.680 --> 12:05.120
So now if I run this code with all four of these tests, then you can see that we got four dots,

12:05.120 --> 12:10.080
and it says that we ran four tests. And all of those tests pass with all of those assert

12:10.080 --> 12:15.680
equal statements. So you can imagine how useful this is. So if you have a module with some complicated

12:15.680 --> 12:20.480
functions, then once you put in the work to write good tests like this, then you can just come back

12:20.480 --> 12:25.280
and rerun these tests to make sure that everything still works. So if you change something in your

12:25.280 --> 12:29.840
program that you think will work, but it actually broke some stuff, then your test should catch

12:29.840 --> 12:36.960
that. So for example, let's say that I came in here to our calc function, and we just made a typo

12:36.960 --> 12:42.080
in this multiply function. And instead of one asterisk there, we put two. Now this is actually

12:42.080 --> 12:48.080
going to return x to the power of y. So if we come back here to our tests and rerun this,

12:48.080 --> 12:54.160
then we can see that if we look here at our output, that we have two dots, and then an f,

12:54.160 --> 12:59.440
and then a dot. So that means that three of our tests pass and one test failed. And the one that

12:59.440 --> 13:06.320
failed, it says that we have an assertion error that the 10 times five should actually be equal to

13:06.320 --> 13:12.000
50. And it's not instead we got this value here. So that gives us an idea of exactly where the problem

13:12.000 --> 13:17.040
is, and where we can make that change to get these tests to pass again. So let's go ahead and go back

13:17.040 --> 13:22.080
here and change this back. Now, sometimes you might make a change that doesn't actually break

13:22.080 --> 13:28.320
your test, but will actually unexpectedly break your code. So for example, let's say that we

13:28.320 --> 13:34.240
came in here and changed our divide function to be floor division instead of regular division.

13:34.240 --> 13:38.720
And we can do this by changing this to two division signs. Now if you don't know what floor

13:38.720 --> 13:44.240
division is, basically, it just doesn't give you the remainder. Now our current test won't catch

13:44.240 --> 13:50.960
this because right now all of our and let me save this here. So right now, all of our divisions

13:50.960 --> 13:55.360
currently come out to whole numbers anyway. So it doesn't matter if we're using floor division

13:55.360 --> 14:00.640
or regular division. So if we run our test, then we can see that currently all of these tests are

14:00.640 --> 14:05.600
passing. So let's say that at some point that floor division broke our program. And after some

14:05.600 --> 14:11.920
debugging, we traced it back to that and found the problem. Now in that case, it's always a good

14:12.000 --> 14:17.120
practice to go update your test with a test that would have caught the problem that you just found.

14:17.680 --> 14:23.040
That way, we can know that we don't revisit the same bugs over and over. So for example,

14:23.040 --> 14:29.760
a test that would have caught this, I'm going to copy and assert equals statement here. Now a test

14:29.760 --> 14:36.560
that would have caught this is if we would say, you know, five divided by two, we want that to

14:36.560 --> 14:42.720
actually equal 2.5. But with floor division, that's actually just going to equal two. So now

14:42.720 --> 14:47.600
if we run this, then we can see that we got our error because we're using that floor division.

14:47.600 --> 14:55.120
And we can see that it is an assertion error that two is not equal to 2.5. So that should point us

14:55.120 --> 14:59.600
in the right direction. And then we can go and see why that would be the case. And then we can find

14:59.600 --> 15:04.480
out that we're using floor division there instead of regular revision and fix that go back to our

15:04.480 --> 15:10.080
test and run it. And now they're all passing. Okay, so now there's one more thing within our

15:10.080 --> 15:16.640
calc.py file here that we can see. We can see here that we are checking if the number that we're

15:16.640 --> 15:24.160
dividing by is zero. And if so, then we're raising a value error with the message that we can't divide

15:24.160 --> 15:30.480
by zero. So we'll likely want to test that our expectations are working on that as well. So,

15:31.200 --> 15:36.800
but this is done a little differently than the other assertions. So let's go back to our test

15:36.800 --> 15:42.720
and show how we can test that dividing by zero raises this correct error. So there's actually

15:42.720 --> 15:52.320
two ways that we can do this. So first we could say self dot assert raises. And within assert raises,

15:52.320 --> 16:00.000
first we want to pass in the exception that we expect and that is a value error. And now the

16:00.000 --> 16:05.760
function that we want to test, and that is calc divide, now we're not putting parentheses or any

16:05.760 --> 16:11.520
arguments there, we're putting the arguments as arguments to this assert raises method. So let's

16:11.520 --> 16:18.240
look at this one more time. So our first argument is the exception that we expect. The second argument

16:18.240 --> 16:23.760
is the function that we want to run, but we aren't passing arguments to the function. So leave off

16:23.760 --> 16:29.520
the parentheses. And then we pass in each argument that we want to pass into the divide function

16:29.520 --> 16:34.560
separately. So now the reason that we have to do it this way, instead of just running the function

16:34.560 --> 16:39.760
normally, is because our function would actually throw that value error. And our test will think

16:39.760 --> 16:45.440
that something failed. But we'll look at a way that we can do this right after this test. So

16:45.440 --> 16:50.560
right now, if we run this, then we can see that this is currently passing. And that's because the

16:50.560 --> 16:58.160
10 divided by zero did throw this value error. So if I was to change this zero to a two, then it's

16:58.160 --> 17:03.520
not going to throw that value error. So if I run that, then it failed. And we can see that the

17:03.520 --> 17:11.200
assertion error is that value error not raised by divide. So which makes sense if we divided by two.

17:11.200 --> 17:16.160
So if we divide by zero, that test passes. Now, I've never preferred this method of testing

17:16.160 --> 17:21.680
exceptions, because I just like to call the function that I want to test normally, instead

17:21.680 --> 17:27.520
of passing in all of the arguments separately, like we're doing here. And we can do this if we test

17:28.240 --> 17:35.520
the exceptions using a context manager. Now that will allow us to handle and check the exception

17:35.520 --> 17:41.600
properly. And also call our function normally. So to do this, I'm actually going to get rid

17:41.600 --> 17:49.200
of everything here. And to do this, we say with self dot assert raises value error. And that's

17:49.200 --> 17:55.440
using the context manager. And within this context manager, we can just call our function normally

17:55.440 --> 18:02.160
like we normally would. So calc divide, and we'll divide 10 by zero and save that and run it. Then

18:02.160 --> 18:07.280
you can see that by using this context manager, that all of those tests still pass. So you can

18:07.280 --> 18:12.160
choose either method that you prefer. But I've always preferred to use the context manager when

18:12.160 --> 18:19.520
testing exceptions. Okay, so now let's look at writing slightly more difficult tests. So I have

18:19.520 --> 18:25.040
a simple employee class here. And this is the employee class from the object oriented series.

18:25.040 --> 18:30.320
And if you don't know exactly what this class is doing, then it's not really important. We're just

18:30.320 --> 18:35.600
going to see how this affects some testing strategies. So basically what this code is doing

18:35.600 --> 18:42.240
is it allows us to create employee instances, where it will set the employee's first name,

18:42.240 --> 18:49.120
last name and pay. And then we have some methods that return the employee's email address, which

18:49.120 --> 18:55.360
is their first name and last name at email.com. Then we have a method that returns the employee's

18:55.360 --> 19:00.720
full name, which is just their first name and last name combined. And we also have a regular

19:00.720 --> 19:06.320
method here where we can apply a raise, and it will set their pay to the current pay times the

19:06.320 --> 19:13.920
raise amount, which by default is 5% up here. Now the way that this code is set up, if an employee's

19:13.920 --> 19:19.360
first name or last name changes, then that should automatically be reflected in the email and first

19:19.360 --> 19:23.920
name. Okay, so let's say that we wanted to write some tests for this. So first, what we would do is

19:23.920 --> 19:31.360
we would create a new file, and I'm going to call this test underscore employee dot pi. And to save

19:31.360 --> 19:36.880
time from you watching me type all of these tests, I'm instead going to grab them out of my snippets

19:36.880 --> 19:43.440
file here, and we'll explain exactly what we're testing. So I'm going to copy all of these down

19:43.440 --> 19:50.240
to this point, and paste these in here. Okay, so if we scroll up to the top here, then first we're

19:50.320 --> 19:56.800
importing unit test, and also importing our employee class from the employee module. And then we're

19:56.800 --> 20:04.160
creating our test case that inherits from unit test test case. And then we have three different

20:04.160 --> 20:11.040
tests here. So our first test is called test underscore email. And this creates two employees

20:11.040 --> 20:15.760
here. And when these employees are created, we should immediately be able to access the email

20:15.760 --> 20:21.520
property. So we test both of their emails to check if we're getting the expected values.

20:21.520 --> 20:28.560
And then we are changing their first names, and then checking the emails again here, because

20:28.560 --> 20:33.840
their email should change with when their name changes. So this test email is just testing to

20:33.840 --> 20:38.720
make sure that all that functionality is working properly. And then when we test the full name,

20:38.720 --> 20:44.000
it's basically the same thing, we're creating two employees, and then we're checking their full

20:44.000 --> 20:48.800
names to make sure they were created correctly. Then we're changing their first names. And then

20:48.800 --> 20:54.400
we are rechecking to make sure that the full names were changed as well. And lastly, we have a test

20:54.400 --> 21:00.960
for testing the apply raise function here. And again, we are creating two employees. And then we

21:00.960 --> 21:07.520
are applying arrays. And by default, that's 5%. So we just test to make sure that the pay was raised

21:07.520 --> 21:13.840
by 5%. So this is basically just a slightly more complicated test than our simple calculator test,

21:13.840 --> 21:18.800
but there isn't anything here that we haven't seen yet. So we just have three different tests

21:18.800 --> 21:25.680
and have some assert equals in here to make sure that things have the values that we expect. So

21:25.680 --> 21:31.360
if we run this, then we can see that all of those tests pass. Now, one thing that you might notice

21:31.360 --> 21:38.320
is that at the beginning of every one of these tests, we are creating two employees. Now anytime

21:38.320 --> 21:42.960
you see the same code over and over, that should be something that pops out to you that there might

21:42.960 --> 21:48.320
be a better way of doing this. Because usually programmers try to make their code dry, which

21:48.320 --> 21:53.360
stands for don't repeat yourself. Now the reason for that is because if anything ever changes with

21:53.360 --> 21:58.880
these two setup employees here, then we'll need to make changes to every single test where we

21:58.880 --> 22:04.320
created these employees. Now this might not be a big deal when we just have three tests like this.

22:04.320 --> 22:09.920
But if you have hundreds, then it could be a pain to maintain. So it would be nice if we could create

22:09.920 --> 22:16.480
these from scratch in one place and reuse them for every test. And there is a way to do that.

22:16.480 --> 22:23.280
So that's what the setup and tear down methods are for. So at the top of our test class here,

22:23.280 --> 22:30.480
let's create two new methods. And one of these is going to be called a setup and then self as

22:30.480 --> 22:35.760
the first argument. And for now, we'll just put in a past statement there. And the second method

22:35.760 --> 22:41.760
here will be tear down with self as the first argument and another past statement. Now these

22:41.760 --> 22:48.320
are camel case with the uppercase U and the uppercase D. So be sure that you type those correctly.

22:48.320 --> 22:53.920
Python usually doesn't do that. But I think this is carried over from some older code. So the setup

22:53.920 --> 22:59.920
method will run its code before every single test. And the tear down method will run its code

22:59.920 --> 23:06.480
after every single test. So for example, we wanted to create these two employees before

23:06.480 --> 23:12.160
every single test. So we can come down here and grab where we're creating these employees. And

23:12.160 --> 23:17.280
I'm just going to copy that and paste it here within the setup. Now in order to access these

23:17.280 --> 23:23.840
from within our other test, we're actually going to have to set these as instance attributes by

23:23.920 --> 23:30.880
putting self dot employee one and self dot employee two. Now if you don't understand how these

23:30.880 --> 23:37.280
instance attributes work, then I do have a video in my object oriented series where I go over

23:37.280 --> 23:42.800
exactly how those work. But now that we have these within our setup method, now we can delete the

23:42.800 --> 23:49.120
creation of these employees from the beginning of every test. So I'm going to go down and remove

23:49.120 --> 23:57.120
these from the beginning of all three of these tests. And now since those are instance attributes,

23:57.120 --> 24:02.960
everywhere that we reference employee one and employee two, we need to add self to the beginning.

24:02.960 --> 24:08.240
So I'm going to do this with the multi cursor functionality here within sublime text. But in

24:08.240 --> 24:14.800
your ID or editor, you could just use a simple find and replace. So I'm going to grab all of these

24:14.800 --> 24:23.680
employee ones here. And just add a self dot before that. And then I'll grab these employee

24:23.680 --> 24:31.280
twos here. And add a self dot before that. So now one more time, let's go ahead and just look

24:31.280 --> 24:36.400
at this one more time here. So within our setup, we're creating these two employees, and it's

24:36.400 --> 24:42.000
going to create these before every single test. So now here within our test, we're saying, okay,

24:42.000 --> 24:47.360
self dot assert equals, and make sure that this employee that we created up here in the setup

24:48.000 --> 24:53.920
is equal to this email. And this employee twos email is equal to this email. And we can reuse

24:53.920 --> 24:58.960
those same employees for every single one of these tests. And they get created a new for every

24:58.960 --> 25:03.920
single one of these tests. So let's go ahead and rerun this and make sure that this is still working.

25:03.920 --> 25:08.720
And it does look like all three of these tests are still passing. Now we're currently not using our

25:09.520 --> 25:14.560
tear down method for anything. But I still wanted to show you that it exists just in case

25:14.560 --> 25:19.360
you have a use case for it. So let's say, for example, that you had some functions that you

25:19.360 --> 25:25.360
wanted to test that added files to a directory or to a database, then in your setup method,

25:25.360 --> 25:30.320
you could create the test directory or the test database to hold those files. And in the tear

25:30.320 --> 25:35.360
down method, you could delete all of those so that you have a clean slate for the next test.

25:35.360 --> 25:40.560
Now, just to be more clear where all of this code is being run, let me grab some

25:40.560 --> 25:46.480
code here from my snippets that has print statements included throughout all of our tests.

25:46.480 --> 25:56.080
So I'm going to grab from here down and replace this employee test here. Now this code is exactly

25:56.080 --> 26:01.840
what we just had. But now we have print statements throughout our code. So we have a print statement

26:01.840 --> 26:09.840
in the setup and in the tear down and also within every single test case. So now if I go ahead and

26:09.840 --> 26:16.800
run this and scroll up here to the top, then we can see that we have the setup and then the test

26:16.800 --> 26:22.880
and then the tear down. And it does this for every single test set up the test and tear down set

26:22.880 --> 26:28.000
up test tear down. Now another thing to notice here is that the test don't necessarily run in

26:28.000 --> 26:33.280
order. So you should never assume that the test run straight down through the script. Now that's

26:33.280 --> 26:38.480
why we need to keep all of our tests isolated from one another. Now sometimes it's also useful to have

26:38.480 --> 26:44.880
some code run at the very beginning of the test file and then have some cleanup code that runs

26:44.880 --> 26:50.640
after all of the tests has have been run. So unlike the setup and tear down that runs before

26:50.640 --> 26:56.640
and after every single test, it would be nice if we had something that ran once before anything

26:56.640 --> 27:02.880
and then once after everything. Now we can do this with two class methods called setup class

27:02.880 --> 27:09.200
and tear down class. Now I have these in my snippets also. So let me grab these so we can see

27:09.200 --> 27:17.600
what these look like. And I'll paste these here at the top of our test. And let me fix the indentation

27:17.600 --> 27:22.800
there. Okay, so we can see that these are class methods. And if you don't know what that means,

27:22.800 --> 27:28.400
basically it means that we're working with the class rather than the instance of the class like

27:28.400 --> 27:34.080
we were with self. Now I have an object oriented video on this as well where I go into this concept

27:34.080 --> 27:38.560
more in depth. And I'll leave a link to that in the description section below. But once we have

27:38.560 --> 27:44.000
these class methods in place with these naming conventions of setup class and tear down class

27:44.000 --> 27:49.600
with that camel case, if we run this code, then if we scroll up here to the top, then we can see

27:49.600 --> 27:57.200
that it runs setup class first. And then the setups tests and tear downs for each test. And then at

27:57.200 --> 28:03.040
the very end here, it runs that tear down class. Now the print buffering is a little strange with

28:03.040 --> 28:09.760
that. So it ran after this line here. But it ran tear down class at the end of all those tests.

28:09.760 --> 28:15.120
Now this setup class and tear down class can be useful if you just want to do something once

28:15.120 --> 28:21.600
and is too costly to do before each test. So for example, maybe you want to populate a database

28:21.600 --> 28:26.880
to run test against now as long as you're just reading from the database, then it might be

28:26.880 --> 28:32.640
appropriate to just set this up once in the setup class method. And then you can tear it down in the

28:32.640 --> 28:37.920
tear down class method. Okay, now I know that this video is getting a bit long. But there's one more

28:37.920 --> 28:43.040
thing that I wanted to show you about unit testing that I think is important for most people to know.

28:43.040 --> 28:48.320
So sometimes our code relies on certain things that we have no control over. So for example,

28:48.320 --> 28:53.600
let's say that you have a function that goes to a website and pulls down some information. Now if

28:53.600 --> 28:59.200
that website is down, then your function is going to fail, which will also make your tests fail.

28:59.200 --> 29:05.360
But this isn't what we want, because we only want our test to fail if something is wrong with our

29:05.360 --> 29:10.320
code. So if a website is down, then there's nothing that we can actually do about that. So

29:10.320 --> 29:14.240
we're going to get around this with something called mocking. Now there's a lot that we could

29:14.240 --> 29:19.600
look at in terms of mocking, and it could probably be a video all on its own. But let's take a look

29:19.600 --> 29:26.000
at an example of some basic usage. So one more time, I'm going to go over here to my snippets and

29:26.000 --> 29:33.280
grab a little bit of code here. And this is going to be a new method in our employee class. So I'm

29:33.280 --> 29:40.800
going to paste this at the bottom of our employee class, and then fix these indentations. So this

29:40.800 --> 29:47.200
is a sample method that we're going to pretend that goes to a company's website, this line here

29:47.200 --> 29:55.040
using request dot get and pulls down an employee's schedule for a given month. And real quick, I also

29:55.120 --> 30:04.000
have to import the request library here at the top. So import requests and back down here in our

30:04.000 --> 30:11.040
method. So we do the request dot get for this website for this employee and for this month to

30:11.040 --> 30:17.200
get their schedule. And if the response is okay, then we want to return the text of that response.

30:17.200 --> 30:23.440
And if the response is not okay, then we want to return the text bad response. So the information

30:23.440 --> 30:28.640
from that website is something that we would want to mock because we don't want the success of our

30:28.640 --> 30:36.000
test to depend on that website being up. We only care that the get method was called with the correct

30:36.000 --> 30:42.240
URL, and that our code behaves correctly, whether the response is okay, and whether the response

30:42.240 --> 30:51.360
is not okay. So to do this, let's import something from mock called patch. So up here at the top of

30:51.360 --> 30:59.840
our test employee module, I will say from unit test dot mock import patch. Now there are a couple

30:59.840 --> 31:05.520
of different ways that we can use patch. So we can use patch either as a decorator or as a context

31:05.520 --> 31:12.000
manager. And it will allow us to mock an object during a test. And then that object is automatically

31:12.000 --> 31:19.680
restored after the test is run. So let's create a new test down here at the bottom for that monthly

31:19.680 --> 31:27.120
schedule method. And we'll just call this test underscore monthly. Oops, and I wanted to call

31:27.120 --> 31:33.440
that monthly schedule not monthly method. And then we'll pass in self. And so in this example,

31:33.440 --> 31:37.200
we'll use patch as a context manager. So we'll just say

31:37.440 --> 31:51.440
So what we said here was with patch, and then within patch, we pass what we want to mock,

31:51.440 --> 31:59.200
and we want to mock request dot get of the employee module. And then we're setting that equal to

31:59.200 --> 32:06.240
mocked get. Now you may wonder why we didn't just import requests into our test and just mock that

32:06.240 --> 32:12.000
instead of the employee request. But we want to mock these objects where they're actually

32:12.000 --> 32:17.760
used. So it's actually used in this employee module. So that is the request dot get that we

32:17.760 --> 32:24.160
want to mock. Okay, so now when request dot get is run in the employee module, it's actually going

32:24.160 --> 32:32.080
to use our mocked get variable here instead of the regular get method. And we can just assign

32:32.080 --> 32:38.400
the return value instead of actually going out to the website. So we can test a successful call

32:38.400 --> 32:47.120
by saying mocked get dot return value. And if we look back at our employee module,

32:47.120 --> 32:56.320
we want that return value to have an okay of true. So I can say return value dot okay is equal to

32:56.320 --> 33:06.480
true. And let's also set the text of that return value so we can set the text equal to, you know,

33:06.480 --> 33:13.200
something like success. So if you look here in our employee module, if it returns okay as true,

33:13.200 --> 33:20.640
then we should get our response text back. So now within our context manager here, let's just run

33:20.640 --> 33:26.960
our monthly schedule method just like we're testing it. So we can say schedule is equal to

33:26.960 --> 33:40.240
self dot employee one dot monthly schedule. And we'll just pass in a value of May to get the May

33:40.240 --> 33:46.000
schedule. Now one more awesome thing about these mock objects is that they actually record when

33:46.000 --> 33:51.600
they were called and with what values. So we want to make sure that the get method was called

33:51.600 --> 34:01.120
with the correct URL. So to do this, we can say mocked get dot assert called with. And this is

34:01.120 --> 34:07.760
just a method of that mocked object. And now we can test that it got called with the correct URL.

34:07.760 --> 34:17.040
So since this is employee one here, the last name is Schaefer right here. So this should have been

34:17.040 --> 34:25.920
called with the URL HTTP company dot com slash Schaefer and the month that we passed in was May.

34:25.920 --> 34:31.680
And if you're wondering where I get that here in our employee class, this is where it creates the

34:31.680 --> 34:38.320
URL here. So it's saying HTTP company dot com and then the employee's last name and then the

34:38.320 --> 34:43.440
month that we passed in. So that's the URL that it should have called that get method with. Now

34:43.440 --> 34:48.640
after we know that the method was called with the correct URL, let's make sure that it returned the

34:48.640 --> 34:58.320
correct text, which we set to success. So let's say self dot assert equal. And we want to assert

34:58.320 --> 35:06.240
that our schedule, which is the response is equal to success. Okay, so now if we run this code,

35:06.240 --> 35:10.080
then we still have our print statements in here. But we can see down here at the bottom

35:10.080 --> 35:16.800
that it ran for tests, and that they all passed. Okay, now last thing is that we want to test a

35:16.800 --> 35:24.240
failed response. So to do this, we can just do the exact same thing. So I'll just copy all of this

35:24.320 --> 35:31.520
here and paste it in down below. But instead of this okay value being true, I'm going to set this

35:31.520 --> 35:38.560
to false. So that'll test a bad response from the website. And if that okay value isn't true,

35:38.560 --> 35:44.240
then our monthly schedule function should just return the string bad response. So we actually

35:44.240 --> 35:49.600
don't need this text value here at all. So we can just remove that. And just to switch this

35:49.600 --> 35:56.560
second test up a bit, let's change our employee here to employee two, and we'll use the month

35:56.560 --> 36:02.080
of June just to make these tests a little better. So now the get method should be called with the

36:02.080 --> 36:08.480
URL of Smith, which is our employee to if I scroll up here to the top, you can see our employee two

36:08.480 --> 36:14.560
is Smith. And then that month that we used is June. So I'll save that. And lastly, instead of our

36:14.560 --> 36:22.000
result equaling success, it should instead return the text bad response with an exclamation point.

36:22.000 --> 36:27.680
So now if we run this, then we can see that all of our tests are still passing. So I know that

36:27.680 --> 36:32.240
this mocking can be a little confusing when you first see it. And like I said, it could probably

36:32.240 --> 36:38.160
be a video all on its own. But you don't use it a whole lot unless you're, you know, accessing

36:38.160 --> 36:43.840
things like URLs and things that are basically out of your control. So you don't use it a lot.

36:43.840 --> 36:49.040
But whenever you do need it, it is definitely nice to know. Okay, so I think that's going to

36:49.040 --> 36:54.880
about do it for this video. But before we finish up here, let me mention a few things about best

36:54.880 --> 37:00.720
practices. So first of all, like we saw in this video, tests should be isolated. So if you're

37:00.720 --> 37:06.400
still unclear what that means, basically, this just means that your test shouldn't rely on other

37:06.400 --> 37:13.440
test or affect other tests. So you should be able to run any test by itself, independent of the other

37:13.440 --> 37:18.720
tests. And one more thing that I wanted to mention is that you'll notice that in this video, I was

37:18.720 --> 37:24.560
adding tests to existing code. Now you may have heard something called test driven development.

37:24.560 --> 37:29.840
And basically what test driven development means is that you write the test before you write the

37:29.840 --> 37:34.960
code. And I know that that might sound a little strange. But sometimes I've found it useful.

37:34.960 --> 37:39.680
I don't strictly follow test driven development to where it's something that I always do. But

37:39.680 --> 37:45.200
basically, the concept is that you should think about what you want your code to do, and then

37:45.200 --> 37:51.600
write a test implementing that behavior, then watch the test fail, since it doesn't actually have any

37:51.600 --> 37:57.040
code to run against, and then to write the code in a way that gets the test to pass. So if you

37:57.040 --> 38:01.600
ever hear someone talking about test driven development, then that's what they're talking about.

38:01.600 --> 38:05.840
Okay, so I think that is going to do it for this video. I hope that everyone now has a good idea

38:05.840 --> 38:11.360
for how they can get started with unit testing. Now any testing is better than no testing. So don't

38:11.360 --> 38:16.640
feel like you have to be an expert with mocks and things like that before you start writing any tests.

38:16.640 --> 38:21.600
Even if you just write some basic assertions, then it's better than not having anything. Now

38:21.600 --> 38:26.880
there is another test framework out there called Pi test that a lot of people like to use more than

38:26.880 --> 38:31.920
this built in unit test library. And I'll be doing a video on that in the near future so that you

38:31.920 --> 38:36.160
can compare the two and see which one you like better. Now if anyone has any questions about

38:36.160 --> 38:40.240
what we covered in this video, then feel free to ask in the comment section below and I'll do my best

38:40.240 --> 38:44.080
to answer those. And if you enjoy these tutorials and would like to support them, then there are

38:44.080 --> 38:48.080
several ways you can do that. The easiest way is to simply like the video and give it a thumbs up.

38:48.080 --> 38:52.000
And also it's a huge help to share these videos with anyone who you think would find them useful.

38:52.000 --> 38:55.360
And if you have the means you can contribute through Patreon and there's a link to that page

38:55.360 --> 39:00.000
in the description section below. Be sure to subscribe for future videos and thank you all for watching.

