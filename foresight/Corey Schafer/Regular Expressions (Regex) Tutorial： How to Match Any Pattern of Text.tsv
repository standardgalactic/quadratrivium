start	end	text
0	3040	Hey there, how's it going everybody? In this video we're going to be learning how to use
3040	7280	regular expressions. So we're actually going to look at regular expressions as a standalone
7280	11360	topic because they aren't specific to any one programming language. Now there are some slightly
11360	15760	different flavors here and there, but for the most part, whether you're programming in Python or
15760	21200	JavaScript or Java or whatever, if you learn how to use general regular expressions, then it should
21200	25840	mostly carry over into your language of choice. And it will also allow you to use them in text
25840	30320	editors and the command line and things like that. Now I am going to do a follow up video where I
30320	34640	show how to use regular expressions specifically in Python since that's a language that I cover
34640	39360	most on this channel. But for this video, we're going to be learning how to use regular expressions
39360	43920	by themselves so that you can apply these to other areas. So with that said, let's go ahead and get
43920	49200	started. So regular expressions basically allow us to search for specific patterns of text. And
49200	53600	they can look extremely complicated. But that's mainly because there's just so much that you
53600	57680	can do with them. You can create a regular expression for just about any pattern of text that
57680	62560	you can think of. So let's see what some of these look like. So I have a test file open here that
62560	67680	we're going to use to search for specific patterns. And I'm going to be using the regular expression
67680	73280	tool in the atom text editor to write these regular expressions and find what text matches our patterns.
73280	78000	Now in order to open up this regular expression search tool, I'm just going to go to find and
78000	83280	then find in buffer. Now you could have also opened this up with command F on a Mac. And I believe
83280	90320	that's control F on Windows. Now within the options here, make sure that you have the dot
90320	95680	asterisk selected over here because that's going to tell our search tool to use regular expressions.
95680	101200	And also select this match case option here as well. That's just going to give us behavior that
101200	106000	is more common to how regular expressions usually behave. Okay, so let's start writing some regular
106000	111040	expressions. And first we'll start off kind of simple. So first of all, we can just search for
111040	117120	literal characters. So if I was to search for ABC, then we can see here at the top that it
117120	123920	highlighted ABC because it matched the ABC and our lowercase alphabet. Now it didn't match the
123920	130320	capital ABC here because it's case sensitive. Now this search right now is looking specifically
130320	136720	for A, B, and C. But if I was to type in something like BCA, then we can see that there were no
136720	143280	results found because the order does matter. Now if we look at this meta character section here,
143280	148560	I have some examples of characters that I say need to be escaped. So for example,
148560	155920	if you wanted to search for a literal period, now if I was to just type in a period here and
155920	160720	hit enter for my search, then we can see that it does this weird thing where it matches everything.
160720	166320	And that is because the dot is a special character in regular expressions. And we'll see more of this
166320	172160	in just a second. But for now, if we just wanted to actually search for a period or a dot, then we
172160	178480	have to escape it. And to escape characters, we can use the backslash. So if I do a backslash and
178480	185040	search, then now we can see that it only matches the actual literal dot or period within our document
185040	189760	here. And that goes for any of these meta characters that I've listed here. So for example,
189760	194560	we can see that the backslash is a special character also. So if you wanted to search
194560	200240	specifically for a backslash, then you have to escape itself. So a backslash to escape,
200240	204560	and then a backslash for the search. And if I search for that, then we can see that we matched
204560	210240	a literal backslash. So a practical example of this might be trying to match this URL right here.
210240	216000	So if we wanted to match that literal URL, exactly, then we could just say corey Ms.
216000	221680	And then for the dot on the dot com, we have to escape that with a backslash and then a period,
221680	226320	and then a com. And we can see that it matches our URL. Okay, so that's how you match literal
226320	230800	characters. But a literal search isn't too exciting, because we're used to that already.
230800	235040	Really, we want to use regular expressions to search for patterns. And to do this, we're going
235040	240480	to be using some of these meta characters that we were just escaping. So I have a snippets file
240480	245920	open here. So I'm going to switch over to this. And in here, I have a list of values where we can
245920	250640	see the types of characters that we can match. Now just for now, I'm going to try to make this
250640	257360	into a split screen here, as we're walking down this list. So the first one I have listed here
257360	263440	is this dot or period. And we can see that this matches any character except a new line. Now we've
263440	268880	already seen this, but let's take a look again. If we just do a dot and search for that, then we
268880	273920	can see that it matches any character except it does not match the new lines. Okay, so next on
273920	281520	the list is backslash D. And that matches any digit zero through nine. So if I was to do a backslash
281520	286640	D here and search for that, then you can see that this matches all of our digits. So anything
286640	291760	zero through nine, it matches. Now we also have an uppercase D here. And that matches anything
291760	297840	that is not a digit. So if I search for an uppercase D, then we can see that our digits are not
297840	303120	matched. But everything else is highlighted. So it matched everything except for the digit. Now
303120	308400	you'll notice that this is a common theme here that the uppercase versions of all of these are the
308400	315200	ones that kind of negate the search. So moving on down here, we have backslash w that searches for
315200	321840	any word character and a word character is lowercase a through z uppercase a through z zero through
321840	328080	nine and an underscore. So let's search for the word character. And we can see that it matches,
328080	332480	you know, all these lowercase uppercase numbers and things like that. It doesn't match these
332480	338720	special meta characters here. And just like with the digit, the uppercase w will match anything that
338720	344720	is not a word character. So anything that is not in this list here. So let's go ahead and search
344720	350160	for that uppercase w. And we can see that, you know, it picks up the spaces and these special
350160	355520	punctuations and things like that. But it does not match the word characters that we saw before.
355520	359200	Now, if you're not quite getting this just yet, we are going to look at a lot of examples to where
359200	364720	it'll start to sink in. So moving down the list here, we have backslash s, which will match any
364720	372080	white space. And white space is a space tab or a new line. So if we search for backslash s,
372080	377280	then we can see that it matches our new lines here and our spaces, but it doesn't match any of these
377280	382800	characters in here. So it's mainly white space. And just like with the others, the capital s
382800	387600	will search for anything that is not white space. So now you can see that we have, you know, all
387600	393200	these lowercase uppercase digits and then also this punctuation, anything that isn't a new line
393200	398640	or a space or anything like that. Now these bottom ones over here, the backslash b, the
398640	403760	carrot and the dollar sign, these ones are a little bit different. So these are called anchors.
403760	410880	And they don't actually match any characters, but rather they match invisible positions before or
410880	417200	after characters. So let's see what I mean by this. So for a word boundary, if I search for a
417200	424240	word boundary here. So now let's search for where we have this ha ha ha here. Let's search for a
424240	431120	word boundary and then ha and match that. So we can see that that matched because there is a word
431120	437760	boundary here at the start of this line before this first one here. And this space here is also
437760	443920	word boundary. So this one gets matched as well. But this last one does not get matched because
443920	449520	there's no word boundary between these two ha's here. Now just to show what this would look like
449520	453920	without the word boundary. If I was to search for that, then you can see that it highlights all three
453920	460000	of those. Now just like with the other ones, if I do a an uppercase b, then that matches anything
460000	465760	that is not a word boundary. So if I do an uppercase b, then we can see that we match the one that it
465760	471040	didn't match before, because there is no word boundary between these two here. So it doesn't
471040	477840	match these first two. Now if I was to put word boundaries on both sides of these, then it should
477840	484640	only match this first one, because this is the only one that has a word boundary at the beginning,
484640	491040	which we're matching here, and at the end. So this one has a word boundary at the beginning,
491040	496720	but not at the end because it's in the middle of this word. And this one has a word boundary at
496720	502000	the end, but not at the beginning. Okay, so our other two anchors here are pretty similar. So the
502000	508080	carrot matches the position at the beginning of a string, and the dollar sign matches the position
508080	514880	at the end of a string. So let's say for example, that we only wanted to match a ha if it was at
514880	522160	the beginning of a string. So for example, if I was to do a carrot and then a ha and match that,
522160	525760	then we can see that it only matched this one, because it's the only one
525760	531440	that is at the beginning of a line. Now if we wanted to only match it if it was at the end,
531440	537120	then we could put that dollar sign at the end. And what we're saying here is that we only want
537120	543600	to match this if the end of the string is the is in the following position. So we can see that it
543600	548960	not only matches this last one, because the end of the string is the next position in line. Okay,
548960	554320	so now that we've seen what we can match with these special characters here, now let's go ahead
554320	559520	and take a look at some practical examples. So I'm going to move my snippets file back here,
559520	564960	and we will keep referencing that later on. But for now, let's go ahead and say that we wanted
564960	569120	to match a couple of phone numbers. And let's write some regular expressions to do this. Now
569120	574160	with a phone number, we can't just type in a literal search like we did before, because all of these
574160	580400	are different. So they have a similar pattern, but they're not all the same digits. So in this case,
580400	586800	we need to use the meta characters instead of literal characters. So we just have a pattern here
586800	593440	of three digits, and then a dash or a period, and then three more digits, and then a dash
593440	599920	or a period, and then four digits at the end. So we saw before that we can match a digit with a
600000	606480	backslash d. And that is going to match all of the digits in our file. So we want to match
606480	612400	this phone number here. So we want to match first three digits in a row. So we can just put in
612400	617920	three backslash d's, and that will match any three digits in a row. So now that we're matching
617920	622400	those first three digits, now we're getting to where we can see that we're either going to match
622400	628960	a dash or a dot in our phone number. So for now, let's just match any character that's in this
628960	634640	position. So from our snippets file, we saw that if we want to match any character that we can use
634640	640080	a dot. So we can see that for now, our pattern is still matching some other stuff as well. But
640080	646320	let's just continue on. So now that we're matching this hyphen or this dot, now let's go ahead and
646320	652880	add in the next three digits. So we want to search for three more digits. So I'll do three backslash
652880	658800	d's. And now we're going to want a dot to match any character, which should match that dash or
658800	665440	that dot. And now we want four digits. So we can just do four backslash d's. So now we can see that
665440	670320	this regular expression highlights both of our phone numbers and matches both of those. So now
670320	676080	we're starting to see how this could be pretty useful. So for example, I have a data file here.
676080	681920	Now if I pull this up, then I have a bunch of fake names and numbers and addresses and emails.
681920	686320	But if I wanted to match all of the phone numbers in this file, then you can see that the regular
686320	692080	expression that we just wrote matches all of the phone numbers here. So now we're starting to kind
692080	696880	of get a sense of how this could be more useful than just a literal search, because now we're
696880	703360	actually searching for a specific pattern. So now let me go back to our simple text file here.
703360	707600	So now let's get a little bit more specific. So let's say that we only wanted to match a phone
707600	713840	number if it had a dash or a dot. Now right now, this pattern will match any separator,
713840	719280	because we're using the period down here, which will match any character. So if I was to put in
719280	726560	a another number here that doesn't have a regular separator, let's just say it's an asterisk,
726560	731120	then we can see that it matches this number as well, even though the asterisk isn't really a
731120	737360	phone number separator. So to only match the dash or the dot, we're going to have to use a character
737360	743680	set. And a character set uses square brackets with the characters that we want to match. So to
743680	748640	create a character set, I'm going to replace our first dot here. And this is going to be square
748640	754240	brackets. Now this is a character set. Now within this character set, we want to put the characters
754240	761040	that we want to match. So we want to match either a dash or a dot. And I will just copy that and
761040	766880	we'll replace this second dot here, which was matching any character. And we will put that
766880	772880	in for that as well. And now you can see that it only matches our phone numbers here that have a
772880	778480	dash or a dot separator. And it does not match this one with the weird asterisk there. Now you
778480	784000	probably also notice that we didn't need to escape our dot character within our character set. And
784000	788880	that's because character sets have some slightly different rules. Now you can escape these characters
788880	793600	if you'd like. But it just makes it a lot more difficult to read if you do that. Now even though
793600	799760	the character set has multiple characters here in the set, it's still only matching one character
799760	806080	in our text. It's matching one character that is either a dash or a period. But if I was to put in,
806080	811600	let's say two dashes here into one of these numbers, then you can see now it doesn't match that number
811600	818080	because it's only matching the first dash or a dot. And then it moves right on to looking for a
818080	822480	digit. So it's looking for a digit in this position. So that's something that can kind of throw
822480	826560	people off when they first start working with regular expressions. So even though, you know,
826560	830880	we have four characters total here in this character set with these square brackets,
830880	836720	and all of the characters in this set, it's still only searching for one literal character up here,
836720	842080	which is either a dash or a dot. Now to show another example of this, let's say that we only
842080	848640	wanted to match 800 and 900 numbers. So I'm going to create two different numbers here. I'll do an
848640	856720	800 number and a 900 number here. So if we only wanted to match 800 and 900 numbers, then our first
856720	862160	three digits here, we have to do something different. So first, we want the first digit that we're
862160	867680	going to match to either be an eight or a nine. So we can do a character set. And we can say that
867680	874480	we're looking to either start with an eight or a nine. Now the following two numbers are going to be
874480	880480	zero zero. And that's just a literal search. So now you can see that we're finding the 800 and 900
880480	886960	numbers here. Now within our character set, the dash is actually a special character as well.
886960	892400	So when it's put at the beginning or the end of the character set, then it will just match the
892480	898960	literal dash. But when it's placed between values that can actually specify a range of values. So
898960	905520	for example, we know that the backslash D matches any digit. But what if we only wanted to match
905520	911840	digits between let's say one and seven. So to do that, we can use a character set. And we can just
911840	919040	say instead of typing out 1234567, if we wanted to specify a range of those values, then we can
919120	924880	just say one dash seven. So now we can see that we're matching all of the digits between one and
924880	930800	seven, but the eight, nine and the zero aren't getting matched up here. Now you can do this with
930800	936880	letters as well. So if we only wanted to match the lowercase letters a through Z, then we could just
936880	942560	do a character set of a through Z. Now you can see all of the capital letters aren't getting matched,
942560	947920	but the lowercase ones are. Now if we wanted to match the uppercase and lowercase numbers,
947920	954400	then we could just put our ranges back to back. So I could say a through Z and then just add on
954400	960960	to this character set and say capital A through capital Z. And now we're matching all letters,
960960	965840	regardless of whether they are uppercase or lowercase. And you could keep adding to those ranges.
965840	970960	If you wanted to, you could do a zero through nine there as well, to add in all digits. Now
970960	977440	another special character in our character set is the carrot. Now we saw before that outside of the
977440	982880	character set, it matches the beginning of a string, but within the character set, it negates
982880	988720	the set and matches everything that is not in the set. So for example, if we wanted to match every
989520	996720	character that is not a lowercase letter, then we could say this carrot and then A through Z.
996720	1001360	So we can see that it matches everything on our screen that isn't a lowercase letter. It's not
1001360	1006720	matching these lowercase letters here. So it's even matching these new lines and the spaces and
1006800	1013520	everything. So just to show another example of this, let's say that we had some words here,
1013520	1021280	cat, mat, pat, and bat. So let's say that we wanted to match every word that ends in A-T,
1021280	1028400	except bat. We don't want to match bat. So to do this, we can just say that we want a character
1028400	1035680	set of everything that is not B, followed by A-T. So now we can see that it matches all of these
1035680	1042480	three letter words that end in A-T, except for bat, because our character set here negated that B.
1042480	1048160	So everything that we've looked at so far has involved single characters. So in this example
1048160	1055200	right here, we're matching any single character that is not a B, then followed by an A, and then
1055200	1060640	followed by a T. But we can actually use these things called quantifiers to match more than one
1060640	1066720	character at a time. So let's go back to our original phone number example from earlier,
1066720	1073040	and we'll just match any character like we did before. So I will do three digits and then a
1073040	1079120	period for any character, and then three digits again, and a period for any character, and then
1079120	1084160	four digits at the end. And I'm just going to remove what we had there for an example
1084160	1090320	and scroll those back up. So to see what quantifiers we have available, I'm going to make my snippets
1090400	1096400	half of my screen here again, and then scroll down to my quantifiers section. So the asterisk will
1096400	1103440	match zero or more of what we're searching for. The plus sign will match one or more. The question
1103440	1109600	mark will match zero or one. And to match exact numbers, we can use these curly braces with a
1109600	1114560	number on the inside. So in this example, this would match exactly three of what it is we're
1114560	1120560	looking for. And we can also specify a range of numbers as well, with the first number being the
1120560	1126720	minimum, and the last number being the max. So this would search for whatever our pattern is. It
1126720	1131920	would look for three or four of those. So let's take a look at an example of this to see how this
1131920	1137920	works. So you can see that with our phone number, we are searching for one digit at a time. But we
1137920	1145120	could change this. If I erase my digits here, then we could say that I'm searching for a digit.
1145120	1152080	And then we could put in our quantifier for exactly three digits. And we could do this
1152080	1158720	after our separator as well. So we're searching for three digits, and then any character. And then
1158720	1164800	here at the end, we want to match four digits. So instead of writing out the same characters over
1164800	1171040	and over, we can see how these quantifiers allow us to specify exactly how much we want. Now here
1171040	1176480	we're matching exact numbers. But sometimes we don't know the exact number. And we'll need to use one
1176480	1182560	of these other quantifiers. So for example, here at the bottom of this test file here, we have some
1182560	1189680	lines where each starts with a prefix of mister, or miss, or misses. So let's say that we wanted to
1189760	1197280	match these prefixes, as well as the names after. So just to start, let's start by matching the names
1197280	1204000	that start with mister. Now we can see that some of these have a period after the prefix, and some
1204000	1211440	do not. Some of them just have a space. So let's start our regular expression by searching for
1211440	1216560	lines that start with mister. And then we're going to put a backslash period to search for that
1217440	1223840	literal period. And right now it isn't matching this mister Smith, which doesn't have a period
1223840	1231280	after the prefix. Now to match that also, we can use this question mark quantifier, which tells our
1231280	1238000	pattern that we want to match zero or one of that character. So if I put a question mark after that
1238000	1244480	literal period, then it's saying that there can be zero periods there, or there can be one. So we
1244480	1249680	can see that now it's matching the ones with one period there, and it's also matching the one with
1249680	1258160	no period. So now to continue and match the entire line. Now we want to match a space after that.
1258160	1264960	And after the space, we want to match any uppercase letter. And to do that, we can use
1264960	1270880	our character class, and we can match any uppercase letter by doing a range of uppercase letters
1270880	1276400	there. So at this point, after that first uppercase letter that we match, we've completely matched the
1276400	1282160	name for Mr. T down here at the bottom. But we still need to match the rest of our other names.
1282160	1289600	So we could say that we will match any word character after that uppercase. So let's put in
1289600	1294480	a backslash w to match any word character. And now we don't know how many more characters are
1294480	1300240	going to be in our name. So we'll have to use a quantifier here. Now if we look over here,
1300240	1305760	we could use the asterisk or the plus sign. And the plus sign will match one or more of
1305760	1312400	these word characters. And the asterisk will match zero or more. So if we used the plus sign,
1312400	1319040	then we can see that it matches our two top names here. But now it's not matching this Mr. T because
1319040	1324880	after our word character, it's searching for one or more word characters after our uppercase
1324880	1330800	character. So a better solution in this case, maybe to use the asterisk, which matches zero or
1330800	1337120	more word characters. And if we use that asterisk, then we can see that it matches all three of our
1337120	1342320	names that begin with Mr. Now I know that we've covered a lot so far, but we've got a couple
1342320	1347200	of more concepts to go. And then we'll look at some examples that wrap everything together.
1347200	1354160	So we still haven't matched our miss or misses names here. So how would we do that? So you might
1354160	1361280	think that we could use a character set that matches either an r or an s. And there are maybe
1361280	1366400	some ways that we could get that to work. But it probably would be a bit ugly, since we'd have to
1366400	1373360	match either an r or an s as the second character and then the optional s after that. So that could
1373360	1378160	get kind of ugly. But I think a better solution here would be to use a group. Now we haven't looked
1378240	1384480	at groups yet. But groups allow us to match several different patterns. And to create a group, we use
1384480	1391840	parentheses. So after the m here, instead of just searching for Mr, I'm going to create a group
1391840	1398560	with open and closed parentheses here. And now within our group, we can specify different
1398560	1404960	matches. So I can say that we want to match either an r and then or and we use this character here
1404960	1411360	to specify an or. And that is just the vertical bar character to specify an or. So we can say that
1411360	1417840	we want to match an r or an s. And whenever we add that in, we can see that now we're matching the
1417840	1424640	miss name here. But we're still not matching this misses. So to match the misses, we can put in
1424640	1430560	another or and say that we want to match an RS. Okay, so now we can see that we are matching
1430560	1434960	all of our names here. So let's do a quick walkthrough of this one more time to make sure
1434960	1441680	we know what's going on. So we have a capital M to start. And then that capital M is followed by
1441680	1451520	either an r and s or an RS. And then we are looking for a literal period. And this question mark says
1451520	1457040	that we can have zero or one of those. So that is optional. So it's matching the ones that do have
1457040	1462800	that period and the ones that don't. And then after that, we are matching a space. Then after
1462800	1468720	that space, we the first letter of the last name, we're looking for any capital letter. So we have
1468720	1474800	a character set here that is a through Z of capital letters. And then for the rest of the last name,
1474800	1481920	we are matching zero or more word characters. Now these groups can actually be used to capture
1481920	1486320	sections of your matched regular expression. And that's something that we'll look at in just a
1486320	1491600	minute. But for now, let's do a quick recap of everything that we've learned so far. And look
1491600	1496720	at some examples that incorporates all of these things together. So I have a file here and I'm
1496720	1503840	going to move my snippets back into the group here and open up this file emails.txt. So I've got a
1503840	1508560	file here with three fairly different email addresses. So let's try to write a regular
1508560	1514640	expression that will match all of these emails. So let's just match the first email address first
1514640	1520240	and see what that looks like. So the first email address, we have a mix of upper and lowercase
1520240	1526960	letters here before we hit this at symbol. So let's go ahead and match those first. So to match
1526960	1533520	any upper or lowercase letters, we can do a character set. And we can do a lowercase a through
1533520	1540000	Z or an uppercase a through uppercase Z. Now right now, this is only matching those single
1540000	1546720	characters. So we can use the plus quantifier to say that we want one or more of these upper or
1546720	1551760	lowercase letters. So we're still working on the first email address here, we have our upper and
1551760	1556560	lowercase letters here. And now we want to match that at symbol. So I'll just put in a literal
1556560	1563120	at symbol. And now for the domain name here, I'll just do a another search for any upper or lowercase
1563120	1569920	letters. So I'll do the same as we did before. And then I will do a plus sign for a quantifier to
1569920	1576000	match any upper lowercase letters after that at symbol. And then that's when we hit the end with
1576000	1582640	the dot com. So to match the dot com, we can do a backslash period for the dot. And then we can
1582640	1588320	just fill in a literal com. So now we've successfully matched that first address. Now it looks like
1588320	1594240	it's not matching the second address. So let's see why and see if we can mold this to match the
1594240	1600240	second address as well. So we can see that the second address has a dot in the first part of
1600240	1607680	the name here. So let's add a dot to our first character set, so that dots are included in
1607680	1614080	that character set. So now it's still not matching that second address. And it's because at the end
1614080	1621200	here, we don't have a dot com but a dot edu. So in order to search for both, we can use a group
1621200	1629360	like we saw before using open and close parentheses. And we can search for either com or edu. Okay, so
1629360	1634640	now we are building this up a little bit at a time. And we can see that we are now matching our
1634640	1639680	second email address. Okay, so now let's see if we can change this to match our third email address
1639680	1647440	here. So in our third email address, it looks like before the at symbol, we also have some hyphens
1647440	1653280	and some numbers in the first part here. So let's add those to the character set as well.
1653280	1661520	So back here after our capital letters, I'm also going to add in digits by doing zero through nine.
1661520	1668800	And we also want to add a dash in there as well. So that should match everything before the at symbol.
1668800	1674400	Now it looks like we also have a dash in our domain here. So we'll have to add that in as well.
1674400	1680400	So after the at symbol, we're matching any characters right now, it's just lowercase and uppercase,
1680400	1686560	but we can put a dash in there as well. And lastly, it's still not matching because just like the
1686560	1693600	other two instead, we have a dot net here instead. So we can just add in a second or at the end and
1693600	1699760	also include dot net. So we can see that we built that up a little bit at a time to match all three
1699760	1704720	of our email addresses. Now with something like email addresses, it can be pretty tough writing
1704720	1709920	your own regular expressions from scratch. But there are a lot of these available online. And
1709920	1714960	once we learn how to write regular expressions, then we should be able to read them and figure out
1714960	1720320	how they're matching as well. Now, I've always found that reading other people's regular expressions
1720320	1725680	to be a lot harder than writing them. But let's take a look at one and see if we can do this.
1725680	1731680	So I have an expression here that I pulled offline that matches email addresses. And let's
1731680	1737520	paste this in here and see if we can read through and see what this is matching. So we can see that
1737520	1742880	the one that I got offline does match all three of my email addresses here. Now let's look through
1742880	1748640	this. So we can see that it's somewhat similar to what we had before. But first we have a character
1748640	1756400	set here and it's a pretty large character set. And it matches lowercase, uppercase, any number,
1757120	1764240	an underscore, a period, a plus sign, or a hyphen. And then the plus sign here says that we want to
1764240	1770000	match one or more of any of those characters. And we match one or more of those characters
1770000	1775680	all the way up until we hit an at sign. And then after the at sign, we have another character set
1775680	1783120	here. And in this character set, we have lowercase letters, uppercase letters, any digits, and also
1783120	1788720	a hyphen. Now I don't know a lot about email addresses, but I'm assuming that since they left out the
1788720	1793920	underscore, the period, and the plus sign that were in the first part of the email address,
1793920	1798560	I'm assuming that those aren't allowed in the domain. So then we have a plus sign after that
1798560	1803680	character set, which means that we're matching one or more of any of those characters all the way
1803680	1810240	up until we reach this literal dot. And that literal dot is escaped with a backslash. And then
1810240	1815760	after the dot, we have another character set here. And this character set is any lowercase letter,
1815760	1823280	any uppercase letter, any digits, any hyphen, or a period. And then that is followed by a plus sign,
1823280	1828320	which matches one or more of anything in that character set. So just like I did with the phone
1828320	1834080	numbers, if we open up our data file here, with this regular expression that we've typed in,
1834080	1840400	then we can see that it does match all of the email addresses in this data file as well. So we've
1841200	1846480	got an expression that will match email addresses fairly well. So doing what we just did and reading
1846480	1851920	through a regular expression written by other people is probably the hardest part of all this.
1851920	1857120	But if you walk through it bit by bit, then you should be able to break down just about any pattern.
1857120	1861920	Okay, so the last thing that I'd like to look at in this video is how to capture information
1861920	1868080	from groups. Now, we've already seen how to match groups, but we can actually use the information
1868080	1873760	captured from those groups. So to show an example of this, I'm going to open up a file here with
1873760	1882640	some URLs. Okay, so we can see here that some of the URLs are HTTP, some are HTTPS. Also, some of
1882640	1888960	these have WWW before the domain name, and some do not. So let's say that you had a list of a lot
1888960	1895200	of different URLs within your document, and you only wanted to grab the domain name and the top
1895200	1901200	level domain, which is .com or .gov. So for example, out of all these domains, you only wanted to grab
1901200	1908800	google.com or coreyms.com or youtube.com or nasa.gov. And you just wanted to ignore everything else.
1908800	1914080	So let's see how we can do this. So first, let's write an expression that actually matches these
1914080	1921840	URLs. So let me get rid of the one that we currently have. Now, first, to match this, we can say
1921840	1929360	all of these start with with HTTP. And then the s is optional. So we can say s and then put in a
1929360	1935520	question mark to say that we want to match zero or one for the s. And then after that optional s,
1935520	1940960	we want a colon forward slash forward slash. So at this point, some of these domains have a
1940960	1950240	WWW dot before the domain name and some do not. So that WWW dot is optional. So since this isn't
1950240	1958160	one character, we're actually going to create a group here and say this group of WWW and then a
1958160	1964560	literal dot, which is a backslash dot. Now, all of that group is optional. So now you can see on
1964560	1969920	all of our URLs, we've matched up to the domain name. So now to complete this, I'm just going to say
1970720	1978640	any word character, so backslash w, and I will put in a plus sign to say one or more of those word
1978640	1984960	characters. And then we get here to the top level domain. So we want to match a literal dot. So we'll
1984960	1990400	do a backslash dot. And then for the rest of that top level domain, I will just do any word
1990400	1996960	character one or more times so we can do a word character with a plus sign to do one or more.
1996960	2003600	Okay, so we can see that this matches all of our URLs. But the point here was to use our groups
2003600	2010640	to capture some information from our URLs. So let's capture the domain name and the top level
2010640	2016560	domain, which is the dot com or the dot gov and things like that. So to capture these sections,
2016640	2023440	we can just put them in a group by surrounding them in parentheses. So what we want to group here
2023440	2030400	is our domain name. And the domain name is this part right here, this string of one or more word
2030400	2035360	characters. So I'm just going to wrap those in parentheses and create a group. And we've seen
2035360	2040400	that before. And now we also want to put the top level domain in a group as well. That is the dot
2040720	2047920	com or the dot gov. So we can put a parentheses around that dot, and then also around the ending
2047920	2052400	there that is the string of one or more word characters. Okay, so we can see that we're
2052400	2057840	still matching all of our URLs here. But now we have three different groups. So our first group
2057840	2065120	is just that optional www dot. Our second group is the word characters that make up our domain name.
2065120	2071200	And the third group is that top level domain. Now there's also an implicit group zero. And
2071200	2077920	group zero is everything that we captured. So in this case, it's the entire URL. So now let's get
2077920	2082560	to the cool part about this. So let me show you what we can do now that we've captured these.
2082560	2088560	So we can use something called a back reference to reference our captured group. So for example,
2088560	2094720	here in Adam, we have the ability to replace our matches, we can see down here that we can replace.
2094720	2102320	So let's replace all of our matches with just the literal text group one, and then a colon,
2102320	2109280	and then a dollar sign one. Now this dollar sign one is a reference to our first group. Now sometimes
2109280	2116080	this is a backslash. But for some reason in Adam, they use a dollar sign. So if I do a replace all
2116080	2122800	here, then we can see that it replaced our matches with this literal text group one. But then it
2122800	2128880	also replaced the dollar sign one with our first captured group. And the first capture group is that
2128880	2136080	optional www dot. So for the ones for the domains that had that www, we can see that it shows up.
2136080	2142320	And for ones that didn't, it doesn't have anything. So let me undo this. And now let's replace our
2142320	2148720	matches with the second group. And now the second group should be the domain name. So now if I do
2148720	2155680	a replace all now, then we can see that now it says group two is Google, CoreMS, YouTube,
2155680	2162960	and NASA. And if I undo that, and replace this with the group three, then the group three should
2162960	2169200	give us our top level domain. So our group three is the dot com dot com dot gov things like that.
2169200	2173760	So let me undo this one more time. So now that we know how to use those back references,
2173760	2179520	then we can actually take our regular URLs and clean them up like we meant to from before.
2180320	2187680	So we could convert these to a cleaned up version without the HTTP or the www just by replacing
2187680	2194400	our matches with the domain name, which is group two, followed by the top level domain,
2194400	2199840	which is group three. So now if I replace all of our selections with those two,
2199840	2204880	then we can see that replaced all of our URLs with just the domain name and the top level domain.
2204880	2209760	So you can imagine if you had a lot of information like this that you needed to clean up or modify
2209760	2214800	in some way, then knowing how to match these groups with regular expressions could save you
2214800	2219120	a ton of time with doing things like this. Okay, so I think that's going to do it for this video.
2219120	2223360	Now there's a lot of advanced features that we could go over with regular expressions as well.
2223360	2227920	So if anyone is interested in learning more, then I could put together an advanced video
2227920	2232400	covering those topics in the near future. But hopefully now you feel comfortable with being
2232400	2237280	able to read and write these regular expressions that we went over in this video. But if anyone
2237280	2241360	does have any questions about what we covered in this video, then feel free to ask in the comment
2241360	2245520	section below and I'll do my best to answer those. And if you enjoy these tutorials and would like to
2245520	2249600	support them, then there are several ways you can do that. The easiest ways to simply like the video
2249600	2253440	and give it a thumbs up. And also it's a huge help to share these videos with anyone who you think
2253440	2257280	would find them useful. And if you have the means you can contribute your Patreon and there's a link
2257280	2261280	to that page in the description section below. Be sure to subscribe for future videos and thank
2261280	2265280	you all for watching.
