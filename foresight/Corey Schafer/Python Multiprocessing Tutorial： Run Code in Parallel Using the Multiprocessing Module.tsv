start	end	text
0	3200	Hey there, how's it going everybody? In this video, we're going to be learning how to run
3200	7760	code in parallel using the multi-processing module. Now, if you'd also like to learn about
7760	12320	running code concurrently using the threading module, then I did recently put out a video on
12320	16640	that as well, so I'll be sure to leave a link to that video in the description section below. Now,
16640	20640	if you don't know the difference between threading and multi-processing, then you should have a grasp
20640	24160	on the difference between those once we're finished. Now, I would like to mention that we
24160	28960	do have a sponsor for this video, and that is Brilliant.org. So, I really want to thank Brilliant
28960	32560	for sponsoring the video, and it would be great if you all could go and check them out using the
32560	36720	link in the description section below and support the sponsors, and I'll talk more about their
36720	42240	services in just a bit. So, with that said, let's go ahead and get started. Okay, so first, why would
42240	47760	we want to use multi-processing? So, basically, we want to use multi-processing whenever it's going
47760	53520	to significantly speed up our program. Now, the speed up comes from different tasks running in
53520	58480	parallel. Now, in this video, we're going to start off with a basic example of where we learn how to
58480	63920	run some simple sleep methods in parallel, but then we'll finish up with a real-world example
63920	68960	where we do some image processing on a directory of high-resolution images. I want to show that
68960	73840	real-world example because, personally, when I watch tutorials that only show how it works on
73840	78480	basic examples, then I always feel like I don't really walk away with any useful knowledge. So,
78480	83120	we'll use the sleep method to get a good idea of how to use multi-processing, and then we'll
83120	88160	be sure to go over the more complicated real-world example of image processing. So, let's go ahead
88160	93200	and get started. So, I have a starting script open here, and if you'd like to follow along, then
93200	98560	I'll be sure to have a link to this code in the description section below. And, like I said, we'll
98560	104400	start with a very simple example to see how this works and then build up with more realistic examples.
104400	109920	So, let me go over the script that I currently have open here. So, first, I'm importing time,
109920	115200	and I'm just using time to measure how long it takes the script to run. That's also what this
115200	120880	is here. This is just a start time for our script, and then we have a function here called
120880	126080	doSomething, and all this is doing is printing that we are sleeping for one second, then we actually
126080	131360	sleep a second using that time module, and then we are printing out that we are done sleeping,
131360	135200	and then we are actually executing that function. So, it should do all of this,
135200	140320	and then we are calculating the finish time and printing out that our script is finished.
140320	144720	Okay, so, if I run the code that we have right now, we can see that it said that it was sleeping
144720	149280	for one second, done sleeping, and that we finished in about one second. And that sounds
149280	154400	about right since we were running our doSomething function one time, and that sleeps for one second.
154400	159200	And if we were to run that function twice, then our program will likely take two seconds. So,
159200	166000	let's go ahead and see that. So, right below doSomething here, I'm going to run this again,
166000	172080	and if I run that, then we can see that now that it printed out that it was sleeping for one second
172160	177600	twice, and that it took about two seconds. So, we can see that each time we run this doSomething
177600	182560	function, it's adding about one second to our script. So, our script is just waiting around
182560	188320	sleeping for a second, and once that's done, it moves on to run that next function,
188320	192720	and sits around waiting for another second. And then at that point, we're basically done,
192720	197840	and our script finishes. Now, I created a quick graphic to try to represent what this looks like.
197840	202160	So, let me bring that up here in my browser real quick. And this is actually the second
202160	206960	graphic. We'll go over that in just a second. Okay. So, this is basically what it looks like
207600	213360	for our script to be executed right now. So, we are running a function. In this case, it's that
213360	218960	doSomething function. And then this is just coming up here and waiting and executing for one second.
218960	224000	And once that one second is over, then we come back and we execute this another function,
224080	229120	and it's that same function again. So, then it comes up here and executes this sleep for one
229120	233680	second again. And when that one second is done, then we can come down here and print that our
233680	238880	script is done. And running everything in order like this is called running it synchronously.
238880	242880	Now, if you have some tasks that don't need to be run synchronously, then we can use the
242880	249200	multi-processing module to split these tasks up onto other CPUs and run them at the same time.
249200	254400	Now, if you watched my last video on threading, then I mentioned that tasks were going to either
254400	261200	be IO bound or CPU bound. So, CPU bound tasks are things that are crunching a lot of numbers and
261200	266960	using the CPU. And IO bound tasks are things that are waiting for input and output operations
266960	272320	to be completed. And they're not really using the CPU all that much. So, some other examples of
272320	278960	IO bound tasks include file system operations and network operations like downloading stuff online.
278960	283040	Now, in that threading video, I mentioned that we wouldn't get much of a speed up when using
283040	289120	threading on CPU bound tasks because those threads are still only running one process. But with
289120	294400	multi-processing, we're going to actually spread the work out onto multiple processors on our machine
294400	300560	and run those tasks at the same time. So, we can use this with both IO bound tasks and CPU bound
300560	305360	tasks. So, it really just depends on what we're doing and your computer's hardware that will
305440	309840	determine if it's better to use threading or multi-processing. But with that said,
309840	314560	let's look at what it looks like to run something in parallel using multi-processing.
314560	319360	And I've got another graphic put together of what this would look like. So, in this example,
319360	324080	we can see that we still have our two tasks. But now we're just breaking these up onto two
324080	329840	different processes. And unlike with threading, where we were running these concurrently, and I
329840	333760	said that running concurrently doesn't necessarily mean that they're running at the same time,
334480	339840	with multi-processes, these actually are running at the same time on different processes. So,
339840	346240	we can see here that once we kick off our multiple processes and we spread out our tasks onto those
346240	352560	processes, then we can just run each of these functions one time. And then both of these will
352560	357440	sleep for a second. And then once they're both done, we'll come down here and print that they're
357440	361760	done. Okay, so now that we've talked about multi-processing and what it looks like to run code
361760	368160	in parallel, now let's see how to actually do this with our current script. So, first,
368160	373600	let's import the multi-processing module. So, this is in the standard library, so we don't need to
373600	381120	install anything. So, up here at the top, I'm just going to say import multi-processing. Now,
381120	385040	I'm going to show an older way of how to do multi-processing first so that we can get a good
385040	389680	idea of what's going on. But if it seems confusing at first, then definitely stick around, because
389680	394880	I'm also going to show some newer ways of doing multi-processing using pools that allow us to
394880	401360	add this to our program with just a few lines of code. Okay, so first, instead of running the
401360	406960	do something function twice in a row like we have here, let's instead turn both of these into
406960	412640	processes. So, to do this, I'm just going to create two processes. And for both of these,
412640	421200	we can just say p1 is equal to multi-processing.process. And now, we are going to pass in a
421200	427200	target. And the target is the function that we want to run. So, if I want to run this do something
427200	433600	function, then I can pass in do something. Now, we want to pass in the actual function and not
433600	437760	the return value of the function. So, we don't want to execute the function with parentheses
437760	445200	like this. We just want to pass it in with no parentheses. Okay, so now that will be one process.
445200	452800	And now, if I do a p2 is equal to multi-processing.process with a target of do something, then
452800	459120	that will be our second process. Okay, so at this point, we've created two process objects,
459120	465600	but we're not actually running that code. So, if I run this right now, then we can see that it says
465600	471200	that it finished immediately, but nothing from our function printed out. So, our functions didn't
471200	477600	actually run. So, in order to get our processes to run, we need to use the start method on each one.
477600	484560	So, down here below our p2, I'm going to say p1.start to start that first process,
484560	492880	and p2.start to start that second process. Okay, so now that will actually run our processes,
492880	500240	but it might not do exactly what we think it'll do. So, if we run this, then we can see that now
500240	507200	it runs the functions, but it said that our script was finished in zero seconds, and then it said
507200	512720	that we were sleeping for one second twice because we ran that function twice, and then it said that
512720	518480	it was done sleeping. Now, our entire script didn't actually complete in zero seconds. It actually
518480	524160	took around one second, but the reason that it says that it completed in zero seconds is because
524160	530960	after it started both of these processes here, while those processes were sleeping, our script
530960	537280	continued running and came down here and calculated out the finish time and printed out that our
537280	544000	script was finished in zero seconds, and then it kicked off these processes. Now, actually, I think
544080	549120	that I just said that it started sleeping first before it printed out that we were finished,
549120	554240	but these processes take a little bit longer to spin up than threads, so it actually didn't even
554240	559120	start our processes first. It actually came down here and printed that we were finished before
559120	565200	these sleep statements even first got executed. So, it printed that before it said we were sleeping,
565200	571440	and then after a second we were done. So, basically what this is doing is it's kicking off our processes,
571440	576800	but then it's going down here and running the rest of our script before our process is finished.
576800	581440	Now, what if we wanted our processes to finish before we calculated the finish time and before
581440	586960	we printed out that our script is finished? So, in order to do this, we can use the join method.
586960	596400	So, to do this right below start, I'm going to say p1.join and p2.join. So, when we run that join
596400	602800	method, it means that the process will finish before moving on in the script. So, now, if we
602800	609520	run this, then we can see that both processes started at almost the same time, and then they
609520	614880	both printed that they were done sleeping after one second, and then our script continued on to
614880	620800	print that our script had finished in about one second. Now, if using multi-processing seems a
620800	625760	bit complicated right now, then definitely stick around until the end of the video, because we're
625760	631280	going to see an easier way of how to do what we're doing here, but I think it's important to understand
631280	637280	what this is doing so far, even if we use other methods where we don't actually manually call
637280	642320	these start methods and join methods. Okay, so, right now, we're not really getting that big of a
642320	648240	speedup. Now, so, our code ran in two seconds before, and now it's running in one second,
648240	652880	but that's because our function doesn't take too long, and we're only running it twice,
652880	658400	but what if we wanted to run our function 10 times? Well, if we were to run our code synchronously,
658400	664640	then we can take a guess that it would take 10 seconds since one would have to finish before
664640	669440	the other, and we'd be running 10 in a row. But if we ran this with multiple processes,
669440	675680	then it should be significantly faster. So, let's see an example of this. Now, instead of manually
675680	681520	creating 10 different processes, let's instead create and start these in a loop. So, to do this,
682320	688560	I can come up here, and I'm going to copy this whole part here, and now I'm just going to
688560	696560	overwrite all the code that we have here so far, and I'm going to say 4 underscore in range of 10,
697440	704240	and we'll say p is equal to multi-processing dot process with a target set to the do something
704240	711120	function. And now, let's also start that process here within our loop. Now, if you're unfamiliar with
711120	716720	the underscore in Python, basically, that's just a throwaway variable name. It's just saying that
716720	722800	we're not actually using the integer from this range in the loop. So, we just have something as
722800	728480	a throwaway variable there. So, we're starting all these processes here within our loop, but we can't
728480	736080	do a p dot join within the loop, because it would run join on the process before looping through
736160	741120	and creating and starting the next process in the loop. So, it would basically be the same
741120	747200	as running it synchronously. So, we need a way that we can start all of these processes in one loop,
747200	751520	and then loop through those processes again, and run the join method on them
751520	756880	so that they all finish before the end of our script. So, to do this, let's just append each
756880	765840	process to a list. So, above our for loop here, I'm just going to create a list called processes
765840	773600	and set that to an empty list. And then below p dot start, I'm going to say processes dot append,
773600	782320	and I will append each process to our processes list. And now, here below our for loop, I'm going
782320	793440	to say for process in processes, let's do a process dot join. Okay, so just one more time here. We are
794240	800320	looping over a range of 10. So, we're going to do this loop 10 times here. And each time through
800320	806320	the loop, we are creating a new process with this target of do something. And we are starting that
806320	813360	process. And then we are appending that process to a processes list. So, then after that loop is
813360	817520	complete, and all of our processes have been started, we're coming through and looping over all
817520	823040	those processes, and we are joining them. And again, when we join a process, when we run the join
823040	828560	method, it means that it is going to wait until that finishes before continuing on to the rest
828560	833360	of the script. So, it'll finish before it comes down here and calculates the finish time and
833360	838240	prints that our script is finished. So, we're running this do something function 10 times,
838240	843360	and it sleeps for one second every time. But since we're using multiple processes, it'll just run
843360	848880	all of these in parallel at the same time. So, instead of it taking 10 seconds, let's save this
848880	855520	and run this and see how long it actually takes. So, we can see that even running the function 10
855520	861120	times, we're still finishing this in about one second. Now, that might seem a little strange,
861120	867120	because I don't actually have 10 cores on this machine. But your computer has ways of switching
867120	873360	off between cores when one of them isn't too busy. So, even though we had more processes than we do
873360	878320	cores, it's still finished in about a second. So, that's pretty good. Okay, so now let's look at
878320	883120	how we can pass in arguments into our function. So, right now, we're running a function that
883120	888640	doesn't accept any arguments. But let's add a couple of arguments real quick. So, right now,
888640	894560	we're just sleeping for one second. So, let's add an argument that specifies how long to sleep.
894560	900480	So, up here, we will accept an argument. And I'm just going to pass in an argument of seconds.
900480	909840	And let's also change that we are going to sleep for that number of seconds. And let me also put
910880	916560	a parentheses s there as well. Now, this needs to be an f string, since we're now using this
916560	923600	variable here within our string. Now, I want to sleep for that number of seconds. Okay, so with
923600	929120	that small change, our do something function now accepts an argument of seconds. And then it'll
929120	933360	print out that we're sleeping for that number of seconds. And then it will actually sleep for that
933360	940480	number of seconds. So, let's pass in seconds as an argument to this function. And we need to pass
940480	947280	that in as a list of arguments to our process. So, I'll say, down here, where we are saying that
947280	953760	our target is that do something function, we can also pass in an argument of arcs. And we'll pass
953760	961200	that in as a list of arguments. So, I'll do 1.5. So, now, instead of sleeping for one second
961920	967680	for 10 different times, now it's going to sleep for 1.5 seconds for 10 different times. Now,
967680	973760	unlike with threads, in order to pass arguments to a multi processing process, the arguments must
973760	980000	be able to be serialized using pickle. Now, if you don't know what that means, basically serializing
980000	986560	something with pickle means that we're converting Python objects into a format that can be deconstructed
986560	992880	and reconstructed in another Python script. So, now we should expect our function to take
992880	1000400	1.5 seconds instead. So, if I save this and run it, then we can see that now our script is finishing
1000400	1006800	in about 1.5 seconds. Okay, so, I said before that I was going to show you the older way of doing
1006800	1012320	multi processing, and then I'd show you what I believe is a faster, easier way of doing this.
1012320	1017520	And I still wanted to show you the manual way of creating these processes, because I think this can
1017520	1022160	still be useful depending on what you're doing. And also, I think it's better to learn this manual
1022480	1028960	first to understand a bit better what's going on in the background. But in Python 3.2, they added
1028960	1034640	something called a process pull executor. And in a lot of cases, this will be an easier and more
1034640	1040000	efficient way to run multiple processes. And it also allows us to easily switch over to using
1040000	1045040	multiple threads instead of processes as well, depending on the problem that we're trying to
1045040	1051840	solve. So, let's replace what we currently have and instead use this process pull executor.
1052240	1057520	Now, this actually isn't in the multi processing module. It's in the concurrent futures module
1057520	1064720	instead. So, up here at the top, let's instead import concurrent futures. And I actually don't
1064720	1071440	think I need multi processing anymore. So, I'm just going to say import concurrent futures.
1071440	1075600	Now, I'm going to leave everything else that I have here for now, so that we can see the
1075600	1081680	difference between these. Now, when we use this process pull executor, it's usually best to use
1081680	1087600	this with a context manager. So, above our processes list here, I'm going to do the same thing that
1087600	1094320	we already have. But just with our concurrent futures module instead. So, I'm going to say with
1094320	1103200	concurrent dot futures dot process pull executor, and make sure you get those capitalizations in
1103200	1112800	the right place. And then, we will say, whoops, we'll say as executor. And now, within our or
1112800	1117600	with our executor here, there are a couple of different methods that we can use. Now, if we
1117600	1123680	want to execute the function once at a time, then we can use the submit method. So, the submit method
1123680	1129520	schedules a function to be executed and returns a future object. So, let's add this in and then
1129600	1137920	I'll explain this a bit more. So, I'm going to say f one is equal to executor dot submit. And I will
1137920	1146000	submit that do something function. And let's also pass in an argument of one. So, again, the submit
1146000	1154000	method schedules a function to be executed and returns a future object. So, a future object
1154000	1160000	basically encapsulates the execution of our function and allows us to check on it after it's
1160000	1166720	been scheduled. So, we can check that it's running or if it's done, and also check the result. So,
1166720	1172160	if we grab the result, then it'll give us the return value of the function. Now, right now,
1172160	1177920	we're just printing out values. But let me add in a return value so that we can grab that. So,
1177920	1184800	instead of just printing that we are done sleeping up here, instead, I'm going to return that string.
1184800	1190720	So, I'm going to say return done sleeping instead of just printing that out. Okay, so now that's
1190720	1196640	returning that string. So, if we still want to print that out, then we'll need to print that return
1196640	1203440	value. So, let's grab that by using the result method on that future object. So, I'm going to say
1203440	1212080	print and we will print out F1 dot result. Now, if we run the return method, then this will wait
1212080	1218720	until the function completes. Okay, so let's comment out what we had before and run our code. So,
1218720	1226400	I'm going to comment out this processes list here and our previous starts and joins. And instead,
1226400	1232640	we're just going to use this process pull executor. Okay, so if I run this, then we can see that
1232640	1238240	that still works. And that's a lot less code than we had down here that's commented out. But we're
1238240	1243120	still not running this multiple times yet like we were down here. So, if we wanted to run this
1243120	1250480	multiple times, then we could just run submit multiple times. So, I could say let me go above
1250480	1256320	our result here. I'm going to add in another execution of this do something function. So,
1256320	1264000	I'm going to call this F2 is equal to executor dot submit do something with one second. And then,
1264000	1272560	I will also print out the F2 result. So, if I run this, then we can see that it's the same thing.
1272560	1277440	It kicks both of these off at the same time. And we finished in about one second. And if we wanted
1277440	1282320	to run this 10 times like we did below, then we likely wouldn't want to run submit 10 different
1282320	1287760	times. So, we could use a loop like we did before. So, instead of running one at a time,
1287760	1292480	I'm going to use a loop. And we could use a regular loop like we did below. But I'm going
1292480	1298000	to go ahead and use a list comprehension to create these instead. So, we could say, I'm just going
1298000	1304640	to copy this executor dot submit part. And I'm just going to overwrite all of this other stuff
1304640	1311200	right now. And I'm going to say results are equal to, then I will start a list comprehension here
1311200	1320640	and say executor dot submit do something for one second for underscore range 10. Now, if you're
1320640	1325440	not familiar with list comprehensions like we have here, then I do have a separate video on that
1325440	1329920	as well. So, I'll put a link to that in the description section below if you've never seen
1329920	1334000	this type of code before. And if you're not comfortable using list comprehensions, then
1334000	1339360	you can always use a regular loop like we did down here below. Okay, so now we've created a list
1339360	1345600	comprehension that's running our submit method with this do something function, and an argument of
1345600	1351520	one second, 10 different times. Now, in order to get these results, we can actually use another
1351520	1356800	function from the concurrent futures module called as completed. And this will give us an
1356800	1362240	iterator that we can loop over that will yield the results of our processes as they're completed.
1362240	1367520	So, I think this is really useful. And it's one of the good things about using these processing
1367520	1376800	pull executors. So to use this, we can say just for f in concurrent, oops, sorry about my typing
1376800	1385440	there, concurrent dot futures dot as underscore completed. And now we want to pass in this list
1385440	1393680	of results, which is a list of futures objects. And now within this list, let's print out f dot
1394560	1401920	result. So if we run this, oops, and it looks like I have some invalid syntax here. Oh,
1401920	1408000	I forgot to say, I should have said for underscore in range of 10. Some of you probably saw that
1408000	1416240	as I was typing it out. Okay, so now if I run this, then we can see that we slept for one second.
1416240	1421120	Now it's still ran 10 different times. But if we scroll down to the bottom, then we can see
1421120	1427360	how much time it took. So we can see here that it actually took three seconds this time. Now,
1427360	1432640	the reason behind that is that our poll may have made a decision based on our hardware,
1432640	1439440	not to a lot as many processes. So that's why it might take longer. But even though it took longer
1439440	1445040	in our simple little example here, I still you like to use these processing pull executors most
1445040	1451680	of the time, because I trust it to a lot the processes a lot more than I trust myself. So
1451680	1457200	I passed that off to the process pull executor to do and to make that decision for me. Now to
1457200	1462240	prove that these results are actually coming in as they're completed, let me actually pass in a
1462240	1468000	different range of seconds for our processes to sleep. And those should print out in the order
1468000	1473760	that they complete. So I'm going to create a list of seconds to sleep. And I'll make that sleep
1473760	1480480	from five seconds all the way down to one second. So above our results here, I'm going to make a list
1480480	1487680	of seconds. And I will just make a list of five, four, three, two, one. And I'll also print out
1487680	1494400	the seconds in the return statement of our do something function, so that we can tell which
1494400	1500240	ones are finishing and in what order. So again, I'm going to make this an f string by putting an f
1500240	1508720	right there. And I'm just going to pass that in to so we can see which seconds is actually done
1508720	1515440	sleeping. So now, let me also change our list comprehension here, so that we are running our
1515440	1522160	do something function with each of these seconds in this seconds list. So I'm going to say executor
1522240	1533280	dot submit, do something. And I want to do that for whatever second. So four sec in our seconds
1533280	1540800	list. Okay, so now if I run this, then we can see that it actually started our five second
1540800	1546880	process first, and then our four, then our three, then our two, then our one. But it finished these
1546880	1552480	in the order that they came in. And the lower number seconds are towards the top. Now I'm not
1552480	1559120	sure why the one second process took so much longer than the two and the three second processes. I
1559120	1563920	guess it just got hung up on something. But the four and the five second processes were down here
1563920	1570240	at the bottom. Actually, let me run that one more time. And Oh, okay, so that's why it's because
1570240	1576880	our one second process was down here. And since I have four cores on my machine,
1577440	1583760	it started these four processes here first. And it didn't start the one second process until
1584560	1589840	this two was finished right here. So that's why that took a little bit longer. But since we are
1589840	1595920	using this as completed method, this actually did print our result out our results in the order
1595920	1601040	that they completed. So this two second one finished first, and then this three, then one,
1601040	1606000	then four, then five. And we can see here down at the bottom that our script is still finishing
1606000	1611360	in about five seconds. So that's pretty good. Okay, so with this submit method right now,
1612160	1619280	it's submitting each function once at a time. But in order to run submit on an entire list,
1619280	1624560	then we need to do a loop or a comprehension like we did here. But if you're familiar with the built
1624560	1629760	in map method, then there is actually something similar that we can do with processes, where we
1629760	1635280	can use the map method to run our function over a list of values. So if you're familiar with the
1635280	1641600	built in map method, then this is very similar, except it uses processes instead. So it runs the
1641600	1647440	function every time or with every item of the interval that we pass in. So let's say that I
1647440	1656160	want to map our function to our list of seconds. So to do this, I am just going to overwrite our
1656160	1661520	list comprehension here. And I'm not going to be using this as completed anymore either. So I'm
1661520	1671040	also going to get rid of that. So now in order to do this, we can simply say executor dot map.
1671760	1682400	And now we will map our do something function. And we will map our list of seconds. So again,
1682400	1687040	what this map method does, if you're not familiar with the built in Python map method and what it
1687040	1696080	does, basically map will run this do something function with every item of this list with every
1696080	1702240	item of whatever iterable you pass in. So that is what map does. Now, when we were using the submit
1702240	1709040	method, it returned future objects. But when we use map, it just returns the results. Now, it is
1709040	1714320	going to run those processes in parallel. But instead of returning the results as they're completed,
1714320	1720240	like we saw before, map is going to return the results in the in the order that they were started.
1720240	1726000	So to loop over these results, we can simply just do a for loop. So I'm going to say for
1726000	1734160	result in results. And then I will just print out our result, whoop, make sure that I'm printing
1734160	1740720	out the result and not that results list. Okay, so now if I run this, then we can see that all of
1740720	1746560	our processes kicked off at pretty much the same time, except for that one second when it looked
1746560	1753200	like it got outside of the pool like it did before. But they actually didn't all complete at the same
1753200	1759840	time. But when you loop over your results using map like we did here, then it returns the results
1759840	1766080	in the order that they were started. So since we slept for five seconds first, then we waited for
1766080	1771360	that one to finish before printing out the other results. But it still didn't slow us down, we can
1771360	1777520	see that our entire script still finished in five seconds here. But it looks like our five
1777520	1782320	seconds was done sleeping first, and then our four, then three, then two, then one, it actually didn't
1782320	1790240	finish in that order. But it printed out in that order, because again, it prints out the ones that
1790240	1794480	in the order that they were started and not in the order that they were finished. Now another
1794480	1799520	thing to point out here is that if our function raises an exception, it won't actually raise that
1799520	1805760	exception while running the process. The exception will be raised when its value is retrieved from
1805760	1811920	the results iterator. So if you need to handle any exceptions, then you can do that here within the
1811920	1816720	iterator if you'd like. And if you'd like to learn more about handling exceptions, then I do have a
1816720	1821360	more in depth video. If you'd like to learn more about that. So I'll be sure to leave a link to
1821360	1825600	that video in the description section below for anyone who's interested. Now even if we don't
1825600	1830960	grab our results within the context manager, it's still going to automatically join all of those
1831840	1838320	processes and let them finish after the context manager ends. So if I comment out where we are
1838320	1844800	printing out our results, let me also get rid of our old way of doing this here so that we can
1844800	1850880	see our code below our processes here. So now I'm commenting out where we're printing those results.
1850960	1857280	And if I run this, then we can see that it still didn't move on to our finish time here
1858080	1864480	until it returned the results from our processes. So anytime you're using a context manager like
1864480	1870080	this, it's going to automatically join those processes. And they're going to complete before
1870080	1875760	that context manager finishes. Okay, so now that we've looked at a basic example of using sleep,
1875760	1880000	now let's take a look at a more real world example of where using multiple processes
1880000	1886080	would be useful. So I've got another script open here where I'm not using multiple processes at
1886080	1892000	the moment. So let me open this up and let's go over what this is doing. And again, I'll have a
1892000	1896960	link to this code in the description section below for anyone who wants to follow along. So in our
1896960	1902640	last video on threading, I showed how we could use threads to go out and download some high resolution
1902640	1908080	photos from unsplash. Now if you don't know what unsplash is, it's a website that has some really
1908080	1914560	nice photos available for anyone to use. Now downloading images is something that is IO bound
1914560	1920160	since we're waiting for the images to download. So for this multi processing example, we want
1920160	1925280	something that is more CPU bound. So in this script, I'm doing some image processing on the
1925280	1929920	images that we downloaded in the threading video. And I'll have these images available in the
1929920	1934880	description section below as well, in case anyone didn't follow along with that threading video.
1934880	1940400	So let me go over the script to show you how someone might do this image processing normally.
1940400	1947360	So I'm using the pillow library here, which if you don't know what the pillow library is, it's a
1947360	1953600	image library for Python that makes it makes image processing easy. I also have a video on pillow if
1953600	1959360	you'd like to learn more about image processing. But I have a list here of image names. And these
1959360	1965200	are all of the images or all of the image names that we downloaded in the last video using threading.
1965760	1971440	So I am starting a counter here so that we can measure how long our script took.
1971440	1978000	I am setting a size of 1200 pixels. And that is what we are going to resize these high resolution
1978000	1984640	photos to. Okay, and now what I am doing is I am looping over all of those image names.
1984640	1992000	So with one image at a time, I am opening that image. And then I am running running this image
1992000	1999200	filter. And we're just doing a Gaussian blur on that image. And then I am doing an image thumbnail
1999200	2007520	and setting it to this 1200 pixel size. And then we are saving that image into a processed folder
2008320	2014000	with that the image name. And then we are printing out that that image was processed.
2014000	2019600	Now I do have a processed folder here within my directory. If you don't, you'll probably get an
2019600	2025200	error. And I also have all of these photos here within my directory. If you don't have those,
2025200	2030400	then you're also going to get an error. So you want to have all of those photos in order for
2030400	2036640	this code to work. Then after that's done, I am printing out the time that it took. And then
2036640	2043280	I am printing out that our script is finished. Okay, so this is processing 15 high resolution photos.
2043280	2049280	So if I run this now, then let's see how long this takes. So I'm running this, we can see that
2049280	2056160	it is just going through synchronously and running these one at a time. And then we will print out
2056160	2063040	the final time once this is done. Now, I think that my processing here, I think that this still
2063040	2069440	might be more IO bound than CPU bound. Because opening the image and saving this here is going
2069520	2077920	to be more of an IO bound thing. I don't know how much is actually getting CPU bound here using
2077920	2083520	this filter. But if we were doing some more computations, then this would be more CPU bound.
2083520	2089440	And we can even test this in a second. But anyways, we can see that our script finished in 22
2089440	2096880	seconds. So that's how long it took to do this image processing here on 15 of these high resolution
2096880	2101920	photos. Now, when we're processing a lot of items like this, this is actually a great candidate to
2101920	2108400	use multi processing, because this can be one of those CPU bound operations that's spending a lot
2108400	2113520	of time processing each image. And it's not moving on to the next image until the previous one
2113520	2119280	finishes. And if we use multiple processes, then it can actually go ahead and move on to the to
2119280	2125040	process another image while the previous one is finishing. And even if this is IO bound, unlike
2125040	2130800	threading, CP or multi processing is actually going to be beneficial for IO bound processes as
2130800	2136880	well. So now let's see how we can change this code so that it's using multiple processes instead.
2136880	2143280	So first, let's think about what we're doing here. So we're looping over our list of images
2143280	2149280	and processing each one at a time. So if we remember from our previous examples, then this
2149280	2156160	would probably be a good candidate for the processing pull map method, where we can pass in a function
2156160	2163200	and a list and have that function run with every value in that list. But first we'll have to create
2163200	2170000	a function that will process a single image. So to do that, if we think about this, we can basically
2170000	2177280	just replace our for loop, because our for loop is processing a single image from our images list.
2177280	2184400	So instead, we can just change this one line here and just turn this into a process image function.
2185120	2190800	And we will just accept this image name as the argument. And now that we have that function,
2190800	2198160	that process is a single image, then we can create a process pull and map our list of images using
2198160	2204960	that function. So first let's import the concurrent futures module so that we can use that. So up here
2204960	2215760	at the top, I'm going to import concurrent dot futures. And now down here below our function,
2216480	2229760	we can do this by saying with concurrent dot futures dot process pull executor as executor.
2230560	2240960	And now within our context manager, we can just say executor dot map. And we want to map this
2240960	2251840	process image function. And we want to pass in the list of these image names. Now, just in case
2251840	2259040	that was confusing, let me go over exactly what we did again, in order to change our previous
2259040	2264640	script in order to use multiprocessing. So we were using a for loop here. But instead,
2264640	2269760	we changed this to a function that processes one image at a time. And now we're using our
2269760	2276560	processing pull executor like we saw before within a context manager, we're running executor dot map.
2276560	2282640	And we are passing in that function that we created. And then we're passing in our list of
2282640	2290800	image names. And again, what map does is it runs this process image function with every item in
2290800	2296640	this image names list. And just with those small changes, this will actually use multiple processes
2296640	2303840	to process those images and run these in parallel, instead of running these synchronously. So if I
2303840	2310880	run this, whoops, and I made another mistake here, you guys probably saw that one also. But I needed
2310880	2316480	to put a colon there. Okay, hopefully that's my only mistake. Okay, so if I run this, then we can
2316480	2321760	see now these are processing faster. And I'm going to open up my activity monitor here, and scroll
2321760	2328400	down to the P's. And we can see here that we have multiple Python processes running here. So we can
2328400	2334320	actually see these in our activity monitor. And now that this script is finished, then we can see
2334320	2339600	most of those go away. The only one that's still here is probably just one that is open here in
2339600	2345680	my sublime text. So we could see all of those kick off in our activity monitor. And we could see that
2345680	2350400	they were all returning faster. That's because they were running in parallel. And now instead of
2350400	2356720	taking 22 seconds, like it did before, now it finished in seven seconds, so more than a third
2356720	2361680	of the time. So that's a pretty significant speed up there. And this would be even more
2361680	2366880	significant if we were processing even more images. So the speed ups can be pretty drastic,
2366960	2372160	depending on what you're doing. Now, again, you might want to experiment when using multiple
2372160	2377360	threads or processes for specific tasks, depending on what you're doing and what kind of hardware
2377360	2382400	you're running. One might be drastically different than the other. And it's hard to tell exactly what
2382400	2387440	you should be using without some benchmarks. But again, a good rule of thumb is that you want to use
2387440	2393520	threads for things that are IO bound. And you'll want to use processes for things that are CPU bound.
2393520	2400000	But you may actually see significant speed ups using threads with this example, since this is
2400000	2405760	reading and writing to disk, which is an IO bound operation. Now, one nice thing about using the
2405760	2410720	concurrent futures library like this is that switching between threads and processes is just
2410720	2417600	as simple as changing this process pull executor, and just using a thread pull executor instead.
2417600	2424720	And you can do that vice versa to change from threads to processes with your programs. So
2424720	2430240	if I change this to a thread pull executor, let me see if I'm right about a lot of this
2430240	2437120	being IO bound here. If I run this, then we'll see how long this takes us to finish this script
2437120	2443200	using threads instead of multiple processes. And that was actually faster. So that was 7.2 seconds.
2443200	2449040	So even though I tried to put together an example that was doing a lot of processing on the CPU,
2449040	2455920	it looks like most of this is IO bound from opening and saving these files and not CPU bound, but from
2455920	2460640	doing some image processing here with these Gaussian blurs and these resizes and things like that.
2460640	2466720	But that's okay. That's why you want to always experiment. And, you know, if you try it with
2466720	2471920	a process pulled, and maybe try it once with threads and see if you get a better execution. And
2472000	2478400	also, whenever you add in even more items, maybe processes will start to become
2478400	2482880	more performant than threads. So it really just depends on what you're doing. Now,
2482880	2488160	before we finish up here, I'd like to mention the sponsor of this video. And that is brilliant.org.
2488160	2493440	So when we're talking about threading and multi processing, these topics are especially useful
2493440	2498560	in the field of data science. And the data science field is growing at a very rapid pace.
2498560	2502400	If you'd like to learn more about programming and data science, then I would definitely recommend
2502400	2507680	checking out brilliant.org. So brilliant is a problem solving website that helps you understand
2507680	2513120	underlying concepts by actively working through guided lessons. And they've recently added some
2513120	2518800	brand new interactive content that makes solving puzzles and challenges even more fun and hands
2518800	2523440	on. And if you'd like to learn more about data science and programming with Python, then I would
2523440	2528080	recommend checking out their new probability course that covers everything from the basics
2528080	2533920	to real world applications and also fun things like casino games. They even use Python in their
2533920	2539280	statistics courses and will quiz you on how to correctly analyze the data within the language.
2539280	2543600	So their guided lessons will challenge you, but you also have the ability to get hints or even
2543600	2548160	solutions if you need them. It's really tailored towards understanding the material. They even
2548160	2553200	have a coding environment built into their website so that you can run code directly in the browser.
2553200	2557200	And that is a great compliment to watching my tutorials, because you can apply what you've
2557200	2561920	learned in their active problem solving environment. And that helps to solidify that knowledge.
2561920	2567920	So to support my channel and learn more about brilliant, you can go to brilliant.org forward slash
2567920	2574080	CMS to sign up for free. And also the first 200 people that go to that link will get 20% off the
2574080	2578400	annual premium subscription. And you can find that link in the description section below. And
2578400	2584800	again, that is brilliant.org forward slash CMS. Okay, so I think that's going to do it for this
2584800	2589760	video. I hope you feel like you got a good idea of how to use the multiprocessing module and how
2589760	2594880	we can use these to speed up our scripts. Now, I hope you also feel like you got a good overview
2594880	2600080	of threads and processes. And when you should use those. But like I said, if you're unsure,
2600080	2605360	then there's no hurt in simply trying both on a subset of your data to see what gives you the
2605360	2610480	most speed up. Now, there are some more advanced topics that we could cover in future videos,
2610480	2616000	such as race conditions, locks and things like that. But we'll save that for a future video if
2616000	2620080	anyone is interested. But if anyone has any questions about what we covered in this video,
2620080	2624000	then feel free to ask in the comment section below and I'll do my best to answer those. And if you
2624000	2627920	enjoy these tutorials and would like to support them, then there are several ways you can do that.
2627920	2631840	The easiest way is to simply like the video and give it a thumbs up. And also it's a huge help
2631840	2635520	to share these videos with anyone who you think would find them useful. And if you have the means
2635520	2639520	you can contribute to Patreon and there's a link to that page in the description section below.
2639520	2642560	Be sure to subscribe for future videos and thank you all for watching.
