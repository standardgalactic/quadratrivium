WEBVTT

00:00.000 --> 00:03.040
Hey there, how's it going everybody? In this video we're going to be learning how to use

00:03.040 --> 00:07.280
regular expressions. So we're actually going to look at regular expressions as a standalone

00:07.280 --> 00:11.360
topic because they aren't specific to any one programming language. Now there are some slightly

00:11.360 --> 00:15.760
different flavors here and there, but for the most part, whether you're programming in Python or

00:15.760 --> 00:21.200
JavaScript or Java or whatever, if you learn how to use general regular expressions, then it should

00:21.200 --> 00:25.840
mostly carry over into your language of choice. And it will also allow you to use them in text

00:25.840 --> 00:30.320
editors and the command line and things like that. Now I am going to do a follow up video where I

00:30.320 --> 00:34.640
show how to use regular expressions specifically in Python since that's a language that I cover

00:34.640 --> 00:39.360
most on this channel. But for this video, we're going to be learning how to use regular expressions

00:39.360 --> 00:43.920
by themselves so that you can apply these to other areas. So with that said, let's go ahead and get

00:43.920 --> 00:49.200
started. So regular expressions basically allow us to search for specific patterns of text. And

00:49.200 --> 00:53.600
they can look extremely complicated. But that's mainly because there's just so much that you

00:53.600 --> 00:57.680
can do with them. You can create a regular expression for just about any pattern of text that

00:57.680 --> 01:02.560
you can think of. So let's see what some of these look like. So I have a test file open here that

01:02.560 --> 01:07.680
we're going to use to search for specific patterns. And I'm going to be using the regular expression

01:07.680 --> 01:13.280
tool in the atom text editor to write these regular expressions and find what text matches our patterns.

01:13.280 --> 01:18.000
Now in order to open up this regular expression search tool, I'm just going to go to find and

01:18.000 --> 01:23.280
then find in buffer. Now you could have also opened this up with command F on a Mac. And I believe

01:23.280 --> 01:30.320
that's control F on Windows. Now within the options here, make sure that you have the dot

01:30.320 --> 01:35.680
asterisk selected over here because that's going to tell our search tool to use regular expressions.

01:35.680 --> 01:41.200
And also select this match case option here as well. That's just going to give us behavior that

01:41.200 --> 01:46.000
is more common to how regular expressions usually behave. Okay, so let's start writing some regular

01:46.000 --> 01:51.040
expressions. And first we'll start off kind of simple. So first of all, we can just search for

01:51.040 --> 01:57.120
literal characters. So if I was to search for ABC, then we can see here at the top that it

01:57.120 --> 02:03.920
highlighted ABC because it matched the ABC and our lowercase alphabet. Now it didn't match the

02:03.920 --> 02:10.320
capital ABC here because it's case sensitive. Now this search right now is looking specifically

02:10.320 --> 02:16.720
for A, B, and C. But if I was to type in something like BCA, then we can see that there were no

02:16.720 --> 02:23.280
results found because the order does matter. Now if we look at this meta character section here,

02:23.280 --> 02:28.560
I have some examples of characters that I say need to be escaped. So for example,

02:28.560 --> 02:35.920
if you wanted to search for a literal period, now if I was to just type in a period here and

02:35.920 --> 02:40.720
hit enter for my search, then we can see that it does this weird thing where it matches everything.

02:40.720 --> 02:46.320
And that is because the dot is a special character in regular expressions. And we'll see more of this

02:46.320 --> 02:52.160
in just a second. But for now, if we just wanted to actually search for a period or a dot, then we

02:52.160 --> 02:58.480
have to escape it. And to escape characters, we can use the backslash. So if I do a backslash and

02:58.480 --> 03:05.040
search, then now we can see that it only matches the actual literal dot or period within our document

03:05.040 --> 03:09.760
here. And that goes for any of these meta characters that I've listed here. So for example,

03:09.760 --> 03:14.560
we can see that the backslash is a special character also. So if you wanted to search

03:14.560 --> 03:20.240
specifically for a backslash, then you have to escape itself. So a backslash to escape,

03:20.240 --> 03:24.560
and then a backslash for the search. And if I search for that, then we can see that we matched

03:24.560 --> 03:30.240
a literal backslash. So a practical example of this might be trying to match this URL right here.

03:30.240 --> 03:36.000
So if we wanted to match that literal URL, exactly, then we could just say corey Ms.

03:36.000 --> 03:41.680
And then for the dot on the dot com, we have to escape that with a backslash and then a period,

03:41.680 --> 03:46.320
and then a com. And we can see that it matches our URL. Okay, so that's how you match literal

03:46.320 --> 03:50.800
characters. But a literal search isn't too exciting, because we're used to that already.

03:50.800 --> 03:55.040
Really, we want to use regular expressions to search for patterns. And to do this, we're going

03:55.040 --> 04:00.480
to be using some of these meta characters that we were just escaping. So I have a snippets file

04:00.480 --> 04:05.920
open here. So I'm going to switch over to this. And in here, I have a list of values where we can

04:05.920 --> 04:10.640
see the types of characters that we can match. Now just for now, I'm going to try to make this

04:10.640 --> 04:17.360
into a split screen here, as we're walking down this list. So the first one I have listed here

04:17.360 --> 04:23.440
is this dot or period. And we can see that this matches any character except a new line. Now we've

04:23.440 --> 04:28.880
already seen this, but let's take a look again. If we just do a dot and search for that, then we

04:28.880 --> 04:33.920
can see that it matches any character except it does not match the new lines. Okay, so next on

04:33.920 --> 04:41.520
the list is backslash D. And that matches any digit zero through nine. So if I was to do a backslash

04:41.520 --> 04:46.640
D here and search for that, then you can see that this matches all of our digits. So anything

04:46.640 --> 04:51.760
zero through nine, it matches. Now we also have an uppercase D here. And that matches anything

04:51.760 --> 04:57.840
that is not a digit. So if I search for an uppercase D, then we can see that our digits are not

04:57.840 --> 05:03.120
matched. But everything else is highlighted. So it matched everything except for the digit. Now

05:03.120 --> 05:08.400
you'll notice that this is a common theme here that the uppercase versions of all of these are the

05:08.400 --> 05:15.200
ones that kind of negate the search. So moving on down here, we have backslash w that searches for

05:15.200 --> 05:21.840
any word character and a word character is lowercase a through z uppercase a through z zero through

05:21.840 --> 05:28.080
nine and an underscore. So let's search for the word character. And we can see that it matches,

05:28.080 --> 05:32.480
you know, all these lowercase uppercase numbers and things like that. It doesn't match these

05:32.480 --> 05:38.720
special meta characters here. And just like with the digit, the uppercase w will match anything that

05:38.720 --> 05:44.720
is not a word character. So anything that is not in this list here. So let's go ahead and search

05:44.720 --> 05:50.160
for that uppercase w. And we can see that, you know, it picks up the spaces and these special

05:50.160 --> 05:55.520
punctuations and things like that. But it does not match the word characters that we saw before.

05:55.520 --> 05:59.200
Now, if you're not quite getting this just yet, we are going to look at a lot of examples to where

05:59.200 --> 06:04.720
it'll start to sink in. So moving down the list here, we have backslash s, which will match any

06:04.720 --> 06:12.080
white space. And white space is a space tab or a new line. So if we search for backslash s,

06:12.080 --> 06:17.280
then we can see that it matches our new lines here and our spaces, but it doesn't match any of these

06:17.280 --> 06:22.800
characters in here. So it's mainly white space. And just like with the others, the capital s

06:22.800 --> 06:27.600
will search for anything that is not white space. So now you can see that we have, you know, all

06:27.600 --> 06:33.200
these lowercase uppercase digits and then also this punctuation, anything that isn't a new line

06:33.200 --> 06:38.640
or a space or anything like that. Now these bottom ones over here, the backslash b, the

06:38.640 --> 06:43.760
carrot and the dollar sign, these ones are a little bit different. So these are called anchors.

06:43.760 --> 06:50.880
And they don't actually match any characters, but rather they match invisible positions before or

06:50.880 --> 06:57.200
after characters. So let's see what I mean by this. So for a word boundary, if I search for a

06:57.200 --> 07:04.240
word boundary here. So now let's search for where we have this ha ha ha here. Let's search for a

07:04.240 --> 07:11.120
word boundary and then ha and match that. So we can see that that matched because there is a word

07:11.120 --> 07:17.760
boundary here at the start of this line before this first one here. And this space here is also

07:17.760 --> 07:23.920
word boundary. So this one gets matched as well. But this last one does not get matched because

07:23.920 --> 07:29.520
there's no word boundary between these two ha's here. Now just to show what this would look like

07:29.520 --> 07:33.920
without the word boundary. If I was to search for that, then you can see that it highlights all three

07:33.920 --> 07:40.000
of those. Now just like with the other ones, if I do a an uppercase b, then that matches anything

07:40.000 --> 07:45.760
that is not a word boundary. So if I do an uppercase b, then we can see that we match the one that it

07:45.760 --> 07:51.040
didn't match before, because there is no word boundary between these two here. So it doesn't

07:51.040 --> 07:57.840
match these first two. Now if I was to put word boundaries on both sides of these, then it should

07:57.840 --> 08:04.640
only match this first one, because this is the only one that has a word boundary at the beginning,

08:04.640 --> 08:11.040
which we're matching here, and at the end. So this one has a word boundary at the beginning,

08:11.040 --> 08:16.720
but not at the end because it's in the middle of this word. And this one has a word boundary at

08:16.720 --> 08:22.000
the end, but not at the beginning. Okay, so our other two anchors here are pretty similar. So the

08:22.000 --> 08:28.080
carrot matches the position at the beginning of a string, and the dollar sign matches the position

08:28.080 --> 08:34.880
at the end of a string. So let's say for example, that we only wanted to match a ha if it was at

08:34.880 --> 08:42.160
the beginning of a string. So for example, if I was to do a carrot and then a ha and match that,

08:42.160 --> 08:45.760
then we can see that it only matched this one, because it's the only one

08:45.760 --> 08:51.440
that is at the beginning of a line. Now if we wanted to only match it if it was at the end,

08:51.440 --> 08:57.120
then we could put that dollar sign at the end. And what we're saying here is that we only want

08:57.120 --> 09:03.600
to match this if the end of the string is the is in the following position. So we can see that it

09:03.600 --> 09:08.960
not only matches this last one, because the end of the string is the next position in line. Okay,

09:08.960 --> 09:14.320
so now that we've seen what we can match with these special characters here, now let's go ahead

09:14.320 --> 09:19.520
and take a look at some practical examples. So I'm going to move my snippets file back here,

09:19.520 --> 09:24.960
and we will keep referencing that later on. But for now, let's go ahead and say that we wanted

09:24.960 --> 09:29.120
to match a couple of phone numbers. And let's write some regular expressions to do this. Now

09:29.120 --> 09:34.160
with a phone number, we can't just type in a literal search like we did before, because all of these

09:34.160 --> 09:40.400
are different. So they have a similar pattern, but they're not all the same digits. So in this case,

09:40.400 --> 09:46.800
we need to use the meta characters instead of literal characters. So we just have a pattern here

09:46.800 --> 09:53.440
of three digits, and then a dash or a period, and then three more digits, and then a dash

09:53.440 --> 09:59.920
or a period, and then four digits at the end. So we saw before that we can match a digit with a

10:00.000 --> 10:06.480
backslash d. And that is going to match all of the digits in our file. So we want to match

10:06.480 --> 10:12.400
this phone number here. So we want to match first three digits in a row. So we can just put in

10:12.400 --> 10:17.920
three backslash d's, and that will match any three digits in a row. So now that we're matching

10:17.920 --> 10:22.400
those first three digits, now we're getting to where we can see that we're either going to match

10:22.400 --> 10:28.960
a dash or a dot in our phone number. So for now, let's just match any character that's in this

10:28.960 --> 10:34.640
position. So from our snippets file, we saw that if we want to match any character that we can use

10:34.640 --> 10:40.080
a dot. So we can see that for now, our pattern is still matching some other stuff as well. But

10:40.080 --> 10:46.320
let's just continue on. So now that we're matching this hyphen or this dot, now let's go ahead and

10:46.320 --> 10:52.880
add in the next three digits. So we want to search for three more digits. So I'll do three backslash

10:52.880 --> 10:58.800
d's. And now we're going to want a dot to match any character, which should match that dash or

10:58.800 --> 11:05.440
that dot. And now we want four digits. So we can just do four backslash d's. So now we can see that

11:05.440 --> 11:10.320
this regular expression highlights both of our phone numbers and matches both of those. So now

11:10.320 --> 11:16.080
we're starting to see how this could be pretty useful. So for example, I have a data file here.

11:16.080 --> 11:21.920
Now if I pull this up, then I have a bunch of fake names and numbers and addresses and emails.

11:21.920 --> 11:26.320
But if I wanted to match all of the phone numbers in this file, then you can see that the regular

11:26.320 --> 11:32.080
expression that we just wrote matches all of the phone numbers here. So now we're starting to kind

11:32.080 --> 11:36.880
of get a sense of how this could be more useful than just a literal search, because now we're

11:36.880 --> 11:43.360
actually searching for a specific pattern. So now let me go back to our simple text file here.

11:43.360 --> 11:47.600
So now let's get a little bit more specific. So let's say that we only wanted to match a phone

11:47.600 --> 11:53.840
number if it had a dash or a dot. Now right now, this pattern will match any separator,

11:53.840 --> 11:59.280
because we're using the period down here, which will match any character. So if I was to put in

11:59.280 --> 12:06.560
a another number here that doesn't have a regular separator, let's just say it's an asterisk,

12:06.560 --> 12:11.120
then we can see that it matches this number as well, even though the asterisk isn't really a

12:11.120 --> 12:17.360
phone number separator. So to only match the dash or the dot, we're going to have to use a character

12:17.360 --> 12:23.680
set. And a character set uses square brackets with the characters that we want to match. So to

12:23.680 --> 12:28.640
create a character set, I'm going to replace our first dot here. And this is going to be square

12:28.640 --> 12:34.240
brackets. Now this is a character set. Now within this character set, we want to put the characters

12:34.240 --> 12:41.040
that we want to match. So we want to match either a dash or a dot. And I will just copy that and

12:41.040 --> 12:46.880
we'll replace this second dot here, which was matching any character. And we will put that

12:46.880 --> 12:52.880
in for that as well. And now you can see that it only matches our phone numbers here that have a

12:52.880 --> 12:58.480
dash or a dot separator. And it does not match this one with the weird asterisk there. Now you

12:58.480 --> 13:04.000
probably also notice that we didn't need to escape our dot character within our character set. And

13:04.000 --> 13:08.880
that's because character sets have some slightly different rules. Now you can escape these characters

13:08.880 --> 13:13.600
if you'd like. But it just makes it a lot more difficult to read if you do that. Now even though

13:13.600 --> 13:19.760
the character set has multiple characters here in the set, it's still only matching one character

13:19.760 --> 13:26.080
in our text. It's matching one character that is either a dash or a period. But if I was to put in,

13:26.080 --> 13:31.600
let's say two dashes here into one of these numbers, then you can see now it doesn't match that number

13:31.600 --> 13:38.080
because it's only matching the first dash or a dot. And then it moves right on to looking for a

13:38.080 --> 13:42.480
digit. So it's looking for a digit in this position. So that's something that can kind of throw

13:42.480 --> 13:46.560
people off when they first start working with regular expressions. So even though, you know,

13:46.560 --> 13:50.880
we have four characters total here in this character set with these square brackets,

13:50.880 --> 13:56.720
and all of the characters in this set, it's still only searching for one literal character up here,

13:56.720 --> 14:02.080
which is either a dash or a dot. Now to show another example of this, let's say that we only

14:02.080 --> 14:08.640
wanted to match 800 and 900 numbers. So I'm going to create two different numbers here. I'll do an

14:08.640 --> 14:16.720
800 number and a 900 number here. So if we only wanted to match 800 and 900 numbers, then our first

14:16.720 --> 14:22.160
three digits here, we have to do something different. So first, we want the first digit that we're

14:22.160 --> 14:27.680
going to match to either be an eight or a nine. So we can do a character set. And we can say that

14:27.680 --> 14:34.480
we're looking to either start with an eight or a nine. Now the following two numbers are going to be

14:34.480 --> 14:40.480
zero zero. And that's just a literal search. So now you can see that we're finding the 800 and 900

14:40.480 --> 14:46.960
numbers here. Now within our character set, the dash is actually a special character as well.

14:46.960 --> 14:52.400
So when it's put at the beginning or the end of the character set, then it will just match the

14:52.480 --> 14:58.960
literal dash. But when it's placed between values that can actually specify a range of values. So

14:58.960 --> 15:05.520
for example, we know that the backslash D matches any digit. But what if we only wanted to match

15:05.520 --> 15:11.840
digits between let's say one and seven. So to do that, we can use a character set. And we can just

15:11.840 --> 15:19.040
say instead of typing out 1234567, if we wanted to specify a range of those values, then we can

15:19.120 --> 15:24.880
just say one dash seven. So now we can see that we're matching all of the digits between one and

15:24.880 --> 15:30.800
seven, but the eight, nine and the zero aren't getting matched up here. Now you can do this with

15:30.800 --> 15:36.880
letters as well. So if we only wanted to match the lowercase letters a through Z, then we could just

15:36.880 --> 15:42.560
do a character set of a through Z. Now you can see all of the capital letters aren't getting matched,

15:42.560 --> 15:47.920
but the lowercase ones are. Now if we wanted to match the uppercase and lowercase numbers,

15:47.920 --> 15:54.400
then we could just put our ranges back to back. So I could say a through Z and then just add on

15:54.400 --> 16:00.960
to this character set and say capital A through capital Z. And now we're matching all letters,

16:00.960 --> 16:05.840
regardless of whether they are uppercase or lowercase. And you could keep adding to those ranges.

16:05.840 --> 16:10.960
If you wanted to, you could do a zero through nine there as well, to add in all digits. Now

16:10.960 --> 16:17.440
another special character in our character set is the carrot. Now we saw before that outside of the

16:17.440 --> 16:22.880
character set, it matches the beginning of a string, but within the character set, it negates

16:22.880 --> 16:28.720
the set and matches everything that is not in the set. So for example, if we wanted to match every

16:29.520 --> 16:36.720
character that is not a lowercase letter, then we could say this carrot and then A through Z.

16:36.720 --> 16:41.360
So we can see that it matches everything on our screen that isn't a lowercase letter. It's not

16:41.360 --> 16:46.720
matching these lowercase letters here. So it's even matching these new lines and the spaces and

16:46.800 --> 16:53.520
everything. So just to show another example of this, let's say that we had some words here,

16:53.520 --> 17:01.280
cat, mat, pat, and bat. So let's say that we wanted to match every word that ends in A-T,

17:01.280 --> 17:08.400
except bat. We don't want to match bat. So to do this, we can just say that we want a character

17:08.400 --> 17:15.680
set of everything that is not B, followed by A-T. So now we can see that it matches all of these

17:15.680 --> 17:22.480
three letter words that end in A-T, except for bat, because our character set here negated that B.

17:22.480 --> 17:28.160
So everything that we've looked at so far has involved single characters. So in this example

17:28.160 --> 17:35.200
right here, we're matching any single character that is not a B, then followed by an A, and then

17:35.200 --> 17:40.640
followed by a T. But we can actually use these things called quantifiers to match more than one

17:40.640 --> 17:46.720
character at a time. So let's go back to our original phone number example from earlier,

17:46.720 --> 17:53.040
and we'll just match any character like we did before. So I will do three digits and then a

17:53.040 --> 17:59.120
period for any character, and then three digits again, and a period for any character, and then

17:59.120 --> 18:04.160
four digits at the end. And I'm just going to remove what we had there for an example

18:04.160 --> 18:10.320
and scroll those back up. So to see what quantifiers we have available, I'm going to make my snippets

18:10.400 --> 18:16.400
half of my screen here again, and then scroll down to my quantifiers section. So the asterisk will

18:16.400 --> 18:23.440
match zero or more of what we're searching for. The plus sign will match one or more. The question

18:23.440 --> 18:29.600
mark will match zero or one. And to match exact numbers, we can use these curly braces with a

18:29.600 --> 18:34.560
number on the inside. So in this example, this would match exactly three of what it is we're

18:34.560 --> 18:40.560
looking for. And we can also specify a range of numbers as well, with the first number being the

18:40.560 --> 18:46.720
minimum, and the last number being the max. So this would search for whatever our pattern is. It

18:46.720 --> 18:51.920
would look for three or four of those. So let's take a look at an example of this to see how this

18:51.920 --> 18:57.920
works. So you can see that with our phone number, we are searching for one digit at a time. But we

18:57.920 --> 19:05.120
could change this. If I erase my digits here, then we could say that I'm searching for a digit.

19:05.120 --> 19:12.080
And then we could put in our quantifier for exactly three digits. And we could do this

19:12.080 --> 19:18.720
after our separator as well. So we're searching for three digits, and then any character. And then

19:18.720 --> 19:24.800
here at the end, we want to match four digits. So instead of writing out the same characters over

19:24.800 --> 19:31.040
and over, we can see how these quantifiers allow us to specify exactly how much we want. Now here

19:31.040 --> 19:36.480
we're matching exact numbers. But sometimes we don't know the exact number. And we'll need to use one

19:36.480 --> 19:42.560
of these other quantifiers. So for example, here at the bottom of this test file here, we have some

19:42.560 --> 19:49.680
lines where each starts with a prefix of mister, or miss, or misses. So let's say that we wanted to

19:49.760 --> 19:57.280
match these prefixes, as well as the names after. So just to start, let's start by matching the names

19:57.280 --> 20:04.000
that start with mister. Now we can see that some of these have a period after the prefix, and some

20:04.000 --> 20:11.440
do not. Some of them just have a space. So let's start our regular expression by searching for

20:11.440 --> 20:16.560
lines that start with mister. And then we're going to put a backslash period to search for that

20:17.440 --> 20:23.840
literal period. And right now it isn't matching this mister Smith, which doesn't have a period

20:23.840 --> 20:31.280
after the prefix. Now to match that also, we can use this question mark quantifier, which tells our

20:31.280 --> 20:38.000
pattern that we want to match zero or one of that character. So if I put a question mark after that

20:38.000 --> 20:44.480
literal period, then it's saying that there can be zero periods there, or there can be one. So we

20:44.480 --> 20:49.680
can see that now it's matching the ones with one period there, and it's also matching the one with

20:49.680 --> 20:58.160
no period. So now to continue and match the entire line. Now we want to match a space after that.

20:58.160 --> 21:04.960
And after the space, we want to match any uppercase letter. And to do that, we can use

21:04.960 --> 21:10.880
our character class, and we can match any uppercase letter by doing a range of uppercase letters

21:10.880 --> 21:16.400
there. So at this point, after that first uppercase letter that we match, we've completely matched the

21:16.400 --> 21:22.160
name for Mr. T down here at the bottom. But we still need to match the rest of our other names.

21:22.160 --> 21:29.600
So we could say that we will match any word character after that uppercase. So let's put in

21:29.600 --> 21:34.480
a backslash w to match any word character. And now we don't know how many more characters are

21:34.480 --> 21:40.240
going to be in our name. So we'll have to use a quantifier here. Now if we look over here,

21:40.240 --> 21:45.760
we could use the asterisk or the plus sign. And the plus sign will match one or more of

21:45.760 --> 21:52.400
these word characters. And the asterisk will match zero or more. So if we used the plus sign,

21:52.400 --> 21:59.040
then we can see that it matches our two top names here. But now it's not matching this Mr. T because

21:59.040 --> 22:04.880
after our word character, it's searching for one or more word characters after our uppercase

22:04.880 --> 22:10.800
character. So a better solution in this case, maybe to use the asterisk, which matches zero or

22:10.800 --> 22:17.120
more word characters. And if we use that asterisk, then we can see that it matches all three of our

22:17.120 --> 22:22.320
names that begin with Mr. Now I know that we've covered a lot so far, but we've got a couple

22:22.320 --> 22:27.200
of more concepts to go. And then we'll look at some examples that wrap everything together.

22:27.200 --> 22:34.160
So we still haven't matched our miss or misses names here. So how would we do that? So you might

22:34.160 --> 22:41.280
think that we could use a character set that matches either an r or an s. And there are maybe

22:41.280 --> 22:46.400
some ways that we could get that to work. But it probably would be a bit ugly, since we'd have to

22:46.400 --> 22:53.360
match either an r or an s as the second character and then the optional s after that. So that could

22:53.360 --> 22:58.160
get kind of ugly. But I think a better solution here would be to use a group. Now we haven't looked

22:58.240 --> 23:04.480
at groups yet. But groups allow us to match several different patterns. And to create a group, we use

23:04.480 --> 23:11.840
parentheses. So after the m here, instead of just searching for Mr, I'm going to create a group

23:11.840 --> 23:18.560
with open and closed parentheses here. And now within our group, we can specify different

23:18.560 --> 23:24.960
matches. So I can say that we want to match either an r and then or and we use this character here

23:24.960 --> 23:31.360
to specify an or. And that is just the vertical bar character to specify an or. So we can say that

23:31.360 --> 23:37.840
we want to match an r or an s. And whenever we add that in, we can see that now we're matching the

23:37.840 --> 23:44.640
miss name here. But we're still not matching this misses. So to match the misses, we can put in

23:44.640 --> 23:50.560
another or and say that we want to match an RS. Okay, so now we can see that we are matching

23:50.560 --> 23:54.960
all of our names here. So let's do a quick walkthrough of this one more time to make sure

23:54.960 --> 24:01.680
we know what's going on. So we have a capital M to start. And then that capital M is followed by

24:01.680 --> 24:11.520
either an r and s or an RS. And then we are looking for a literal period. And this question mark says

24:11.520 --> 24:17.040
that we can have zero or one of those. So that is optional. So it's matching the ones that do have

24:17.040 --> 24:22.800
that period and the ones that don't. And then after that, we are matching a space. Then after

24:22.800 --> 24:28.720
that space, we the first letter of the last name, we're looking for any capital letter. So we have

24:28.720 --> 24:34.800
a character set here that is a through Z of capital letters. And then for the rest of the last name,

24:34.800 --> 24:41.920
we are matching zero or more word characters. Now these groups can actually be used to capture

24:41.920 --> 24:46.320
sections of your matched regular expression. And that's something that we'll look at in just a

24:46.320 --> 24:51.600
minute. But for now, let's do a quick recap of everything that we've learned so far. And look

24:51.600 --> 24:56.720
at some examples that incorporates all of these things together. So I have a file here and I'm

24:56.720 --> 25:03.840
going to move my snippets back into the group here and open up this file emails.txt. So I've got a

25:03.840 --> 25:08.560
file here with three fairly different email addresses. So let's try to write a regular

25:08.560 --> 25:14.640
expression that will match all of these emails. So let's just match the first email address first

25:14.640 --> 25:20.240
and see what that looks like. So the first email address, we have a mix of upper and lowercase

25:20.240 --> 25:26.960
letters here before we hit this at symbol. So let's go ahead and match those first. So to match

25:26.960 --> 25:33.520
any upper or lowercase letters, we can do a character set. And we can do a lowercase a through

25:33.520 --> 25:40.000
Z or an uppercase a through uppercase Z. Now right now, this is only matching those single

25:40.000 --> 25:46.720
characters. So we can use the plus quantifier to say that we want one or more of these upper or

25:46.720 --> 25:51.760
lowercase letters. So we're still working on the first email address here, we have our upper and

25:51.760 --> 25:56.560
lowercase letters here. And now we want to match that at symbol. So I'll just put in a literal

25:56.560 --> 26:03.120
at symbol. And now for the domain name here, I'll just do a another search for any upper or lowercase

26:03.120 --> 26:09.920
letters. So I'll do the same as we did before. And then I will do a plus sign for a quantifier to

26:09.920 --> 26:16.000
match any upper lowercase letters after that at symbol. And then that's when we hit the end with

26:16.000 --> 26:22.640
the dot com. So to match the dot com, we can do a backslash period for the dot. And then we can

26:22.640 --> 26:28.320
just fill in a literal com. So now we've successfully matched that first address. Now it looks like

26:28.320 --> 26:34.240
it's not matching the second address. So let's see why and see if we can mold this to match the

26:34.240 --> 26:40.240
second address as well. So we can see that the second address has a dot in the first part of

26:40.240 --> 26:47.680
the name here. So let's add a dot to our first character set, so that dots are included in

26:47.680 --> 26:54.080
that character set. So now it's still not matching that second address. And it's because at the end

26:54.080 --> 27:01.200
here, we don't have a dot com but a dot edu. So in order to search for both, we can use a group

27:01.200 --> 27:09.360
like we saw before using open and close parentheses. And we can search for either com or edu. Okay, so

27:09.360 --> 27:14.640
now we are building this up a little bit at a time. And we can see that we are now matching our

27:14.640 --> 27:19.680
second email address. Okay, so now let's see if we can change this to match our third email address

27:19.680 --> 27:27.440
here. So in our third email address, it looks like before the at symbol, we also have some hyphens

27:27.440 --> 27:33.280
and some numbers in the first part here. So let's add those to the character set as well.

27:33.280 --> 27:41.520
So back here after our capital letters, I'm also going to add in digits by doing zero through nine.

27:41.520 --> 27:48.800
And we also want to add a dash in there as well. So that should match everything before the at symbol.

27:48.800 --> 27:54.400
Now it looks like we also have a dash in our domain here. So we'll have to add that in as well.

27:54.400 --> 28:00.400
So after the at symbol, we're matching any characters right now, it's just lowercase and uppercase,

28:00.400 --> 28:06.560
but we can put a dash in there as well. And lastly, it's still not matching because just like the

28:06.560 --> 28:13.600
other two instead, we have a dot net here instead. So we can just add in a second or at the end and

28:13.600 --> 28:19.760
also include dot net. So we can see that we built that up a little bit at a time to match all three

28:19.760 --> 28:24.720
of our email addresses. Now with something like email addresses, it can be pretty tough writing

28:24.720 --> 28:29.920
your own regular expressions from scratch. But there are a lot of these available online. And

28:29.920 --> 28:34.960
once we learn how to write regular expressions, then we should be able to read them and figure out

28:34.960 --> 28:40.320
how they're matching as well. Now, I've always found that reading other people's regular expressions

28:40.320 --> 28:45.680
to be a lot harder than writing them. But let's take a look at one and see if we can do this.

28:45.680 --> 28:51.680
So I have an expression here that I pulled offline that matches email addresses. And let's

28:51.680 --> 28:57.520
paste this in here and see if we can read through and see what this is matching. So we can see that

28:57.520 --> 29:02.880
the one that I got offline does match all three of my email addresses here. Now let's look through

29:02.880 --> 29:08.640
this. So we can see that it's somewhat similar to what we had before. But first we have a character

29:08.640 --> 29:16.400
set here and it's a pretty large character set. And it matches lowercase, uppercase, any number,

29:17.120 --> 29:24.240
an underscore, a period, a plus sign, or a hyphen. And then the plus sign here says that we want to

29:24.240 --> 29:30.000
match one or more of any of those characters. And we match one or more of those characters

29:30.000 --> 29:35.680
all the way up until we hit an at sign. And then after the at sign, we have another character set

29:35.680 --> 29:43.120
here. And in this character set, we have lowercase letters, uppercase letters, any digits, and also

29:43.120 --> 29:48.720
a hyphen. Now I don't know a lot about email addresses, but I'm assuming that since they left out the

29:48.720 --> 29:53.920
underscore, the period, and the plus sign that were in the first part of the email address,

29:53.920 --> 29:58.560
I'm assuming that those aren't allowed in the domain. So then we have a plus sign after that

29:58.560 --> 30:03.680
character set, which means that we're matching one or more of any of those characters all the way

30:03.680 --> 30:10.240
up until we reach this literal dot. And that literal dot is escaped with a backslash. And then

30:10.240 --> 30:15.760
after the dot, we have another character set here. And this character set is any lowercase letter,

30:15.760 --> 30:23.280
any uppercase letter, any digits, any hyphen, or a period. And then that is followed by a plus sign,

30:23.280 --> 30:28.320
which matches one or more of anything in that character set. So just like I did with the phone

30:28.320 --> 30:34.080
numbers, if we open up our data file here, with this regular expression that we've typed in,

30:34.080 --> 30:40.400
then we can see that it does match all of the email addresses in this data file as well. So we've

30:41.200 --> 30:46.480
got an expression that will match email addresses fairly well. So doing what we just did and reading

30:46.480 --> 30:51.920
through a regular expression written by other people is probably the hardest part of all this.

30:51.920 --> 30:57.120
But if you walk through it bit by bit, then you should be able to break down just about any pattern.

30:57.120 --> 31:01.920
Okay, so the last thing that I'd like to look at in this video is how to capture information

31:01.920 --> 31:08.080
from groups. Now, we've already seen how to match groups, but we can actually use the information

31:08.080 --> 31:13.760
captured from those groups. So to show an example of this, I'm going to open up a file here with

31:13.760 --> 31:22.640
some URLs. Okay, so we can see here that some of the URLs are HTTP, some are HTTPS. Also, some of

31:22.640 --> 31:28.960
these have WWW before the domain name, and some do not. So let's say that you had a list of a lot

31:28.960 --> 31:35.200
of different URLs within your document, and you only wanted to grab the domain name and the top

31:35.200 --> 31:41.200
level domain, which is .com or .gov. So for example, out of all these domains, you only wanted to grab

31:41.200 --> 31:48.800
google.com or coreyms.com or youtube.com or nasa.gov. And you just wanted to ignore everything else.

31:48.800 --> 31:54.080
So let's see how we can do this. So first, let's write an expression that actually matches these

31:54.080 --> 32:01.840
URLs. So let me get rid of the one that we currently have. Now, first, to match this, we can say

32:01.840 --> 32:09.360
all of these start with with HTTP. And then the s is optional. So we can say s and then put in a

32:09.360 --> 32:15.520
question mark to say that we want to match zero or one for the s. And then after that optional s,

32:15.520 --> 32:20.960
we want a colon forward slash forward slash. So at this point, some of these domains have a

32:20.960 --> 32:30.240
WWW dot before the domain name and some do not. So that WWW dot is optional. So since this isn't

32:30.240 --> 32:38.160
one character, we're actually going to create a group here and say this group of WWW and then a

32:38.160 --> 32:44.560
literal dot, which is a backslash dot. Now, all of that group is optional. So now you can see on

32:44.560 --> 32:49.920
all of our URLs, we've matched up to the domain name. So now to complete this, I'm just going to say

32:50.720 --> 32:58.640
any word character, so backslash w, and I will put in a plus sign to say one or more of those word

32:58.640 --> 33:04.960
characters. And then we get here to the top level domain. So we want to match a literal dot. So we'll

33:04.960 --> 33:10.400
do a backslash dot. And then for the rest of that top level domain, I will just do any word

33:10.400 --> 33:16.960
character one or more times so we can do a word character with a plus sign to do one or more.

33:16.960 --> 33:23.600
Okay, so we can see that this matches all of our URLs. But the point here was to use our groups

33:23.600 --> 33:30.640
to capture some information from our URLs. So let's capture the domain name and the top level

33:30.640 --> 33:36.560
domain, which is the dot com or the dot gov and things like that. So to capture these sections,

33:36.640 --> 33:43.440
we can just put them in a group by surrounding them in parentheses. So what we want to group here

33:43.440 --> 33:50.400
is our domain name. And the domain name is this part right here, this string of one or more word

33:50.400 --> 33:55.360
characters. So I'm just going to wrap those in parentheses and create a group. And we've seen

33:55.360 --> 34:00.400
that before. And now we also want to put the top level domain in a group as well. That is the dot

34:00.720 --> 34:07.920
com or the dot gov. So we can put a parentheses around that dot, and then also around the ending

34:07.920 --> 34:12.400
there that is the string of one or more word characters. Okay, so we can see that we're

34:12.400 --> 34:17.840
still matching all of our URLs here. But now we have three different groups. So our first group

34:17.840 --> 34:25.120
is just that optional www dot. Our second group is the word characters that make up our domain name.

34:25.120 --> 34:31.200
And the third group is that top level domain. Now there's also an implicit group zero. And

34:31.200 --> 34:37.920
group zero is everything that we captured. So in this case, it's the entire URL. So now let's get

34:37.920 --> 34:42.560
to the cool part about this. So let me show you what we can do now that we've captured these.

34:42.560 --> 34:48.560
So we can use something called a back reference to reference our captured group. So for example,

34:48.560 --> 34:54.720
here in Adam, we have the ability to replace our matches, we can see down here that we can replace.

34:54.720 --> 35:02.320
So let's replace all of our matches with just the literal text group one, and then a colon,

35:02.320 --> 35:09.280
and then a dollar sign one. Now this dollar sign one is a reference to our first group. Now sometimes

35:09.280 --> 35:16.080
this is a backslash. But for some reason in Adam, they use a dollar sign. So if I do a replace all

35:16.080 --> 35:22.800
here, then we can see that it replaced our matches with this literal text group one. But then it

35:22.800 --> 35:28.880
also replaced the dollar sign one with our first captured group. And the first capture group is that

35:28.880 --> 35:36.080
optional www dot. So for the ones for the domains that had that www, we can see that it shows up.

35:36.080 --> 35:42.320
And for ones that didn't, it doesn't have anything. So let me undo this. And now let's replace our

35:42.320 --> 35:48.720
matches with the second group. And now the second group should be the domain name. So now if I do

35:48.720 --> 35:55.680
a replace all now, then we can see that now it says group two is Google, CoreMS, YouTube,

35:55.680 --> 36:02.960
and NASA. And if I undo that, and replace this with the group three, then the group three should

36:02.960 --> 36:09.200
give us our top level domain. So our group three is the dot com dot com dot gov things like that.

36:09.200 --> 36:13.760
So let me undo this one more time. So now that we know how to use those back references,

36:13.760 --> 36:19.520
then we can actually take our regular URLs and clean them up like we meant to from before.

36:20.320 --> 36:27.680
So we could convert these to a cleaned up version without the HTTP or the www just by replacing

36:27.680 --> 36:34.400
our matches with the domain name, which is group two, followed by the top level domain,

36:34.400 --> 36:39.840
which is group three. So now if I replace all of our selections with those two,

36:39.840 --> 36:44.880
then we can see that replaced all of our URLs with just the domain name and the top level domain.

36:44.880 --> 36:49.760
So you can imagine if you had a lot of information like this that you needed to clean up or modify

36:49.760 --> 36:54.800
in some way, then knowing how to match these groups with regular expressions could save you

36:54.800 --> 36:59.120
a ton of time with doing things like this. Okay, so I think that's going to do it for this video.

36:59.120 --> 37:03.360
Now there's a lot of advanced features that we could go over with regular expressions as well.

37:03.360 --> 37:07.920
So if anyone is interested in learning more, then I could put together an advanced video

37:07.920 --> 37:12.400
covering those topics in the near future. But hopefully now you feel comfortable with being

37:12.400 --> 37:17.280
able to read and write these regular expressions that we went over in this video. But if anyone

37:17.280 --> 37:21.360
does have any questions about what we covered in this video, then feel free to ask in the comment

37:21.360 --> 37:25.520
section below and I'll do my best to answer those. And if you enjoy these tutorials and would like to

37:25.520 --> 37:29.600
support them, then there are several ways you can do that. The easiest ways to simply like the video

37:29.600 --> 37:33.440
and give it a thumbs up. And also it's a huge help to share these videos with anyone who you think

37:33.440 --> 37:37.280
would find them useful. And if you have the means you can contribute your Patreon and there's a link

37:37.280 --> 37:41.280
to that page in the description section below. Be sure to subscribe for future videos and thank

37:41.280 --> 37:45.280
you all for watching.

