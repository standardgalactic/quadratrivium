1
00:00:00,000 --> 00:00:02,000
Please welcome Ben O'Riess.

2
00:00:02,000 --> 00:00:10,000
So, yeah, after last year, I thought I'd go a bit less controversial.

3
00:00:10,000 --> 00:00:18,000
Anyway, so I thought I'd start in good form by stealing something from Gary Bernard.

4
00:00:18,000 --> 00:00:20,000
Gary Bernard is the author of the Watt Talk.

5
00:00:20,000 --> 00:00:24,000
If you haven't seen that, see that and then watch Katie's talk about explaining the Watt.

6
00:00:24,000 --> 00:00:28,000
But at the keynote that he gave at PyCon in Montreal a few years back,

7
00:00:28,000 --> 00:00:34,000
he talked about the state of knowing things, but also the state of knowing that you know them.

8
00:00:34,000 --> 00:00:39,000
And he put up this kind of truth table thing about whether you know something or whether you meta-know it.

9
00:00:39,000 --> 00:00:44,000
And, you know, if you know it, if you know something that you know, then you know it, then it's a no-knowing, it's knowledge.

10
00:00:44,000 --> 00:00:46,000
It's there, so you can use.

11
00:00:46,000 --> 00:00:50,000
If it's something you don't know but you know that you don't know it, that's a no, an unknown.

12
00:00:50,000 --> 00:00:52,000
That's something you can go and find out later if you need to.

13
00:00:52,000 --> 00:00:54,000
That's all good.

14
00:00:54,000 --> 00:00:56,840
don't know it and you don't know that you don't know it, then it's an unknown unknown

15
00:00:56,840 --> 00:00:59,280
and that's something that might come to bite you later on.

16
00:00:59,280 --> 00:01:02,520
But there's a row missing from this.

17
00:01:02,520 --> 00:01:08,200
What happens if you know something but you don't know that you know it?

18
00:01:08,200 --> 00:01:12,720
Gary defined that as ideology.

19
00:01:12,720 --> 00:01:17,360
And I think that's a pretty good definition, but tradition I think is also somewhat appropriate

20
00:01:17,360 --> 00:01:18,360
there.

21
00:01:18,360 --> 00:01:20,680
It's something where it's the kind of background radiation and it's something that you just

22
00:01:20,680 --> 00:01:23,880
use without really questioning it.

23
00:01:23,880 --> 00:01:39,520
And so, to get started, let's, so, I work for a company that makes a lot of USB devices.

24
00:01:39,520 --> 00:01:44,080
One of our USB devices, which is not the key that you've got in your things, it's a hardware

25
00:01:44,080 --> 00:01:49,480
storage module, involves a piece of software we call the connector and it talks to it over

26
00:01:49,480 --> 00:01:51,320
USB.

27
00:01:51,320 --> 00:01:56,400
And I was wanting to rewrite that in Rust because you do.

28
00:01:56,400 --> 00:02:00,880
And the problem was that at the time, the lib USB bindings for Rust were somewhat bit

29
00:02:00,880 --> 00:02:02,320
rotted.

30
00:02:02,320 --> 00:02:08,720
And so, I decided to try and implement just enough of what lib USB did in Rust itself

31
00:02:08,720 --> 00:02:13,240
on the three platforms that we cared about, which were Windows, Mac and Linux.

32
00:02:13,240 --> 00:02:15,520
And basically, I just wanted to implement this.

33
00:02:15,520 --> 00:02:18,640
I want to iterate over the USB devices to find a device that matches a given vendor

34
00:02:18,640 --> 00:02:19,640
product tuple.

35
00:02:19,920 --> 00:02:23,320
I want to get the device's serial number because sometimes we have more than one attached.

36
00:02:23,320 --> 00:02:24,800
We want to make sure we're attaching the right one.

37
00:02:24,800 --> 00:02:27,640
I want to open the device and claim interface zero.

38
00:02:27,640 --> 00:02:29,640
USB devices can have multiple interfaces.

39
00:02:29,640 --> 00:02:30,640
It doesn't matter.

40
00:02:30,640 --> 00:02:32,720
Send an echo request packet and get the response back.

41
00:02:32,720 --> 00:02:33,720
All good.

42
00:02:33,720 --> 00:02:37,840
So, here, in fairly quick terms, because otherwise I'm going to blow my entire runtime on just

43
00:02:37,840 --> 00:02:41,680
this, is what that code looks like without any error checking or anything.

44
00:02:41,680 --> 00:02:44,800
Do not run this code.

45
00:02:44,800 --> 00:02:46,120
Windows.

46
00:02:46,120 --> 00:02:49,960
We start by getting a class device thing.

47
00:02:49,960 --> 00:02:51,800
We enumerate.

48
00:02:51,800 --> 00:02:53,960
We create enumerator for it.

49
00:02:53,960 --> 00:02:55,520
We get some devices.

50
00:02:55,520 --> 00:02:58,680
We get interface detail not once but twice because the first time we just try and get

51
00:02:58,680 --> 00:02:59,680
a byte count.

52
00:02:59,680 --> 00:03:01,200
So, we do it again.

53
00:03:01,200 --> 00:03:03,160
Once we've got that, then we have a device path.

54
00:03:03,160 --> 00:03:04,800
This is not a file system path.

55
00:03:04,800 --> 00:03:06,000
This is a device path.

56
00:03:06,000 --> 00:03:09,120
This is not slash dev slash something or the Windows equivalent.

57
00:03:09,120 --> 00:03:12,720
It's like the device tree path that you get.

58
00:03:12,720 --> 00:03:14,360
So, that's all good.

59
00:03:14,360 --> 00:03:19,200
Then we open that with create file W. The W means wide or Windows or something.

60
00:03:19,200 --> 00:03:22,640
It means not ASCII.

61
00:03:22,640 --> 00:03:25,920
And that's about the only actual file operation you'll see in this whole thing because we

62
00:03:25,920 --> 00:03:31,840
rapidly move on to the WinUSB API, which is the API for talking to USB devices from user

63
00:03:31,840 --> 00:03:33,040
space in Windows.

64
00:03:33,040 --> 00:03:35,160
So, we create an interface handle.

65
00:03:35,160 --> 00:03:39,280
We get the device descriptor, which gives us the vendor and product things that we need

66
00:03:39,280 --> 00:03:41,760
in order to be able to tell whether we got the right one.

67
00:03:41,760 --> 00:03:43,000
Then we get a string descriptor.

68
00:03:43,000 --> 00:03:45,360
This 409 value is one you'll see a lot.

69
00:03:45,360 --> 00:03:47,240
That is USB speak for English.

70
00:03:47,240 --> 00:03:52,800
So, we're getting the English serial number, not any of the other fancy serial numbers.

71
00:03:52,800 --> 00:03:53,960
Then we make sure it's the one we want.

72
00:03:53,960 --> 00:03:57,080
This is actually in UTF-16 for reasons but whatever.

73
00:03:57,080 --> 00:03:59,640
So, now we've got the device we want.

74
00:03:59,640 --> 00:04:02,160
We do a bunch of mucking around with setting pipe policies.

75
00:04:02,160 --> 00:04:05,160
Pipes are the things that are used to communicate with the USB device.

76
00:04:05,160 --> 00:04:09,120
This one tells it that we want it to send zero-length packets when necessary.

77
00:04:09,120 --> 00:04:12,840
This one and this one are all about just clearing the pipe to make sure that it's not going

78
00:04:12,840 --> 00:04:17,040
to fail on us, and then we can write data to it and read data from it.

79
00:04:17,040 --> 00:04:19,200
So, that's not so bad.

80
00:04:19,200 --> 00:04:22,720
I was actually pleasantly surprised by this because it's not too bad.

81
00:04:22,720 --> 00:04:26,720
You've got a bit at the start where you are doing the device iteration and finding the

82
00:04:26,720 --> 00:04:30,960
device you're looking for, and then you've got the actual USB stuff on the other side,

83
00:04:30,960 --> 00:04:34,520
and that's, you know, it all flowed together pretty well.

84
00:04:34,520 --> 00:04:36,800
So, Mac.

85
00:04:36,800 --> 00:04:40,080
We start by creating a dictionary which is used for matching devices.

86
00:04:40,080 --> 00:04:42,760
We tell it we want to match USB devices.

87
00:04:42,760 --> 00:04:44,720
Then we go and find all the matching services.

88
00:04:44,720 --> 00:04:48,360
A service is a thing that lets you talk to a device.

89
00:04:48,360 --> 00:04:53,480
We iterate over these, and then we create plug-in interface for service.

90
00:04:53,480 --> 00:04:56,920
This returns as an object that we can use to communicate with the device.

91
00:04:56,920 --> 00:05:01,560
This is a COM object, as in component object model.

92
00:05:01,560 --> 00:05:03,160
I'm not making that up.

93
00:05:03,160 --> 00:05:05,760
But it's for a good reason because it lets them version the interfaces.

94
00:05:05,760 --> 00:05:11,040
You'll notice just above the bit I've highlighted, it says KIO USB interface ID 650.

95
00:05:11,040 --> 00:05:16,080
That means version 650, which pertains to Mac OS 10.0, something I can't remember.

96
00:05:16,080 --> 00:05:19,880
So we have to call query interface, which is comspeak for actually I want this class,

97
00:05:19,880 --> 00:05:24,240
not the one you gave me, at which point we don't need it anymore, and we can go on and

98
00:05:24,240 --> 00:05:25,720
do something else with it.

99
00:05:25,720 --> 00:05:29,920
So, now that we've got our device, we can call get device vendor and get device product.

100
00:05:29,920 --> 00:05:33,480
That lets us find whether we've got the one we want.

101
00:05:33,480 --> 00:05:37,660
Then we can call get serial number string index, which tells us where in the string

102
00:05:37,660 --> 00:05:41,280
table the thing is, and then we have to construct an actual request structure in order to get

103
00:05:41,280 --> 00:05:43,200
it, which we then send.

104
00:05:43,200 --> 00:05:46,520
You'll notice there's a lot of C structure function calling here.

105
00:05:46,520 --> 00:05:47,520
That's all fine.

106
00:05:47,520 --> 00:05:50,440
Then we make sure we've got the right one.

107
00:05:50,440 --> 00:05:55,280
And then the next fun part is we have to create interface iterator because we have to iterate

108
00:05:55,280 --> 00:05:58,160
over the interfaces that the device is giving us.

109
00:05:58,160 --> 00:06:02,480
So this is another one of IO kits iterators, so we're calling IO iterator next again.

110
00:06:02,480 --> 00:06:07,160
That construction is merely tell me what interface number you are so that I can check

111
00:06:07,160 --> 00:06:09,320
it.

112
00:06:09,320 --> 00:06:10,320
And then we get another one.

113
00:06:10,320 --> 00:06:16,200
So this time instead of getting a USB device interface, we're getting a USB interface interface.

114
00:06:16,200 --> 00:06:17,200
Factory.

115
00:06:17,200 --> 00:06:23,480
Again, we have its version, you know, it's all actually not too bad.

116
00:06:23,480 --> 00:06:26,600
And then we can open the interface, and then I'm going to gloss over a bit, which is the

117
00:06:26,600 --> 00:06:31,600
fact that Mac OS uses pipe indexes, and you have to work out whether it's the pipe number

118
00:06:31,600 --> 00:06:35,920
you actually want, but you just call write pipe and read pipe, and the TO means that

119
00:06:35,920 --> 00:06:37,840
you're giving it a timeout.

120
00:06:37,840 --> 00:06:38,840
That's all fine.

121
00:06:38,840 --> 00:06:43,600
These are all, if you actually go digging through lib USB, you will see all of this code

122
00:06:43,600 --> 00:06:45,320
with actual error checking and stuff.

123
00:06:45,320 --> 00:06:47,800
So use that code, not my code.

124
00:06:47,800 --> 00:06:51,640
So how about Linux?

125
00:06:51,640 --> 00:06:53,760
We start with Udev.

126
00:06:53,760 --> 00:06:54,760
Udev is not too bad.

127
00:06:54,760 --> 00:06:58,560
Udev new, Udev numerate new, you know, we're creating an enumerator.

128
00:06:58,560 --> 00:07:00,560
We're telling it we want USB devices.

129
00:07:00,560 --> 00:07:01,680
We're scanning devices.

130
00:07:01,680 --> 00:07:03,320
We get a list.

131
00:07:03,320 --> 00:07:05,200
We iterate through the list.

132
00:07:05,200 --> 00:07:12,120
We get a name, which gives us a path, and then we create a Udev device from that path,

133
00:07:12,120 --> 00:07:14,840
and then we get a bunch of things, bus num, dev adder, and sysname.

134
00:07:14,840 --> 00:07:17,440
Okay, now what?

135
00:07:17,440 --> 00:07:21,880
SN printf.

136
00:07:21,880 --> 00:07:25,840
So we have to get to the file that contains the descriptors, and then read the descriptor

137
00:07:25,840 --> 00:07:30,080
in, at which point we can tell whether we've got the right vendor and product tuple.

138
00:07:30,080 --> 00:07:33,240
SN printf.

139
00:07:33,240 --> 00:07:40,560
So now we've got the actual device device, and at that point, the developers of this

140
00:07:40,560 --> 00:07:44,720
gave up on everything being a file and just made you write out big, long structures and

141
00:07:44,720 --> 00:07:49,160
I octal it.

142
00:07:49,160 --> 00:07:54,200
But now we've got the serial number, so that's okay, and then another I octal, and so that's

143
00:07:54,200 --> 00:07:55,200
the claim interface.

144
00:07:55,200 --> 00:08:00,000
That's to do the right one, and then read and write is you guessed it, I octals.

145
00:08:00,000 --> 00:08:07,040
So yeah, I'm not a fan.

146
00:08:07,040 --> 00:08:08,960
Everything is a file mentality that they've used here.

147
00:08:08,960 --> 00:08:12,000
I don't think it's actually served them well at all.

148
00:08:12,000 --> 00:08:15,640
The Udev interface was quite nice, but as soon as I had to pivot through SN printf using

149
00:08:15,640 --> 00:08:20,240
paths that I had to work out myself in order to actually work out where the device was,

150
00:08:20,240 --> 00:08:21,400
that didn't really work too well.

151
00:08:21,400 --> 00:08:28,160
But this is not the worst USB related or everything is a file API that's around.

152
00:08:28,160 --> 00:08:31,760
The USB function FS is used to create user space devices.

153
00:08:31,760 --> 00:08:33,560
So I wanted to test the code that I'd written.

154
00:08:33,560 --> 00:08:37,440
That meant I needed a USB device that I had on a stick and could control and control the

155
00:08:37,440 --> 00:08:38,440
responses of.

156
00:08:38,440 --> 00:08:39,680
Linux has an answer for that.

157
00:08:39,680 --> 00:08:41,520
It's called the function FS API.

158
00:08:41,520 --> 00:08:43,240
Here's what you need to do.

159
00:08:43,240 --> 00:08:45,280
You have to make a magic directory.

160
00:08:45,280 --> 00:08:47,960
You have to make more magic directories.

161
00:08:47,960 --> 00:08:51,120
You have to echo random values into files that got magically created when you created

162
00:08:51,120 --> 00:08:52,480
those magic directories.

163
00:08:52,480 --> 00:08:56,160
You have to sim link one of your magic directories to another magic directory.

164
00:08:56,160 --> 00:08:59,360
You have to then make another magic directory, mount a magic file system.

165
00:08:59,360 --> 00:09:03,520
Then you have to write a bunch of carefully constructed binary data, shove it into a file

166
00:09:03,520 --> 00:09:08,880
which then creates more devices at which point you can open those devices and start doing

167
00:09:08,880 --> 00:09:12,360
stuff with them, at which point you cat a magic value that's dependent on your system

168
00:09:12,360 --> 00:09:26,000
into another magic file and hopefully it connects.

169
00:09:26,000 --> 00:09:27,600
My colleague Nigel is here.

170
00:09:27,600 --> 00:09:32,480
If you want to see it, you can ask him afterwards how much I was swearing as I tried to write

171
00:09:32,480 --> 00:09:42,240
this in a way that was repeatable.

172
00:09:42,320 --> 00:09:49,480
I mean, one could argue that my problems with the Linux USB API are covered off by the fact

173
00:09:49,480 --> 00:09:51,320
that everyone did use libUSB.

174
00:09:51,320 --> 00:09:56,600
You can say the same thing about C groups, because C groups has a somewhat alarming file

175
00:09:56,600 --> 00:10:06,080
based UI API, sorry, and it's also covered by a library and that's fine, but it's indicative

176
00:10:06,080 --> 00:10:10,800
of a mindset that's gone into this where we've taken this notion that it's kind of fun when

177
00:10:10,840 --> 00:10:16,200
everything's a file and it worked for slash dev and it kind of worked for slash proct,

178
00:10:16,200 --> 00:10:18,520
but it sucked.

179
00:10:18,520 --> 00:10:21,600
We just kept going with it because it was the obvious thing to do and part of it I think

180
00:10:21,600 --> 00:10:26,520
is that Unix never really specified how we're supposed to do that kind of thing.

181
00:10:26,520 --> 00:10:30,640
It was very concerned with a whole bunch of other stuff, but it never sat down and said,

182
00:10:30,640 --> 00:10:35,080
how do you actually configure a system?

183
00:10:35,080 --> 00:10:38,560
I think it's just indicative of people get into this railroaded mindset where they just

184
00:10:38,600 --> 00:10:41,840
don't think that they could do something on the other way, but anyway, let's talk about

185
00:10:41,840 --> 00:10:46,440
stuff that Unix did standardize.

186
00:10:46,440 --> 00:10:51,600
One of the joke titles for this when I first started writing it was Dave Cutler was right.

187
00:10:51,600 --> 00:10:55,440
For those of you who don't know, Dave Cutler was originally with DEC and then went to Microsoft

188
00:10:55,440 --> 00:11:00,200
where he created this little operating system called Windows NT and he was not a fan of

189
00:11:00,200 --> 00:11:05,880
Unix and he was especially not a fan of Unix's IO model where he had his joke apparently

190
00:11:06,440 --> 00:11:10,360
where he would say, got a bite, got a bite, got a bite, bite, bite.

191
00:11:10,360 --> 00:11:16,640
But anyway, so this is the Unix IO API, like the guts of it, and this works reasonably

192
00:11:16,640 --> 00:11:23,000
well when you think about it running on something like a Vax or a PDP or something like that.

193
00:11:23,000 --> 00:11:24,800
You're reading some data in, you're writing some data out.

194
00:11:24,800 --> 00:11:25,800
It's really simple.

195
00:11:25,800 --> 00:11:28,280
Everything's great.

196
00:11:28,280 --> 00:11:33,760
Then the internet happened, or more importantly, people discovered that shoveling data out

197
00:11:33,760 --> 00:11:38,520
of sockets and into sockets and into files and out of files in lots of different ways

198
00:11:38,520 --> 00:11:44,360
didn't really work with that API very well because it's blocking.

199
00:11:44,360 --> 00:11:46,800
A file descriptor in Unix by default will block.

200
00:11:46,800 --> 00:11:50,440
When you read, the read call does not return until it's done its reading.

201
00:11:50,440 --> 00:11:53,360
When you write, it doesn't return until it's done its writing.

202
00:11:53,360 --> 00:11:56,200
This slows you down because you can only do one thing at a time.

203
00:11:56,200 --> 00:11:57,560
But we have an answer for that.

204
00:11:57,560 --> 00:11:58,800
That's fine.

205
00:11:58,800 --> 00:12:02,040
We have the most delightfully named system call in the entire Unix pantheon, which I

206
00:12:02,040 --> 00:12:08,240
won't pronounce, which we can use to set a flag that says we shouldn't block, at which

207
00:12:08,240 --> 00:12:13,920
point we can use the wonderful select API, which showed up in 4.2 BSD in 1983.

208
00:12:13,920 --> 00:12:17,840
The problem with this one is that you have to shovel these FD sets, which are effectively

209
00:12:17,840 --> 00:12:23,320
large bit strings, one bit per file descriptor, into and out of the kernel, and they also

210
00:12:23,320 --> 00:12:28,600
have to know how big they are, which limits how many file descriptors you can have.

211
00:12:28,600 --> 00:12:32,000
That's great when you're talking small things because, let's not forget, Unix

212
00:12:32,000 --> 00:12:34,040
predates the Internet.

213
00:12:34,040 --> 00:12:37,680
And so, you know, that was okay, but it didn't work too well.

214
00:12:37,680 --> 00:12:42,640
AT&T's response with SVR 3 in 1986 was poll.

215
00:12:42,640 --> 00:12:46,080
This fixes the file descriptor cap problem, but it means you still have to shovel large

216
00:12:46,080 --> 00:12:49,360
amounts of file descriptor records in and out of the kernel and all that kind of stuff,

217
00:12:49,360 --> 00:12:51,760
so it still had performance limitations.

218
00:12:51,760 --> 00:12:59,480
And then FreeBSD, in 2000, invented this API, which was actually really good.

219
00:12:59,480 --> 00:13:01,840
It's a kernel event API.

220
00:13:02,080 --> 00:13:04,520
It's not just file descriptor events, it's all kernel events.

221
00:13:04,520 --> 00:13:07,080
You can register to listen for any of them and get them all back.

222
00:13:07,080 --> 00:13:11,840
That's file descriptor events, file events, like, you know, this file got created, deleted,

223
00:13:11,840 --> 00:13:14,040
processes exited, signals happened, all kinds of stuff.

224
00:13:14,040 --> 00:13:16,520
And, of course, this was so, this was really good.

225
00:13:16,520 --> 00:13:20,120
It was used to make a whole bunch of nice high-performance stuff on FreeBSD, so, of course,

226
00:13:20,120 --> 00:13:23,360
Linus said, hell no, I'm not taking that.

227
00:13:23,360 --> 00:13:30,760
E-Poll is okay, I guess, except it's very focused around file descriptors, and so, if

228
00:13:30,800 --> 00:13:33,480
you want anything else to be an event, you have to create a file descriptor for it, because

229
00:13:33,480 --> 00:13:39,600
all events are files, no, anyway, but anyway, that's kind of beside the point.

230
00:13:39,600 --> 00:13:46,360
Now we have non-blocking IO, and that's great, but the thing is this IO is still synchronous.

231
00:13:46,360 --> 00:13:48,560
Synchronous is different to blocking.

232
00:13:48,560 --> 00:13:52,320
Blocking means that you can't do anything else until you finish doing the first thing.

233
00:13:52,320 --> 00:13:56,200
Synchronous means you still have to wait for it to finish, it just might finish and say,

234
00:13:56,200 --> 00:13:58,360
I couldn't do it right now.

235
00:13:58,400 --> 00:14:03,960
And this is really almost tied in with the Unix process model, where a process's memory

236
00:14:03,960 --> 00:14:10,000
is, like, it's not strictly sacrosanct, but it's generally not good form for the kernel

237
00:14:10,000 --> 00:14:14,040
to go rummaging around in your memory a lot, and a synchrony would require that to be the

238
00:14:14,040 --> 00:14:18,200
case, you would have to be able to muck around in the process's memory and have memory that's

239
00:14:18,200 --> 00:14:20,520
shared between two things at once, and that's tricky.

240
00:14:20,520 --> 00:14:25,520
Now it didn't stop POSIX from having a go, hands up, who's actually used this API?

241
00:14:26,480 --> 00:14:36,240
Yeah, not many, but on the flip side, that's the Windows equivalent of those calls, but

242
00:14:36,240 --> 00:14:41,800
ever since NT 3.5, as in the first release, people did it, there's also been these.

243
00:14:41,800 --> 00:14:43,800
Those are asynchronous.

244
00:14:43,800 --> 00:14:45,800
They have a completion handler.

245
00:14:45,800 --> 00:14:47,800
You can do stuff with that.

246
00:14:47,800 --> 00:14:56,280
And then Winsock 2 also had similar things, and they also had completion ports.

247
00:14:56,280 --> 00:15:00,440
And so that's basically a thing that you listen on, and when your I.O. is finished, you get

248
00:15:00,440 --> 00:15:04,960
a notice that it happens, and even they have a solution to the, I have to open a file descriptor

249
00:15:04,960 --> 00:15:09,120
so I can write a byte out it to wake my event loop up problem by just posting your own completion

250
00:15:09,120 --> 00:15:11,120
event.

251
00:15:11,120 --> 00:15:17,280
And I mean, the part of the problem here is that Unix's stuff is all tied to its history.

252
00:15:17,280 --> 00:15:22,280
It grew out of systems that were very simple, and Windows does have an unfair advantage

253
00:15:22,280 --> 00:15:27,440
here in that it came along both after Unix and after VMS and after a whole bunch of other

254
00:15:27,440 --> 00:15:29,920
things where it could learn from it.

255
00:15:29,920 --> 00:15:33,360
But the real, my problem with this is not so much that.

256
00:15:33,360 --> 00:15:36,360
It's more that we haven't really caught up.

257
00:15:36,360 --> 00:15:39,440
When you have a look at what happens under the hood of, like at the kernel level as opposed

258
00:15:39,440 --> 00:15:42,160
to the user level, I.O. is really interesting.

259
00:15:42,160 --> 00:15:47,480
This is a really bad description of a descriptor ring.

260
00:15:47,480 --> 00:15:55,880
Most modern I.O. hardware, we're talking SCSI cards or SATA cards, Nix, NVMe, all uses descriptor

261
00:15:55,880 --> 00:15:56,880
rings like this in memory.

262
00:15:56,880 --> 00:16:02,400
You allocate a block of memory, and you carefully misalign one of the lines of that anyway.

263
00:16:02,400 --> 00:16:07,520
And each one of those is 264 byte values, and you generally have a buffer address and

264
00:16:07,520 --> 00:16:08,520
some metadata.

265
00:16:09,080 --> 00:16:11,480
This varies a lot based on hardware.

266
00:16:11,480 --> 00:16:15,480
But once you've got that, you have a host pointer and a device pointer.

267
00:16:15,480 --> 00:16:20,160
The host moves through and fills in the buffer addresses, and each buffer address points at

268
00:16:20,160 --> 00:16:27,120
some data that might be written out or an address where the device can write data to.

269
00:16:27,120 --> 00:16:31,400
And then as the device sees that those are there, it can move along and fill them in,

270
00:16:31,400 --> 00:16:34,840
and then the host can go back and find the ones that are used, and it just loops around

271
00:16:34,840 --> 00:16:35,840
at the end and keeps going.

272
00:16:35,840 --> 00:16:40,120
If the ring fills up, then you have to wait for stuff to go through.

273
00:16:40,120 --> 00:16:47,800
And Linux now has, as of some very short time ago, I.O.U. ring, which actually does do an

274
00:16:47,800 --> 00:16:48,800
I.O.

275
00:16:48,800 --> 00:16:50,640
API that follows those principles.

276
00:16:50,640 --> 00:16:55,640
And I think that's great, but the real issue for me here is that could have happened a

277
00:16:55,640 --> 00:16:56,640
long time ago.

278
00:16:56,640 --> 00:17:02,960
These hardware descriptor rings have been around for years, but I think there's a combination

279
00:17:02,960 --> 00:17:07,600
of, again, just being stuck in the mindset of where we were before, but also just not

280
00:17:07,600 --> 00:17:11,200
wanting to rock the boat, and a lot of people thinking at a much higher level these days

281
00:17:11,200 --> 00:17:18,000
than the low-level I.O. APIs that means that we don't always take the opportunity to progress

282
00:17:18,000 --> 00:17:21,560
these things when we can.

283
00:17:21,560 --> 00:17:28,360
But at that level, let's go a little deeper.

284
00:17:28,360 --> 00:17:35,840
So I told you I was going for less controversial.

285
00:17:35,840 --> 00:17:41,400
So I want to start this section with a reading from Ian M. Banks's book, Excession, in which

286
00:17:41,400 --> 00:17:45,360
he describes the concept of an outside context problem.

287
00:17:45,360 --> 00:17:49,040
The usual example given to illustrate an outside context problem was imagining you were a tribe

288
00:17:49,040 --> 00:17:50,880
on a large, fertile island.

289
00:17:50,880 --> 00:17:53,840
You tamed the land, invented the wheel, or writing, or whatever.

290
00:17:53,840 --> 00:17:57,280
The neighbors were cooperative or enslaved, but at any rate, peaceful.

291
00:17:57,280 --> 00:18:00,440
When you were busy raising temples to yourself with all the excess product of capacity you

292
00:18:00,440 --> 00:18:03,920
had, you were in a position of absolute power and control which your hallowed ancestors

293
00:18:03,920 --> 00:18:06,760
could hardly have dreamed of, and the whole situation was just running along nicely like

294
00:18:06,760 --> 00:18:08,720
a canoe on wet grass.

295
00:18:08,720 --> 00:18:11,960
When suddenly, this wristling lump of iron appears saleless and trailing steam in the

296
00:18:11,960 --> 00:18:15,040
bay, and these guys carrying long, funny-looking sticks come ashore, and hence you've just

297
00:18:15,040 --> 00:18:16,200
been discovered.

298
00:18:16,200 --> 00:18:17,720
You're all subject to the emperor now.

299
00:18:17,720 --> 00:18:21,160
He's came on presence called tax, and these bright-eyed holy men would like a word with

300
00:18:21,160 --> 00:18:24,960
your priests.

301
00:18:25,640 --> 00:18:31,960
Obviously, this has a lot to do with sea, so now I'm going to talk about farming.

302
00:18:31,960 --> 00:18:35,240
Specifically, I'm going to talk about farming in Europe.

303
00:18:35,240 --> 00:18:36,440
In Europe, they did a lot of farming.

304
00:18:36,440 --> 00:18:39,000
They got pretty good at it.

305
00:18:39,000 --> 00:18:41,840
Then they got really good at building ships.

306
00:18:41,840 --> 00:18:45,840
They got on their ships and went out and found that there were other places they could go,

307
00:18:45,840 --> 00:18:50,800
and they decided they liked the look of some of those other places, and so they went there.

308
00:18:50,800 --> 00:18:54,680
They got there, and they went, right, we're going to farm this place.

309
00:18:54,720 --> 00:19:00,680
Good thing there's nobody else here, we'll just do some farming like we did back home,

310
00:19:00,680 --> 00:19:03,040
and it didn't work out so well.

311
00:19:03,040 --> 00:19:05,080
It's not because the people weren't there.

312
00:19:05,080 --> 00:19:07,480
They had been there for a while.

313
00:19:07,480 --> 00:19:09,000
You should read this book.

314
00:19:09,000 --> 00:19:12,880
It talks about how the indigenous people of Australia had been farming quite happily

315
00:19:12,880 --> 00:19:17,520
until white folks showed up, but the trouble is it's kind of almost an inversion of this

316
00:19:17,520 --> 00:19:22,360
outside context problem where the outside context doesn't come to the people.

317
00:19:22,360 --> 00:19:27,640
The people come to the outside context, and suddenly everything they knew doesn't work anymore.

318
00:19:31,160 --> 00:19:35,960
So this is a PDP-11.

319
00:19:35,960 --> 00:19:39,800
This is what C was born on.

320
00:19:39,800 --> 00:19:45,440
The PDP-11 is a single in-order CPU with a very flat, uncomplicated memory, and when

321
00:19:45,440 --> 00:19:53,040
I'm talking single in-order, I mean almost like the ridiculously simplified diagram of

322
00:19:53,040 --> 00:19:58,720
a CPU that we get occasionally, like earliest models of PDP-11 didn't even have a clock.

323
00:19:58,720 --> 00:20:03,040
When you wanted to read from memory, the CPU would set some address bits, strobe some things,

324
00:20:03,040 --> 00:20:06,800
and then the data would come back, and it would move on to the next instruction.

325
00:20:06,800 --> 00:20:09,480
And so it's fairly straightforward.

326
00:20:09,480 --> 00:20:11,680
It's this very simple lockstep execution thing.

327
00:20:11,680 --> 00:20:14,120
There's no cache, there's no memory hierarchy.

328
00:20:14,120 --> 00:20:18,000
It's just you read a byte from the memory, and then you might read a byte from an IO

329
00:20:18,000 --> 00:20:21,800
device, and then you might add them together, and then you might put them somewhere else.

330
00:20:21,800 --> 00:20:27,840
The thing is that time happens, and the PDP-11 begets the Vax, and the Vax influences the

331
00:20:27,840 --> 00:20:32,400
8086, and then a whole bunch of stuff happens, and you end up with an AMD64 device.

332
00:20:32,400 --> 00:20:37,600
And this isn't an AMD64 device, but this is what a Cortex-A77 looks like inside in a very,

333
00:20:37,600 --> 00:20:40,400
very simplified form.

334
00:20:40,400 --> 00:20:45,840
You will note that this is not a simple in-order CPU with a flat memory hierarchy.

335
00:20:45,840 --> 00:20:49,200
You've got instruction decoders, you've got branch predictors, you've got dispatching

336
00:20:49,200 --> 00:20:54,880
things, you've got two words that generally show up through sort of the 90s, a superscaler

337
00:20:54,880 --> 00:20:58,320
and pipelined, unless it has both of them in spades.

338
00:20:58,320 --> 00:21:01,600
Superscaler refers to the fact that you've got all of these units up the top here that

339
00:21:01,600 --> 00:21:07,160
can all do different things at the same time, and then pipelining means that you've got instructions

340
00:21:07,160 --> 00:21:11,640
moving at various stages through an execution pipeline at once, and new instructions come

341
00:21:11,640 --> 00:21:14,240
into the pipeline as you go through.

342
00:21:14,240 --> 00:21:15,960
What does this mean?

343
00:21:15,960 --> 00:21:23,160
It means that in order to make C run fast, you have to do things that lie about the underlying

344
00:21:23,160 --> 00:21:26,080
execution architecture of what you're actually on.

345
00:21:26,080 --> 00:21:30,760
You're not in Europe anymore.

346
00:21:31,000 --> 00:21:38,720
This leads to things like specter and meltdown, because suddenly you're lying about the actual

347
00:21:38,720 --> 00:21:42,840
state of the machine in order to make it go fast, but the stuff that you're doing still

348
00:21:42,840 --> 00:21:46,920
has ripple effects that go through that can be measured, and that can lead to information

349
00:21:46,920 --> 00:21:49,720
that you can get.

350
00:21:49,720 --> 00:21:55,000
C is not built to handle this, and a whole bunch of the problem is that we are trying

351
00:21:55,000 --> 00:22:00,800
to make a system that looks sufficiently like a PDP-11, but is still really fast, and

352
00:22:00,800 --> 00:22:06,160
the things that we do to make it fast make it break.

353
00:22:06,160 --> 00:22:11,480
There are other things that C is not good at, sorry, let me start that again.

354
00:22:11,480 --> 00:22:14,960
There are ways that we could make it better, but they would involve abandoning things that

355
00:22:14,960 --> 00:22:20,560
make C, C. For example, doing good vectorization means that you can do some kinds of loops

356
00:22:20,560 --> 00:22:22,160
really fast.

357
00:22:22,160 --> 00:22:26,400
Fortran is really good at this, because it knows how big its arrays are, and it has some

358
00:22:26,400 --> 00:22:31,080
more guarantees about what things are independent from what other things.

359
00:22:31,080 --> 00:22:35,720
It can go really fast, which is why Fortran is still used in numerical analysis in ways

360
00:22:35,720 --> 00:22:36,840
that C isn't.

361
00:22:36,840 --> 00:22:41,200
When you use things like NumPy or Pandas, a lot of the underlying routines that you're

362
00:22:41,200 --> 00:22:45,320
using to do that are actually written in Fortran.

363
00:22:45,320 --> 00:22:48,880
Another one that causes problems with is structure layout and padding.

364
00:22:48,880 --> 00:22:54,240
C has arcane rules about how structures get laid out and padded, and they cause a whole

365
00:22:54,240 --> 00:22:58,640
bunch of problems, because you can't then necessarily treat elements in structures as

366
00:22:58,640 --> 00:23:02,800
independent variables, which slows things down again.

367
00:23:02,800 --> 00:23:11,480
That's even before you get onto all of the other fun of C.

368
00:23:11,480 --> 00:23:18,000
The real thing is we're not on a PDP-11 anymore, even as much as we'd like to pretend it.

369
00:23:19,000 --> 00:23:25,520
The core point of this is that C, while it was useful at the time, because when you think

370
00:23:25,520 --> 00:23:29,040
about what C came out of, you had to have a very limited language set, because it was

371
00:23:29,040 --> 00:23:30,800
running on very small computers.

372
00:23:30,800 --> 00:23:36,160
It was running on a very simple thing, but we've failed, again, to progress beyond what

373
00:23:36,160 --> 00:23:37,160
we could do with that.

374
00:23:37,160 --> 00:23:41,600
It's gotten even worse in this case, because we've ended up in this self-reinforcing loop,

375
00:23:41,600 --> 00:23:46,360
where we make CPUs that are designed to run C fast, which means we can't change C, because

376
00:23:46,360 --> 00:23:53,040
then we might not be able to write code that goes fast on those CPUs, and to change one

377
00:23:53,040 --> 00:23:55,200
involves changing the other.

378
00:23:55,200 --> 00:23:57,240
But we do have things that do look different now.

379
00:23:57,240 --> 00:24:01,680
We have GPUs, we have things with a lot more vector hardware, and we have languages that

380
00:24:01,680 --> 00:24:03,680
are evolving to be able to take use of those.

381
00:24:03,680 --> 00:24:04,680
Rust is an obvious example.

382
00:24:04,680 --> 00:24:06,840
I'm not going to tell everyone to go and switch to Rust.

383
00:24:06,840 --> 00:24:10,080
I don't even know if Rust is going to be the long-term solution to this, but I think looking

384
00:24:10,080 --> 00:24:15,200
at the language and being willing to make changes to it is an important thing.

385
00:24:15,200 --> 00:24:16,960
Before I move on, there are two things you should look up here.

386
00:24:16,960 --> 00:24:21,840
I've taken a lot of this stuff from a post called C is not a low-level language, which

387
00:24:21,840 --> 00:24:27,160
is well worth a read, and a lot of the stuff on farming and colonialism I got from Sarah

388
00:24:27,160 --> 00:24:33,280
Tabor, who is well worth a follow on Twitter, and that's a podcast there.

389
00:24:33,280 --> 00:24:38,360
But again, I think there are problems that go even deeper.

390
00:24:38,360 --> 00:24:44,960
So half the problem with the Unix philosophy is, what even is it?

391
00:24:45,720 --> 00:24:46,720
There are a number of different definitions.

392
00:24:46,720 --> 00:24:47,840
I all tend to involve a whole bunch of things.

393
00:24:47,840 --> 00:24:48,840
I went and actually looked around.

394
00:24:48,840 --> 00:24:54,840
There's this one, which I think is the earliest one I found, so making it easier to write

395
00:24:54,840 --> 00:24:58,200
test and run programs, interactive use instead of batch processing, economy and elegance

396
00:24:58,200 --> 00:25:02,400
of design due to size constraints, salvation through suffering.

397
00:25:02,400 --> 00:25:07,400
That's very Protestant of them, and self-supporting.

398
00:25:07,400 --> 00:25:12,960
And then this sort of evolves into we start seeing things that we actually more associate

399
00:25:12,960 --> 00:25:18,040
with the Unix philosophy, make each program do one thing well, expect the output of every

400
00:25:18,040 --> 00:25:22,200
program to become the input to another, see if you're pipelining, so on and so forth.

401
00:25:22,200 --> 00:25:30,800
We have Rob Pike's attempt at making it more complicated, I think.

402
00:25:30,800 --> 00:25:32,800
And then this is probably the simplest one that I found.

403
00:25:32,800 --> 00:25:35,840
Write programs that do one thing and do it well, write programs to work together, write

404
00:25:35,840 --> 00:25:38,280
programs to handle text dreams because that is universal and everything.

405
00:25:38,280 --> 00:25:45,760
Notice that none of those says everything as a file.

406
00:25:45,760 --> 00:25:51,880
And in general, I mean, from what I, you know, the usual sort of surface sort of interpretation

407
00:25:51,880 --> 00:25:58,800
of the Unix philosophy is that you should be able to do this a lot, or maybe that.

408
00:25:58,800 --> 00:26:04,840
But the problem with that is that as a newbie, I don't even know what that means.

409
00:26:04,840 --> 00:26:09,800
And then I have to learn regular expressions.

410
00:26:09,800 --> 00:26:14,040
And the thing is, like, you often see these things when you're trying to do system administration

411
00:26:14,040 --> 00:26:15,040
tasks, which is fine.

412
00:26:15,040 --> 00:26:21,320
But, you know, if I want to, like, as I do at Ubico, a lot, I have to kill my GPG agent

413
00:26:21,320 --> 00:26:24,200
because it just gets confused or in the way.

414
00:26:24,200 --> 00:26:28,840
And so, you know, I'm going to run PSAOXWW, I'm going to get some things there, and crap,

415
00:26:28,840 --> 00:26:34,120
I got my grep command as well as GPG agent, so I'm going to have to get rid of grep.

416
00:26:34,120 --> 00:26:37,080
And now that I've got that, I have to actually get the PID, so I'm going to have to pipe

417
00:26:37,080 --> 00:26:38,400
it through orc or something.

418
00:26:38,400 --> 00:26:42,160
And at that point, I can actually kill the damn thing.

419
00:26:42,160 --> 00:26:44,720
Now I'm on a Mac, though.

420
00:26:44,720 --> 00:26:50,560
So I can hit command space and get spotlight and type a few characters and get effectively

421
00:26:50,560 --> 00:26:55,800
the same thing and then type some stuff in here and then click a button.

422
00:26:55,800 --> 00:26:59,440
It's actually quicker and it's a lot easier to explain to someone than explaining what

423
00:26:59,440 --> 00:27:01,240
grep is.

424
00:27:01,240 --> 00:27:07,400
And I think the UNIX philosophy in its expression of doing one thing and doing it well and all

425
00:27:07,400 --> 00:27:12,080
that kind of stuff is a useful starting point, but it really comes into the interpretation

426
00:27:12,080 --> 00:27:14,640
of where you're going with that.

427
00:27:14,640 --> 00:27:18,480
And I think the trouble that we get is that people get too locked into it.

428
00:27:18,480 --> 00:27:26,720
They get too caught up in the purity of it and don't get, and they're insufficiently pragmatic

429
00:27:26,720 --> 00:27:32,480
and end themselves in knots like the USB function FS interface I showed you before.

430
00:27:32,480 --> 00:27:37,560
And UNIX is not the only thing to have this kind of a philosophy thing.

431
00:27:37,560 --> 00:27:44,360
I mean, the Zen of Python is actually really useful in a bunch of ways, but again, Python

432
00:27:44,360 --> 00:27:48,800
like UNIX has a bunch of things that aren't expressed in the Zen of Python that tend to

433
00:27:48,800 --> 00:27:50,680
make life difficult for it.

434
00:27:50,680 --> 00:27:55,960
Chris gave a talk at PyConAU last year called Fantastic Blocks and Where to Hide Them, where

435
00:27:55,960 --> 00:28:00,080
he does talk a bit about Python's philosophical objections to blocks despite the fact that

436
00:28:00,080 --> 00:28:01,080
it has them.

437
00:28:01,080 --> 00:28:04,880
It just doesn't know what to do with them.

438
00:28:04,880 --> 00:28:09,040
And I think that that's, you know, it's again getting locked into a particular mindset without

439
00:28:09,040 --> 00:28:13,000
actually sort of interrogating it.

440
00:28:13,000 --> 00:28:20,320
So the problem with the UNIX philosophy that I have is that the people who tend to express

441
00:28:20,320 --> 00:28:26,960
it the most enthusiastically tend to express it in a way that ends up being almost universally

442
00:28:26,960 --> 00:28:29,000
user hostile.

443
00:28:29,000 --> 00:28:32,560
All of the things that I like about using computers these days tend to be things that

444
00:28:32,560 --> 00:28:36,560
violate the UNIX philosophy of doing one thing and doing it well.

445
00:28:36,560 --> 00:28:41,080
Because when you abandon that, you can start to glue things together in ways that make

446
00:28:41,080 --> 00:28:44,400
things nice and easy to use and quick.

447
00:28:44,400 --> 00:28:46,280
I quite like Mac OS these days.

448
00:28:46,520 --> 00:28:48,320
Oh, I've liked it for quite a while.

449
00:28:48,320 --> 00:28:54,880
And I should have pasted in the XKCD strip of a chart of my satisfaction with how my

450
00:28:54,880 --> 00:29:00,440
life is going versus how long I've had, how long since I've opened Xorg.conf.

451
00:29:00,440 --> 00:29:03,560
Because that's the usual argument that I give to people when they ask why is the Mac and

452
00:29:03,560 --> 00:29:07,160
not FreeBSD or Linux on my desktop.

453
00:29:07,160 --> 00:29:12,560
And again, it comes down to getting blinkered about the way that we think and feeling that

454
00:29:12,560 --> 00:29:17,080
there is no other way to think.

455
00:29:17,080 --> 00:29:27,880
So to finish up, a lot of this has just been me, you know, ranting.

456
00:29:27,880 --> 00:29:33,760
It is a beautiful day at the conference and I am a horrible curmudgeon.

457
00:29:33,760 --> 00:29:37,280
But when we get down to it, UNIX suited its time.

458
00:29:37,280 --> 00:29:42,120
It was the right operating system for the right people at the right time and then through

459
00:29:42,120 --> 00:29:49,640
an accident of bureaucracy, it became the thing that we all use, to some extent, greater

460
00:29:49,640 --> 00:29:51,280
or lesser.

461
00:29:51,280 --> 00:29:53,880
And that's a wonderful thing.

462
00:29:53,880 --> 00:29:58,800
But I worry that it has ended up straightjacketing the way that we think because that time was

463
00:29:58,800 --> 00:30:02,520
actually quite a while ago.

464
00:30:02,520 --> 00:30:04,760
It still works, which is amazing.

465
00:30:04,760 --> 00:30:11,000
But that doesn't mean that its tenets and its way of thought should be sacrosanct.

466
00:30:11,000 --> 00:30:19,920
We should feel free to examine every idea and throw them out if we feel that they no

467
00:30:19,920 --> 00:30:22,960
longer have value for what we are doing.

468
00:30:22,960 --> 00:30:28,640
And that extends beyond things that are purely technical like UNIX.

469
00:30:28,640 --> 00:30:34,160
A lot of the ways that our communities got built up over the years, like I remember a

470
00:30:34,160 --> 00:30:36,800
time when this was not a dirty word.

471
00:30:36,800 --> 00:30:40,400
If it is not a dirty word for you now, it should be.

472
00:30:40,400 --> 00:30:42,520
Sexuality is a lie.

473
00:30:42,520 --> 00:30:48,440
But I remember back in the mid to late 90s, almost every community that I was a part of

474
00:30:48,440 --> 00:30:51,240
would use this as one of their foundational concepts.

475
00:30:51,240 --> 00:30:56,800
We don't see gender, we don't see race, we don't see sexuality, we just see the ability

476
00:30:56,800 --> 00:30:58,360
that you have for code.

477
00:30:58,360 --> 00:31:04,920
But unexamined underneath that was the reason that you only don't see gender or race or

478
00:31:04,920 --> 00:31:10,160
sexuality is that your community is full of straight white men.

479
00:31:10,280 --> 00:31:14,280
As soon as the people who weren't straight white men either showed up or stopped being

480
00:31:14,280 --> 00:31:18,080
anonymous figures on the internet and revealed themselves to not be straight white men, suddenly

481
00:31:18,080 --> 00:31:19,720
this became a problem.

482
00:31:19,720 --> 00:31:24,480
And so you have to then think about what merit actually means.

483
00:31:24,480 --> 00:31:27,600
Are these people not showing merit because they're bad or are they not showing merit

484
00:31:27,600 --> 00:31:34,200
because we've set up a systemic structure that stops them from being good or allowing

485
00:31:34,200 --> 00:31:36,720
them to be good?

486
00:31:36,760 --> 00:31:44,360
And then we try to fix this by bringing in codes of conduct and the howls and the howls.

487
00:31:44,360 --> 00:31:48,680
Because why should I have to be shackled to this code of conduct?

488
00:31:48,680 --> 00:31:52,960
Because I've always been a good person, I thought.

489
00:31:52,960 --> 00:31:57,000
And that's a problem.

490
00:31:57,000 --> 00:32:02,840
And then the other problem that I have is that people like to resort to the pithy philosophical

491
00:32:02,840 --> 00:32:03,840
thing.

492
00:32:03,960 --> 00:32:08,480
The present of Python is great, but it requires interpretation as does the Unix philosophy.

493
00:32:08,480 --> 00:32:12,040
And so if anyone comes up to you and tells you that your code of conduct only needs to

494
00:32:12,040 --> 00:32:17,240
be excellent to each other, you need to tell them to go away.

495
00:32:17,240 --> 00:32:22,400
Because unspoken beneath this is who must be excellent to whom?

496
00:32:22,400 --> 00:32:29,640
If I bait you by calling you slurs or something like that until you explode at me in a fit

497
00:32:29,640 --> 00:32:35,840
of rage that I have quite rightly earned, have you been excellent to me?

498
00:32:35,840 --> 00:32:39,520
And at that point can I run to my governing body and say, oh, they yelled at me, they

499
00:32:39,520 --> 00:32:42,160
yelled at me, come out.

500
00:32:42,160 --> 00:32:48,760
And conduct and community management requires a lot more sensitivity and a lot more nuance

501
00:32:48,760 --> 00:32:51,200
than that.

502
00:32:51,200 --> 00:32:56,400
And so in both community and technical sense, it's safe to say that complex problems have

503
00:32:56,400 --> 00:33:01,040
simple, easy to understand wrong answers.

504
00:33:01,040 --> 00:33:05,760
And that we should understand the past because it's important to know it so you can learn

505
00:33:05,760 --> 00:33:06,760
from it.

506
00:33:06,760 --> 00:33:11,960
But you can't let it bind the future because that just closes things off.

507
00:33:11,960 --> 00:33:15,960
As Sean Brady said in his keynote yesterday, it's important to learn that sometimes you

508
00:33:15,960 --> 00:33:20,560
can drop your tools and try and make new ones.

509
00:33:20,560 --> 00:33:21,960
And thank you very much.

510
00:33:26,400 --> 00:33:39,040
If anyone does want to come and talk to me, feel free to find me out there.

511
00:33:39,040 --> 00:33:41,880
I will say though that if you want to lecture me and tell me I'm wrong, you have to buy

512
00:33:41,880 --> 00:33:45,080
me a drink first.

513
00:33:45,080 --> 00:33:46,080
Thank you very much.

514
00:33:46,080 --> 00:33:49,560
We've got a small gift, a token of our appreciation.

515
00:33:49,560 --> 00:33:53,960
We do have a few more minutes to go, it's not actually time up yet.

516
00:33:53,960 --> 00:33:57,480
So if you do want to have a question, just put your hand up and I'll bring you the microphone.

517
00:33:57,480 --> 00:33:58,480
No.

518
00:33:58,480 --> 00:33:59,480
No.

519
00:33:59,480 --> 00:34:00,480
No.

520
00:34:00,480 --> 00:34:01,480
No.

521
00:34:01,480 --> 00:34:02,480
No.

522
00:34:02,480 --> 00:34:03,480
No.

523
00:34:03,480 --> 00:34:04,480
No.

524
00:34:04,480 --> 00:34:05,480
No.

525
00:34:05,480 --> 00:34:06,480
No.

526
00:34:06,480 --> 00:34:07,480
No.

527
00:34:07,480 --> 00:34:08,480
No.

528
00:34:08,480 --> 00:34:09,480
No.

529
00:34:09,480 --> 00:34:10,480
No.

530
00:34:10,480 --> 00:34:11,480
No.

531
00:34:11,480 --> 00:34:12,480
No.

532
00:34:12,480 --> 00:34:13,480
No.

533
00:34:13,480 --> 00:34:14,480
No.

534
00:34:14,480 --> 00:34:15,480
No.

535
00:34:15,480 --> 00:34:16,480
No.

536
00:34:16,480 --> 00:34:17,480
No.

537
00:34:17,480 --> 00:34:18,480
No.

538
00:34:18,480 --> 00:34:19,480
No.

539
00:34:19,480 --> 00:34:20,480
No.

540
00:34:20,480 --> 00:34:21,480
No.

541
00:34:21,480 --> 00:34:22,480
No.

