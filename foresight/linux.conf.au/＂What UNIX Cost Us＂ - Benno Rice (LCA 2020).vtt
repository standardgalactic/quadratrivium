WEBVTT

00:00.000 --> 00:02.000
Please welcome Ben O'Riess.

00:02.000 --> 00:10.000
So, yeah, after last year, I thought I'd go a bit less controversial.

00:10.000 --> 00:18.000
Anyway, so I thought I'd start in good form by stealing something from Gary Bernard.

00:18.000 --> 00:20.000
Gary Bernard is the author of the Watt Talk.

00:20.000 --> 00:24.000
If you haven't seen that, see that and then watch Katie's talk about explaining the Watt.

00:24.000 --> 00:28.000
But at the keynote that he gave at PyCon in Montreal a few years back,

00:28.000 --> 00:34.000
he talked about the state of knowing things, but also the state of knowing that you know them.

00:34.000 --> 00:39.000
And he put up this kind of truth table thing about whether you know something or whether you meta-know it.

00:39.000 --> 00:44.000
And, you know, if you know it, if you know something that you know, then you know it, then it's a no-knowing, it's knowledge.

00:44.000 --> 00:46.000
It's there, so you can use.

00:46.000 --> 00:50.000
If it's something you don't know but you know that you don't know it, that's a no, an unknown.

00:50.000 --> 00:52.000
That's something you can go and find out later if you need to.

00:52.000 --> 00:54.000
That's all good.

00:54.000 --> 00:56.840
don't know it and you don't know that you don't know it, then it's an unknown unknown

00:56.840 --> 00:59.280
and that's something that might come to bite you later on.

00:59.280 --> 01:02.520
But there's a row missing from this.

01:02.520 --> 01:08.200
What happens if you know something but you don't know that you know it?

01:08.200 --> 01:12.720
Gary defined that as ideology.

01:12.720 --> 01:17.360
And I think that's a pretty good definition, but tradition I think is also somewhat appropriate

01:17.360 --> 01:18.360
there.

01:18.360 --> 01:20.680
It's something where it's the kind of background radiation and it's something that you just

01:20.680 --> 01:23.880
use without really questioning it.

01:23.880 --> 01:39.520
And so, to get started, let's, so, I work for a company that makes a lot of USB devices.

01:39.520 --> 01:44.080
One of our USB devices, which is not the key that you've got in your things, it's a hardware

01:44.080 --> 01:49.480
storage module, involves a piece of software we call the connector and it talks to it over

01:49.480 --> 01:51.320
USB.

01:51.320 --> 01:56.400
And I was wanting to rewrite that in Rust because you do.

01:56.400 --> 02:00.880
And the problem was that at the time, the lib USB bindings for Rust were somewhat bit

02:00.880 --> 02:02.320
rotted.

02:02.320 --> 02:08.720
And so, I decided to try and implement just enough of what lib USB did in Rust itself

02:08.720 --> 02:13.240
on the three platforms that we cared about, which were Windows, Mac and Linux.

02:13.240 --> 02:15.520
And basically, I just wanted to implement this.

02:15.520 --> 02:18.640
I want to iterate over the USB devices to find a device that matches a given vendor

02:18.640 --> 02:19.640
product tuple.

02:19.920 --> 02:23.320
I want to get the device's serial number because sometimes we have more than one attached.

02:23.320 --> 02:24.800
We want to make sure we're attaching the right one.

02:24.800 --> 02:27.640
I want to open the device and claim interface zero.

02:27.640 --> 02:29.640
USB devices can have multiple interfaces.

02:29.640 --> 02:30.640
It doesn't matter.

02:30.640 --> 02:32.720
Send an echo request packet and get the response back.

02:32.720 --> 02:33.720
All good.

02:33.720 --> 02:37.840
So, here, in fairly quick terms, because otherwise I'm going to blow my entire runtime on just

02:37.840 --> 02:41.680
this, is what that code looks like without any error checking or anything.

02:41.680 --> 02:44.800
Do not run this code.

02:44.800 --> 02:46.120
Windows.

02:46.120 --> 02:49.960
We start by getting a class device thing.

02:49.960 --> 02:51.800
We enumerate.

02:51.800 --> 02:53.960
We create enumerator for it.

02:53.960 --> 02:55.520
We get some devices.

02:55.520 --> 02:58.680
We get interface detail not once but twice because the first time we just try and get

02:58.680 --> 02:59.680
a byte count.

02:59.680 --> 03:01.200
So, we do it again.

03:01.200 --> 03:03.160
Once we've got that, then we have a device path.

03:03.160 --> 03:04.800
This is not a file system path.

03:04.800 --> 03:06.000
This is a device path.

03:06.000 --> 03:09.120
This is not slash dev slash something or the Windows equivalent.

03:09.120 --> 03:12.720
It's like the device tree path that you get.

03:12.720 --> 03:14.360
So, that's all good.

03:14.360 --> 03:19.200
Then we open that with create file W. The W means wide or Windows or something.

03:19.200 --> 03:22.640
It means not ASCII.

03:22.640 --> 03:25.920
And that's about the only actual file operation you'll see in this whole thing because we

03:25.920 --> 03:31.840
rapidly move on to the WinUSB API, which is the API for talking to USB devices from user

03:31.840 --> 03:33.040
space in Windows.

03:33.040 --> 03:35.160
So, we create an interface handle.

03:35.160 --> 03:39.280
We get the device descriptor, which gives us the vendor and product things that we need

03:39.280 --> 03:41.760
in order to be able to tell whether we got the right one.

03:41.760 --> 03:43.000
Then we get a string descriptor.

03:43.000 --> 03:45.360
This 409 value is one you'll see a lot.

03:45.360 --> 03:47.240
That is USB speak for English.

03:47.240 --> 03:52.800
So, we're getting the English serial number, not any of the other fancy serial numbers.

03:52.800 --> 03:53.960
Then we make sure it's the one we want.

03:53.960 --> 03:57.080
This is actually in UTF-16 for reasons but whatever.

03:57.080 --> 03:59.640
So, now we've got the device we want.

03:59.640 --> 04:02.160
We do a bunch of mucking around with setting pipe policies.

04:02.160 --> 04:05.160
Pipes are the things that are used to communicate with the USB device.

04:05.160 --> 04:09.120
This one tells it that we want it to send zero-length packets when necessary.

04:09.120 --> 04:12.840
This one and this one are all about just clearing the pipe to make sure that it's not going

04:12.840 --> 04:17.040
to fail on us, and then we can write data to it and read data from it.

04:17.040 --> 04:19.200
So, that's not so bad.

04:19.200 --> 04:22.720
I was actually pleasantly surprised by this because it's not too bad.

04:22.720 --> 04:26.720
You've got a bit at the start where you are doing the device iteration and finding the

04:26.720 --> 04:30.960
device you're looking for, and then you've got the actual USB stuff on the other side,

04:30.960 --> 04:34.520
and that's, you know, it all flowed together pretty well.

04:34.520 --> 04:36.800
So, Mac.

04:36.800 --> 04:40.080
We start by creating a dictionary which is used for matching devices.

04:40.080 --> 04:42.760
We tell it we want to match USB devices.

04:42.760 --> 04:44.720
Then we go and find all the matching services.

04:44.720 --> 04:48.360
A service is a thing that lets you talk to a device.

04:48.360 --> 04:53.480
We iterate over these, and then we create plug-in interface for service.

04:53.480 --> 04:56.920
This returns as an object that we can use to communicate with the device.

04:56.920 --> 05:01.560
This is a COM object, as in component object model.

05:01.560 --> 05:03.160
I'm not making that up.

05:03.160 --> 05:05.760
But it's for a good reason because it lets them version the interfaces.

05:05.760 --> 05:11.040
You'll notice just above the bit I've highlighted, it says KIO USB interface ID 650.

05:11.040 --> 05:16.080
That means version 650, which pertains to Mac OS 10.0, something I can't remember.

05:16.080 --> 05:19.880
So we have to call query interface, which is comspeak for actually I want this class,

05:19.880 --> 05:24.240
not the one you gave me, at which point we don't need it anymore, and we can go on and

05:24.240 --> 05:25.720
do something else with it.

05:25.720 --> 05:29.920
So, now that we've got our device, we can call get device vendor and get device product.

05:29.920 --> 05:33.480
That lets us find whether we've got the one we want.

05:33.480 --> 05:37.660
Then we can call get serial number string index, which tells us where in the string

05:37.660 --> 05:41.280
table the thing is, and then we have to construct an actual request structure in order to get

05:41.280 --> 05:43.200
it, which we then send.

05:43.200 --> 05:46.520
You'll notice there's a lot of C structure function calling here.

05:46.520 --> 05:47.520
That's all fine.

05:47.520 --> 05:50.440
Then we make sure we've got the right one.

05:50.440 --> 05:55.280
And then the next fun part is we have to create interface iterator because we have to iterate

05:55.280 --> 05:58.160
over the interfaces that the device is giving us.

05:58.160 --> 06:02.480
So this is another one of IO kits iterators, so we're calling IO iterator next again.

06:02.480 --> 06:07.160
That construction is merely tell me what interface number you are so that I can check

06:07.160 --> 06:09.320
it.

06:09.320 --> 06:10.320
And then we get another one.

06:10.320 --> 06:16.200
So this time instead of getting a USB device interface, we're getting a USB interface interface.

06:16.200 --> 06:17.200
Factory.

06:17.200 --> 06:23.480
Again, we have its version, you know, it's all actually not too bad.

06:23.480 --> 06:26.600
And then we can open the interface, and then I'm going to gloss over a bit, which is the

06:26.600 --> 06:31.600
fact that Mac OS uses pipe indexes, and you have to work out whether it's the pipe number

06:31.600 --> 06:35.920
you actually want, but you just call write pipe and read pipe, and the TO means that

06:35.920 --> 06:37.840
you're giving it a timeout.

06:37.840 --> 06:38.840
That's all fine.

06:38.840 --> 06:43.600
These are all, if you actually go digging through lib USB, you will see all of this code

06:43.600 --> 06:45.320
with actual error checking and stuff.

06:45.320 --> 06:47.800
So use that code, not my code.

06:47.800 --> 06:51.640
So how about Linux?

06:51.640 --> 06:53.760
We start with Udev.

06:53.760 --> 06:54.760
Udev is not too bad.

06:54.760 --> 06:58.560
Udev new, Udev numerate new, you know, we're creating an enumerator.

06:58.560 --> 07:00.560
We're telling it we want USB devices.

07:00.560 --> 07:01.680
We're scanning devices.

07:01.680 --> 07:03.320
We get a list.

07:03.320 --> 07:05.200
We iterate through the list.

07:05.200 --> 07:12.120
We get a name, which gives us a path, and then we create a Udev device from that path,

07:12.120 --> 07:14.840
and then we get a bunch of things, bus num, dev adder, and sysname.

07:14.840 --> 07:17.440
Okay, now what?

07:17.440 --> 07:21.880
SN printf.

07:21.880 --> 07:25.840
So we have to get to the file that contains the descriptors, and then read the descriptor

07:25.840 --> 07:30.080
in, at which point we can tell whether we've got the right vendor and product tuple.

07:30.080 --> 07:33.240
SN printf.

07:33.240 --> 07:40.560
So now we've got the actual device device, and at that point, the developers of this

07:40.560 --> 07:44.720
gave up on everything being a file and just made you write out big, long structures and

07:44.720 --> 07:49.160
I octal it.

07:49.160 --> 07:54.200
But now we've got the serial number, so that's okay, and then another I octal, and so that's

07:54.200 --> 07:55.200
the claim interface.

07:55.200 --> 08:00.000
That's to do the right one, and then read and write is you guessed it, I octals.

08:00.000 --> 08:07.040
So yeah, I'm not a fan.

08:07.040 --> 08:08.960
Everything is a file mentality that they've used here.

08:08.960 --> 08:12.000
I don't think it's actually served them well at all.

08:12.000 --> 08:15.640
The Udev interface was quite nice, but as soon as I had to pivot through SN printf using

08:15.640 --> 08:20.240
paths that I had to work out myself in order to actually work out where the device was,

08:20.240 --> 08:21.400
that didn't really work too well.

08:21.400 --> 08:28.160
But this is not the worst USB related or everything is a file API that's around.

08:28.160 --> 08:31.760
The USB function FS is used to create user space devices.

08:31.760 --> 08:33.560
So I wanted to test the code that I'd written.

08:33.560 --> 08:37.440
That meant I needed a USB device that I had on a stick and could control and control the

08:37.440 --> 08:38.440
responses of.

08:38.440 --> 08:39.680
Linux has an answer for that.

08:39.680 --> 08:41.520
It's called the function FS API.

08:41.520 --> 08:43.240
Here's what you need to do.

08:43.240 --> 08:45.280
You have to make a magic directory.

08:45.280 --> 08:47.960
You have to make more magic directories.

08:47.960 --> 08:51.120
You have to echo random values into files that got magically created when you created

08:51.120 --> 08:52.480
those magic directories.

08:52.480 --> 08:56.160
You have to sim link one of your magic directories to another magic directory.

08:56.160 --> 08:59.360
You have to then make another magic directory, mount a magic file system.

08:59.360 --> 09:03.520
Then you have to write a bunch of carefully constructed binary data, shove it into a file

09:03.520 --> 09:08.880
which then creates more devices at which point you can open those devices and start doing

09:08.880 --> 09:12.360
stuff with them, at which point you cat a magic value that's dependent on your system

09:12.360 --> 09:26.000
into another magic file and hopefully it connects.

09:26.000 --> 09:27.600
My colleague Nigel is here.

09:27.600 --> 09:32.480
If you want to see it, you can ask him afterwards how much I was swearing as I tried to write

09:32.480 --> 09:42.240
this in a way that was repeatable.

09:42.320 --> 09:49.480
I mean, one could argue that my problems with the Linux USB API are covered off by the fact

09:49.480 --> 09:51.320
that everyone did use libUSB.

09:51.320 --> 09:56.600
You can say the same thing about C groups, because C groups has a somewhat alarming file

09:56.600 --> 10:06.080
based UI API, sorry, and it's also covered by a library and that's fine, but it's indicative

10:06.080 --> 10:10.800
of a mindset that's gone into this where we've taken this notion that it's kind of fun when

10:10.840 --> 10:16.200
everything's a file and it worked for slash dev and it kind of worked for slash proct,

10:16.200 --> 10:18.520
but it sucked.

10:18.520 --> 10:21.600
We just kept going with it because it was the obvious thing to do and part of it I think

10:21.600 --> 10:26.520
is that Unix never really specified how we're supposed to do that kind of thing.

10:26.520 --> 10:30.640
It was very concerned with a whole bunch of other stuff, but it never sat down and said,

10:30.640 --> 10:35.080
how do you actually configure a system?

10:35.080 --> 10:38.560
I think it's just indicative of people get into this railroaded mindset where they just

10:38.600 --> 10:41.840
don't think that they could do something on the other way, but anyway, let's talk about

10:41.840 --> 10:46.440
stuff that Unix did standardize.

10:46.440 --> 10:51.600
One of the joke titles for this when I first started writing it was Dave Cutler was right.

10:51.600 --> 10:55.440
For those of you who don't know, Dave Cutler was originally with DEC and then went to Microsoft

10:55.440 --> 11:00.200
where he created this little operating system called Windows NT and he was not a fan of

11:00.200 --> 11:05.880
Unix and he was especially not a fan of Unix's IO model where he had his joke apparently

11:06.440 --> 11:10.360
where he would say, got a bite, got a bite, got a bite, bite, bite.

11:10.360 --> 11:16.640
But anyway, so this is the Unix IO API, like the guts of it, and this works reasonably

11:16.640 --> 11:23.000
well when you think about it running on something like a Vax or a PDP or something like that.

11:23.000 --> 11:24.800
You're reading some data in, you're writing some data out.

11:24.800 --> 11:25.800
It's really simple.

11:25.800 --> 11:28.280
Everything's great.

11:28.280 --> 11:33.760
Then the internet happened, or more importantly, people discovered that shoveling data out

11:33.760 --> 11:38.520
of sockets and into sockets and into files and out of files in lots of different ways

11:38.520 --> 11:44.360
didn't really work with that API very well because it's blocking.

11:44.360 --> 11:46.800
A file descriptor in Unix by default will block.

11:46.800 --> 11:50.440
When you read, the read call does not return until it's done its reading.

11:50.440 --> 11:53.360
When you write, it doesn't return until it's done its writing.

11:53.360 --> 11:56.200
This slows you down because you can only do one thing at a time.

11:56.200 --> 11:57.560
But we have an answer for that.

11:57.560 --> 11:58.800
That's fine.

11:58.800 --> 12:02.040
We have the most delightfully named system call in the entire Unix pantheon, which I

12:02.040 --> 12:08.240
won't pronounce, which we can use to set a flag that says we shouldn't block, at which

12:08.240 --> 12:13.920
point we can use the wonderful select API, which showed up in 4.2 BSD in 1983.

12:13.920 --> 12:17.840
The problem with this one is that you have to shovel these FD sets, which are effectively

12:17.840 --> 12:23.320
large bit strings, one bit per file descriptor, into and out of the kernel, and they also

12:23.320 --> 12:28.600
have to know how big they are, which limits how many file descriptors you can have.

12:28.600 --> 12:32.000
That's great when you're talking small things because, let's not forget, Unix

12:32.000 --> 12:34.040
predates the Internet.

12:34.040 --> 12:37.680
And so, you know, that was okay, but it didn't work too well.

12:37.680 --> 12:42.640
AT&T's response with SVR 3 in 1986 was poll.

12:42.640 --> 12:46.080
This fixes the file descriptor cap problem, but it means you still have to shovel large

12:46.080 --> 12:49.360
amounts of file descriptor records in and out of the kernel and all that kind of stuff,

12:49.360 --> 12:51.760
so it still had performance limitations.

12:51.760 --> 12:59.480
And then FreeBSD, in 2000, invented this API, which was actually really good.

12:59.480 --> 13:01.840
It's a kernel event API.

13:02.080 --> 13:04.520
It's not just file descriptor events, it's all kernel events.

13:04.520 --> 13:07.080
You can register to listen for any of them and get them all back.

13:07.080 --> 13:11.840
That's file descriptor events, file events, like, you know, this file got created, deleted,

13:11.840 --> 13:14.040
processes exited, signals happened, all kinds of stuff.

13:14.040 --> 13:16.520
And, of course, this was so, this was really good.

13:16.520 --> 13:20.120
It was used to make a whole bunch of nice high-performance stuff on FreeBSD, so, of course,

13:20.120 --> 13:23.360
Linus said, hell no, I'm not taking that.

13:23.360 --> 13:30.760
E-Poll is okay, I guess, except it's very focused around file descriptors, and so, if

13:30.800 --> 13:33.480
you want anything else to be an event, you have to create a file descriptor for it, because

13:33.480 --> 13:39.600
all events are files, no, anyway, but anyway, that's kind of beside the point.

13:39.600 --> 13:46.360
Now we have non-blocking IO, and that's great, but the thing is this IO is still synchronous.

13:46.360 --> 13:48.560
Synchronous is different to blocking.

13:48.560 --> 13:52.320
Blocking means that you can't do anything else until you finish doing the first thing.

13:52.320 --> 13:56.200
Synchronous means you still have to wait for it to finish, it just might finish and say,

13:56.200 --> 13:58.360
I couldn't do it right now.

13:58.400 --> 14:03.960
And this is really almost tied in with the Unix process model, where a process's memory

14:03.960 --> 14:10.000
is, like, it's not strictly sacrosanct, but it's generally not good form for the kernel

14:10.000 --> 14:14.040
to go rummaging around in your memory a lot, and a synchrony would require that to be the

14:14.040 --> 14:18.200
case, you would have to be able to muck around in the process's memory and have memory that's

14:18.200 --> 14:20.520
shared between two things at once, and that's tricky.

14:20.520 --> 14:25.520
Now it didn't stop POSIX from having a go, hands up, who's actually used this API?

14:26.480 --> 14:36.240
Yeah, not many, but on the flip side, that's the Windows equivalent of those calls, but

14:36.240 --> 14:41.800
ever since NT 3.5, as in the first release, people did it, there's also been these.

14:41.800 --> 14:43.800
Those are asynchronous.

14:43.800 --> 14:45.800
They have a completion handler.

14:45.800 --> 14:47.800
You can do stuff with that.

14:47.800 --> 14:56.280
And then Winsock 2 also had similar things, and they also had completion ports.

14:56.280 --> 15:00.440
And so that's basically a thing that you listen on, and when your I.O. is finished, you get

15:00.440 --> 15:04.960
a notice that it happens, and even they have a solution to the, I have to open a file descriptor

15:04.960 --> 15:09.120
so I can write a byte out it to wake my event loop up problem by just posting your own completion

15:09.120 --> 15:11.120
event.

15:11.120 --> 15:17.280
And I mean, the part of the problem here is that Unix's stuff is all tied to its history.

15:17.280 --> 15:22.280
It grew out of systems that were very simple, and Windows does have an unfair advantage

15:22.280 --> 15:27.440
here in that it came along both after Unix and after VMS and after a whole bunch of other

15:27.440 --> 15:29.920
things where it could learn from it.

15:29.920 --> 15:33.360
But the real, my problem with this is not so much that.

15:33.360 --> 15:36.360
It's more that we haven't really caught up.

15:36.360 --> 15:39.440
When you have a look at what happens under the hood of, like at the kernel level as opposed

15:39.440 --> 15:42.160
to the user level, I.O. is really interesting.

15:42.160 --> 15:47.480
This is a really bad description of a descriptor ring.

15:47.480 --> 15:55.880
Most modern I.O. hardware, we're talking SCSI cards or SATA cards, Nix, NVMe, all uses descriptor

15:55.880 --> 15:56.880
rings like this in memory.

15:56.880 --> 16:02.400
You allocate a block of memory, and you carefully misalign one of the lines of that anyway.

16:02.400 --> 16:07.520
And each one of those is 264 byte values, and you generally have a buffer address and

16:07.520 --> 16:08.520
some metadata.

16:09.080 --> 16:11.480
This varies a lot based on hardware.

16:11.480 --> 16:15.480
But once you've got that, you have a host pointer and a device pointer.

16:15.480 --> 16:20.160
The host moves through and fills in the buffer addresses, and each buffer address points at

16:20.160 --> 16:27.120
some data that might be written out or an address where the device can write data to.

16:27.120 --> 16:31.400
And then as the device sees that those are there, it can move along and fill them in,

16:31.400 --> 16:34.840
and then the host can go back and find the ones that are used, and it just loops around

16:34.840 --> 16:35.840
at the end and keeps going.

16:35.840 --> 16:40.120
If the ring fills up, then you have to wait for stuff to go through.

16:40.120 --> 16:47.800
And Linux now has, as of some very short time ago, I.O.U. ring, which actually does do an

16:47.800 --> 16:48.800
I.O.

16:48.800 --> 16:50.640
API that follows those principles.

16:50.640 --> 16:55.640
And I think that's great, but the real issue for me here is that could have happened a

16:55.640 --> 16:56.640
long time ago.

16:56.640 --> 17:02.960
These hardware descriptor rings have been around for years, but I think there's a combination

17:02.960 --> 17:07.600
of, again, just being stuck in the mindset of where we were before, but also just not

17:07.600 --> 17:11.200
wanting to rock the boat, and a lot of people thinking at a much higher level these days

17:11.200 --> 17:18.000
than the low-level I.O. APIs that means that we don't always take the opportunity to progress

17:18.000 --> 17:21.560
these things when we can.

17:21.560 --> 17:28.360
But at that level, let's go a little deeper.

17:28.360 --> 17:35.840
So I told you I was going for less controversial.

17:35.840 --> 17:41.400
So I want to start this section with a reading from Ian M. Banks's book, Excession, in which

17:41.400 --> 17:45.360
he describes the concept of an outside context problem.

17:45.360 --> 17:49.040
The usual example given to illustrate an outside context problem was imagining you were a tribe

17:49.040 --> 17:50.880
on a large, fertile island.

17:50.880 --> 17:53.840
You tamed the land, invented the wheel, or writing, or whatever.

17:53.840 --> 17:57.280
The neighbors were cooperative or enslaved, but at any rate, peaceful.

17:57.280 --> 18:00.440
When you were busy raising temples to yourself with all the excess product of capacity you

18:00.440 --> 18:03.920
had, you were in a position of absolute power and control which your hallowed ancestors

18:03.920 --> 18:06.760
could hardly have dreamed of, and the whole situation was just running along nicely like

18:06.760 --> 18:08.720
a canoe on wet grass.

18:08.720 --> 18:11.960
When suddenly, this wristling lump of iron appears saleless and trailing steam in the

18:11.960 --> 18:15.040
bay, and these guys carrying long, funny-looking sticks come ashore, and hence you've just

18:15.040 --> 18:16.200
been discovered.

18:16.200 --> 18:17.720
You're all subject to the emperor now.

18:17.720 --> 18:21.160
He's came on presence called tax, and these bright-eyed holy men would like a word with

18:21.160 --> 18:24.960
your priests.

18:25.640 --> 18:31.960
Obviously, this has a lot to do with sea, so now I'm going to talk about farming.

18:31.960 --> 18:35.240
Specifically, I'm going to talk about farming in Europe.

18:35.240 --> 18:36.440
In Europe, they did a lot of farming.

18:36.440 --> 18:39.000
They got pretty good at it.

18:39.000 --> 18:41.840
Then they got really good at building ships.

18:41.840 --> 18:45.840
They got on their ships and went out and found that there were other places they could go,

18:45.840 --> 18:50.800
and they decided they liked the look of some of those other places, and so they went there.

18:50.800 --> 18:54.680
They got there, and they went, right, we're going to farm this place.

18:54.720 --> 19:00.680
Good thing there's nobody else here, we'll just do some farming like we did back home,

19:00.680 --> 19:03.040
and it didn't work out so well.

19:03.040 --> 19:05.080
It's not because the people weren't there.

19:05.080 --> 19:07.480
They had been there for a while.

19:07.480 --> 19:09.000
You should read this book.

19:09.000 --> 19:12.880
It talks about how the indigenous people of Australia had been farming quite happily

19:12.880 --> 19:17.520
until white folks showed up, but the trouble is it's kind of almost an inversion of this

19:17.520 --> 19:22.360
outside context problem where the outside context doesn't come to the people.

19:22.360 --> 19:27.640
The people come to the outside context, and suddenly everything they knew doesn't work anymore.

19:31.160 --> 19:35.960
So this is a PDP-11.

19:35.960 --> 19:39.800
This is what C was born on.

19:39.800 --> 19:45.440
The PDP-11 is a single in-order CPU with a very flat, uncomplicated memory, and when

19:45.440 --> 19:53.040
I'm talking single in-order, I mean almost like the ridiculously simplified diagram of

19:53.040 --> 19:58.720
a CPU that we get occasionally, like earliest models of PDP-11 didn't even have a clock.

19:58.720 --> 20:03.040
When you wanted to read from memory, the CPU would set some address bits, strobe some things,

20:03.040 --> 20:06.800
and then the data would come back, and it would move on to the next instruction.

20:06.800 --> 20:09.480
And so it's fairly straightforward.

20:09.480 --> 20:11.680
It's this very simple lockstep execution thing.

20:11.680 --> 20:14.120
There's no cache, there's no memory hierarchy.

20:14.120 --> 20:18.000
It's just you read a byte from the memory, and then you might read a byte from an IO

20:18.000 --> 20:21.800
device, and then you might add them together, and then you might put them somewhere else.

20:21.800 --> 20:27.840
The thing is that time happens, and the PDP-11 begets the Vax, and the Vax influences the

20:27.840 --> 20:32.400
8086, and then a whole bunch of stuff happens, and you end up with an AMD64 device.

20:32.400 --> 20:37.600
And this isn't an AMD64 device, but this is what a Cortex-A77 looks like inside in a very,

20:37.600 --> 20:40.400
very simplified form.

20:40.400 --> 20:45.840
You will note that this is not a simple in-order CPU with a flat memory hierarchy.

20:45.840 --> 20:49.200
You've got instruction decoders, you've got branch predictors, you've got dispatching

20:49.200 --> 20:54.880
things, you've got two words that generally show up through sort of the 90s, a superscaler

20:54.880 --> 20:58.320
and pipelined, unless it has both of them in spades.

20:58.320 --> 21:01.600
Superscaler refers to the fact that you've got all of these units up the top here that

21:01.600 --> 21:07.160
can all do different things at the same time, and then pipelining means that you've got instructions

21:07.160 --> 21:11.640
moving at various stages through an execution pipeline at once, and new instructions come

21:11.640 --> 21:14.240
into the pipeline as you go through.

21:14.240 --> 21:15.960
What does this mean?

21:15.960 --> 21:23.160
It means that in order to make C run fast, you have to do things that lie about the underlying

21:23.160 --> 21:26.080
execution architecture of what you're actually on.

21:26.080 --> 21:30.760
You're not in Europe anymore.

21:31.000 --> 21:38.720
This leads to things like specter and meltdown, because suddenly you're lying about the actual

21:38.720 --> 21:42.840
state of the machine in order to make it go fast, but the stuff that you're doing still

21:42.840 --> 21:46.920
has ripple effects that go through that can be measured, and that can lead to information

21:46.920 --> 21:49.720
that you can get.

21:49.720 --> 21:55.000
C is not built to handle this, and a whole bunch of the problem is that we are trying

21:55.000 --> 22:00.800
to make a system that looks sufficiently like a PDP-11, but is still really fast, and

22:00.800 --> 22:06.160
the things that we do to make it fast make it break.

22:06.160 --> 22:11.480
There are other things that C is not good at, sorry, let me start that again.

22:11.480 --> 22:14.960
There are ways that we could make it better, but they would involve abandoning things that

22:14.960 --> 22:20.560
make C, C. For example, doing good vectorization means that you can do some kinds of loops

22:20.560 --> 22:22.160
really fast.

22:22.160 --> 22:26.400
Fortran is really good at this, because it knows how big its arrays are, and it has some

22:26.400 --> 22:31.080
more guarantees about what things are independent from what other things.

22:31.080 --> 22:35.720
It can go really fast, which is why Fortran is still used in numerical analysis in ways

22:35.720 --> 22:36.840
that C isn't.

22:36.840 --> 22:41.200
When you use things like NumPy or Pandas, a lot of the underlying routines that you're

22:41.200 --> 22:45.320
using to do that are actually written in Fortran.

22:45.320 --> 22:48.880
Another one that causes problems with is structure layout and padding.

22:48.880 --> 22:54.240
C has arcane rules about how structures get laid out and padded, and they cause a whole

22:54.240 --> 22:58.640
bunch of problems, because you can't then necessarily treat elements in structures as

22:58.640 --> 23:02.800
independent variables, which slows things down again.

23:02.800 --> 23:11.480
That's even before you get onto all of the other fun of C.

23:11.480 --> 23:18.000
The real thing is we're not on a PDP-11 anymore, even as much as we'd like to pretend it.

23:19.000 --> 23:25.520
The core point of this is that C, while it was useful at the time, because when you think

23:25.520 --> 23:29.040
about what C came out of, you had to have a very limited language set, because it was

23:29.040 --> 23:30.800
running on very small computers.

23:30.800 --> 23:36.160
It was running on a very simple thing, but we've failed, again, to progress beyond what

23:36.160 --> 23:37.160
we could do with that.

23:37.160 --> 23:41.600
It's gotten even worse in this case, because we've ended up in this self-reinforcing loop,

23:41.600 --> 23:46.360
where we make CPUs that are designed to run C fast, which means we can't change C, because

23:46.360 --> 23:53.040
then we might not be able to write code that goes fast on those CPUs, and to change one

23:53.040 --> 23:55.200
involves changing the other.

23:55.200 --> 23:57.240
But we do have things that do look different now.

23:57.240 --> 24:01.680
We have GPUs, we have things with a lot more vector hardware, and we have languages that

24:01.680 --> 24:03.680
are evolving to be able to take use of those.

24:03.680 --> 24:04.680
Rust is an obvious example.

24:04.680 --> 24:06.840
I'm not going to tell everyone to go and switch to Rust.

24:06.840 --> 24:10.080
I don't even know if Rust is going to be the long-term solution to this, but I think looking

24:10.080 --> 24:15.200
at the language and being willing to make changes to it is an important thing.

24:15.200 --> 24:16.960
Before I move on, there are two things you should look up here.

24:16.960 --> 24:21.840
I've taken a lot of this stuff from a post called C is not a low-level language, which

24:21.840 --> 24:27.160
is well worth a read, and a lot of the stuff on farming and colonialism I got from Sarah

24:27.160 --> 24:33.280
Tabor, who is well worth a follow on Twitter, and that's a podcast there.

24:33.280 --> 24:38.360
But again, I think there are problems that go even deeper.

24:38.360 --> 24:44.960
So half the problem with the Unix philosophy is, what even is it?

24:45.720 --> 24:46.720
There are a number of different definitions.

24:46.720 --> 24:47.840
I all tend to involve a whole bunch of things.

24:47.840 --> 24:48.840
I went and actually looked around.

24:48.840 --> 24:54.840
There's this one, which I think is the earliest one I found, so making it easier to write

24:54.840 --> 24:58.200
test and run programs, interactive use instead of batch processing, economy and elegance

24:58.200 --> 25:02.400
of design due to size constraints, salvation through suffering.

25:02.400 --> 25:07.400
That's very Protestant of them, and self-supporting.

25:07.400 --> 25:12.960
And then this sort of evolves into we start seeing things that we actually more associate

25:12.960 --> 25:18.040
with the Unix philosophy, make each program do one thing well, expect the output of every

25:18.040 --> 25:22.200
program to become the input to another, see if you're pipelining, so on and so forth.

25:22.200 --> 25:30.800
We have Rob Pike's attempt at making it more complicated, I think.

25:30.800 --> 25:32.800
And then this is probably the simplest one that I found.

25:32.800 --> 25:35.840
Write programs that do one thing and do it well, write programs to work together, write

25:35.840 --> 25:38.280
programs to handle text dreams because that is universal and everything.

25:38.280 --> 25:45.760
Notice that none of those says everything as a file.

25:45.760 --> 25:51.880
And in general, I mean, from what I, you know, the usual sort of surface sort of interpretation

25:51.880 --> 25:58.800
of the Unix philosophy is that you should be able to do this a lot, or maybe that.

25:58.800 --> 26:04.840
But the problem with that is that as a newbie, I don't even know what that means.

26:04.840 --> 26:09.800
And then I have to learn regular expressions.

26:09.800 --> 26:14.040
And the thing is, like, you often see these things when you're trying to do system administration

26:14.040 --> 26:15.040
tasks, which is fine.

26:15.040 --> 26:21.320
But, you know, if I want to, like, as I do at Ubico, a lot, I have to kill my GPG agent

26:21.320 --> 26:24.200
because it just gets confused or in the way.

26:24.200 --> 26:28.840
And so, you know, I'm going to run PSAOXWW, I'm going to get some things there, and crap,

26:28.840 --> 26:34.120
I got my grep command as well as GPG agent, so I'm going to have to get rid of grep.

26:34.120 --> 26:37.080
And now that I've got that, I have to actually get the PID, so I'm going to have to pipe

26:37.080 --> 26:38.400
it through orc or something.

26:38.400 --> 26:42.160
And at that point, I can actually kill the damn thing.

26:42.160 --> 26:44.720
Now I'm on a Mac, though.

26:44.720 --> 26:50.560
So I can hit command space and get spotlight and type a few characters and get effectively

26:50.560 --> 26:55.800
the same thing and then type some stuff in here and then click a button.

26:55.800 --> 26:59.440
It's actually quicker and it's a lot easier to explain to someone than explaining what

26:59.440 --> 27:01.240
grep is.

27:01.240 --> 27:07.400
And I think the UNIX philosophy in its expression of doing one thing and doing it well and all

27:07.400 --> 27:12.080
that kind of stuff is a useful starting point, but it really comes into the interpretation

27:12.080 --> 27:14.640
of where you're going with that.

27:14.640 --> 27:18.480
And I think the trouble that we get is that people get too locked into it.

27:18.480 --> 27:26.720
They get too caught up in the purity of it and don't get, and they're insufficiently pragmatic

27:26.720 --> 27:32.480
and end themselves in knots like the USB function FS interface I showed you before.

27:32.480 --> 27:37.560
And UNIX is not the only thing to have this kind of a philosophy thing.

27:37.560 --> 27:44.360
I mean, the Zen of Python is actually really useful in a bunch of ways, but again, Python

27:44.360 --> 27:48.800
like UNIX has a bunch of things that aren't expressed in the Zen of Python that tend to

27:48.800 --> 27:50.680
make life difficult for it.

27:50.680 --> 27:55.960
Chris gave a talk at PyConAU last year called Fantastic Blocks and Where to Hide Them, where

27:55.960 --> 28:00.080
he does talk a bit about Python's philosophical objections to blocks despite the fact that

28:00.080 --> 28:01.080
it has them.

28:01.080 --> 28:04.880
It just doesn't know what to do with them.

28:04.880 --> 28:09.040
And I think that that's, you know, it's again getting locked into a particular mindset without

28:09.040 --> 28:13.000
actually sort of interrogating it.

28:13.000 --> 28:20.320
So the problem with the UNIX philosophy that I have is that the people who tend to express

28:20.320 --> 28:26.960
it the most enthusiastically tend to express it in a way that ends up being almost universally

28:26.960 --> 28:29.000
user hostile.

28:29.000 --> 28:32.560
All of the things that I like about using computers these days tend to be things that

28:32.560 --> 28:36.560
violate the UNIX philosophy of doing one thing and doing it well.

28:36.560 --> 28:41.080
Because when you abandon that, you can start to glue things together in ways that make

28:41.080 --> 28:44.400
things nice and easy to use and quick.

28:44.400 --> 28:46.280
I quite like Mac OS these days.

28:46.520 --> 28:48.320
Oh, I've liked it for quite a while.

28:48.320 --> 28:54.880
And I should have pasted in the XKCD strip of a chart of my satisfaction with how my

28:54.880 --> 29:00.440
life is going versus how long I've had, how long since I've opened Xorg.conf.

29:00.440 --> 29:03.560
Because that's the usual argument that I give to people when they ask why is the Mac and

29:03.560 --> 29:07.160
not FreeBSD or Linux on my desktop.

29:07.160 --> 29:12.560
And again, it comes down to getting blinkered about the way that we think and feeling that

29:12.560 --> 29:17.080
there is no other way to think.

29:17.080 --> 29:27.880
So to finish up, a lot of this has just been me, you know, ranting.

29:27.880 --> 29:33.760
It is a beautiful day at the conference and I am a horrible curmudgeon.

29:33.760 --> 29:37.280
But when we get down to it, UNIX suited its time.

29:37.280 --> 29:42.120
It was the right operating system for the right people at the right time and then through

29:42.120 --> 29:49.640
an accident of bureaucracy, it became the thing that we all use, to some extent, greater

29:49.640 --> 29:51.280
or lesser.

29:51.280 --> 29:53.880
And that's a wonderful thing.

29:53.880 --> 29:58.800
But I worry that it has ended up straightjacketing the way that we think because that time was

29:58.800 --> 30:02.520
actually quite a while ago.

30:02.520 --> 30:04.760
It still works, which is amazing.

30:04.760 --> 30:11.000
But that doesn't mean that its tenets and its way of thought should be sacrosanct.

30:11.000 --> 30:19.920
We should feel free to examine every idea and throw them out if we feel that they no

30:19.920 --> 30:22.960
longer have value for what we are doing.

30:22.960 --> 30:28.640
And that extends beyond things that are purely technical like UNIX.

30:28.640 --> 30:34.160
A lot of the ways that our communities got built up over the years, like I remember a

30:34.160 --> 30:36.800
time when this was not a dirty word.

30:36.800 --> 30:40.400
If it is not a dirty word for you now, it should be.

30:40.400 --> 30:42.520
Sexuality is a lie.

30:42.520 --> 30:48.440
But I remember back in the mid to late 90s, almost every community that I was a part of

30:48.440 --> 30:51.240
would use this as one of their foundational concepts.

30:51.240 --> 30:56.800
We don't see gender, we don't see race, we don't see sexuality, we just see the ability

30:56.800 --> 30:58.360
that you have for code.

30:58.360 --> 31:04.920
But unexamined underneath that was the reason that you only don't see gender or race or

31:04.920 --> 31:10.160
sexuality is that your community is full of straight white men.

31:10.280 --> 31:14.280
As soon as the people who weren't straight white men either showed up or stopped being

31:14.280 --> 31:18.080
anonymous figures on the internet and revealed themselves to not be straight white men, suddenly

31:18.080 --> 31:19.720
this became a problem.

31:19.720 --> 31:24.480
And so you have to then think about what merit actually means.

31:24.480 --> 31:27.600
Are these people not showing merit because they're bad or are they not showing merit

31:27.600 --> 31:34.200
because we've set up a systemic structure that stops them from being good or allowing

31:34.200 --> 31:36.720
them to be good?

31:36.760 --> 31:44.360
And then we try to fix this by bringing in codes of conduct and the howls and the howls.

31:44.360 --> 31:48.680
Because why should I have to be shackled to this code of conduct?

31:48.680 --> 31:52.960
Because I've always been a good person, I thought.

31:52.960 --> 31:57.000
And that's a problem.

31:57.000 --> 32:02.840
And then the other problem that I have is that people like to resort to the pithy philosophical

32:02.840 --> 32:03.840
thing.

32:03.960 --> 32:08.480
The present of Python is great, but it requires interpretation as does the Unix philosophy.

32:08.480 --> 32:12.040
And so if anyone comes up to you and tells you that your code of conduct only needs to

32:12.040 --> 32:17.240
be excellent to each other, you need to tell them to go away.

32:17.240 --> 32:22.400
Because unspoken beneath this is who must be excellent to whom?

32:22.400 --> 32:29.640
If I bait you by calling you slurs or something like that until you explode at me in a fit

32:29.640 --> 32:35.840
of rage that I have quite rightly earned, have you been excellent to me?

32:35.840 --> 32:39.520
And at that point can I run to my governing body and say, oh, they yelled at me, they

32:39.520 --> 32:42.160
yelled at me, come out.

32:42.160 --> 32:48.760
And conduct and community management requires a lot more sensitivity and a lot more nuance

32:48.760 --> 32:51.200
than that.

32:51.200 --> 32:56.400
And so in both community and technical sense, it's safe to say that complex problems have

32:56.400 --> 33:01.040
simple, easy to understand wrong answers.

33:01.040 --> 33:05.760
And that we should understand the past because it's important to know it so you can learn

33:05.760 --> 33:06.760
from it.

33:06.760 --> 33:11.960
But you can't let it bind the future because that just closes things off.

33:11.960 --> 33:15.960
As Sean Brady said in his keynote yesterday, it's important to learn that sometimes you

33:15.960 --> 33:20.560
can drop your tools and try and make new ones.

33:20.560 --> 33:21.960
And thank you very much.

33:26.400 --> 33:39.040
If anyone does want to come and talk to me, feel free to find me out there.

33:39.040 --> 33:41.880
I will say though that if you want to lecture me and tell me I'm wrong, you have to buy

33:41.880 --> 33:45.080
me a drink first.

33:45.080 --> 33:46.080
Thank you very much.

33:46.080 --> 33:49.560
We've got a small gift, a token of our appreciation.

33:49.560 --> 33:53.960
We do have a few more minutes to go, it's not actually time up yet.

33:53.960 --> 33:57.480
So if you do want to have a question, just put your hand up and I'll bring you the microphone.

33:57.480 --> 33:58.480
No.

33:58.480 --> 33:59.480
No.

33:59.480 --> 34:00.480
No.

34:00.480 --> 34:01.480
No.

34:01.480 --> 34:02.480
No.

34:02.480 --> 34:03.480
No.

34:03.480 --> 34:04.480
No.

34:04.480 --> 34:05.480
No.

34:05.480 --> 34:06.480
No.

34:06.480 --> 34:07.480
No.

34:07.480 --> 34:08.480
No.

34:08.480 --> 34:09.480
No.

34:09.480 --> 34:10.480
No.

34:10.480 --> 34:11.480
No.

34:11.480 --> 34:12.480
No.

34:12.480 --> 34:13.480
No.

34:13.480 --> 34:14.480
No.

34:14.480 --> 34:15.480
No.

34:15.480 --> 34:16.480
No.

34:16.480 --> 34:17.480
No.

34:17.480 --> 34:18.480
No.

34:18.480 --> 34:19.480
No.

34:19.480 --> 34:20.480
No.

34:20.480 --> 34:21.480
No.

34:21.480 --> 34:22.480
No.

