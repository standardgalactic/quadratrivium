WEBVTT

00:00.000 --> 00:23.820
Music

00:23.820 --> 00:53.740
All right, this is CS50.

00:53.740 --> 00:55.300
And this is week one.

00:55.300 --> 01:00.020
And by the end of today, you will know how to create programs that

01:00.020 --> 01:01.340
look like this.

01:01.340 --> 01:02.540
So this, of course, is binary.

01:02.540 --> 01:05.300
This is the only language that machines ultimately understand.

01:05.300 --> 01:08.540
But thankfully, per last week, there's so many abstractions

01:08.540 --> 01:10.500
and there's so many humans that have come before us

01:10.500 --> 01:12.700
that we don't actually have to write anything at this level.

01:12.700 --> 01:15.540
We can abstract way above it, like we did with Scratch already,

01:15.540 --> 01:19.340
and like we will starting today with C. But does anyone nonetheless

01:19.340 --> 01:24.700
want to take a guess at what that program, when fed to your Mac or PC,

01:24.700 --> 01:27.060
actually does?

01:27.060 --> 01:30.180
Anyone recognize?

01:30.180 --> 01:32.060
Anyone want to hazard a guess?

01:32.060 --> 01:34.820
It's perhaps the simplest program you could write.

01:34.820 --> 01:39.100
It indeed does, when fed to the brain of your computer,

01:39.100 --> 01:42.100
this is all called CPU, simply print that.

01:42.100 --> 01:44.020
So how do we actually get to that point?

01:44.020 --> 01:46.340
Well, recall where we started this conversation last time,

01:46.340 --> 01:49.140
talking about computer science more generally, and problem solving.

01:49.140 --> 01:52.260
We propose can be distilled really is this, like you've got some inputs,

01:52.260 --> 01:54.140
you want some outputs, and somewhere in the middle

01:54.140 --> 01:56.500
you need to do something with those inputs.

01:56.500 --> 02:00.660
And to get to that point, though, we had to represent those inputs and outputs.

02:00.660 --> 02:03.020
We just had to decide as sort of humans, how

02:03.020 --> 02:05.380
are we going to represent all the inputs to our problem

02:05.380 --> 02:07.980
when it comes time to have a computer actually process them?

02:07.980 --> 02:11.660
And at the end of the day, all of the phones and the computers that we're all using,

02:11.660 --> 02:13.660
only end at the end of the day plug into the wall

02:13.660 --> 02:15.900
to get their physical resource, electricity,

02:15.900 --> 02:18.180
and they might store that temporarily in a battery.

02:18.220 --> 02:19.700
But that really is our only input.

02:19.700 --> 02:22.140
It's either plugged in or it's not.

02:22.140 --> 02:24.820
It's either a one or a zero, true or false.

02:24.820 --> 02:28.100
So the world really reduces to those two states, so to speak.

02:28.100 --> 02:30.020
And so you can think of those states, then.

02:30.020 --> 02:31.780
It's just being like a light bulb, on or off.

02:31.780 --> 02:35.020
Or I pulled up my cell phone last time to turn the flashlight on or off,

02:35.020 --> 02:37.300
one or zero, true or false.

02:37.300 --> 02:39.580
Now, of course, if you only have one light bulb,

02:39.580 --> 02:41.940
you can only count from zero to one.

02:41.940 --> 02:44.820
But if you start to have a bunch of them back to back to back to back,

02:44.820 --> 02:47.300
you can permute them like I did my fingers.

02:47.300 --> 02:51.020
Zero, one, two, three, and so forth.

02:51.020 --> 02:54.140
And so we started talking about binary more generally.

02:54.140 --> 02:59.220
And so here, for instance, were three sequences of zeros and ones.

02:59.220 --> 03:01.420
And each of those represented something.

03:01.420 --> 03:03.900
But we don't need to think about the world at that level.

03:03.900 --> 03:05.180
We can abstract on top of that.

03:05.180 --> 03:07.780
All of us are so much more familiar with decimal, of course.

03:07.780 --> 03:11.220
And indeed, recall that this was just 72, 73, and 33,

03:11.220 --> 03:14.220
which, if anyone recalls, when you use ASCII, which

03:14.220 --> 03:16.620
is this global standard for mapping numbers to letters,

03:16.620 --> 03:18.380
we got what message?

03:18.380 --> 03:22.020
Yeah, it was just high, capital H, capital I, exclamation point.

03:22.020 --> 03:26.380
And so that's an abstraction on top of those otherwise binary numbers.

03:26.380 --> 03:29.540
But we don't have to model just text using numbers.

03:29.540 --> 03:32.540
At the end of the day, our only resource is still that electricity.

03:32.540 --> 03:35.300
And the only way we think about it digitally is still zeros and ones.

03:35.300 --> 03:39.140
But if we take these same values, 72, 73, 33,

03:39.140 --> 03:42.900
and treat them in the context of like Photoshop or like a photo program

03:42.900 --> 03:45.020
or a graphics program, we can instead interpret them

03:45.020 --> 03:48.100
as like some amount of red, some amount of green, some amount of blue,

03:48.100 --> 03:50.780
which gave us, last time, recall this yellowish color.

03:50.780 --> 03:54.380
So now we had another abstraction on top of binary colors.

03:54.380 --> 03:55.780
And this is just one pixel.

03:55.780 --> 03:57.780
What can you do once you have more than one pixel?

03:57.780 --> 04:00.660
What can you represent next?

04:00.660 --> 04:01.980
Yeah, right, images, right?

04:01.980 --> 04:04.260
So we're sort of continuing the conversation up and up and up.

04:04.260 --> 04:06.940
And we could represent something like a graphical emoji on the screen,

04:06.940 --> 04:08.620
which has more than just one yellow dot.

04:08.620 --> 04:11.500
It's got a whole bunch of yellow dots and other colors as well.

04:11.500 --> 04:13.940
And recall that if we want to animate things,

04:13.940 --> 04:16.420
whether it's through silly things like an emojis on a phone

04:16.420 --> 04:19.060
or just more proper videos and movies, well, those

04:19.060 --> 04:24.140
are just sequences of images flying past your human eyes really quite quickly.

04:24.140 --> 04:27.220
So that's where we kind of left off last time, starting at the base level

04:27.220 --> 04:30.340
and abstracting away so that we could sort of stipulate thereafter.

04:30.340 --> 04:35.340
We can represent inputs and we can represent outputs, whatever those happen to be.

04:35.340 --> 04:37.340
And here on out, we don't need to think at that level.

04:37.340 --> 04:39.660
We can just assume we all know how to do this.

04:39.660 --> 04:42.580
And even if it eventually becomes kind of a distant memory,

04:42.580 --> 04:44.580
we know that someone can indeed do this.

04:44.580 --> 04:46.780
And that's the value of abstraction.

04:46.780 --> 04:50.260
But inside of this black box, we're so-called algorithms, the sort of secret

04:50.260 --> 04:53.260
sauce, this is where the problems are actually solved.

04:53.260 --> 04:57.060
And we not only talked about what these algorithms are,

04:57.060 --> 04:59.220
but for instance, how efficient they were.

04:59.220 --> 05:02.700
So recall that this red line represented a very simple algorithm

05:02.700 --> 05:05.420
of just turning the phone book page by page one at a time.

05:05.420 --> 05:07.940
And the reason that it's a straight line is because there's like a one

05:07.940 --> 05:11.060
to one correspondence between how many pages there are in the book

05:11.060 --> 05:12.420
and how many page turns there are.

05:12.900 --> 05:15.140
One more page, one more turn, and so forth.

05:15.140 --> 05:20.180
If I fly through it at twice the speed, two, four, six, eight, I can do better.

05:20.180 --> 05:24.060
And so that yellow line now, recall, was lower on the graph.

05:24.060 --> 05:26.460
If you just kind of look at any two points, yellow and red,

05:26.460 --> 05:29.020
yellow is below red, saying it takes less time.

05:29.020 --> 05:30.860
But it was not quite correct.

05:30.860 --> 05:35.100
There was one bug when I was looking for Mike two pages at a time.

05:35.100 --> 05:37.260
What was that issue?

05:37.260 --> 05:38.140
Yeah, I might miss him.

05:38.140 --> 05:40.580
He might accidentally get sandwiched in between two pages.

05:40.580 --> 05:43.620
It's not a huge deal because I could fix it, but I have to fix it.

05:43.620 --> 05:47.300
I have to apply that additional logic and double back at least a page if I go too fast.

05:47.300 --> 05:50.100
But of course, the sort of final algorithm, and frankly,

05:50.100 --> 05:53.660
all of our initial intuition probably, was the dividing and conquer.

05:53.660 --> 05:56.980
Open it roughly to the middle, look down, and then go left and go right.

05:56.980 --> 05:59.940
And just repeat that process as the problem gets this big, to this big,

05:59.940 --> 06:02.300
to this big, to this big, to just one page left.

06:02.300 --> 06:05.100
So that was all about efficiency.

06:05.100 --> 06:08.540
But to get to that point, we needed to express ourselves more precisely.

06:08.540 --> 06:09.900
And so we introduced pseudocode.

06:09.900 --> 06:11.420
There's no formal definition.

06:11.420 --> 06:12.740
It can be English, English-like.

06:12.740 --> 06:15.220
It's just meant to be succinct and get the point across.

06:15.220 --> 06:18.540
And recall that along the way, we introduced a whole bunch of concepts,

06:18.540 --> 06:20.780
many of which you probably experimented with with Scratch,

06:20.780 --> 06:26.420
like loops and conditions, Boolean expressions, variables, and so forth.

06:26.420 --> 06:31.060
And those were building blocks that kind of came out of this kind of demonstration here.

06:31.060 --> 06:34.260
But honestly, even in this demonstration, in this pseudocode,

06:34.260 --> 06:36.260
there were a whole bunch of assumptions.

06:36.260 --> 06:38.060
If you read these instructions one at a time

06:38.060 --> 06:39.700
and you're holding the phone book yourself,

06:39.700 --> 06:42.980
odds are you can execute the pseudocode, this algorithm.

06:42.980 --> 06:48.660
But what does it really mean to, say, open to the middle of the phone book?

06:48.660 --> 06:51.380
All of us have an intuitive understanding of what that means.

06:51.380 --> 06:54.140
But honestly, if you were sort of explaining that to a kid or someone

06:54.140 --> 06:56.660
who's learning English or whatever language for the first time,

06:56.660 --> 06:58.820
open to the middle of the phone book, you should probably

06:58.820 --> 07:00.300
set forth some assumptions.

07:00.300 --> 07:04.060
OK, this thing in front of you has 1,000 pages, pieces of paper,

07:04.060 --> 07:05.940
turned to the 500th page.

07:05.940 --> 07:07.740
And let's call that the middle.

07:07.740 --> 07:10.420
This would very quickly get tedious if all of us humans

07:10.420 --> 07:12.100
are talking at that level of detail.

07:12.100 --> 07:14.740
And so we abstract away with more sweeping statements,

07:14.740 --> 07:16.420
like open to the middle of the phone book.

07:16.420 --> 07:18.100
But that's an abstraction.

07:18.100 --> 07:21.380
And it's not quite as precise as is probably ideal, especially feeding

07:21.380 --> 07:24.740
this algorithm to a newbie or to a robot or a computer.

07:24.740 --> 07:27.980
But it's useful because we can then make a 12-step program instead

07:27.980 --> 07:30.700
of a 20-step program by elaborating too much.

07:30.700 --> 07:33.620
And for instance, throughout here, too, we had our loops and conditions

07:33.620 --> 07:35.580
and so forth, but even call mic.

07:35.580 --> 07:36.740
Like, what does that mean?

07:36.740 --> 07:39.380
Well, if you imagine that the human knows how to use the phone,

07:39.380 --> 07:40.580
then it goes without saying.

07:40.580 --> 07:43.420
But if he or she also needs to be programmed to use the phone,

07:43.420 --> 07:45.700
you've got to explain, pick it up, hit this button,

07:45.700 --> 07:47.740
type this sequence of buttons, and so forth.

07:47.740 --> 07:50.780
So call mic is also an abstraction.

07:50.780 --> 07:55.620
So these abstractions are useful, but they can sometimes get in the way,

07:55.620 --> 08:01.700
especially if you're not precise enough to program the computer correctly.

08:01.700 --> 08:04.100
And to sort of paint this picture, thought

08:04.100 --> 08:07.100
we'd begin a little lightheartedly here.

08:07.100 --> 08:10.860
Brought some breakfast if you didn't quite make it next door or beyond.

08:10.860 --> 08:12.300
Just need a couple of volunteers.

08:12.300 --> 08:15.140
If you're comfy appearing on stage and on the internet here.

08:15.140 --> 08:17.020
Let me kind of, there's a lot of lights here.

08:17.020 --> 08:20.820
How about over there on the left and over here in the front?

08:20.820 --> 08:21.500
Yeah, right there.

08:21.500 --> 08:22.500
I think your hand was up.

08:22.500 --> 08:24.500
Come on down.

08:24.500 --> 08:27.340
And Brian, do you mind lending us a hand here, too?

08:27.340 --> 08:29.460
Come on down.

08:29.460 --> 08:29.960
Thank you.

08:29.960 --> 08:32.900
If you want to take control here, let me go ahead and switch over

08:32.900 --> 08:36.260
to another program for you.

08:36.260 --> 08:36.980
OK, what's your name?

08:36.980 --> 08:37.380
Gene.

08:37.380 --> 08:37.980
Gene, David.

08:37.980 --> 08:38.420
Nice to meet you.

08:38.420 --> 08:40.260
Have a seat on the far left in your name.

08:40.260 --> 08:40.900
Hi, I'm Abby.

08:40.900 --> 08:42.140
Abby, nice to meet you as well.

08:42.140 --> 08:43.420
On the far right, if you could.

08:43.420 --> 08:46.900
So Gene and Abby, do you want to say a little something about yourselves

08:46.900 --> 08:48.620
quickly?

08:48.620 --> 08:49.340
I'm Gene.

08:49.340 --> 08:51.420
I'm a Massachusetts native.

08:51.420 --> 08:53.340
And I'm taking CS for the first time.

08:53.340 --> 08:54.820
It's my first time coding or anything.

08:54.820 --> 08:56.940
So I'm doing this, and I'm enjoying it.

08:56.940 --> 08:57.300
Nice.

08:57.300 --> 08:58.580
Glad to have you with us.

08:58.580 --> 09:00.060
Abby?

09:00.060 --> 09:00.820
Hi, I'm Abby.

09:00.820 --> 09:02.300
I'm taking this as a sophomore.

09:02.300 --> 09:04.940
And I know nothing about computers and computer science.

09:04.940 --> 09:06.980
So I'm probably taking it sat on sat.

09:06.980 --> 09:08.620
OK, well, nice to have you as well.

09:08.620 --> 09:11.500
All right, so in front of us is a whole bunch of ingredients.

09:11.500 --> 09:13.460
And hopefully, we can start the semester off gently.

09:13.460 --> 09:16.260
And if we're successful, we'll actually have a quick bite here.

09:16.260 --> 09:17.980
But we thought we'd defer to the audience here.

09:17.980 --> 09:19.540
And Brian's going to scribe as we go.

09:19.540 --> 09:21.500
And all we want to do this morning is just

09:21.500 --> 09:23.980
make a peanut butter and jelly sandwich.

09:23.980 --> 09:27.580
One instruction at a time, and each of us will just execute what we hear.

09:27.580 --> 09:28.620
How's that sound?

09:28.620 --> 09:30.980
All right, if someone could volunteer with the first instruction.

09:30.980 --> 09:31.980
And Brian, I'll type it down.

09:36.860 --> 09:37.900
Open bread, we heard.

09:37.900 --> 09:39.300
Open bread is the first instruction.

09:39.300 --> 09:41.100
So if you'd like to execute, open bread.

09:47.380 --> 09:49.940
Don't look at me.

09:49.940 --> 09:51.260
OK.

09:51.260 --> 09:53.380
All right, so we're kind of on our way.

09:54.380 --> 09:59.420
OK, I think Abby did it better, certainly.

09:59.420 --> 10:01.500
But we did it correctly, arguably.

10:01.500 --> 10:05.580
So let's move on to step two and see if we can't improve.

10:05.580 --> 10:06.620
Take out bread.

10:11.540 --> 10:15.180
OK, welcome to the team now.

10:15.180 --> 10:17.740
Nice, all right, step three.

10:17.740 --> 10:18.740
Yeah.

10:18.740 --> 10:20.580
Place two pieces of bread on the table.

10:20.620 --> 10:22.860
Place two pieces of bread on the table.

10:26.860 --> 10:28.700
Never mind the plates.

10:28.700 --> 10:30.060
OK, step four.

10:34.820 --> 10:37.180
Twist cover of jelly till it opens.

10:37.180 --> 10:37.660
Thank you.

10:42.540 --> 10:43.260
Step five.

10:46.060 --> 10:49.180
Step five, yeah.

10:49.180 --> 10:51.780
Thank you, place the lid to the side.

10:51.780 --> 10:53.180
I took some liberties myself.

10:53.180 --> 10:54.980
Step six, take the knife.

11:01.740 --> 11:03.460
Peel off the cover of the jelly.

11:06.740 --> 11:07.660
No covers on ours.

11:12.140 --> 11:17.420
Stick knife into the bottle.

11:17.420 --> 11:19.100
From the top.

11:19.100 --> 11:19.600
Stick.

11:22.700 --> 11:24.660
OK, step nine.

11:28.380 --> 11:32.420
Rotate hands, so jelly ends up on.

11:32.420 --> 11:32.920
OK.

11:36.260 --> 11:39.260
OK, step quickly, 10.

11:42.660 --> 11:45.180
Yeah, step 10.

11:45.180 --> 11:46.180
Pull out the knife.

11:46.180 --> 11:47.940
Pull out knife, OK.

11:49.820 --> 11:56.260
Step 11, jelly side down on bread.

12:02.380 --> 12:04.860
All right, step 12.

12:09.660 --> 12:11.020
Step 12, anyone?

12:11.020 --> 12:12.700
Yes.

12:12.700 --> 12:15.180
Thank you.

12:15.180 --> 12:16.500
Step 13.

12:17.500 --> 12:20.500
Pour jelly on bread.

12:24.500 --> 12:25.740
Oh, pour jelly on bread.

12:25.740 --> 12:28.220
Pour jelly, jelly.

12:28.220 --> 12:28.900
All of it?

12:28.900 --> 12:30.340
OK, now you're just messing with us.

12:35.740 --> 12:37.220
Step 14.

12:40.620 --> 12:42.820
Put jelly down, thank you.

12:42.820 --> 12:45.300
15.

12:45.340 --> 12:48.460
Pick up peanut butter.

12:48.460 --> 12:49.700
Take lid off, thank you.

12:53.100 --> 12:55.380
Peel off lid, thank you.

12:57.900 --> 13:01.340
Step 18, pick up knife.

13:04.820 --> 13:08.060
By blunt end.

13:08.060 --> 13:09.780
Scoop, it's OK.

13:10.380 --> 13:11.380
Scoop.

13:11.380 --> 13:16.900
Step 20, put peanut butter on bread.

13:20.900 --> 13:22.540
21.

13:24.540 --> 13:28.060
Move the knife left to right, please.

13:28.060 --> 13:29.500
Left to right.

13:34.500 --> 13:38.180
Step 22, put peanut butter on bread.

13:38.620 --> 13:44.500
Step 22, thank you.

13:44.500 --> 13:49.980
23, 24, what was that?

13:54.460 --> 13:57.300
Eat sandwich, OK, I think we're OK.

13:57.300 --> 13:59.100
Well, how about why don't we each take a bite

13:59.100 --> 14:01.500
and a round of applause if we could for our volunteers.

14:01.500 --> 14:07.500
Thank you.

14:11.500 --> 14:14.980
You can take some for the row if you'd like.

14:14.980 --> 14:18.260
Thank you, so thank you, Brian.

14:18.260 --> 14:19.540
OK, now I need a minute.

14:19.540 --> 14:22.940
So thank you.

14:22.940 --> 14:28.900
So suffice it to say, this obviously demonstrated even more so

14:28.900 --> 14:32.260
than the phone book example where our certain assumptions are

14:32.260 --> 14:33.940
and our abstractions are.

14:33.940 --> 14:35.940
And honestly, almost all the time, those are useful.

14:35.940 --> 14:37.420
And of course, we kind of ham things up.

14:37.420 --> 14:40.100
And I think the instructions, we're kind of helping with that here.

14:40.100 --> 14:44.060
But when it comes time to program with Scratch and certainly with C starting

14:44.060 --> 14:47.340
this week, you can't really make as many of those assumptions anymore.

14:47.340 --> 14:49.700
Because if you don't handle these sort of corner cases,

14:49.700 --> 14:52.300
and if you don't think about what that instruction means,

14:52.300 --> 14:54.820
you're going to get the proverbial spinning beach ball or the hour

14:54.820 --> 14:56.540
glass that you're familiar with on your Mac or PC.

14:56.540 --> 14:57.940
The program is going to crash.

14:57.940 --> 15:02.180
Something's going to go wrong just because you missed some specificity

15:02.180 --> 15:03.460
or precision.

15:03.460 --> 15:09.460
Now, over, so over time, we're going to find that much like in Scratch,

15:09.460 --> 15:11.460
we were able to make our own building blocks.

15:11.460 --> 15:14.900
You might recall the short examples we did with the cough example, where

15:14.900 --> 15:17.300
I had cough 0 and then cough 1 and cough 2,

15:17.300 --> 15:20.260
where I was making my own puzzle piece within Scratch.

15:20.260 --> 15:23.420
That was useful because after that example, theoretically, I never again

15:23.420 --> 15:26.940
need to think about or worry about how to implement cough.

15:26.940 --> 15:28.460
I can just use that abstraction.

15:28.460 --> 15:30.860
But someone has to implement them, and sometimes it's

15:30.860 --> 15:34.180
going to be other people who come before us, and sometimes it's going to be us.

15:34.180 --> 15:37.020
So this isn't to say that programming ends up being so tedious

15:37.020 --> 15:39.060
that you have to point out every little thing,

15:39.060 --> 15:43.420
but you or someone does have to do that level of precision at least once.

15:43.420 --> 15:47.500
And nicely enough, in Scratch, MIT did most of that legwork for you.

15:47.500 --> 15:49.180
We all had the building blocks with which

15:49.180 --> 15:51.740
to make our own animation or game or artwork or the like.

15:51.740 --> 15:54.900
But even then, you probably had to connect several dozen puzzle pieces

15:54.900 --> 15:59.980
or even more to get those fundamentals to do what it is that you wanted it to do.

15:59.980 --> 16:02.420
So today, we're going to start to transition from Scratch,

16:02.420 --> 16:05.700
this graphical programming language that, while targeted at younger students,

16:05.700 --> 16:08.940
is typically representative of a lot of the same concepts that are now

16:08.940 --> 16:10.980
going to be laced throughout the semester.

16:10.980 --> 16:14.540
But we're going to introduce today an older, more traditional language that's

16:14.540 --> 16:15.460
just text-based.

16:15.460 --> 16:17.380
And as such, it's a lot more powerful.

16:17.380 --> 16:20.340
But at first glance, it's actually going to look a lot more cryptic.

16:20.340 --> 16:23.740
In fact, instead of writing 0s and 1s starting today,

16:23.740 --> 16:26.140
we're instead going to write something like this.

16:26.140 --> 16:29.020
Now, if you've never programmed before, odds are at first glance,

16:29.020 --> 16:30.940
this does look pretty cryptic.

16:30.940 --> 16:34.300
And there's a lot of symbols within it, punctuation from the keyboard.

16:34.300 --> 16:36.980
There's probably some familiar English-like words.

16:36.980 --> 16:40.620
And frankly, even after doing Scratch, anyone even with no prior background

16:40.620 --> 16:43.820
can probably hazard a guess as to what this program written

16:43.820 --> 16:47.580
in this other language called C does when you run it.

16:47.580 --> 16:49.180
It just prints hello world.

16:49.180 --> 16:52.540
Now, granted, there's a decent amount of overhead syntactically.

16:52.540 --> 16:55.220
There's a bunch of stuff you have to type to make this program do

16:55.220 --> 16:56.380
what you want it to do.

16:56.380 --> 16:58.980
But at the end of the day, that's all it's going to do.

16:58.980 --> 17:01.060
And this is among the simplest of programs.

17:01.060 --> 17:04.780
We're going to add to our puzzle pieces, so to speak, today in C,

17:04.780 --> 17:07.900
some of those same concepts that we saw last time as well.

17:07.900 --> 17:09.740
So let's do this first, though.

17:09.740 --> 17:13.420
Let me take a moment to sort of compare Scratch to C,

17:13.420 --> 17:15.380
because the most important takeaway for today

17:15.380 --> 17:18.300
is going to be that even if the syntax doesn't look so obvious,

17:18.300 --> 17:22.020
and frankly, even if your first minutes or hours with writing your own code

17:22.020 --> 17:25.300
in C is frustrating because, damn it, you left off a semicolon,

17:25.300 --> 17:27.420
or, oh, I had a parenthesis in the wrong place.

17:27.420 --> 17:30.740
There's a lot of these stupid syntactic hangups that make you feel quite often

17:30.740 --> 17:33.540
that you really aren't getting it, but that's not the important stuff.

17:33.540 --> 17:36.260
A lot of the syntax is the least important.

17:36.260 --> 17:38.700
It's not at all fundamentally intellectually interesting.

17:38.700 --> 17:41.620
So try to see past that, and try to take comfort in the fact

17:41.620 --> 17:44.340
that it's the principles that are going to be important.

17:44.340 --> 17:46.420
And honestly, just through muscle memory and practice,

17:46.420 --> 17:49.060
all of the other stuff that at first is going

17:49.060 --> 17:51.700
to be an occasional frustration, it just starts to go away

17:51.700 --> 17:55.780
as you start to see this for what it is and not for the syntax alone

17:55.780 --> 17:57.660
that you see on first glance.

17:57.660 --> 18:03.020
So this is to say, this program on the right in C is equivalent to what

18:03.020 --> 18:05.660
we did just a week ago with two puzzle pieces in Scratch.

18:05.660 --> 18:08.620
Now, there isn't going to be a green flag on my Mac or my PC

18:08.620 --> 18:10.340
as we move forward that you can just click.

18:10.340 --> 18:12.580
We're going to have to run these programs in a little different way,

18:12.580 --> 18:14.380
but that's all the code on the right is doing.

18:14.380 --> 18:15.820
It's equivalent to the code on the left.

18:15.820 --> 18:18.780
So let's do this again and again for just a few of those concepts from last time,

18:18.780 --> 18:21.220
and then we'll start writing some of our own programs.

18:21.220 --> 18:27.060
So this was an example, this purple block of what concept in programming?

18:27.060 --> 18:27.820
Yeah, function.

18:27.820 --> 18:29.540
So it was a verb, it was an action, and we're

18:29.540 --> 18:30.940
going to call those generally functions.

18:30.940 --> 18:32.740
They just have functionality built into them.

18:32.740 --> 18:33.980
So how do we do this in C?

18:33.980 --> 18:35.780
Well, you might remember from just a moment ago,

18:35.780 --> 18:38.740
because one of the lines of code was representative of this,

18:38.740 --> 18:40.540
it had some of this syntax.

18:40.540 --> 18:43.700
So in fact, if I were to translate the block on the left in Scratch

18:43.700 --> 18:46.940
to the equivalent code in this other text-based language called C,

18:46.940 --> 18:49.780
I'm going to start by writing print and then open parenthesis

18:49.780 --> 18:51.020
and then close parenthesis.

18:51.020 --> 18:54.260
And those parentheses kind of represent the oval, the white oval

18:54.260 --> 18:57.140
on the left that we typed hello world into before.

18:57.140 --> 18:59.500
Now in C, it's not quite as literal as that.

18:59.500 --> 19:02.420
The function or the verb is actually not called print.

19:02.420 --> 19:05.060
It's called printf, and the f stands for formatted.

19:05.060 --> 19:07.220
And it just means that in C, you can actually

19:07.220 --> 19:08.980
format your text in different ways.

19:08.980 --> 19:10.540
So we'll see that before long.

19:10.540 --> 19:13.540
And it turns out that you don't just write hello world between those

19:13.540 --> 19:15.300
parentheses like we did in Scratch.

19:15.300 --> 19:18.700
You also actually have to surround them with double quotes in C.

19:18.700 --> 19:20.340
OK, not such a big deal, but something you

19:20.340 --> 19:21.660
didn't have to do before.

19:21.660 --> 19:24.460
But you know what, in C, you're also going to generally

19:24.460 --> 19:26.700
want to be super specific to the computer.

19:26.700 --> 19:29.340
And when you want the cursor, the text on the screen,

19:29.340 --> 19:32.220
to move down to the next line, you need to tell the computer

19:32.220 --> 19:34.540
that by literally typing backslash n.

19:34.540 --> 19:36.900
The human is not going to see a backslash and an n.

19:36.900 --> 19:39.740
He or she is actually going to see the cursor move to the next line

19:39.740 --> 19:43.420
of the screen, like in Google Docs or in Microsoft Word or the like.

19:43.420 --> 19:45.820
But this just speaks to the precision that you

19:45.820 --> 19:48.420
need to have when talking to a computer at this level

19:48.420 --> 19:50.060
and not just with the puzzle pieces.

19:50.060 --> 19:52.180
And then one last thing, and I alluded to it earlier,

19:52.180 --> 19:54.740
because it's sort of the bane of a lot of programmers early on,

19:54.740 --> 19:58.900
most lines of code in C have to end in a semicolon.

19:58.900 --> 20:02.780
That's the sort of code equivalent of a period in English or some other language

20:02.780 --> 20:03.540
in sentence.

20:03.540 --> 20:04.260
So that's it.

20:04.260 --> 20:07.100
It took us a little while to kind of build that up, but that's all it is.

20:07.100 --> 20:09.740
The idea on the left of saying something is the same in C

20:09.740 --> 20:13.540
as printing something with this function called printf.

20:13.540 --> 20:15.900
And before I forge ahead with some other comparisons,

20:15.900 --> 20:18.460
any questions on just this translation?

20:18.460 --> 20:20.980
How do you write backslash n?

20:20.980 --> 20:22.260
How do you write backslash n?

20:22.260 --> 20:22.760
Good.

20:22.760 --> 20:26.940
So thinking ahead, this would seem to make it hard to literally show the user

20:26.940 --> 20:28.180
backslash n.

20:28.180 --> 20:32.780
Well, it turns out that this backslash, because it's not a terribly common character,

20:32.780 --> 20:35.780
the programming world uses it as what's called an escape character.

20:35.780 --> 20:39.020
It's one that you use when you want to escape information

20:39.020 --> 20:40.820
and show it in a slightly different way.

20:40.820 --> 20:43.380
So the way you would show literally to the human,

20:43.420 --> 20:49.460
a actual backslash n is to actually, in your code, do backslash backslash

20:49.460 --> 20:53.340
n, because the second backslash is like saying, treat the next character

20:53.340 --> 20:55.620
special and actually show it to the human.

20:55.620 --> 20:57.500
And there's other such examples of that.

20:57.500 --> 20:58.580
So how about this one?

20:58.580 --> 21:03.020
This orange block was an example of what concept in scratch?

21:03.020 --> 21:03.460
Yeah.

21:03.460 --> 21:05.940
So this was a variable, like an x and y and algebra.

21:05.940 --> 21:07.500
This was just a placeholder for data.

21:07.500 --> 21:09.020
And you could store numbers.

21:09.020 --> 21:10.420
It turns out you can store words.

21:10.420 --> 21:12.740
You can store other things, too, in other languages.

21:12.740 --> 21:14.620
So in C, we're going to do this.

21:14.620 --> 21:17.500
We're going to say literally the name of the variable we want, for instance,

21:17.500 --> 21:20.780
counter, but we could call it anything we want, equals 0,

21:20.780 --> 21:22.940
if we're setting it initially equal to 0.

21:22.940 --> 21:24.980
But C is a little more pedantic.

21:24.980 --> 21:28.380
You've also got to tell the computer, this type of variable I want

21:28.380 --> 21:32.140
is specifically for an integer, otherwise abbreviated int.

21:32.140 --> 21:34.700
So you have to tell the computer in advance what type of data you're

21:34.700 --> 21:36.620
going to store in it and take a guess.

21:36.620 --> 21:40.780
You've got to finish the thought and see, what more do we need to add to the?

21:40.780 --> 21:42.100
Yeah, just a semicolon.

21:42.140 --> 21:43.020
And that's it.

21:43.020 --> 21:46.820
Looks a little more cryptic, but the idea is fundamentally the same.

21:46.820 --> 21:48.820
So what if we wanted to do this in scratch?

21:48.820 --> 21:50.220
Change counter by 1.

21:50.220 --> 21:54.220
This was equivalent to incrementing or adding 1 to counter.

21:54.220 --> 21:57.500
Well, let me go ahead and propose that you could literally just do this in C.

21:57.500 --> 22:03.740
Set counter equal to whatever counter currently is, plus 1.

22:03.740 --> 22:05.580
That seems to be kind of the right intuition.

22:05.580 --> 22:09.300
And now notice what's key to note here is that this equal sign

22:09.300 --> 22:12.900
isn't saying that counter equals counter plus 1,

22:12.900 --> 22:15.460
because that just doesn't seem possible.

22:15.460 --> 22:19.460
If you pick any value for counter, like the number 1, well, 1 definitely

22:19.460 --> 22:22.700
does not equal 1 plus 1, which is 2.

22:22.700 --> 22:24.180
And 1 does not equal 2.

22:24.180 --> 22:28.220
And you can come up with an infinite number of worrisome incorrect comparisons.

22:28.220 --> 22:31.420
So the equal sign in C, like a lot of languages we'll see in the class,

22:31.420 --> 22:32.580
actually means assignment.

22:32.580 --> 22:36.020
Copy the value on the right into the value on the left.

22:36.020 --> 22:39.420
So set counter equal to whatever it is, plus 1.

22:39.420 --> 22:42.780
Well, we've got to finish the thought, so we need a semicolon.

22:42.780 --> 22:45.780
I don't, though, need to re-mention int.

22:45.780 --> 22:48.460
And why might that be?

22:48.460 --> 22:50.620
Yeah, I already told the computer it's an integer.

22:50.620 --> 22:52.860
You don't need to repeat yourself by mentioning int again,

22:52.860 --> 22:56.220
assuming in this context, even though we're looking at it just on the slide,

22:56.220 --> 22:59.020
has actually been created before, just like you

22:59.020 --> 23:01.180
did with scratch by saying make a variable.

23:01.180 --> 23:04.780
So it turns out you can be a little more succinct in C in a lot of languages.

23:04.820 --> 23:08.180
If you find this a little tedious to type, and it's a little verbose,

23:08.180 --> 23:10.860
it's a bunch of keystrokes, you can actually abbreviate it with just this.

23:10.860 --> 23:15.940
So plus equals is just syntactic sugar, as a programmer would say.

23:15.940 --> 23:19.620
It's just a nice, fancy feature that lets you write fewer words or characters,

23:19.620 --> 23:20.620
but do the same thing.

23:20.620 --> 23:22.060
And frankly, we can do a little better.

23:22.060 --> 23:25.020
And if you've taken a PCS, you might have seen this in Java as well.

23:25.020 --> 23:30.100
You can also simplify this even more to just counter plus plus semicolon.

23:30.100 --> 23:31.500
So that's it, all equivalent.

23:31.500 --> 23:32.980
This is just a little more efficient.

23:33.020 --> 23:36.620
As you get more comfortable programming, saving keystrokes just saves you time.

23:36.620 --> 23:40.780
Now this, of course, was an example of what in scratch, by contrast.

23:40.780 --> 23:43.700
Yeah, we called this a condition, and it had a Boolean expression

23:43.700 --> 23:45.740
that we were asking a question of.

23:45.740 --> 23:48.940
In this case, we're apparently asking in scratch, is x less than y.

23:48.940 --> 23:51.220
And if so, say it on the screen.

23:51.220 --> 23:53.060
So how might we translate this to C?

23:53.060 --> 23:56.660
Well, it turns out we can quite simply translate this one pretty literally.

23:56.660 --> 23:59.260
We've seen almost all of the building blocks thus far,

23:59.260 --> 24:01.780
but we do have to introduce a little something new here.

24:01.820 --> 24:05.740
Notice that the printf line is almost identical to what I used earlier

24:05.740 --> 24:06.540
for just Hello World.

24:06.540 --> 24:10.140
I've obviously just changed the words in it, but I still have the backslash n.

24:10.140 --> 24:12.380
I still have the quotes, still have the semicolon.

24:12.380 --> 24:14.580
So the rest of that is the same.

24:14.580 --> 24:17.620
Now if is new, but this is a one-to-one translation.

24:17.620 --> 24:19.340
Scratch calls it if, C calls it if.

24:19.340 --> 24:20.940
And the only additional thing you need in C

24:20.940 --> 24:22.940
is parentheses around the Boolean expression.

24:22.940 --> 24:26.100
So that's what takes the place of the little green block there.

24:26.100 --> 24:30.100
And then assuming x and y are indeed variables that we created earlier,

24:30.100 --> 24:31.900
you can just compare them like this.

24:31.900 --> 24:34.900
And you can use greater than and other symbols for comparison as well.

24:34.900 --> 24:36.540
But there is something a little interesting.

24:36.540 --> 24:40.260
And most of us don't often have occasion to even use these keys on our keyboard.

24:40.260 --> 24:43.820
Curly braces on a US keyboard, they tend to be over on the top right

24:43.820 --> 24:45.420
above your Enter key.

24:45.420 --> 24:49.620
These are just kind of C's equivalent of this shape.

24:49.620 --> 24:52.380
Notice that most of the yellow blocks in Scratch

24:52.380 --> 24:56.180
kind of had this embracing or this embracing shape to them.

24:56.180 --> 24:59.740
You can simulate that in C by having what's called an open curly brace

24:59.780 --> 25:00.940
and then a closed curly brace.

25:00.940 --> 25:02.380
So that's the same exact idea.

25:02.380 --> 25:06.340
Now as an aside, you don't technically always need these curly braces.

25:06.340 --> 25:08.980
If you've just got a one-liner like this, you can omit them

25:08.980 --> 25:10.820
as you might see online or in textbooks.

25:10.820 --> 25:12.660
But we'll just always draw them for consistency

25:12.660 --> 25:17.380
so that the C code always looks like this.

25:17.380 --> 25:20.300
What if you wanted to express this, though?

25:20.300 --> 25:23.100
If x is less than y, then say x is less than y.

25:23.100 --> 25:25.660
Else, say x is not less than y.

25:25.660 --> 25:27.940
Well, it turns out this is almost identical.

25:27.940 --> 25:31.580
So the first four lines perfectly the same as before.

25:31.580 --> 25:35.740
But it turns out in C you can literally say else after that closing curly brace

25:35.740 --> 25:39.140
and then just print out alternatively whatever it is you want to say.

25:39.140 --> 25:40.820
So this is like the fork in the road.

25:40.820 --> 25:42.340
If you go one way, say this.

25:42.340 --> 25:45.340
If you go the other way, say this other thing.

25:45.340 --> 25:47.580
Any questions on these comparisons thus far?

25:47.580 --> 25:48.080
Yeah?

25:48.080 --> 25:52.780
Can we put the first bracket on the same line?

25:52.780 --> 25:54.340
Really good question.

25:54.340 --> 25:56.940
Can you or do you put the curly brace on the same line

25:56.940 --> 25:57.940
as the if you can?

25:57.940 --> 26:01.180
And we're going to talk about this in the next couple of weeks, this matter of style.

26:01.180 --> 26:04.620
There are different ways I could express this exact same code.

26:04.620 --> 26:09.380
Frankly, I could write out all of this code with no spaces whatsoever.

26:09.380 --> 26:13.820
In fact, just to make that point, if I go ahead and just open up a simple text

26:13.820 --> 26:17.620
editor here, not to actually program, but to just type something,

26:17.620 --> 26:20.020
I could actually do something like this.

26:20.020 --> 26:28.540
If x less than y, then go ahead and print out x is less than y backslash n semicolon

26:28.540 --> 26:31.380
curly brace else print and so forth.

26:31.380 --> 26:34.140
Completely unreadable at the end of the day or unmaintainable,

26:34.140 --> 26:35.860
especially when the code gets complicated.

26:35.860 --> 26:38.660
But white space does not tend to matter to the computer,

26:38.660 --> 26:40.060
but it does matter to the human.

26:40.060 --> 26:42.260
And as you're alluding to in some languages,

26:42.260 --> 26:46.540
it's actually conventional to do this, where you actually keep the curly brace

26:46.540 --> 26:47.340
on the same line.

26:47.340 --> 26:50.460
And indeed, you might see textbooks do this as well.

26:50.460 --> 26:52.260
Some people will even do this.

26:52.260 --> 26:54.300
These are all long story short matters of style.

26:54.300 --> 26:56.900
And CS50, in the earliest weeks of the class,

26:56.900 --> 26:59.420
we're going to insist that everyone follow the same style,

26:59.420 --> 27:01.380
so that we have some basis for comparison.

27:01.380 --> 27:03.180
But eventually, this is the kind of thing

27:03.180 --> 27:06.900
that, like in your own English writing or whatever language you tend to write in,

27:06.900 --> 27:09.940
you have your own sort of stylistic or linguistic flair to it.

27:09.940 --> 27:11.580
Code has that as well.

27:11.580 --> 27:13.460
Other questions?

27:13.460 --> 27:14.460
Yeah?

27:14.900 --> 27:17.180
Do you establish the counter variable?

27:17.180 --> 27:22.380
Do you always have to say what is equal to or equal to the counter?

27:22.380 --> 27:23.260
Really good question.

27:23.260 --> 27:25.740
When you declare a variable, create a variable,

27:25.740 --> 27:28.420
do you have to set it equal to something right away?

27:28.420 --> 27:29.340
Short answer, no.

27:29.340 --> 27:32.020
And we'll see examples of that before long, where you can actually say,

27:32.020 --> 27:36.980
give me a variable called counter, but don't actually set it equal to some value.

27:36.980 --> 27:38.780
Come back to that in a bit.

27:38.780 --> 27:41.340
All right, so what if we want to add this logic?

27:41.340 --> 27:44.620
Frankly, in Scratch, it's starting to look a little overwhelming,

27:44.620 --> 27:46.540
but this is just a three-way fork in the road.

27:46.540 --> 27:48.980
If x is less than y, say so.

27:48.980 --> 27:52.380
Else if x is greater than y, say so.

27:52.380 --> 27:57.140
Else if x equals y, then go ahead and say they're equal.

27:57.140 --> 28:00.820
And in C, we can do this translation pretty directly as well.

28:00.820 --> 28:04.620
In fact, now the first eight lines of code are identical to before,

28:04.620 --> 28:08.580
except this middle one here, where I'm adding a second Boolean expression,

28:08.580 --> 28:10.580
is x greater than y.

28:10.580 --> 28:13.900
And then I have this third condition, else if x equals y.

28:13.900 --> 28:19.420
But there seems to be a typo, perhaps, or something anomalous here.

28:19.420 --> 28:20.180
Does anything jump out?

28:20.180 --> 28:22.580
Yeah.

28:22.580 --> 28:27.020
I have a double equal sign, which maybe is just a typographical error on my part.

28:27.020 --> 28:28.180
But turns out it's not.

28:28.180 --> 28:29.900
This is deliberate.

28:29.900 --> 28:30.740
But why?

28:30.740 --> 28:33.380
This seems like our first example of where Scratch doesn't really

28:33.380 --> 28:34.780
map perfectly to C. Yeah.

28:34.820 --> 28:38.900
So the equal sign is an assignment, and so not the equal sign,

28:38.900 --> 28:40.780
and actually the same thing.

28:40.780 --> 28:41.340
Exactly.

28:41.340 --> 28:45.340
We already, a moment ago, decided as humans, really years ago,

28:45.340 --> 28:48.260
equals is actually, in the context of C, going to be assignment.

28:48.260 --> 28:51.020
Copy the value from the right to the value on the left.

28:51.020 --> 28:53.140
And so we kind of painted ourselves into a corner.

28:53.140 --> 28:55.020
We still, as humans, as programmers, want

28:55.020 --> 28:58.300
to be able to express the notion of equality and comparing.

28:58.300 --> 29:00.700
But if we've already used the equal sign for assignment,

29:00.700 --> 29:03.980
we need another pattern of symbols to represent equality.

29:03.980 --> 29:07.540
And as it turns out, humans just chose two equal signs instead.

29:07.540 --> 29:09.260
So slightly different from Scratch.

29:09.260 --> 29:11.420
The reason Scratch does it this way is because you don't really

29:11.420 --> 29:12.980
want to have to get into those weeds.

29:12.980 --> 29:15.500
Certainly when the target audience is eight-year-olds just learning

29:15.500 --> 29:17.660
to program in the first place, it's not important.

29:17.660 --> 29:19.820
Nor is it really important for us, but for us,

29:19.820 --> 29:23.060
there's going to be a logical difference.

29:23.060 --> 29:25.540
Because if we use the wrong one, the behavior is going to be wrong.

29:25.540 --> 29:27.620
If we had just one equal sign, we would literally

29:27.620 --> 29:32.180
be changing x to equal y rather than just comparing it.

29:32.180 --> 29:34.260
How is their hand in here?

29:34.260 --> 29:34.760
Yeah?

29:34.760 --> 29:35.620
Just a quick question.

29:35.620 --> 29:38.340
So if you wanted to express greater than or equal to,

29:38.340 --> 29:40.380
would you write equal greater than?

29:40.380 --> 29:40.880
Good question.

29:40.880 --> 29:44.140
If you wanted to express greater than or equal to, how might you do that?

29:44.140 --> 29:46.140
It turns out there are ways to do that.

29:46.140 --> 29:50.060
And if I go ahead and just give myself some place to draw here for a moment,

29:50.060 --> 29:55.900
you can actually, indeed, do less than or equal or greater than or equal.

29:55.900 --> 29:58.540
There's no way on a typical keyboard to put them atop each other,

29:58.540 --> 29:59.940
like you might recall for math class.

29:59.940 --> 30:01.300
So you just put them next to each other.

30:05.180 --> 30:06.060
Well, it depends.

30:06.060 --> 30:08.900
I want the double equal sign here, because I

30:08.900 --> 30:15.020
want to explicitly check this third case and say x is equal to y.

30:15.020 --> 30:16.060
So that was my goal.

30:16.060 --> 30:17.860
But logically, this is not necessary.

30:17.860 --> 30:20.380
Let's make the program a little better designed.

30:20.380 --> 30:26.140
How many possible cases are there when comparing two integers, x and y,

30:26.140 --> 30:29.020
for greater than, less than, or equality?

30:29.220 --> 30:31.580
I just answered the question, didn't I?

30:31.580 --> 30:32.460
Is there a?

30:32.460 --> 30:33.620
Three, excellent.

30:33.620 --> 30:34.940
There's three scenarios there.

30:34.940 --> 30:38.140
x is either less than or greater than or equal to.

30:38.140 --> 30:41.260
And I'm hard pressed to think of a fourth.

30:41.260 --> 30:46.340
So do I need this amount of specificity?

30:46.340 --> 30:49.220
What could I do to give myself a slight optimization,

30:49.220 --> 30:52.060
improve the code just a little bit, just to save myself a little bit of time

30:52.060 --> 30:54.900
writing it, and maybe even the computer a little time running it?

30:54.900 --> 30:55.380
Yeah?

30:55.380 --> 30:56.580
You don't need the last condition.

30:56.580 --> 30:58.740
Yeah, I don't need the last condition, because if we all

30:58.740 --> 31:03.300
agree logically that either x is less than y or greater than y or maybe

31:03.300 --> 31:05.940
equal to y, well, if there's only a third and final case,

31:05.940 --> 31:07.500
that can just be my so-called else.

31:07.500 --> 31:09.620
Just make that be the so-called default case.

31:09.620 --> 31:13.140
And in fact, even though this is what most people would call an over

31:13.140 --> 31:15.860
optimization, you are saving the computer some time.

31:15.860 --> 31:18.420
Because suppose that x does, in fact, equal y,

31:18.420 --> 31:20.260
and they're both the value number one.

31:20.260 --> 31:24.860
So is one less than one when this line of code is executed?

31:24.860 --> 31:26.460
True or no?

31:26.460 --> 31:27.380
No, obviously not.

31:27.380 --> 31:28.580
One is not less than one.

31:28.620 --> 31:31.980
So this code does not execute, but the Boolean expression is evaluated,

31:31.980 --> 31:32.480
so to speak.

31:32.480 --> 31:33.860
The question is asked.

31:33.860 --> 31:35.820
Is one greater than one?

31:35.820 --> 31:36.580
No.

31:36.580 --> 31:39.500
And so this code is not executed, but this Boolean expression is.

31:39.500 --> 31:43.820
So we just spent another step or second, or however fast the computer is,

31:43.820 --> 31:45.820
is one equal to one?

31:45.820 --> 31:46.380
Yeah, it is.

31:46.380 --> 31:47.860
So this actually prints.

31:47.860 --> 31:49.980
But to your point, you don't need to ask that question.

31:49.980 --> 31:52.900
And in fact, you just increased by a factor of 50%

31:52.900 --> 31:56.820
how many questions you're asking, so you just wasted a little bit of time.

31:56.820 --> 31:59.620
Now, as an aside, are Macs and PCs and phones these days?

31:59.620 --> 32:01.700
I mean, again, they're operating at like a gigahertz speed,

32:01.700 --> 32:03.500
one billion things per second.

32:03.500 --> 32:07.020
So in practice, who cares if you're asking that third question?

32:07.020 --> 32:09.980
And frankly, if it makes your code more readable,

32:09.980 --> 32:12.900
or to your teaching fellow, or to a colleague, or a friend who's

32:12.900 --> 32:14.900
working on the program for you, then that's great.

32:14.900 --> 32:18.100
If it's more clear from the code what's going on, leave it that way.

32:18.100 --> 32:21.060
But these are the kinds of design decisions that we'll now make.

32:21.060 --> 32:24.400
And arguably, this version of the Scratch program and this version

32:24.400 --> 32:26.680
of the C code is just a little better design,

32:26.680 --> 32:32.200
because why write more code than you need to to express the exact same idea?

32:32.200 --> 32:32.760
All right.

32:32.760 --> 32:33.800
So what about this?

32:33.800 --> 32:35.360
This was a loop in Scratch.

32:35.360 --> 32:38.800
This was an infinite loop, because it was just forever saying hello world.

32:38.800 --> 32:41.860
Now, in C, this gets a little less directly translated.

32:41.860 --> 32:44.120
It turns out C uses the keyword while.

32:44.120 --> 32:47.880
So there is no forever keyword in C, but there is the word while.

32:47.880 --> 32:51.600
And of course, I'm going to use my curly braces, or curly braces,

32:51.600 --> 32:54.920
or curly brackets to kind of encompass the following lines of code.

32:54.920 --> 32:57.320
The line of code I want in there is just another printf,

32:57.320 --> 32:59.400
so that's the exact same as before.

32:59.400 --> 33:01.680
But it's not sufficient to just say while.

33:01.680 --> 33:06.760
It turns out that while wants you to ask it a question every time the loop

33:06.760 --> 33:09.000
executes, and it's going to check that question.

33:09.000 --> 33:11.320
And if the answer is yes, it's going to run the loop.

33:11.320 --> 33:15.720
But if the answer being asked in C is ever no or false,

33:15.720 --> 33:17.520
it's going to not execute the code, and it's just

33:17.520 --> 33:20.840
going to move on to any further lines of code lower down in the file.

33:20.840 --> 33:24.600
So in C, you actually need a pair of parentheses after the keyword while.

33:24.600 --> 33:26.880
And then you need to ask a question.

33:26.880 --> 33:29.960
You need to ask a question like, is x less than y?

33:29.960 --> 33:31.940
Or a question like, is x greater than y?

33:31.940 --> 33:33.600
Or is x equal to y?

33:33.600 --> 33:36.840
But none of those scenarios apply, because the whole purpose of this

33:36.840 --> 33:40.160
scratch block is literally to do something forever.

33:40.160 --> 33:45.040
So what's a question we could ask to which the answer is surely true?

33:47.440 --> 33:48.480
Does one equal one?

33:48.480 --> 33:52.280
We could kind of contrive an arbitrary but very mathematically correct scenario.

33:52.280 --> 33:54.600
We could just say, does one equal equal one?

33:54.600 --> 33:57.800
But it turns out you can be even more succinct, because in C,

33:57.800 --> 34:01.960
there's a couple key words, one of which is true, one of which is false.

34:01.960 --> 34:04.840
And the word true is by definition always true,

34:04.840 --> 34:06.920
and the word false is by definition always false.

34:06.920 --> 34:08.840
So you don't need to contrive some arbitrary,

34:08.840 --> 34:13.720
but correct the idea of does one equal equal one, or does 50 equal equal 50.

34:13.720 --> 34:16.000
You don't need to just come up with some arbitrary solution.

34:16.040 --> 34:21.280
You can literally just say true, because that key word true never changes value.

34:21.280 --> 34:23.160
So even though this is a little weird looking,

34:23.160 --> 34:26.760
it's how you induce something to happen forever.

34:26.760 --> 34:28.680
You ask the same question again, and assume

34:28.680 --> 34:31.520
that the question always has the same answer of true.

34:31.520 --> 34:34.960
Any questions on that one?

34:34.960 --> 34:36.840
Yeah, in the back.

34:36.840 --> 34:40.760
Do spaces matter, or do you take out the space in a while?

34:40.760 --> 34:41.360
Good question.

34:41.360 --> 34:43.040
Do spaces matter?

34:43.040 --> 34:45.240
Short answer, no, not in this case.

34:45.240 --> 34:48.320
You can add, in fact, delete all of the spaces here,

34:48.320 --> 34:49.960
except for the one in the English phrase,

34:49.960 --> 34:52.160
and it would still be functionally correct.

34:52.160 --> 34:54.440
You can even add spaces anywhere you want.

34:54.440 --> 34:56.640
You can make this taller by hitting Enter a bunch of times,

34:56.640 --> 34:58.800
Tab, Spaces around the word true.

34:58.800 --> 35:02.120
All of the examples I'll show here today, and you'll see in the coming weeks,

35:02.120 --> 35:05.040
are sort of the better way to do things, because they're more readable.

35:05.040 --> 35:06.840
But again, as you get more comfortable with code,

35:06.840 --> 35:08.440
or if you're coming in with some prior experience,

35:08.440 --> 35:10.040
you might already have your own opinions.

35:10.040 --> 35:12.680
And frankly, this is just a religious debate among programmers,

35:12.680 --> 35:14.480
which is the right way to write your code.

35:14.480 --> 35:15.080
And that's fine.

35:15.080 --> 35:18.240
Once you get comfy, so long as you're consistent is the most important thing.

35:18.240 --> 35:20.800
You don't need to adhere to one person's or the other.

35:20.800 --> 35:22.640
So how does this code work logically?

35:22.640 --> 35:25.360
Well, the first thing the computer, your Mac or PC, or your phone,

35:25.360 --> 35:28.080
or whatever is going to do, it's going to ask the question.

35:28.080 --> 35:28.840
Well, true.

35:28.840 --> 35:32.280
Well, true is always true, so it's going to proceed to execute the line of code.

35:32.280 --> 35:35.360
But after it does, because that's the entirety of the code that's

35:35.360 --> 35:37.560
been between the curly braces, we could have more lines.

35:37.560 --> 35:39.520
These are just short programs.

35:39.520 --> 35:42.440
The computer is going to check, OK, is true still true?

35:42.440 --> 35:44.640
Yes, so it's going to execute it again.

35:44.640 --> 35:47.000
Then it's going to ask the question again, is true still true?

35:47.000 --> 35:49.120
Yes, so it's going to execute the code again,

35:49.120 --> 35:52.960
and this is going to repeat literally forever.

35:52.960 --> 35:55.240
But what if you don't want to repeat something forever?

35:55.240 --> 35:57.120
What if you only want to repeat it 50 times?

35:57.120 --> 35:59.400
Scratch doesn't make you think very hard about this.

35:59.400 --> 36:02.960
It will just figure out how to keep track of 1, 2, 3, 4, 5,

36:02.960 --> 36:04.920
it all the way up to 50, and then stop.

36:04.920 --> 36:05.440
That's nice.

36:05.440 --> 36:07.160
It makes it easy to use the block.

36:07.160 --> 36:11.640
C and a lot of languages aren't quite that user-friendly.

36:11.640 --> 36:15.040
You will see later in the semester that newer languages are a little closer

36:15.040 --> 36:16.320
to what Scratch offers.

36:16.320 --> 36:18.280
But in C, we need to be more explicit.

36:18.280 --> 36:20.960
But this is a chance to use some of these more primitive building blocks.

36:20.960 --> 36:26.400
In C, the equivalent of repeat is going to be the preposition for,

36:26.400 --> 36:28.280
just because for now.

36:28.280 --> 36:32.080
And then just as before, if we want to do something again and again

36:32.080 --> 36:34.160
within this loop, we're going to use the curly braces,

36:34.160 --> 36:36.560
similar to the little orange block there.

36:36.560 --> 36:37.720
And then what am I going to do?

36:37.720 --> 36:40.840
I'm going to do this every time, 50 times, hopefully.

36:40.840 --> 36:42.400
Print out, hello, world.

36:42.400 --> 36:46.280
So now I just need to figure out in C how to express the number of times

36:46.280 --> 36:48.080
specifically 50.

36:48.080 --> 36:50.920
So it turns out in C, use parentheses again.

36:50.920 --> 36:54.120
This is going to be a pretty common characteristic of a lot of the code

36:54.120 --> 36:54.960
rewrite.

36:54.960 --> 36:56.840
And then you need to do three things.

36:56.840 --> 36:59.920
The burden is now going to be on us, the programmer,

36:59.920 --> 37:04.080
to keep track of how many times we want to execute this code,

37:04.080 --> 37:07.240
to how many times we've already executed this code,

37:07.240 --> 37:10.200
and then constantly make sure that one does not exceed the other.

37:10.200 --> 37:12.280
So we stop once we hit 50.

37:12.280 --> 37:14.840
So what's the sort of fundamental construct

37:14.840 --> 37:18.560
that we use to keep track of anything in a program?

37:18.560 --> 37:20.400
Counter, which was an example of a variable.

37:20.400 --> 37:22.160
So we just need to use a variable.

37:22.160 --> 37:24.960
Now, it's actually going to be inside of the parentheses this time.

37:24.960 --> 37:27.320
So it's not on its own as it was just a bit ago.

37:27.320 --> 37:28.880
But the syntax is the same.

37:28.880 --> 37:30.120
I could call it counter.

37:30.120 --> 37:32.360
But the reality is that the convention in programming

37:32.360 --> 37:35.440
is just to use shorter variables when you're just doing something mundane.

37:35.440 --> 37:38.560
And if all you're doing is looping, i stands for integer,

37:38.560 --> 37:41.480
is sort of many programmers go to variable name rather than the more

37:41.480 --> 37:44.000
verbose but correct counter or whatever.

37:44.000 --> 37:47.840
So this says, hey, computer, give me a variable called i.

37:47.840 --> 37:52.800
Let me store integers or ints in it and set the initial value to 0.

37:52.800 --> 37:53.480
Why?

37:53.480 --> 37:57.040
Well, almost everyone in this room probably starts counting from 1.

37:57.040 --> 37:59.840
Computers just tend to start counting from 0.

37:59.840 --> 38:00.320
But why?

38:00.320 --> 38:03.680
What's the rationale for starting to count from 0, perhaps, based on last week?

38:04.680 --> 38:05.680
Why is that kind of makes sense?

38:05.680 --> 38:06.680
Yeah, what do you think?

38:06.680 --> 38:08.680
Yeah, it's just 1s and 0s.

38:08.680 --> 38:09.680
And what's the smallest number?

38:09.680 --> 38:11.680
Negative values aside that you can represent in binary?

38:11.680 --> 38:14.680
Well, it's just 0, 0, 0, the bunch of 0s.

38:14.680 --> 38:18.160
So why would you waste that representation, that permutation of bits?

38:18.160 --> 38:20.880
Let's just start counting at 0 and then add to that.

38:20.880 --> 38:25.120
So you can start counting from 1 in C. But the convention in most languages

38:25.120 --> 38:25.920
is count from 0.

38:25.920 --> 38:27.680
So we'll get off on that footage.

38:27.680 --> 38:29.680
So let's just start counting from 0.

38:29.680 --> 38:32.680
In C, but the convention in most languages is count from 0.

38:32.680 --> 38:34.360
So we'll get off on that foot as well.

38:34.360 --> 38:42.200
And you might recall, even, that in our PBJ code for the phone book,

38:42.200 --> 38:44.120
pseudocode, I actually deliberately started

38:44.120 --> 38:48.040
numbering the lines from 0 to 1 to 2 for that same intuition.

38:48.040 --> 38:50.280
So here's how you then say to the computer,

38:50.280 --> 38:52.920
check, if you would, whether i is less than 50.

38:52.920 --> 38:54.880
Now, initially, it's obviously going to be less than 50

38:54.880 --> 38:56.320
because 0 is less than 50.

38:56.320 --> 38:59.660
But that same condition is going to be checked again and again and again.

38:59.660 --> 39:01.220
As this loop executes.

39:01.220 --> 39:06.500
And then recall from before, we can just plus plus a variable to add 1 to it.

39:06.500 --> 39:08.540
We could do this more verbosely.

39:08.540 --> 39:11.020
We could say i equals i plus 1.

39:11.020 --> 39:14.300
But it's just more conventional to write i plus plus just to say

39:14.300 --> 39:15.820
the same thing more tersally.

39:15.820 --> 39:17.380
So what happens next logically?

39:17.380 --> 39:18.420
That's the code I've written.

39:18.420 --> 39:19.860
What does the computer do with it?

39:19.860 --> 39:24.140
Well, it initializes i to 0 and prepares to store integers in it.

39:24.140 --> 39:27.820
It checks the condition just in case you initialized it to too big of a value.

39:27.860 --> 39:29.860
You might not want the loop to execute at all.

39:29.860 --> 39:32.060
But obviously, 0 is less than 50.

39:32.060 --> 39:34.500
So this line of code executes.

39:34.500 --> 39:38.020
Take a guess as to what happens next.

39:38.020 --> 39:40.300
Yeah, you probably want to do i plus plus because you've

39:40.300 --> 39:43.460
done executing all of the lines of code in between the curly braces,

39:43.460 --> 39:44.660
even though there's just one.

39:44.660 --> 39:46.140
So let's go ahead and increment i.

39:46.140 --> 39:47.820
So i is now 1.

39:47.820 --> 39:49.940
Let's now make sure is 1 less than 50.

39:49.940 --> 39:52.260
Obviously, execute the code.

39:52.260 --> 39:54.940
i plus plus is 2 less than 50.

39:54.940 --> 39:56.900
Obviously, execute the code.

39:56.900 --> 39:59.140
i plus plus is 3 less than 50.

39:59.140 --> 40:01.980
Obviously, now go ahead and execute the code.

40:01.980 --> 40:03.980
And again, and again, and again.

40:03.980 --> 40:08.260
And at some point, we're going to get up to i equals 49.

40:08.260 --> 40:10.340
And is 49 less than 50?

40:10.340 --> 40:10.940
Obviously.

40:10.940 --> 40:13.180
So we print out hello world.

40:13.180 --> 40:15.220
And then i plus plus kicks in.

40:15.220 --> 40:18.260
And then it's 50 less than 50.

40:18.260 --> 40:18.900
No.

40:18.900 --> 40:21.020
So wait, that feels like a logical error, though.

40:21.020 --> 40:25.140
No, should I be checking if i is less than or equal to 50?

40:25.180 --> 40:27.380
Yeah, because if I started from 0, I already

40:27.380 --> 40:28.940
spent that one additional cycle.

40:28.940 --> 40:34.860
So I can count from 0 through 49, which seems to work, or from 1 through 50.

40:34.860 --> 40:37.060
But the convention in programming, honestly,

40:37.060 --> 40:39.060
is typically to start counting at some value

40:39.060 --> 40:44.100
and then count up to but not through some value, just because.

40:44.100 --> 40:46.980
But logically, you can implement this in half a dozen different ways,

40:46.980 --> 40:48.140
most likely.

40:48.140 --> 40:49.900
All right, let's look at one final example that

40:49.900 --> 40:52.780
allowed us to actually get user input in scratch.

40:52.780 --> 40:57.340
Recall that we use this block to actually get the name of someone in lecture.

40:57.340 --> 41:00.100
And we also, in the animation with the gingerbread house,

41:00.100 --> 41:01.700
used it to get yes or no.

41:01.700 --> 41:03.780
Do you want the cupcake or the apple or the like?

41:03.780 --> 41:08.100
So this is an example of a function in scratch that actually takes input,

41:08.100 --> 41:09.900
like the sentence, what's your name.

41:09.900 --> 41:13.220
But it also returns a value, which in this case was just

41:13.220 --> 41:15.940
hard-coded in scratch by MIT, to be called answer.

41:15.940 --> 41:17.980
So it's like a special variable called answer.

41:17.980 --> 41:21.220
But effectively, it's being handed back to the user.

41:21.260 --> 41:23.300
So how might we think about this?

41:23.300 --> 41:27.580
In C, it turns out that you can express this line of code a little more

41:27.580 --> 41:31.180
verbose than before by using a new function called getString.

41:31.180 --> 41:33.580
So get underscore string is the name of the function.

41:33.580 --> 41:36.700
The underscore is convention in C. If you ever want to have a space,

41:36.700 --> 41:38.620
you can't have spaces in the names of functions.

41:38.620 --> 41:40.380
So people just started using underscores.

41:40.380 --> 41:43.580
Like you might in your own social media user names and the like

41:43.580 --> 41:45.500
is the convention there as well.

41:45.500 --> 41:48.780
Here's the sentence I want to display.

41:48.780 --> 41:51.260
And I'm going to start calling this more formally a string.

41:51.260 --> 41:54.500
A string in a programming language is just a sequence of characters.

41:54.500 --> 41:57.380
Like it's a word, it's a phrase, it's a character, it's a paragraph.

41:57.380 --> 41:58.100
This is a string.

41:58.100 --> 42:00.300
Anything between double quotes is a string in C.

42:00.300 --> 42:03.780
And the backslash n is just end of line, as before.

42:03.780 --> 42:05.580
We still already have the semicolon.

42:05.580 --> 42:09.500
But this isn't quite a literal translation of what's going on just yet,

42:09.500 --> 42:13.660
because I also now need to do something with the answer.

42:13.660 --> 42:17.580
So if getString is a function that actually gets input from the user,

42:17.580 --> 42:20.860
as via his or her keyboard, just like the blue block in Scratch.

42:20.860 --> 42:23.780
In C, we need to be a little more explicit as to where

42:23.780 --> 42:27.020
we're putting the return value from that function.

42:27.020 --> 42:29.260
What it is, it's handing back.

42:29.260 --> 42:31.700
And so I can store it in a variable, call it answer.

42:31.700 --> 42:33.380
I could call it anything I want.

42:33.380 --> 42:36.740
But for consistency with Scratch, let's call it answer.

42:36.740 --> 42:41.540
But recall what we have to do in C any time we create a variable.

42:41.540 --> 42:44.820
We have to be more precise, yeah.

42:44.820 --> 42:47.100
We have to define it's let me call it type or class

42:47.100 --> 42:48.580
if you've taken a previous class.

42:48.580 --> 42:51.900
It's type, and it's not going to be an int, because probably the words being

42:51.900 --> 42:53.100
typed in are not numbers.

42:53.100 --> 42:55.500
It's going to be this time what I just call it a string.

42:55.500 --> 42:59.220
And so indeed, we would declare the variable on the left by saying,

42:59.220 --> 43:04.300
give me a string, call it answer, and assign to it whatever's on the right.

43:04.300 --> 43:05.300
Well, what's on the right?

43:05.300 --> 43:09.460
What is on the right is whatever this function getString comes back with

43:09.460 --> 43:12.740
and gets stored from right to left.

43:12.740 --> 43:16.380
So how do I now say this person's name?

43:16.380 --> 43:19.660
Well, in Scratch, I just say say, and then I drag and drop the answer variable,

43:19.660 --> 43:20.660
and it's done.

43:20.660 --> 43:24.620
What's the function in C with which we can say something though on the screen?

43:24.620 --> 43:27.260
Yeah, so printf, print a formatted string, even though we haven't really

43:27.260 --> 43:29.220
seen any formatting it, until now.

43:29.220 --> 43:35.380
It turns out in C, you have to actually tell printf

43:35.380 --> 43:39.460
if you're not passing in a hard-coded string or sentence,

43:39.460 --> 43:44.500
you have to pass to printf what's called a format code or a format string.

43:44.500 --> 43:46.780
This first input to printf.

43:46.780 --> 43:49.220
Now printf apparently seems to take two things.

43:49.220 --> 43:51.300
The first is this one before the comma.

43:51.300 --> 43:53.060
The second is the thing after the comma.

43:53.060 --> 43:55.620
And we've not seen this before yet in C.

43:55.620 --> 44:01.340
So printf is being told, go ahead and print out a string that looks like this.

44:01.340 --> 44:04.780
Percent s is a placeholder, and s stands for string.

44:04.780 --> 44:07.340
And that literally is a placeholder saying, printf,

44:07.340 --> 44:12.060
I'm going to give you a string to plug in to this first input.

44:12.100 --> 44:13.140
What is that string?

44:13.140 --> 44:14.940
Literally, the answer variable.

44:14.940 --> 44:17.100
Now it feels like we're jumping through hoops here, right?

44:17.100 --> 44:19.860
It would have been nice to just say printf, open parenthesis, answer,

44:19.860 --> 44:22.340
close parenthesis, semicolon, and be done with it.

44:22.340 --> 44:24.300
That's just not the way printf works.

44:24.300 --> 44:27.300
In older versions, you could maybe do something a little more simple like that.

44:27.300 --> 44:31.020
But honestly, we're not typically going to be printing out just what the human typed in.

44:31.020 --> 44:33.340
After all, this is kind of a stupid example at the moment.

44:33.340 --> 44:35.620
I'm typing in a word, you're just saying it on the screen.

44:35.620 --> 44:37.940
We already decided in Scratch that's kind of lame.

44:37.940 --> 44:42.980
It'd be nice to at least have the program not just say, David, or whatever the name is,

44:42.980 --> 44:45.340
but what did we do last time?

44:45.340 --> 44:47.260
Like, hello, comma, David.

44:47.260 --> 44:51.020
But this would seem to give us that capability, right?

44:51.020 --> 44:54.940
Right now, I'm literally just printing out the human's name in C.

44:54.940 --> 44:58.420
But let me change this ever so slightly, just as we did in Scratch.

44:58.420 --> 45:03.020
Recall that in C, we did this green block of join,

45:03.020 --> 45:05.460
where I literally get past join two arguments.

45:05.460 --> 45:08.060
The first one was hello, comma, space.

45:08.060 --> 45:09.580
The second one was answer.

45:09.580 --> 45:13.140
And this concatenated, this combined, back to back, those two strings.

45:13.140 --> 45:16.660
Well, in C, thanks to printf, we can do that same thing.

45:16.660 --> 45:18.540
It's just a different syntax.

45:18.540 --> 45:22.100
Printf still gets one argument first.

45:22.100 --> 45:25.740
That is the string you want to format, ergo the f in printf.

45:25.740 --> 45:27.340
But this time, I'm going to literally say,

45:27.340 --> 45:33.020
h-e-l-l-o, comma, space, percent s for string,

45:33.020 --> 45:35.580
and then give printf a second argument, which

45:35.580 --> 45:39.220
is its instruction to go ahead and plug in whatever this variable is

45:39.220 --> 45:43.140
to whatever this placeholder is.

45:43.140 --> 45:45.900
And so here, we've now joined the two strings effectively,

45:45.900 --> 45:51.820
and thus was born our first formatted string.

45:51.820 --> 45:54.700
Any questions, then, on that?

45:54.700 --> 45:55.200
Yeah?

45:55.560 --> 45:59.120
Would you want to say something extra after?

45:59.120 --> 46:01.240
If you want to say something extra after,

46:01.240 --> 46:02.960
you could certainly continue the logic.

46:02.960 --> 46:06.680
You don't have to end this quoted expression with percent s.

46:06.680 --> 46:11.120
You could say, hello, comma, percent s, comma, nice to meet you.

46:11.120 --> 46:13.560
And then what printf will do is it's only going

46:13.560 --> 46:17.680
to substitute that variable called answer, where the percent s is.

46:17.680 --> 46:21.520
And if you wanted to have 2% s's, you could just add another comma here

46:21.520 --> 46:24.200
and pass in another variable, and a third variable, and even more,

46:24.200 --> 46:27.440
thus formatting the string even more detailed.

46:27.440 --> 46:28.800
Question over here?

46:28.800 --> 46:29.560
Other questions?

46:29.560 --> 46:30.640
Yeah, in the back.

46:30.640 --> 46:38.360
How do you make a distinction between the placeholders if you have

46:38.360 --> 46:39.440
different variables?

46:39.440 --> 46:41.360
It's the ordering from left to right.

46:41.360 --> 46:44.640
So in this case, it's a trivial example because there's only one variable

46:44.640 --> 46:45.720
and one placeholder.

46:45.720 --> 46:48.640
But if, as you were hinting, I had multiple, percent s, something,

46:48.640 --> 46:51.280
something, something, percent s, something, something, something,

46:51.280 --> 46:55.720
I would just make sure that I pass printf, the first variable, comma,

46:55.720 --> 46:59.880
the second variable, comma, the third variable, and so forth left to right.

46:59.880 --> 47:00.680
Other questions?

47:00.680 --> 47:01.680
Yeah?

47:01.680 --> 47:04.280
Why is there no comma, comma, percent s?

47:04.280 --> 47:06.720
Damn it, because I screwed up and didn't include that,

47:06.720 --> 47:09.680
and I was going to fix it after class quickly.

47:09.680 --> 47:10.180
Bug.

47:10.180 --> 47:11.240
It's a bug.

47:11.240 --> 47:11.740
Yeah?

47:11.740 --> 47:15.240
I bet you want to use the answer twice in the string.

47:15.240 --> 47:17.920
Do you want to say, hello, David, hi, David?

47:17.920 --> 47:21.260
Sure, same exact thing, comma, answer, comma, answer.

47:21.260 --> 47:22.620
With 2% s's.

47:22.620 --> 47:26.180
If you want to say the same variable twice in two places for whatever reason,

47:26.180 --> 47:29.060
two placeholders, and then answer, comma, answer.

47:29.060 --> 47:31.180
To plug that in twice.

47:31.180 --> 47:31.460
Other question?

47:31.460 --> 47:31.960
Yeah?

47:31.960 --> 47:32.460
Yeah?

47:32.460 --> 47:35.740
It's going to happen in the first place for a lot of people.

47:35.740 --> 47:37.660
No, and we're going to see some others in just a bit.

47:37.660 --> 47:38.660
It turns out there's others.

47:38.660 --> 47:41.940
It's percent i for integer, and there's going to be even more than that.

47:41.940 --> 47:44.980
Percent c for a single character and more.

47:44.980 --> 47:46.780
Other questions?

47:46.780 --> 47:47.280
Yeah?

47:48.280 --> 47:52.400
Good question.

47:52.400 --> 47:54.920
If I did have correctly, and if this weren't a PDF,

47:54.920 --> 47:56.280
I would just edit it on the fly.

47:56.280 --> 48:02.200
If I had the percent n, it always has to go in the formatted string,

48:02.200 --> 48:03.760
in the first argument.

48:03.760 --> 48:07.160
So the only thing that comes after printf's first argument

48:07.160 --> 48:10.960
is optionally variable, comma, variable, comma, variable, comma,

48:10.960 --> 48:12.280
variable.

48:12.280 --> 48:14.800
Other questions?

48:14.800 --> 48:15.320
All right.

48:15.360 --> 48:18.960
So let's go ahead and actually do something with code.

48:18.960 --> 48:20.920
I'm going to go ahead and open up another window,

48:20.920 --> 48:23.280
and this is a tool called CS50 Sandbox.

48:23.280 --> 48:27.600
And this is a tool via the web via which you can actually play with code.

48:27.600 --> 48:30.680
And I'll show you in just a moment how I get to this particular location.

48:30.680 --> 48:33.800
But let me first explain the user interface, much like we started off

48:33.800 --> 48:34.960
our conversation with Scratch.

48:34.960 --> 48:36.560
So I need a place to write code.

48:36.560 --> 48:38.800
The reality is I could just use my own Mac.

48:38.800 --> 48:40.440
I could just use my own PC.

48:40.440 --> 48:43.160
Frankly, I could even use certain mobile devices these days.

48:43.160 --> 48:46.600
But then we would have hundreds of other people in the class,

48:46.600 --> 48:49.120
all with slightly different configurations on their Macs,

48:49.120 --> 48:51.160
and their PCs, and their phones, and the like.

48:51.160 --> 48:53.880
And so everyone would kind of have different software and different settings,

48:53.880 --> 48:55.440
and that just never works very well.

48:55.440 --> 48:57.960
So at the beginning of the course, we just standardize everything

48:57.960 --> 49:01.200
by actually using a web-based environment, just like Scratch is,

49:01.200 --> 49:05.640
whereby we'll all have access to the exact same computer,

49:05.640 --> 49:07.760
but virtualized in the so-called cloud.

49:07.760 --> 49:09.720
If you've ever wondered what the cloud is,

49:09.720 --> 49:12.680
it just means other people's servers somewhere on the internet

49:12.680 --> 49:16.120
that people can use for free or to rent, and now have to host

49:16.120 --> 49:18.080
those physical servers themselves.

49:18.080 --> 49:22.280
So CS50 Sandbox, just like Scratch, is a cloud-based application

49:22.280 --> 49:24.960
that someone else wrote that's hosted on the internet.

49:24.960 --> 49:27.880
And the user interface, at first glance, looks just like this.

49:27.880 --> 49:29.720
There's only two components to it.

49:29.720 --> 49:33.200
At the top of the user interface of CS50 Sandbox

49:33.200 --> 49:36.600
is just a code editor, a very simple text editor, similar in spirit

49:36.600 --> 49:39.800
to Google Docs and Microsoft Word, and so forth, but much simpler.

49:39.800 --> 49:40.760
There's no formatting.

49:40.760 --> 49:42.280
There's no bold-facing in centering.

49:42.280 --> 49:44.320
You can just type words of text.

49:44.320 --> 49:46.680
Down here is a so-called terminal window,

49:46.680 --> 49:48.720
but we'll come back to that in just a moment.

49:48.720 --> 49:51.280
Let me go ahead and write my first program.

49:51.280 --> 50:00.600
Let me go ahead and write include standardio.h int main void open curly

50:00.600 --> 50:05.880
brace printf hello world backslash n semicolon done.

50:05.880 --> 50:10.960
OK, now, few people in this room could probably whip up a parent program

50:10.960 --> 50:12.760
that quickly, unless you do have prior background.

50:12.760 --> 50:14.720
And if you did take APCS or something else,

50:14.720 --> 50:17.800
looks kind of like Java, but not quite the same.

50:17.800 --> 50:19.480
But this is my first program.

50:19.480 --> 50:22.400
Now, recall from earlier, this was the black and white program

50:22.400 --> 50:25.000
we saw on the slide just a little bit ago.

50:25.000 --> 50:28.560
And even if you didn't quite appreciate what all the funky syntax is doing,

50:28.560 --> 50:31.760
all of us probably had the intuition of what this program does,

50:31.760 --> 50:35.240
which is just to print out the words at the end of the day, hello world.

50:35.240 --> 50:39.080
And we'll tease apart in just a bit what all of these various lines are doing.

50:39.080 --> 50:41.480
But the interesting part is what's highlighted in green here.

50:41.480 --> 50:44.880
And this is just one of the features of CS50's sandbox.

50:44.880 --> 50:48.440
It will color code different concepts within your code

50:48.440 --> 50:49.840
so that they just kind of jump out at you.

50:49.840 --> 50:50.960
The colors aren't actually there.

50:50.960 --> 50:54.640
You don't have to color code things yourself.

50:54.640 --> 50:57.520
It just does it automatically so that you can see the different components,

50:57.520 --> 51:01.600
just like MIT colorizes the various Scratch puzzle pieces the same.

51:01.600 --> 51:06.560
So this is a program that I want to call hello.

51:06.560 --> 51:07.280
It's in a file.

51:07.320 --> 51:09.720
This is just a tab up top called hello.c.

51:09.720 --> 51:11.960
Because it turns out when you write a program in C,

51:11.960 --> 51:16.480
you save it in files by human convention, whatever.c,

51:16.480 --> 51:19.080
as the file extension, so to speak.

51:19.080 --> 51:21.720
How do I run this program?

51:21.720 --> 51:26.560
There's no green flag to click, which Scratch gave us.

51:26.560 --> 51:28.520
So how do I actually run the program?

51:28.520 --> 51:32.520
And frankly, moreover, the green flag seems to be the least of my concerns.

51:32.520 --> 51:34.840
What is the language that any computer understands,

51:34.840 --> 51:39.080
whether it's my Mac here or the cloud server, where this thing is?

51:39.080 --> 51:40.560
Zeros and ones.

51:40.560 --> 51:43.720
And we started with that sort of overwhelming slide of the lots of zeros

51:43.720 --> 51:46.600
and ones, and that is the point we need to get to.

51:46.600 --> 51:50.480
But hopefully, we ourselves don't have to write at that level of tedium.

51:50.480 --> 51:54.600
So we need some way of converting this code from C,

51:54.600 --> 51:56.480
which we'll start calling source code, which

51:56.480 --> 52:00.680
is the English-like code we see on the screen that's mildly pleasurable

52:00.680 --> 52:03.440
to write as opposed to just zeros and ones.

52:03.440 --> 52:06.960
But we nonetheless need to convert it somehow to zeros and ones.

52:06.960 --> 52:09.680
And so the way we can do this is essentially as follows.

52:09.680 --> 52:14.480
If we have what we'll start calling our source code, which

52:14.480 --> 52:19.000
can be written, in our case, in C, but you can write source code in Java,

52:19.000 --> 52:21.720
in C++, in Python, in dozens of other language.

52:21.720 --> 52:23.800
Source code is a generic term that just means the code

52:23.800 --> 52:25.160
that we humans have written.

52:25.160 --> 52:29.760
We need some way of converting it into zeros and ones, which henceforth

52:29.760 --> 52:32.600
we're just going to call machine code, which feels like a reasonable name.

52:32.600 --> 52:35.360
It's the zeros and ones that a machine understands.

52:35.360 --> 52:38.280
How does a machine know what zeros and ones to understand?

52:38.280 --> 52:42.000
Well, that's the whole reasoning behind having CPUs, central processing units,

52:42.000 --> 52:43.200
the brains of a computer.

52:43.200 --> 52:46.040
They are just hardwired at the factory, so to speak.

52:46.040 --> 52:49.760
It entails factory to understand certain patterns of zeros and ones.

52:49.760 --> 52:54.440
But the point for us now is we need to take source code, like the C program

52:54.440 --> 52:56.960
I wrote a moment ago that's supposed to print hello world,

52:56.960 --> 53:01.120
and somehow convert it to machine code.

53:01.120 --> 53:04.480
So it turns out this is the step that humans who've come before us

53:04.480 --> 53:05.560
have solved for us.

53:05.560 --> 53:08.320
Other humans have already written programs

53:08.320 --> 53:12.360
that we're going to start calling a compiler that allows us to convert

53:12.360 --> 53:14.400
source code to machine code.

53:14.400 --> 53:15.680
It's just one additional step.

53:15.680 --> 53:17.680
This step did not exist in Scratch, but we're

53:17.680 --> 53:21.440
going to run a program that's generally called a compiler

53:21.440 --> 53:29.000
that we pass our program to as input and we get as output machine code,

53:29.000 --> 53:32.440
thereby perfectly bringing us full circle to what computer science is

53:32.440 --> 53:34.400
in now the context of programming.

53:34.400 --> 53:37.320
Input source code, outputs machine code, the algorithm,

53:37.320 --> 53:39.960
or the special software we're going to use in just a moment,

53:39.960 --> 53:42.960
is called a compiler that just converts one to the other so that none of us

53:42.960 --> 53:45.960
have to ever think about or write in zeros and ones.

53:45.960 --> 53:48.440
So it's a little old school how you do this.

53:48.440 --> 53:52.160
In Scratch, you obviously just hit the green flag and MIT and all those folks

53:52.160 --> 53:53.440
took care of it for you.

53:53.440 --> 53:56.680
We have to be a little more manual about this.

53:56.680 --> 53:59.880
And that's where the second piece of the CS50 Sandbox user interface

53:59.880 --> 54:00.920
comes into play.

54:00.920 --> 54:03.000
Notice I have a blinking prompt here.

54:03.000 --> 54:05.720
There's a dollar sign at left, which is just a common convention.

54:05.720 --> 54:10.800
A dollar sign tends to, in these types of computers, represent a prompt.

54:10.800 --> 54:12.360
It's waiting for me to type something.

54:12.360 --> 54:15.520
And indeed, it's literally blinking, waiting for me to type something.

54:15.520 --> 54:17.880
This is an example of a terminal window.

54:17.880 --> 54:20.840
And your own Mac and your own PC actually has or can

54:20.840 --> 54:22.360
have this exact same feature.

54:22.360 --> 54:25.520
It's just all of us operate with graphical user interfaces these days.

54:25.560 --> 54:27.920
So we've got buttons and menus and things to drag and click.

54:27.920 --> 54:30.960
But back in the day, and typically in programming,

54:30.960 --> 54:33.280
you don't bother with these sort of aesthetics.

54:33.280 --> 54:37.480
You actually get your hands dirtier with just the keyboard alone typing

54:37.480 --> 54:38.680
anything you want to do.

54:38.680 --> 54:42.720
And at first, it might feel like a regression, like why are we giving up

54:42.720 --> 54:46.720
all these beautiful amenities of modern computers, but it's more powerful.

54:46.720 --> 54:47.880
And it's more explicit.

54:47.880 --> 54:51.880
It lets you do exactly what you want to do by sending commands to the computer.

54:51.880 --> 54:53.200
So this is my terminal one.

54:53.200 --> 54:55.320
I can create others just to have multiple windows.

54:55.320 --> 55:00.400
But this is giving me access to the underlying server that I now have access to.

55:00.400 --> 55:03.720
So if any of you, when it comes time to the first problem set,

55:03.720 --> 55:06.680
log into the same tool, you don't all have the same environment.

55:06.680 --> 55:10.440
You all have your own isolated copies of the same software,

55:10.440 --> 55:13.040
but your own storage space, so to speak.

55:13.040 --> 55:18.600
So I need to somehow convert hello.c to zeros and ones.

55:18.600 --> 55:21.240
And the way I'm going to do this is like this.

55:21.280 --> 55:29.320
Clang, which stands for C language, hello.c, enter.

55:29.320 --> 55:33.200
And the fact that I see nothing happening is actually an amazing thing,

55:33.200 --> 55:36.000
because there's an infinite number of things, frankly, that can go wrong.

55:36.000 --> 55:38.960
And the computer will happily yell at you with its cryptic-looking error

55:38.960 --> 55:41.040
messages if any of those things do go wrong.

55:41.040 --> 55:44.640
So seeing nothing but another blinking prompt with a dollar sign

55:44.640 --> 55:45.800
is actually a good thing.

55:45.800 --> 55:49.080
My code has somehow been converted to zeros and ones.

55:49.080 --> 55:50.960
Where are those zeros and ones?

55:50.960 --> 55:54.560
Well, by convention, they are stored in a file that's

55:54.560 --> 55:57.800
weirdly and historically just called a.out.

55:57.800 --> 55:58.600
And we can see that.

55:58.600 --> 56:01.520
If I click this folder icon up here, you'll actually

56:01.520 --> 56:06.720
see my file, hello.c, and another file now called a.out.

56:06.720 --> 56:09.720
Stands for assembly output, but for historical reasons.

56:09.720 --> 56:12.640
Now, if I let me close the folder icon, because we're generally not

56:12.640 --> 56:16.320
going to use the graphical user interface, how do I run that program?

56:16.320 --> 56:17.840
I couldn't just double click on the icon.

56:17.840 --> 56:18.560
This isn't a Mac.

56:18.560 --> 56:19.600
This isn't a PC.

56:19.600 --> 56:22.240
This is a cloud-based Linux environment.

56:22.240 --> 56:24.240
Linux is a super popular operating system.

56:24.240 --> 56:27.000
Happens to be used by lots of computer scientists, lots of websites,

56:27.000 --> 56:27.760
lots of servers.

56:27.760 --> 56:30.080
In fact, almost every website you visit these days

56:30.080 --> 56:34.120
is powered, if not by Windows, by Linux and variations thereof called

56:34.120 --> 56:36.280
Unix and other flavors still.

56:36.280 --> 56:38.760
It's just a very popular and often free operating system

56:38.760 --> 56:41.080
that CS50 Sandbox itself uses.

56:41.080 --> 56:46.040
To run a file called a.out that's in this folder, so to speak,

56:46.040 --> 56:48.040
even though you don't see a graphical version of it,

56:48.080 --> 56:51.520
you literally just type dot slash a.out.

56:51.520 --> 56:55.880
Completely non-obvious and kind of a stupid name for the program.

56:55.880 --> 56:59.880
But this is the equivalent in your Mac or PC of double-clicking on an icon.

56:59.880 --> 57:00.960
Let me go ahead and hit Enter.

57:00.960 --> 57:04.640
And when I do, I should hopefully see what?

57:04.640 --> 57:05.320
Hello, world.

57:05.320 --> 57:07.000
And here we go.

57:07.000 --> 57:09.440
Wow, that's our first program.

57:09.440 --> 57:13.240
Like, it's not doing all that much, but it's at least doing what we promised it

57:13.240 --> 57:13.720
would do.

57:13.720 --> 57:17.360
And this is the equivalent in scratch of just saying on the screen, hello,

57:17.360 --> 57:17.760
world.

57:17.760 --> 57:19.640
Now, to be fair, there were more steps involved.

57:19.640 --> 57:22.960
And God knows there was more cryptic-looking code to write.

57:22.960 --> 57:25.160
But at the end of the day, all we've done now

57:25.160 --> 57:27.920
is re-implement last week's logic in this newer language.

57:27.920 --> 57:31.880
But we're now going to very quickly introduce new puzzle pieces, but in C.

57:31.880 --> 57:34.440
But first, let's solve this sort of minor headache.

57:34.440 --> 57:37.600
I don't really want to sort of tell friends, like, hey, everyone,

57:37.600 --> 57:39.600
come run my a.out program.

57:39.600 --> 57:41.040
Like, let's give it a real name.

57:41.040 --> 57:42.920
Suppose I just want to call my program hello,

57:42.920 --> 57:45.520
like you might download from the App Store or Google Play Store.

57:45.520 --> 57:47.240
Programs have names.

57:47.240 --> 57:48.600
So how do I do that?

57:48.600 --> 57:52.760
Well, it turns out, in a terminal window, the so-called command line

57:52.760 --> 57:54.880
environment, which is just a fancy way of saying you

57:54.880 --> 57:57.280
write lines of commands with your keyboard,

57:57.280 --> 58:02.040
you can actually pass in what are called command line arguments.

58:02.040 --> 58:06.760
Additional inputs to programs that are just words that you type at your keyboard

58:06.760 --> 58:08.000
that tell it how to behave.

58:08.000 --> 58:12.160
So instead of just running clang on hello.c,

58:12.160 --> 58:13.920
I'm actually going to be more explicit.

58:13.920 --> 58:18.360
And I'm going to tell clang, please output, as is implied by literally

58:18.360 --> 58:23.320
typing dash o for output, a file called hello instead.

58:23.320 --> 58:27.880
So it's a little more verbose, hello, dash o, hello, sorry, clang,

58:27.880 --> 58:30.080
dash o, hello, hello.c.

58:30.080 --> 58:34.160
But what this is going to do now is still convert source code to machine code,

58:34.160 --> 58:37.440
but it's going to save it in a file called hello.

58:37.440 --> 58:40.720
And indeed, now I have hello.c, a.out, and hello,

58:40.720 --> 58:43.680
as pictured in the little graphical folder there.

58:43.680 --> 58:47.640
So now I can instead run dot slash hello.

58:47.640 --> 58:48.280
What should it say?

58:48.280 --> 58:49.840
Hopefully the same.

58:49.840 --> 58:51.160
Enter.

58:51.160 --> 58:51.960
So that's it.

58:51.960 --> 58:53.440
Those are called command line arguments.

58:53.440 --> 58:57.120
And it's just sort of the old school way of telling a text-based command

58:57.120 --> 58:59.320
how to behave a little bit differently from its defaults.

58:59.320 --> 59:01.480
But frankly, this is going to get tedious quickly.

59:01.480 --> 59:03.920
Like, we aren't going to want to write our code.

59:03.920 --> 59:06.880
And then every darn time we want to convert it to 0s and 1s to run it,

59:06.880 --> 59:11.040
actually remember these sort of magical incantations of commands.

59:11.040 --> 59:13.800
And so humans have abstracted these away too.

59:13.800 --> 59:16.760
It turns out that if you want to make a program from source code

59:16.760 --> 59:19.400
into machine code, there's another command you can use.

59:19.400 --> 59:23.640
And you can literally type make hello, where hello is the name of the program

59:23.640 --> 59:25.040
you want to make.

59:25.040 --> 59:30.800
This program, whose name is make, will look for a file by default called

59:30.800 --> 59:35.280
hello.c, therefore saving you the time of specifying it.

59:35.280 --> 59:36.560
Hit Enter Now.

59:36.560 --> 59:38.920
And oh my god, look what it just did.

59:38.920 --> 59:43.680
It has even more configuration options that are baked into it.

59:43.680 --> 59:46.840
And we, the CS50 staff, configured CS50 sandbox

59:46.840 --> 59:48.360
to have these various features.

59:48.360 --> 59:51.040
And even though we're not going to go into detail on them now,

59:51.040 --> 59:52.960
I'm going to wave my hand at what they actually do,

59:52.960 --> 59:55.840
they just make additional features possible that we'll eventually get to.

59:55.840 --> 59:58.640
But this would be otherwise the command that you all do

59:58.640 --> 01:00:02.240
have to type in just two or three or four weeks time.

01:00:02.240 --> 01:00:03.840
And no one can ever remember that.

01:00:03.840 --> 01:00:05.000
I certainly couldn't.

01:00:05.000 --> 01:00:07.560
So make just automates that for you.

01:00:07.600 --> 01:00:10.680
But when you run make, make is not a compiler.

01:00:10.680 --> 01:00:15.560
Make is not the thing in the middle here, converting source code to machine code.

01:00:15.560 --> 01:00:19.920
It's just a second program that some humans wrote years ago that

01:00:19.920 --> 01:00:24.440
use clang in an automated way to achieve the same output.

01:00:24.440 --> 01:00:26.480
Because people got tired of typing stuff like this,

01:00:26.480 --> 01:00:30.840
so someone made a program called make that does it for us.

01:00:30.840 --> 01:00:32.800
Any questions?

01:00:32.800 --> 01:00:35.720
All right, let's add a little bit then to this program.

01:00:35.720 --> 01:00:39.240
Instead of this version of hello, let me get some user input

01:00:39.240 --> 01:00:41.160
and actually do something with it.

01:00:41.160 --> 01:00:44.360
Suppose I actually want to get the user's name and then print that out.

01:00:44.360 --> 01:00:46.800
Well, we saw the spoiler for that just a moment ago.

01:00:46.800 --> 01:00:49.080
But let me go ahead and add it to this program here.

01:00:49.080 --> 01:00:50.760
Now I have a second line of code.

01:00:50.760 --> 01:00:52.720
And I want to get a string from a user.

01:00:52.720 --> 01:00:56.800
And with what function do I get a string from the user?

01:00:56.800 --> 01:00:58.040
Get string was the one.

01:00:58.040 --> 01:01:02.160
And recall, I can do get underscore string, open parenthesis.

01:01:02.160 --> 01:01:04.440
And then I have to pass in an argument, so to speak,

01:01:05.400 --> 01:01:06.720
give me your name.

01:01:06.720 --> 01:01:08.200
Actually, what did we say before?

01:01:08.200 --> 01:01:10.640
What is your name, I think, was the prompt?

01:01:10.640 --> 01:01:11.920
Backslash n?

01:01:11.920 --> 01:01:12.880
Semicolon?

01:01:12.880 --> 01:01:14.600
Now it's not enough to just get the string.

01:01:14.600 --> 01:01:16.720
What do I want to do with it?

01:01:16.720 --> 01:01:18.040
Yeah, store it in a variable.

01:01:18.040 --> 01:01:19.640
What type of variable?

01:01:19.640 --> 01:01:20.760
A string.

01:01:20.760 --> 01:01:23.920
So I just need to go on the left-hand side of this line of code

01:01:23.920 --> 01:01:26.080
and say, OK, well, give me a string.

01:01:26.080 --> 01:01:29.200
I'll call it name, but I could call it x or y or anything.

01:01:29.200 --> 01:01:31.320
But name feels like a good descriptor for it.

01:01:31.320 --> 01:01:34.280
Using a single equal sign to copy from right to left.

01:01:34.280 --> 01:01:35.840
And now I've got that.

01:01:35.840 --> 01:01:39.640
Now it's not sufficient to just store the value in the variable.

01:01:39.640 --> 01:01:40.920
I need to print it out.

01:01:40.920 --> 01:01:44.760
So let me start with this.

01:01:44.760 --> 01:01:46.920
It auto-saves the sandbox, so I don't even

01:01:46.920 --> 01:01:48.680
have to go up to file-save or anything.

01:01:48.680 --> 01:01:51.520
Let me go ahead and do make hello now.

01:01:51.520 --> 01:01:53.640
Uh-oh.

01:01:53.640 --> 01:01:55.720
Oh my god, look at all these errors already.

01:01:55.720 --> 01:01:58.160
So clearly something is wrong, as the computer

01:01:58.160 --> 01:01:59.560
has fond of telling me in red.

01:01:59.560 --> 01:02:01.600
And frankly, this is where you very quickly get derailed.

01:02:01.600 --> 01:02:03.520
They're kind of freaked out, because oh my god,

01:02:03.560 --> 01:02:04.400
two lines of code.

01:02:04.400 --> 01:02:06.920
How do I have 20 lines of errors somehow?

01:02:06.920 --> 01:02:10.120
So the computer is kind of as confused as you.

01:02:10.120 --> 01:02:12.880
And the most important thing when you face this kind of situation,

01:02:12.880 --> 01:02:16.000
where it's just cryptic erroneous output, start at the top.

01:02:16.000 --> 01:02:18.520
Even if your window's kind of small, and therefore a whole bunch of stuff

01:02:18.520 --> 01:02:20.880
scrolls on the screen quickly, scroll up to the top.

01:02:20.880 --> 01:02:23.520
Because odds are there's one mistake up at the very top,

01:02:23.520 --> 01:02:26.480
and that one mistake just had a cascading effect on the computer,

01:02:26.480 --> 01:02:28.640
on the compiler, that it just got really confused

01:02:28.640 --> 01:02:31.680
and it just kept spitting out messages because it got tripped up early.

01:02:31.720 --> 01:02:35.400
So let's scroll back up to the top here.

01:02:35.400 --> 01:02:39.560
And here is the very long command that I said make automates for you.

01:02:39.560 --> 01:02:40.960
So that's not erroneous.

01:02:40.960 --> 01:02:43.080
Here seems to be the first error.

01:02:43.080 --> 01:02:47.360
And it's a little cryptic still, but let's glean some information.

01:02:47.360 --> 01:02:50.360
Here's a familiar phrase, hello.c.

01:02:50.360 --> 01:02:52.360
Let me go ahead and zoom in on the bottom here.

01:02:52.360 --> 01:02:56.560
So hello.c, you recall, is the name of my file, albeit nonobviously.

01:02:56.560 --> 01:03:00.960
Clang is telling me, look at line five, and then your fifth character.

01:03:00.960 --> 01:03:04.840
So this something, colon, something, means line number, character, or column number.

01:03:04.840 --> 01:03:07.120
If you're looking from left to right, error means error.

01:03:07.120 --> 01:03:10.840
And then this is where things get a little sophisticated.

01:03:10.840 --> 01:03:17.000
Use of undeclared identifier string, did you mean standard in?

01:03:17.000 --> 01:03:21.080
Now, I didn't, but I do recognize standard in, or rather,

01:03:21.080 --> 01:03:22.640
it seems similar to standard I.O.

01:03:22.640 --> 01:03:23.720
But no, I didn't mean that.

01:03:23.720 --> 01:03:26.280
I'm pretty sure this code is right.

01:03:26.280 --> 01:03:27.840
Well, why am I getting this error?

01:03:27.840 --> 01:03:32.360
It sounds like string, on line five, fifth character, right there.

01:03:32.360 --> 01:03:33.960
That is wrong.

01:03:33.960 --> 01:03:37.360
Well, it turns out there is no such thing as a string.

01:03:37.360 --> 01:03:41.560
C, the language, has integers, and it has Booleans, it turns out,

01:03:41.560 --> 01:03:43.760
and it has characters and a few other things.

01:03:43.760 --> 01:03:45.520
It actually doesn't have strings.

01:03:45.520 --> 01:03:49.040
Strings is a word that's useful to describe sequences of characters,

01:03:49.040 --> 01:03:50.080
paragraphs, words.

01:03:50.080 --> 01:03:51.800
But string is not a type.

01:03:51.800 --> 01:03:54.880
It's not a type of variable unless you make it so.

01:03:54.880 --> 01:03:58.200
And in fact, this is one of the simplifications

01:03:58.200 --> 01:04:01.560
we do in just the first couple of weeks of the course to get us off the ground.

01:04:01.560 --> 01:04:06.200
It turns out that we need to add one line of code here.

01:04:06.200 --> 01:04:10.080
We need to do not only include standard I.O., which we'll explain in a moment,

01:04:10.080 --> 01:04:14.240
but also CS50, so-called library.

01:04:14.240 --> 01:04:16.840
So CS50 has a lot of humans involved with it.

01:04:16.840 --> 01:04:18.680
And over time, we've decided, you know what?

01:04:18.680 --> 01:04:21.680
We could make the first hour of CS50 a little easier,

01:04:21.680 --> 01:04:25.200
in the sort of on-ramp, a little cleaner for folks with no background,

01:04:25.200 --> 01:04:28.400
by just inventing a few features ourselves, such as the ability

01:04:28.400 --> 01:04:29.720
to get strings from the user.

01:04:29.720 --> 01:04:32.600
So it turns out, getString is also not a function that comes with C.

01:04:32.600 --> 01:04:36.360
That is a custom puzzle piece, so to speak, that CS50 made.

01:04:36.360 --> 01:04:42.040
And where we created that function is essentially in a file called CS50.h.

01:04:42.040 --> 01:04:46.360
And so by including CS50.h, you now get access to more puzzle pieces,

01:04:46.360 --> 01:04:48.600
if you will, that we have created for you.

01:04:48.600 --> 01:04:51.920
And it turns out, this line of code that has been here before

01:04:51.920 --> 01:04:54.280
is also giving you features too.

01:04:54.280 --> 01:04:57.720
We're just doing what everyone does in programming, which is solve a problem

01:04:57.720 --> 01:05:00.280
once, and then let other people use that solution.

01:05:00.280 --> 01:05:03.520
Take a guess, what functionality is actually

01:05:03.520 --> 01:05:08.400
implemented in a file called standard I.O., input output.h?

01:05:08.400 --> 01:05:12.640
This is just a file somewhere on the server that actually does come with C.

01:05:12.640 --> 01:05:16.240
And it provides you with handy features, like what?

01:05:16.240 --> 01:05:17.920
Say again?

01:05:17.920 --> 01:05:18.880
Once more?

01:05:18.880 --> 01:05:19.720
Printf.

01:05:19.720 --> 01:05:24.680
It turns out that the means by which you are allowed to use a function called

01:05:24.680 --> 01:05:29.040
printf here is you have to include the file in which it is declared.

01:05:29.040 --> 01:05:33.040
So some humans years ago literally wrote a function, a puzzle piece called

01:05:33.040 --> 01:05:36.480
printf, and they figured out how to actually draw characters on the screen.

01:05:36.480 --> 01:05:41.240
They then stored information about that function in a file called standard I.O.h.

01:05:41.240 --> 01:05:44.680
If I had not included that seemingly cryptic line of code

01:05:44.680 --> 01:05:48.720
at the very top of my previous program, even that hello world program would not

01:05:48.720 --> 01:05:51.520
have worked, because clang, the compiler, wouldn't

01:05:51.520 --> 01:05:52.880
have known what I'm talking about.

01:05:52.880 --> 01:05:53.640
What is printf?

01:05:53.640 --> 01:05:57.840
I don't know what that is, unless you tell it to also include this file

01:05:57.840 --> 01:06:01.640
that humans wrote years ago in which printf has been created.

01:06:01.640 --> 01:06:06.040
And now, if I want to use getString as well as the new keyword string,

01:06:06.040 --> 01:06:10.440
I need to tell clang, the compiler, also go ahead and look in cs50.h

01:06:10.440 --> 01:06:14.040
for more functionality, such as string and getString.

01:06:14.080 --> 01:06:17.360
So let me go ahead now and try this again.

01:06:17.360 --> 01:06:21.160
I'm going to clear my terminal here and just try that same command again.

01:06:21.160 --> 01:06:24.760
Make, hello, enter.

01:06:24.760 --> 01:06:25.760
Damn it.

01:06:25.760 --> 01:06:28.920
Now I've got another error, but, but, but, progress.

01:06:28.920 --> 01:06:30.000
Well, no, well, no.

01:06:30.000 --> 01:06:32.320
Just as many errors as before somehow.

01:06:32.320 --> 01:06:33.720
But different ones.

01:06:33.720 --> 01:06:37.360
Notice now, well, wait, that was before.

01:06:37.360 --> 01:06:38.200
Oh, no, I'm sorry.

01:06:38.200 --> 01:06:39.040
It is fewer errors.

01:06:39.040 --> 01:06:41.160
Here's where I ran the command a moment ago.

01:06:41.160 --> 01:06:43.640
And now I'm getting this error instead.

01:06:43.640 --> 01:06:45.000
OK, so progress.

01:06:45.000 --> 01:06:46.480
Now my error is not on line five.

01:06:46.480 --> 01:06:50.400
It's on line six, though fun fact, line six used to be line five.

01:06:50.400 --> 01:06:53.160
So it's apparently still involved in the problem.

01:06:53.160 --> 01:06:54.880
So let's read the error message.

01:06:54.880 --> 01:06:58.840
The problem is on line six, which not surprising is that one there.

01:06:58.840 --> 01:06:59.880
But this time it's different.

01:06:59.880 --> 01:07:02.960
Error, unused variable name.

01:07:02.960 --> 01:07:07.200
OK, that one I kind of understand even without being a programmer.

01:07:07.200 --> 01:07:10.040
What does the, what does it mean?

01:07:10.040 --> 01:07:11.040
Yeah?

01:07:12.040 --> 01:07:14.960
Uh, maybe declare prior to using.

01:07:14.960 --> 01:07:17.080
But turns out this is how you declare it.

01:07:17.080 --> 01:07:23.520
But I'm actually, yeah, yeah, I'm just kind of wasting the computer's time.

01:07:23.520 --> 01:07:24.600
I'm creating it.

01:07:24.600 --> 01:07:26.240
So line six on the left is correct.

01:07:26.240 --> 01:07:30.680
Hey, computer, give me a string variable and call it name and put a value in it.

01:07:30.680 --> 01:07:33.520
But what's the point of that exercise if you're never, as you say,

01:07:33.520 --> 01:07:34.920
doing anything with it?

01:07:34.920 --> 01:07:38.840
And in fact, recall from the slide a moment ago, how do I do something with it?

01:07:38.840 --> 01:07:40.960
Well, this is not how you do something with it.

01:07:40.960 --> 01:07:43.480
If I go ahead and run this program now successfully,

01:07:43.480 --> 01:07:46.280
what would I actually see on the screen?

01:07:46.280 --> 01:07:47.800
Like literally, hello name.

01:07:47.800 --> 01:07:51.680
H-E-L-L-O comma space N-A-M-E, obviously not correct.

01:07:51.680 --> 01:07:53.040
So how do I plug in the variable?

01:07:53.040 --> 01:07:55.000
What was the trick?

01:07:55.000 --> 01:07:59.960
Yeah, percent s for string, a format code, so to speak, hence the name print f.

01:07:59.960 --> 01:08:03.200
And then I need to pass a second argument to print f.

01:08:03.200 --> 01:08:06.840
And I do that with a comma and then the name of the variable I want to plug in.

01:08:06.840 --> 01:08:09.120
Now notice there are two commas in this line here.

01:08:09.120 --> 01:08:11.640
If I zoom in, notice there's two commas.

01:08:11.640 --> 01:08:14.840
But there's only two arguments or inputs to print f.

01:08:14.840 --> 01:08:18.000
The input to a function is just typically called an argument

01:08:18.000 --> 01:08:19.800
or also called a parameter.

01:08:19.800 --> 01:08:23.600
So there are two commas, but this one is an English comma,

01:08:23.600 --> 01:08:26.440
just separating hello from the person's name.

01:08:26.440 --> 01:08:30.560
This white comma here, color coded because the sandbox is doing that for me,

01:08:30.560 --> 01:08:35.360
is actually separating, excuse me, the first argument from the second argument.

01:08:35.400 --> 01:08:39.600
So now for a third time, make hello, enter.

01:08:39.600 --> 01:08:40.800
Oh my god, thank you.

01:08:40.800 --> 01:08:41.800
Now it worked.

01:08:41.800 --> 01:08:45.560
It still spit out this pretty long cryptic command in white, but that's OK.

01:08:45.560 --> 01:08:49.640
That is, again, the automated command that make is making possible for us.

01:08:49.640 --> 01:08:53.080
But the fact that I see no red, no errors, just another blinking prompt

01:08:53.080 --> 01:08:55.040
means that my program has been made.

01:08:55.040 --> 01:09:00.480
So let me go ahead and do, how do I run a program if it's called hello?

01:09:00.480 --> 01:09:01.920
Yeah, dot slash hello.

01:09:01.920 --> 01:09:04.200
And we'll see why you have the stupid dot at the beginning.

01:09:04.200 --> 01:09:07.560
It essentially means run the program called hello that's right here

01:09:07.560 --> 01:09:11.080
in your current folder on the server, dot slash hello.

01:09:11.080 --> 01:09:11.800
What is your name?

01:09:11.800 --> 01:09:13.120
Very nice.

01:09:13.120 --> 01:09:15.040
David, enter.

01:09:15.040 --> 01:09:16.200
Hello, David.

01:09:16.200 --> 01:09:17.160
Interesting.

01:09:17.160 --> 01:09:20.600
Let's make one tweak because I did this by accident earlier, as you noted.

01:09:20.600 --> 01:09:23.720
What if I left off, for instance, one of these backslash ends?

01:09:23.720 --> 01:09:26.440
That's literally now not telling the computer

01:09:26.440 --> 01:09:28.320
to move the cursor to another line.

01:09:28.320 --> 01:09:31.560
So let me go ahead and rerun the program.

01:09:31.560 --> 01:09:32.120
Wait a minute.

01:09:32.120 --> 01:09:34.200
That looks the same.

01:09:34.200 --> 01:09:38.000
I just changed the code, but it's still behaving exactly the same.

01:09:38.000 --> 01:09:40.880
Where's my confusion?

01:09:40.880 --> 01:09:42.080
I didn't recompile it.

01:09:42.080 --> 01:09:44.400
Unlike Scratch, which is amazing because you just hit the green flag

01:09:44.400 --> 01:09:47.600
and it runs the code again, we have a second intermediate step.

01:09:47.600 --> 01:09:49.360
I have to rerun the code.

01:09:49.360 --> 01:09:50.800
Now, how do you get out of a program?

01:09:50.800 --> 01:09:51.560
I could just hit Enter.

01:09:51.560 --> 01:09:54.680
You can also hit Control C for cancel, and that will just get you out

01:09:54.680 --> 01:09:56.320
of whatever confusion you're in.

01:09:56.320 --> 01:09:57.400
Let me go ahead and rerun.

01:09:57.400 --> 01:09:58.760
Make hello.

01:09:58.760 --> 01:10:00.080
Seems to be OK.

01:10:00.080 --> 01:10:02.720
Dot slash hello, Enter.

01:10:02.720 --> 01:10:05.720
OK, this is why I've had all those backslash ends.

01:10:05.720 --> 01:10:07.920
Let me zoom in on what's happening.

01:10:07.920 --> 01:10:12.160
I mean, it doesn't look horrible, but frankly, it kind of rubs me the wrong

01:10:12.160 --> 01:10:15.320
way if this is what my program looks like when I'm typing in user input.

01:10:15.320 --> 01:10:16.560
I mean, this just looks stupid.

01:10:16.560 --> 01:10:18.560
Minimally, I should add a space.

01:10:18.560 --> 01:10:20.560
Maybe I could put backslash end to move the character.

01:10:20.560 --> 01:10:21.880
This is just user interface now.

01:10:21.880 --> 01:10:23.080
This isn't really logic.

01:10:23.080 --> 01:10:25.400
It's just aesthetics, but I think this looks stupid.

01:10:25.400 --> 01:10:28.040
So that's why I've had the backslash ends there all the time,

01:10:28.040 --> 01:10:31.640
but that's why they need to be there to tell the computer to actually put

01:10:31.640 --> 01:10:32.800
things where you want them.

01:10:32.800 --> 01:10:34.160
Alternatively, you know what?

01:10:34.160 --> 01:10:35.040
OK, I don't like that.

01:10:35.040 --> 01:10:36.440
Control C for cancel.

01:10:36.440 --> 01:10:37.760
Let me put this one back.

01:10:37.760 --> 01:10:39.880
What happens if I get rid of this one?

01:10:39.880 --> 01:10:43.840
And let me go ahead and recompile the code first, as you note.

01:10:43.840 --> 01:10:46.040
Dot slash hello, Enter.

01:10:46.040 --> 01:10:49.080
OK, I've cleaned up that aesthetic headache.

01:10:49.080 --> 01:10:50.400
Enter.

01:10:50.400 --> 01:10:55.280
OK, I mean, it's not quite the same problem, but this looks stupid too,

01:10:55.280 --> 01:10:57.320
because the dollar sign just represents my prompt,

01:10:57.320 --> 01:11:00.640
where I'm supposed to type commands, and yet hello comma David prompt.

01:11:00.640 --> 01:11:01.280
This is messy.

01:11:01.280 --> 01:11:03.560
So this is why we've had all of these new lines.

01:11:03.560 --> 01:11:06.480
Now, you asked earlier, what if you put the new line elsewhere in the string?

01:11:06.480 --> 01:11:07.600
Well, suppose I do that.

01:11:07.600 --> 01:11:09.080
Suppose I put a couple of them.

01:11:09.080 --> 01:11:10.000
Let me do this.

01:11:10.000 --> 01:11:11.680
And no space is whatsoever.

01:11:11.680 --> 01:11:14.600
Now, this is looking a little weird, but the computer is just

01:11:14.600 --> 01:11:15.880
going to interpret this literally.

01:11:15.880 --> 01:11:18.720
Print H-E-L-L-L comma new line.

01:11:18.720 --> 01:11:22.000
Substitute in the string for percent s, then another new line.

01:11:22.000 --> 01:11:26.280
So how many lines of output is this going to display?

01:11:26.320 --> 01:11:27.040
I heard four.

01:11:30.280 --> 01:11:30.920
Other values?

01:11:30.920 --> 01:11:31.640
Let's see.

01:11:31.640 --> 01:11:36.000
Let's go ahead and make hello, and then run dot slash hello.

01:11:36.000 --> 01:11:38.080
What is your name as before?

01:11:38.080 --> 01:11:40.360
Enter hello comma new line David.

01:11:40.360 --> 01:11:45.160
So four total lines, certainly, or just two lines from the computer itself.

01:11:45.160 --> 01:11:48.640
So just to recap then, with code like this,

01:11:48.640 --> 01:11:55.280
how many functions have I used in this particular program?

01:11:55.280 --> 01:11:56.120
How many functions?

01:11:59.720 --> 01:12:00.320
So it's two.

01:12:00.320 --> 01:12:02.920
Print F, which we've been using, and get string, which is the new one.

01:12:02.920 --> 01:12:06.120
Where is get string declared?

01:12:06.120 --> 01:12:11.280
CS50.H, print F, meanwhile, is declared in standard IO.H, standard input output.

01:12:11.280 --> 01:12:15.480
Meanwhile, string, this data type, also comes from CS50 itself.

01:12:15.480 --> 01:12:18.120
And then we've used the format codes, and we've used variables

01:12:18.120 --> 01:12:19.480
to achieve the same result.

01:12:19.480 --> 01:12:20.800
And let's just hammer this one.

01:12:20.800 --> 01:12:23.880
Brian and Karim, do you mind popping up for just a second?

01:12:23.880 --> 01:12:25.040
Or who's that?

01:12:25.040 --> 01:12:26.680
Aaron, come on up.

01:12:26.680 --> 01:12:30.200
So just to make this clear, because there's now some terminology

01:12:30.200 --> 01:12:31.600
that we want to use.

01:12:31.600 --> 01:12:34.240
Let's see, do you want to be get string?

01:12:34.240 --> 01:12:37.920
OK, so we have some name tags here, like you get it, events.

01:12:37.920 --> 01:12:42.760
So Aaron shall be get underscore string.

01:12:42.760 --> 01:12:45.680
If you want to go ahead and put this on.

01:12:45.680 --> 01:12:49.440
OK, and Brian, you want to be print F.

01:12:49.440 --> 01:12:51.760
So we won't act out all of our actual programs,

01:12:51.760 --> 01:12:53.480
because this will quickly become obvious.

01:12:53.480 --> 01:12:57.240
So Brian is print F. So this point, though, remains,

01:12:57.240 --> 01:13:00.280
in that this is nice that I have some colleagues with whom I work here,

01:13:00.280 --> 01:13:04.760
because I don't really want to do all of the hard work of making things happen.

01:13:04.760 --> 01:13:08.000
And so if I'm instead the programmer, or the orchestrator of a whole bunch

01:13:08.000 --> 01:13:11.920
of things happening, I can actually implement this code now more physically.

01:13:11.920 --> 01:13:15.640
And let's focus, though, for just a moment on what the key takeaways are.

01:13:15.640 --> 01:13:18.640
One, functions can take inputs.

01:13:18.640 --> 01:13:21.840
Those inputs are called arguments or parameters.

01:13:21.840 --> 01:13:23.840
And functions can return things.

01:13:23.840 --> 01:13:25.560
They can have return values.

01:13:25.560 --> 01:13:26.880
Print F, for instance.

01:13:26.880 --> 01:13:27.760
Does it take inputs?

01:13:30.360 --> 01:13:31.960
What's the input to print F, for instance?

01:13:34.600 --> 01:13:35.680
Yeah, like hello world.

01:13:35.680 --> 01:13:39.880
Whatever it is you want to print is, by definition, the input to print F.

01:13:39.880 --> 01:13:44.040
Does print F return a value thus far?

01:13:44.040 --> 01:13:46.040
It does do something on the screen, certainly.

01:13:46.040 --> 01:13:47.320
Like it prints stuff on the screen.

01:13:47.320 --> 01:13:49.320
But we haven't seen it return something,

01:13:49.320 --> 01:13:52.560
because we haven't seen it with an equal sign to the left.

01:13:52.560 --> 01:13:54.400
Now, it turns out print F does return things.

01:13:54.400 --> 01:13:56.480
It's just not often that useful to use.

01:13:56.480 --> 01:13:59.000
But we've only seen print F for the moment as taking inputs.

01:13:59.000 --> 01:14:00.360
More on that another time.

01:14:00.360 --> 01:14:01.320
Get string, meanwhile.

01:14:01.320 --> 01:14:04.400
Does get string take inputs?

01:14:04.400 --> 01:14:06.560
How many inputs?

01:14:06.560 --> 01:14:09.680
Just one, the prompt that you want the human to see.

01:14:09.680 --> 01:14:11.640
The first prompt I used was, what is your name?

01:14:11.640 --> 01:14:14.560
I could make the prompt anything, but that's the question that get string is asking.

01:14:14.560 --> 01:14:16.920
Does get string return a value?

01:14:16.920 --> 01:14:17.520
It does.

01:14:17.520 --> 01:14:21.040
That's, of course, in Scratch called answer, hard coded as answer.

01:14:21.040 --> 01:14:22.880
We can store it in any variable we want.

01:14:22.880 --> 01:14:24.800
So let me just go ahead and implement this program.

01:14:24.800 --> 01:14:30.080
Aaron, go get me a string and ask the person, what is their name?

01:14:30.080 --> 01:14:41.200
So she's writing down Elizabeth now.

01:14:41.200 --> 01:14:42.640
But Aaron has taken input from me.

01:14:42.640 --> 01:14:44.880
Aaron, go get someone's name and ask them, what is their name?

01:14:44.880 --> 01:14:46.960
Now you've produced output for me.

01:14:46.960 --> 01:14:47.960
Thank you.

01:14:47.960 --> 01:14:50.200
This is the return value, storing the value, Elizabeth.

01:14:50.200 --> 01:14:52.600
And I'm going to go ahead and tuck it away in a variable called name,

01:14:52.600 --> 01:14:53.760
like this piece of paper here.

01:14:53.760 --> 01:14:56.320
OK, Brian, could you go ahead and say hello, Elizabeth?

01:15:09.480 --> 01:15:11.960
OK, so what's going on here?

01:15:11.960 --> 01:15:13.720
I'm just doing less work.

01:15:13.720 --> 01:15:15.440
Like, I kind of am writing this program.

01:15:15.440 --> 01:15:16.520
Aaron, go get someone's name.

01:15:16.520 --> 01:15:17.920
Brian, could you print this out?

01:15:17.920 --> 01:15:19.880
Like, that's what I've been doing is programming,

01:15:19.880 --> 01:15:22.920
just delegating functionality to other functions, or in this case,

01:15:22.920 --> 01:15:24.600
other humans who know how to do that.

01:15:24.600 --> 01:15:27.360
And honestly, I don't have to know how Aaron got that name.

01:15:27.360 --> 01:15:28.280
She just got it.

01:15:28.280 --> 01:15:31.320
I don't have to know how Brian wrote in that particular kind

01:15:31.320 --> 01:15:33.320
of style of English on the screen.

01:15:33.320 --> 01:15:35.000
I just know that he can do it.

01:15:35.000 --> 01:15:37.240
And now my program is complete.

01:15:37.240 --> 01:15:39.280
Thank you very much to both of these two here.

01:15:39.280 --> 01:15:42.520
We'll continue in just a moment as follows.

01:15:42.520 --> 01:15:44.960
So all this time, we've been taking for granted

01:15:44.960 --> 01:15:48.640
that we have an actual computer on which we can execute code.

01:15:48.640 --> 01:15:50.320
And I keep saying Intel inside, because that's

01:15:50.320 --> 01:15:54.280
a sort of silly slogan that you see inside of most Macs and PCs

01:15:54.280 --> 01:15:55.480
with the hardware they have.

01:15:55.480 --> 01:15:58.080
But the CPU is just the brains of the computer.

01:15:58.080 --> 01:16:00.520
And at the end of the day, recall that the goal

01:16:00.520 --> 01:16:04.120
is to actually have the computer turn something like this, source code,

01:16:04.120 --> 01:16:07.320
into actual machine code, 0s and 1s.

01:16:07.320 --> 01:16:10.520
And that's all Clang was actually doing for us.

01:16:10.520 --> 01:16:13.320
Of course, we've only just scratched the surface now of what we can do.

01:16:13.320 --> 01:16:16.240
It turns out there's going to be not just these commands that we can run,

01:16:16.240 --> 01:16:20.400
but other features of C. And in particular, the CS50 library.

01:16:20.400 --> 01:16:22.320
We've only seen thus far how to get a string,

01:16:22.320 --> 01:16:25.040
but you can get integers and characters and funky things like floats

01:16:25.040 --> 01:16:28.120
and doubles, which actually open a can of worms as two problems that

01:16:28.120 --> 01:16:29.440
can happen in a computer.

01:16:29.440 --> 01:16:32.440
And it turns out you can store different types of variables,

01:16:32.440 --> 01:16:36.360
not just integers and strings, but bool for Boolean and chars

01:16:36.360 --> 01:16:37.080
for characters.

01:16:37.080 --> 01:16:39.040
And you can format those things in printf.

01:16:39.040 --> 01:16:41.240
We've only seen %i, %s.

01:16:41.240 --> 01:16:44.640
I alluded to %i earlier, but there's a few others still.

01:16:44.640 --> 01:16:46.760
But we've got a lot of possibilities here.

01:16:46.760 --> 01:16:48.720
But let's go ahead and take, say, a five minute break

01:16:48.720 --> 01:16:51.720
to give everyone a bit of a respite, turn on some music and come back in five,

01:16:51.720 --> 01:16:55.240
and dive in deeper to more sophisticated programs in C.

01:16:55.240 --> 01:16:57.160
All right.

01:16:57.160 --> 01:17:01.040
So recall we began by comparing some scratch blocks

01:17:01.040 --> 01:17:02.440
against the corresponding C code.

01:17:02.440 --> 01:17:05.960
But we didn't actually use most of those blocks in C just yet.

01:17:05.960 --> 01:17:08.240
So let's try out a number of examples, some of which

01:17:08.240 --> 01:17:12.280
I'll write on the fly in typing code out on my own keyboard, some of which

01:17:12.280 --> 01:17:15.560
we already have on the course's website, so we can just open them to save some time.

01:17:15.560 --> 01:17:18.120
But let me just draw your attention to what CS50 Sandbox is,

01:17:18.120 --> 01:17:20.360
because this was the step that I skipped over earlier.

01:17:20.360 --> 01:17:23.880
CS50 Sandbox can be used to program in bunches of languages.

01:17:23.880 --> 01:17:26.120
Will initially in the semester use it for C.

01:17:26.120 --> 01:17:30.440
But if you've written Java before or Python or any number of languages,

01:17:30.440 --> 01:17:33.720
when you go to sandbox.cs50.io, you can simply

01:17:33.720 --> 01:17:35.440
choose the language you want to write in.

01:17:35.440 --> 01:17:38.640
And then at the bottom, you'll see you can specify the name of the file

01:17:38.640 --> 01:17:39.880
you want to pre-create.

01:17:39.880 --> 01:17:44.320
So for instance, what I did earlier was I selected C at top.

01:17:44.320 --> 01:17:46.720
And then at the bottom, I typed in hello.c,

01:17:46.720 --> 01:17:49.560
because that was the name of the file I wanted, and then I clicked Start.

01:17:49.560 --> 01:17:54.600
And what that led me to was precisely the interface in which we wrote hello.c

01:17:54.600 --> 01:17:57.920
just a moment ago, where my code editor appears on the top here,

01:17:57.920 --> 01:18:00.080
my terminal window appears at the bottom,

01:18:00.080 --> 01:18:02.400
and then I'm allowed to just start writing code.

01:18:02.400 --> 01:18:04.200
So that's how we got to where we were.

01:18:04.240 --> 01:18:07.280
And if you want to follow along now with some of these examples,

01:18:07.280 --> 01:18:10.000
note that on the course's website, we have all of them pre-made.

01:18:10.000 --> 01:18:13.560
And you can actually click the links on the course's website

01:18:13.560 --> 01:18:16.240
and open up your own copy of a sandbox with that code.

01:18:16.240 --> 01:18:19.000
So if the Wi-Fi cooperates, you're welcome to tinker and play and run

01:18:19.000 --> 01:18:22.400
the same commands, but everything is also on the course's website after.

01:18:22.400 --> 01:18:24.320
So you need to type everything out.

01:18:24.320 --> 01:18:26.200
So let's go ahead and do just a quick example.

01:18:26.200 --> 01:18:31.040
I'm going to call this int.c just so that we can reinforce some of what we did

01:18:31.040 --> 01:18:32.160
just a moment ago.

01:18:32.200 --> 01:18:35.440
Rather than get a string, like we did with our hello example,

01:18:35.440 --> 01:18:40.360
let me go ahead and just get, say, an integer, and then print it out,

01:18:40.360 --> 01:18:41.920
just as we did print a name.

01:18:41.920 --> 01:18:44.600
So I'm going to have to go ahead and just through muscle memory,

01:18:44.600 --> 01:18:47.840
I kind of remember that I need standard io.h at the top,

01:18:47.840 --> 01:18:51.440
and then int main void, and then curly braces,

01:18:51.440 --> 01:18:55.360
and then I can do the act of actually getting the input.

01:18:55.360 --> 01:18:57.680
So there was a function before called get string.

01:18:57.680 --> 01:18:59.840
Turns out there's another function called get int,

01:18:59.840 --> 01:19:01.160
if you want to get an integer.

01:19:01.160 --> 01:19:04.480
So I can actually call get int, and I can say something like integer

01:19:04.480 --> 01:19:07.440
is the prompt, like, hey, human, please give me an integer.

01:19:07.440 --> 01:19:09.840
I need a semicolon at the end of this line.

01:19:09.840 --> 01:19:15.280
And then how do I actually store the return value of get int in a variable?

01:19:15.280 --> 01:19:17.960
Just as Aaron handed me a sheet of paper with a string,

01:19:17.960 --> 01:19:20.680
how do if I'm handed a sheet of paper with a number,

01:19:20.680 --> 01:19:23.240
how do I store it somewhere?

01:19:23.240 --> 01:19:27.160
What should I literally type on line five here?

01:19:27.160 --> 01:19:29.120
Int, space, and then number or something.

01:19:29.120 --> 01:19:31.000
So I'm going to call it i just because it's an integer,

01:19:31.000 --> 01:19:33.160
but I could call it number or anything else.

01:19:33.160 --> 01:19:35.160
And then I'm going to go ahead and print this out.

01:19:35.160 --> 01:19:42.360
So printf, let's say something like hello, i, backslash, n, semicolon.

01:19:42.360 --> 01:19:43.800
OK, not quite correct, right?

01:19:43.800 --> 01:19:46.080
This is going to literally print hello, comma, i.

01:19:46.080 --> 01:19:47.760
How do I actually substitute something in?

01:19:47.760 --> 01:19:50.040
Well, we've only seen how to substitute in a string,

01:19:50.040 --> 01:19:52.080
but I think I spoiled earlier the answer.

01:19:52.080 --> 01:19:56.040
Fuse, percent, i, that says, hey, computer, put an integer here.

01:19:56.040 --> 01:20:00.840
Then I need a second argument to printf, just as we handed Brian

01:20:00.840 --> 01:20:02.480
an argument as well.

01:20:02.480 --> 01:20:04.640
And I said i.

01:20:04.640 --> 01:20:06.200
I want to say i here.

01:20:06.200 --> 01:20:08.360
But this program isn't quite correct yet.

01:20:08.360 --> 01:20:09.800
It's in a file called int.c.

01:20:09.800 --> 01:20:11.680
I've included standard io.h.

01:20:11.680 --> 01:20:13.880
It's in main, and so what is main?

01:20:13.880 --> 01:20:16.520
Well, today, we're largely going to wave our hands at that.

01:20:16.520 --> 01:20:20.000
But int main void is perhaps the most cryptic way

01:20:20.000 --> 01:20:22.680
you can say the equivalent of when green flag clicked.

01:20:22.680 --> 01:20:23.800
Like, that's all that does.

01:20:23.800 --> 01:20:27.080
And we'll come back in the weeks to come as to why it's int, why it's main,

01:20:27.080 --> 01:20:27.880
why it's void.

01:20:27.880 --> 01:20:30.000
But for now, humans years ago just decided

01:20:30.040 --> 01:20:33.560
that when you're writing a program in C and you want to start the program off,

01:20:33.560 --> 01:20:36.800
you literally have to type int main void with those parentheses,

01:20:36.800 --> 01:20:39.800
with those curly braces, and it's the equivalent to scratches when green

01:20:39.800 --> 01:20:40.760
flag clicked.

01:20:40.760 --> 01:20:42.720
But this program will not compile.

01:20:42.720 --> 01:20:45.320
And I don't even want to induce the stress of seeing those errors.

01:20:45.320 --> 01:20:47.280
How do I void it?

01:20:47.280 --> 01:20:51.040
Yeah, I need to teach the computer that get int exists.

01:20:51.040 --> 01:20:55.600
And I know how to do that from before by including the so-called CS50 library.

01:20:55.600 --> 01:20:58.320
Technically, CS50.h is a header file.

01:20:58.320 --> 01:21:00.000
.h means header.

01:21:00.000 --> 01:21:03.640
And it's just a file containing C code in which the functions are created.

01:21:03.640 --> 01:21:05.080
More on that another time.

01:21:05.080 --> 01:21:07.320
But that just gives us access to printf.

01:21:07.320 --> 01:21:10.440
So if I've made no typos, I should be able to compile this program

01:21:10.440 --> 01:21:13.640
by running what command?

01:21:13.640 --> 01:21:14.360
Make int.

01:21:14.360 --> 01:21:15.520
I could do clang.

01:21:15.520 --> 01:21:17.200
I could do clang-o.

01:21:17.200 --> 01:21:20.360
But for now, I'm going to do it simpler, would just make int

01:21:20.360 --> 01:21:24.080
and let make automate the process of compiling this program.

01:21:24.080 --> 01:21:25.800
No error messages is good.

01:21:25.800 --> 01:21:27.600
Let me go ahead and zoom in.

01:21:27.600 --> 01:21:30.320
.int, I think, would run the program.

01:21:30.320 --> 01:21:32.680
Integer, how about 42?

01:21:32.680 --> 01:21:34.080
Hello, 42.

01:21:34.080 --> 01:21:35.440
Notice I can save time now.

01:21:35.440 --> 01:21:38.600
If I want to run it again, I don't have to do .int all the time.

01:21:38.600 --> 01:21:41.280
It turns out that in this kind of Linux environment,

01:21:41.280 --> 01:21:44.560
this operating system called Linux, you can actually go up and down

01:21:44.560 --> 01:21:47.520
and see previous commands you've typed and some others that

01:21:47.520 --> 01:21:49.000
happen to be system specific.

01:21:49.000 --> 01:21:51.440
And if you just hit up and enter, you can run it again.

01:21:51.440 --> 01:21:54.880
Type in 50 this time and see another output as well.

01:21:54.880 --> 01:21:56.440
All right, so any questions then?

01:21:56.440 --> 01:21:59.840
On just an example like that?

01:21:59.840 --> 01:22:00.160
No?

01:22:00.160 --> 01:22:02.760
Well, let me go ahead and I'm going to save time in this environment.

01:22:02.760 --> 01:22:07.280
I can actually create files in here if I want by clicking the folder icon,

01:22:07.280 --> 01:22:11.000
clicking the plus, and then I can actually say, give me a file called float.c.

01:22:11.000 --> 01:22:13.120
So this is equivalent to going back to the main menu

01:22:13.120 --> 01:22:14.280
and typing in the name of the file.

01:22:14.280 --> 01:22:15.880
I'm just going to do it a little more quickly now

01:22:15.880 --> 01:22:17.160
in this graphical environment.

01:22:17.160 --> 01:22:18.920
And I want to call it float.c.

01:22:18.920 --> 01:22:21.520
It's a bit of a weird name, because at least growing up,

01:22:21.520 --> 01:22:24.160
you probably learned maybe about integers.

01:22:24.160 --> 01:22:27.480
You probably learned about real numbers, numbers that can have decimal points,

01:22:27.480 --> 01:22:29.520
and then things after the decimal point in a computer.

01:22:29.520 --> 01:22:33.680
Those things with decimal points are called floating point values, or floats.

01:22:33.680 --> 01:22:36.720
And you can think of it as the decimal point can kind of float to the left

01:22:36.720 --> 01:22:38.960
or the right, depending on how big or small the number is,

01:22:38.960 --> 01:22:41.680
or how precise the numbers after the decimal point are.

01:22:41.680 --> 01:22:42.720
That's a float.

01:22:42.720 --> 01:22:45.120
So let me go ahead and implement a very similar program.

01:22:45.160 --> 01:22:51.320
Include cs50.h, include standardio.h int main void.

01:22:51.320 --> 01:22:54.520
And this is after 20 years of doing this, that you can do it so quickly.

01:22:54.520 --> 01:22:58.840
Now, let me instead get a float from the user, so a real number that

01:22:58.840 --> 01:23:00.920
may very well have a decimal point in it.

01:23:00.920 --> 01:23:02.960
I'm going to do that a little differently.

01:23:02.960 --> 01:23:06.200
I'll zoom in, and I'm going to say, hey, computer, give me a float,

01:23:06.200 --> 01:23:10.120
as is the data type called, not int, not string, but float.

01:23:10.120 --> 01:23:12.360
I'll call it f, just because that sounds like float,

01:23:12.360 --> 01:23:13.840
and it's nice and succinct.

01:23:13.840 --> 01:23:18.080
Equals get float, and then I'm just going to say float.

01:23:18.080 --> 01:23:18.840
That's the prompt.

01:23:18.840 --> 01:23:21.160
I could make the prompt in green anything I want.

01:23:21.160 --> 01:23:22.440
And now I'm going to print it.

01:23:22.440 --> 01:23:26.360
Print f, hello, f, but I don't want f.

01:23:26.360 --> 01:23:28.480
I want to actually print out a placeholder,

01:23:28.480 --> 01:23:31.560
and you can probably guess by now what the pattern is,

01:23:31.560 --> 01:23:37.760
percent f for a float, new line, comma, f, semicolon.

01:23:37.760 --> 01:23:41.080
So this is like the same program three times now with a string,

01:23:41.120 --> 01:23:43.760
with an int and a float, but again, just for some muscle memory

01:23:43.760 --> 01:23:44.880
and going through the pattern.

01:23:44.880 --> 01:23:46.600
But let's see what happens differently here.

01:23:46.600 --> 01:23:49.400
Let me go ahead and type make float, enter.

01:23:49.400 --> 01:23:50.560
OK, good, no errors.

01:23:50.560 --> 01:23:59.120
Let me zoom in and run this now as dot slash float.

01:23:59.120 --> 01:24:00.520
And let me go ahead and type in a number.

01:24:00.520 --> 01:24:02.280
I'm going to just say 42.

01:24:02.280 --> 01:24:05.920
But the computer now has the capability of storing more precision.

01:24:05.920 --> 01:24:08.440
Before, it was just an integer by definition of int.

01:24:08.440 --> 01:24:13.160
Now it's a float, so even though it's pretty precise as 42.000,

01:24:13.160 --> 01:24:17.720
that's indeed a real number now storing some amount of precision there.

01:24:17.720 --> 01:24:21.920
So it turns out, though, that we can do more interesting math.

01:24:21.920 --> 01:24:25.440
Let me go ahead and just open this example in advance.

01:24:25.440 --> 01:24:27.720
This one's going to be called ints.c, so they

01:24:27.720 --> 01:24:29.840
don't have to type everything out.

01:24:29.840 --> 01:24:33.800
And in ints.c, we're going to see some math written in code

01:24:33.800 --> 01:24:36.600
that I pre-created just to reinforce that you can actually

01:24:36.600 --> 01:24:38.560
do some basic arithmetic in a program.

01:24:38.560 --> 01:24:41.800
I can see more of the code here by just scrolling down.

01:24:41.800 --> 01:24:44.200
And let me scroll this up so we can focus on main.

01:24:44.200 --> 01:24:46.760
And let me zoom in on the first few lines.

01:24:46.760 --> 01:24:50.160
On this first line, I'm just getting an int, and I'm calling it x.

01:24:50.160 --> 01:24:52.000
We've not used a variable called x recently,

01:24:52.000 --> 01:24:52.600
but now we are.

01:24:52.600 --> 01:24:55.200
It's no different logically than before.

01:24:55.200 --> 01:24:57.280
Here, give me another variable so we can see now

01:24:57.280 --> 01:25:00.240
that you can get multiple variables from the user, just like in Scratch.

01:25:00.240 --> 01:25:05.360
And now, in these lines, in green, are just some format strings.

01:25:05.520 --> 01:25:07.560
What do I want printf to display?

01:25:07.560 --> 01:25:10.000
I literally, in this highlighted line here,

01:25:10.000 --> 01:25:14.640
want printf to display x plus y equals something.

01:25:14.640 --> 01:25:15.600
What is that something?

01:25:15.600 --> 01:25:21.240
Well, notice what's cool about printf is that before it is passed an input,

01:25:21.240 --> 01:25:23.200
you can perform simple arithmetic operations.

01:25:23.200 --> 01:25:26.360
So if you want to add x and y together, literally do x plus y,

01:25:26.360 --> 01:25:30.760
then the sum of those numbers will get handed to printf as its input.

01:25:30.760 --> 01:25:33.640
Just like I handed Aaron's piece of paper to Brian as input,

01:25:33.640 --> 01:25:39.160
I'm handing not x and y to Brian in this case, but x plus y or some value,

01:25:39.160 --> 01:25:40.120
the actual sum.

01:25:40.120 --> 01:25:43.880
Similarly, subtraction is the hyphen on your keyboard.

01:25:43.880 --> 01:25:45.760
For multiplication, it's not an x.

01:25:45.760 --> 01:25:47.080
That would be weird, x, x, y.

01:25:47.080 --> 01:25:49.840
It's instead star or an asterisk on your keyboard.

01:25:49.840 --> 01:25:51.520
Division is a single slash.

01:25:51.520 --> 01:25:54.400
And then this one's a little funky, but we'll come up with some uses for this.

01:25:54.400 --> 01:25:59.040
You can actually do modular arithmetic or just more simply, remainders.

01:25:59.080 --> 01:26:06.280
If you do x percent y, you'll get back the remainder of dividing x by y.

01:26:06.280 --> 01:26:07.160
And what's the remainder?

01:26:07.160 --> 01:26:14.800
So if x is 20 and y is 10, well, 20 divided by 10 goes in twice perfectly.

01:26:14.800 --> 01:26:17.320
So remainder is 0, for instance, if it's been a while.

01:26:17.320 --> 01:26:19.400
So notice what's curious here.

01:26:19.400 --> 01:26:22.160
In this context, percent is not a placeholder.

01:26:22.160 --> 01:26:22.800
It's not percent s.

01:26:22.800 --> 01:26:23.520
It's not percent i.

01:26:23.520 --> 01:26:24.400
It's not percent f.

01:26:24.400 --> 01:26:27.600
Notice it's not inside of printf's format string.

01:26:27.600 --> 01:26:30.640
This is just literally math, a math operator,

01:26:30.640 --> 01:26:32.960
as is implied by the different color blue there.

01:26:32.960 --> 01:26:36.320
So if I actually run this, let's go ahead and run this program.

01:26:36.320 --> 01:26:39.960
I'm going to go ahead and make ints plural, because that's the name of the file.

01:26:39.960 --> 01:26:42.240
Enter dot slash int.

01:26:42.240 --> 01:26:45.120
And let me zoom in and clear the screen.

01:26:45.120 --> 01:26:46.160
Enter.

01:26:46.160 --> 01:26:48.000
Give me a number.

01:26:48.000 --> 01:26:48.880
2, I heard.

01:26:48.880 --> 01:26:50.960
And another.

01:26:50.960 --> 01:26:52.360
10, I heard.

01:26:52.360 --> 01:26:56.760
So fyi, 2 plus 10 is 12.

01:26:56.760 --> 01:26:58.480
2 minus 10 is negative 8.

01:26:58.480 --> 01:26:59.960
2 times 10 is 20.

01:26:59.960 --> 01:27:08.240
2 divided by 10, 2 mod y, or 2, and then take the remainder when dividing by y

01:27:08.240 --> 01:27:10.960
is what mod means, is 2.

01:27:10.960 --> 01:27:14.800
So I get like 4 out of 5 for correctness.

01:27:14.800 --> 01:27:16.400
What's a little funky here?

01:27:17.400 --> 01:27:26.320
Yeah, like 2 divided by 10, I'm pretty sure that's like 2 tenths, or maybe 1

01:27:26.320 --> 01:27:28.000
fifth, or 0.2.

01:27:28.000 --> 01:27:30.520
I mean, I'll take any number of answers, but not 0.

01:27:30.520 --> 01:27:31.680
So what's going on?

01:27:31.680 --> 01:27:33.360
Well, this is a matter of representation.

01:27:33.360 --> 01:27:38.000
It turns out in a computer program, we decided in advance, I'm going to store ints.

01:27:38.000 --> 01:27:40.720
OK, an int is something that does not have a decimal point.

01:27:40.720 --> 01:27:43.320
And yet here I am, rather presumptuously,

01:27:43.320 --> 01:27:46.880
trying to do 2, an integer, divided by 10, an integer,

01:27:46.880 --> 01:27:49.080
and expecting something other than an integer.

01:27:49.080 --> 01:27:53.240
No, like I literally am doing integer arithmetic.

01:27:53.240 --> 01:27:56.240
So what's the computer apparently doing, just intuitively?

01:27:56.240 --> 01:28:01.160
Why when dividing x by y, as I did in this line here,

01:28:01.160 --> 01:28:04.560
or specifically in this example you proposed, 2 divided by 10,

01:28:04.560 --> 01:28:08.680
where is my 2 tenths going?

01:28:08.680 --> 01:28:10.600
Yeah, it's as though it's technically what?

01:28:10.600 --> 01:28:13.240
It's supposed to be 0.2, or 0.2.

01:28:13.240 --> 01:28:15.040
OK, that's actually the solution, right?

01:28:15.040 --> 01:28:18.880
Because if it's 0.2, but integers can't store decimal points or anything

01:28:18.880 --> 01:28:20.640
after them, what do you have left?

01:28:20.640 --> 01:28:22.560
Just the 0 at the beginning.

01:28:22.560 --> 01:28:25.520
So integer arithmetic is fine if you're working with integers,

01:28:25.520 --> 01:28:27.800
but if you want floating point arithmetic,

01:28:27.800 --> 01:28:29.760
you're going to need to make some changes.

01:28:29.760 --> 01:28:31.280
And so I can fix this.

01:28:31.280 --> 01:28:34.480
In fact, let me go ahead and write a different program here.

01:28:34.480 --> 01:28:39.920
Let me go ahead and open up from the course's website, floats.c.

01:28:39.920 --> 01:28:43.520
And that's going to give me this example, which

01:28:43.520 --> 01:28:47.000
is implemented using floating point values instead.

01:28:47.000 --> 01:28:49.720
So once this loads, I'm going to see a program I wrote in advance.

01:28:49.720 --> 01:28:53.560
It's a little shorter, because now I only care about looking at one problem.

01:28:53.560 --> 01:28:56.720
And notice now, x and y are now floats and not ints.

01:28:56.720 --> 01:28:59.440
Another data type that exists, and I'm using get float, which also comes

01:28:59.440 --> 01:29:00.920
from CS50's library.

01:29:00.920 --> 01:29:05.040
And then this line is almost the same, but let me tweak this.

01:29:05.040 --> 01:29:06.840
Let me just make it exactly the same.

01:29:06.840 --> 01:29:10.920
This line now that I've highlighted is exactly the same as before.

01:29:10.920 --> 01:29:14.760
So if I do type in the same number, so let's go ahead and zoom in and do

01:29:14.760 --> 01:29:21.040
make floats plural and dot slash floats, I'll give it 2 and 10.

01:29:21.040 --> 01:29:24.240
And I should hopefully see what now?

01:29:24.240 --> 01:29:25.320
0.2.

01:29:25.320 --> 01:29:28.000
Yeah, OK, that's pretty good, pretty precise.

01:29:28.000 --> 01:29:30.320
But you know what?

01:29:30.320 --> 01:29:35.560
I hate to tell you, but let's look a little farther.

01:29:35.560 --> 01:29:38.000
It turns out, by default, when you do percent F,

01:29:38.000 --> 01:29:41.880
you only see a few decimal places, like five or so it looks, by default.

01:29:41.880 --> 01:29:43.440
Let me see a few more.

01:29:43.440 --> 01:29:49.920
So this was 1, 2, 3, 4, 5, 6 points after the decimal point.

01:29:49.920 --> 01:29:50.640
So you know what?

01:29:50.640 --> 01:29:53.280
I'm going to say, hey, computer, give me seven decimal points.

01:29:53.280 --> 01:29:55.200
This looks completely cryptic, and you just

01:29:55.200 --> 01:29:57.720
have to kind of remember this or look it up if you forget.

01:29:57.720 --> 01:30:01.480
If you put a dot and a number in between the percent and the F,

01:30:01.480 --> 01:30:04.680
that's the cryptic way of telling the computer, show me a float,

01:30:04.720 --> 01:30:06.600
but with this many decimal places, please.

01:30:06.600 --> 01:30:10.280
So that just gives me seven decimal places, weird as the expression looks.

01:30:10.280 --> 01:30:13.080
All right, hopefully, I'm just going to see some more zeros.

01:30:13.080 --> 01:30:15.440
So let me go ahead and make floats.

01:30:15.440 --> 01:30:20.880
And let me go ahead and zoom in and do dot slash floats, 2, 10, enter.

01:30:20.880 --> 01:30:23.600
OK, still correct.

01:30:23.600 --> 01:30:26.080
Let me get a little curious.

01:30:26.080 --> 01:30:29.000
Let's see a lot of zeros, like 50 of them.

01:30:29.000 --> 01:30:33.440
Let me go down here and do make floats, because I changed the code,

01:30:33.480 --> 01:30:37.760
dot slash floats, 2, 10.

01:30:37.760 --> 01:30:39.480
Ha!

01:30:39.480 --> 01:30:42.000
Your grade school teachers lied to you.

01:30:42.000 --> 01:30:50.400
2 divided by 10 is apparently not 0.2000000 infinitely.

01:30:50.400 --> 01:31:01.160
It's apparently 0.2000000298023223876953125, and then all of those zeros.

01:31:01.200 --> 01:31:03.800
What the hell is going on?

01:31:03.800 --> 01:31:05.000
Where's the bug?

01:31:05.000 --> 01:31:06.080
Where's my mistake?

01:31:06.080 --> 01:31:07.280
Where's my misunderstanding?

01:31:10.280 --> 01:31:13.920
What's the explanation for this?

01:31:13.920 --> 01:31:19.040
Well, what if I told you that inside of your computer is stuff like this?

01:31:19.040 --> 01:31:20.560
This is RAM or memory.

01:31:20.560 --> 01:31:22.280
And you've probably generally known this idea, right?

01:31:22.280 --> 01:31:25.960
They store files to store music and videos, like you need memory,

01:31:25.960 --> 01:31:28.640
some kind of space, hard disk space is permanent storage.

01:31:28.640 --> 01:31:31.960
RAM or random access memory is temporary storage.

01:31:31.960 --> 01:31:35.880
So when your laptop is open or your desktop computer is on or your phone is powered,

01:31:35.880 --> 01:31:38.400
you're using RAM for all of the programs you're running at once.

01:31:38.400 --> 01:31:41.120
So if you open a file, that file is stored in RAM,

01:31:41.120 --> 01:31:42.840
but it's permanently stored on your hard drive.

01:31:42.840 --> 01:31:44.320
So there's different types of memory.

01:31:44.320 --> 01:31:45.960
But notice this is zoomed in.

01:31:45.960 --> 01:31:50.000
In reality, this is like a couple of inches wide and maybe an inch tall.

01:31:50.000 --> 01:31:53.080
So it's pretty small, but it doesn't really matter how big it is.

01:31:53.080 --> 01:31:55.680
It just matters that it's finite in size.

01:31:55.680 --> 01:31:59.080
You have physical hardware on your laps or in your pockets or at home

01:31:59.080 --> 01:32:02.640
that only are so big and therefore only have so many parts

01:32:02.640 --> 01:32:07.000
and therefore only have so many transistors and other pieces of hardware

01:32:07.000 --> 01:32:09.520
that's actually doing the work of storing information.

01:32:09.520 --> 01:32:12.920
And so if you only have a finite amount of memory,

01:32:12.920 --> 01:32:18.960
how in the world are we going to represent an infinite number of numbers?

01:32:18.960 --> 01:32:20.800
Because I do recall from grade school I was taught

01:32:20.800 --> 01:32:23.360
there's an infinite number of numbers, certainly real numbers,

01:32:23.360 --> 01:32:25.680
where the decimal point can go on forever.

01:32:25.680 --> 01:32:29.360
That is a problem if you want to represent all possible numbers

01:32:29.360 --> 01:32:35.400
in the universe, which is infinitely many, with a finite amount of hardware.

01:32:35.400 --> 01:32:39.880
So at some point, the computers got to start cutting some corners.

01:32:39.880 --> 01:32:43.600
And so what you're really seeing here is as close as the computer

01:32:43.600 --> 01:32:47.480
can get to storing that fraction for you precisely.

01:32:47.480 --> 01:32:48.480
And I got a little greedy.

01:32:48.480 --> 01:32:50.680
I looked a little too far to the right.

01:32:50.680 --> 01:32:53.720
And granted, these are infinitesimally small values.

01:32:53.720 --> 01:32:55.760
It's not hugely, hugely off.

01:32:55.760 --> 01:32:58.200
But it is off, because I can't expect the computer

01:32:58.200 --> 01:33:02.120
to represent an infinite number of values using a finite amount of memory.

01:33:02.120 --> 01:33:07.680
It's got to kind of round off here or there and be imprecise, so to speak.

01:33:07.680 --> 01:33:08.680
So is this a problem?

01:33:11.840 --> 01:33:14.400
I mean, we would never have known this if I hadn't gotten greedy

01:33:14.400 --> 01:33:19.400
and looked at 50 decimal places instead of 7, which was already pretty precise.

01:33:19.440 --> 01:33:20.200
Is this a problem?

01:33:22.680 --> 01:33:23.180
Yeah?

01:33:23.180 --> 01:33:24.480
Like why?

01:33:24.480 --> 01:33:24.980
Why?

01:33:28.820 --> 01:33:29.320
Yeah.

01:33:29.320 --> 01:33:30.020
That's a good one.

01:33:30.020 --> 01:33:34.160
Logically, if I start using equals equals to compare things for equality,

01:33:34.160 --> 01:33:37.680
it's going to be really hard for me to ever compare something for too tense

01:33:37.680 --> 01:33:40.760
as its value, because I'm going to literally have to remember or write

01:33:40.760 --> 01:33:43.840
down or figure out this value and compare against that and not just

01:33:43.840 --> 01:33:45.880
compare more loosely against point two.

01:33:45.880 --> 01:33:46.640
And that's true.

01:33:46.640 --> 01:33:50.960
You should actually never compare floating point values in code for equality.

01:33:50.960 --> 01:33:53.960
I could probably get away with less than or greater than,

01:33:53.960 --> 01:33:58.080
but even then, it's going to be a little off from what I expect.

01:33:58.080 --> 01:34:00.160
Why else might this imprecision be worrisome?

01:34:03.520 --> 01:34:06.560
When might you not want your computer being imprecise?

01:34:06.560 --> 01:34:07.360
What domains?

01:34:07.360 --> 01:34:09.080
What worlds outside of a classroom?

01:34:09.080 --> 01:34:10.080
Yeah?

01:34:10.080 --> 01:34:12.240
What's that?

01:34:12.240 --> 01:34:14.160
Yeah, so rockets, right?

01:34:14.160 --> 01:34:17.960
Are there anything involving math and physics and danger?

01:34:17.960 --> 01:34:21.560
Like, you don't want numbers to be ever so slightly off.

01:34:21.560 --> 01:34:23.720
And if you think about it, rockets is a good example,

01:34:23.720 --> 01:34:27.040
because I don't know much about rockets, but I know they go pretty fast.

01:34:27.040 --> 01:34:28.940
And there's probably angles involved, because you're

01:34:28.940 --> 01:34:30.600
trying to keep them on a trajectory.

01:34:30.600 --> 01:34:31.440
And that's fine.

01:34:31.440 --> 01:34:33.440
But if your trajectory is ever so slightly off

01:34:33.440 --> 01:34:36.000
and something's going really fast and really far,

01:34:36.000 --> 01:34:40.840
I'm pretty sure that eventually, those small imprecisions start to add up.

01:34:40.840 --> 01:34:43.560
And indeed, there's been historical incidents

01:34:43.560 --> 01:34:45.960
where that kind of imprecision does, in fact,

01:34:45.960 --> 01:34:49.880
add up in the realm of militaristic operations or in financial operations.

01:34:49.880 --> 01:34:52.280
In fact, if you've ever seen Office Space or way back when,

01:34:52.280 --> 01:34:55.040
like Superman 3, this is how some people made some money,

01:34:55.040 --> 01:34:59.280
because they just kind of kept all of the fractions of pennies

01:34:59.280 --> 01:35:03.160
that computer systems were just ignoring, and eventually, they start to add up.

01:35:03.160 --> 01:35:06.920
So long story short, any time you have scientific or financial

01:35:06.920 --> 01:35:11.040
or any sort of large data sets that involve big numbers and lots of them

01:35:11.040 --> 01:35:13.360
and lots of time, this is a problem.

01:35:13.360 --> 01:35:17.000
And it almost suggests you shouldn't use C or let alone computers

01:35:17.000 --> 01:35:18.440
unless we actually address this.

01:35:18.440 --> 01:35:21.440
Now, as a spoiler, humans have chipped away at this problem.

01:35:21.440 --> 01:35:26.160
And you can use more and more bits, but not infinitely many bits.

01:35:26.160 --> 01:35:27.920
At some point, you have to draw a line.

01:35:27.920 --> 01:35:30.920
But this is why, for instance, the stock exchange might only represent

01:35:30.920 --> 01:35:33.840
two decimal points of precision for dollars or maybe four decimal points

01:35:33.840 --> 01:35:36.280
to the thousands place for dollars and cents.

01:35:36.280 --> 01:35:39.000
And they just have to decide, that's all the precision we can actually

01:35:39.000 --> 01:35:39.840
store precisely.

01:35:39.840 --> 01:35:43.600
But you've got to decide how to handle it and not just ignore the problem.

01:35:43.600 --> 01:35:44.960
But we can do a little better.

01:35:44.960 --> 01:35:45.720
You know what?

01:35:45.720 --> 01:35:48.480
It turns out that in most computers, a float,

01:35:48.480 --> 01:35:51.360
it takes up, yes, a finite amount of space, but very specifically,

01:35:51.360 --> 01:35:54.240
32 bits of space or four bytes.

01:35:54.240 --> 01:35:55.680
A byte, recall, is eight bits.

01:35:55.680 --> 01:35:57.480
So four bytes is 32 bits.

01:35:57.480 --> 01:35:59.800
And that's just a very common unit of measure.

01:35:59.800 --> 01:36:00.880
But there's another one.

01:36:00.880 --> 01:36:03.680
Turns out, if you want twice as many bits,

01:36:03.680 --> 01:36:07.240
you can literally use a data type called double.

01:36:07.240 --> 01:36:11.800
And in the CS50 library, there is a function called get double.

01:36:11.800 --> 01:36:18.080
And if I go ahead and do it here, I can now recompile this code, make floats,

01:36:18.080 --> 01:36:21.080
even though they're not technically float types anymore.

01:36:21.080 --> 01:36:24.440
And let me go ahead and do dot slash floats, enter.

01:36:24.440 --> 01:36:26.960
And let me type in 2 and 10.

01:36:26.960 --> 01:36:29.720
And now it's still imprecise.

01:36:29.720 --> 01:36:33.040
But notice, instead of seven zeros, which I think I had before,

01:36:33.040 --> 01:36:39.240
now I've got 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 zeros.

01:36:39.240 --> 01:36:42.320
So I've kind of pushed the problem further out, so to speak.

01:36:42.320 --> 01:36:44.440
So it's more precise, but it's not perfect.

01:36:44.440 --> 01:36:46.760
Can't get certain values perfect if you want

01:36:46.760 --> 01:36:50.000
to be able to represent an infinite range.

01:36:50.000 --> 01:36:53.760
Any questions, then, about this?

01:36:53.760 --> 01:36:55.440
We'll come back as to some implications.

01:36:55.440 --> 01:36:55.940
Yeah?

01:36:55.940 --> 01:36:56.480
Yeah, here.

01:36:56.480 --> 01:37:00.920
So would it be better to double the size?

01:37:00.920 --> 01:37:01.440
Good question.

01:37:01.440 --> 01:37:04.120
Would it always be better to use doubles because they're more precise?

01:37:04.120 --> 01:37:05.240
Short answer, yes.

01:37:05.240 --> 01:37:07.720
But we're going to see thematically in this course in computer science

01:37:07.720 --> 01:37:09.640
more generally, there's always a trade-off.

01:37:09.640 --> 01:37:13.920
And yes, if you use a double, you will avoid this problem a bit more.

01:37:13.920 --> 01:37:16.760
But what price will you pay, so to speak?

01:37:16.760 --> 01:37:19.600
Maybe processing power, because it's got to deal with more bits at once.

01:37:19.600 --> 01:37:22.920
And even more, literally, more space.

01:37:22.920 --> 01:37:24.840
I mean, sure, we can take your solution, but I'm

01:37:24.840 --> 01:37:26.400
going to charge you twice as many bits.

01:37:26.400 --> 01:37:29.520
And back in the day, decades ago, when C was first being invented

01:37:29.560 --> 01:37:33.400
and computers were really coming into play, spending twice as many bits,

01:37:33.400 --> 01:37:36.080
even if it's only 32 more tiny zeros and ones,

01:37:36.080 --> 01:37:38.360
that was actually expensive, literally, financially.

01:37:38.360 --> 01:37:39.120
And it adds up.

01:37:39.120 --> 01:37:41.840
And even today, if you want to spend more space, that's fine.

01:37:41.840 --> 01:37:44.280
But you're going to spend more space, therefore more money,

01:37:44.280 --> 01:37:46.520
and therefore have less space available for other things.

01:37:46.520 --> 01:37:47.560
So it's just a trade-off.

01:37:47.560 --> 01:37:51.760
And you have to decide as an intelligent human

01:37:51.760 --> 01:37:55.360
where the right inflection point is between what's more important.

01:37:55.360 --> 01:37:58.800
Let me open up a very different example now called parity.

01:37:58.800 --> 01:38:01.360
Just as an example, and let me ask this question,

01:38:01.360 --> 01:38:06.480
how do you know if a number is even or odd?

01:38:06.480 --> 01:38:08.880
What's the trick?

01:38:08.880 --> 01:38:13.200
If it's divided by 2, so 0, and 2, and 4, and 6 are even,

01:38:13.200 --> 01:38:15.920
because if you divide by 2, you don't get a remainder.

01:38:15.920 --> 01:38:18.360
So actually, if you just want to see a quick example of why

01:38:18.360 --> 01:38:20.880
you might use a remainder, even though it's out of context,

01:38:20.880 --> 01:38:22.200
here's an example for parity.

01:38:22.200 --> 01:38:26.000
Parity is just a term referring to even or odd in this context.

01:38:26.000 --> 01:38:27.120
How might we use this?

01:38:27.120 --> 01:38:30.320
Well, notice I can get an in from the user up at the top.

01:38:30.320 --> 01:38:32.240
I can then check the parity of the integer.

01:38:32.240 --> 01:38:34.160
Is it even or odd with syntax like this?

01:38:34.160 --> 01:38:36.640
Now I'm kind of combining some of these operators

01:38:36.640 --> 01:38:38.360
as you might be inclined intuitively.

01:38:38.360 --> 01:38:43.680
If n, the number the user typed in, mod 2, or divided by and then

01:38:43.680 --> 01:38:47.240
check the remainder of, but that's a mouthful, equals equals 0,

01:38:47.240 --> 01:38:51.600
you just said it's an even number, so print even, else print odd.

01:38:51.600 --> 01:38:53.280
Because what's the possible other remainder?

01:38:53.280 --> 01:38:55.800
If you do n or any value divided by 2, you

01:38:55.800 --> 01:38:59.040
might get a remainder of 0 or 1.

01:38:59.040 --> 01:39:02.120
I only have to check for one of those, 0, because the else

01:39:02.120 --> 01:39:03.640
implies the other thing.

01:39:03.640 --> 01:39:05.400
So again, very simple example.

01:39:05.400 --> 01:39:07.920
But honestly, all of us probably have an intuitive understanding

01:39:07.920 --> 01:39:09.080
of what's even and odd.

01:39:09.080 --> 01:39:11.440
A computer needs to be taught that, and so there's

01:39:11.440 --> 01:39:13.680
a program that does exactly that.

01:39:13.680 --> 01:39:17.000
Let me open up a larger program called Conditions.

01:39:17.000 --> 01:39:19.840
And rather than type this one out because it's a few lines of code,

01:39:19.840 --> 01:39:23.240
let me just open it up because it concludes exactly the code we

01:39:23.240 --> 01:39:27.840
saw a little bit ago on the slide when we compared it to a similar C block.

01:39:27.840 --> 01:39:30.480
In this program, in my main function, let

01:39:30.480 --> 01:39:32.560
me focus on the first few lines there.

01:39:32.560 --> 01:39:36.560
I have an int called x that I'm getting via get int.

01:39:36.560 --> 01:39:39.240
Another int called y that I'm getting via get int.

01:39:39.240 --> 01:39:41.680
And then I'm just doing some simple comparisons.

01:39:41.680 --> 01:39:43.840
We saw this again when we compared it to scratch.

01:39:43.840 --> 01:39:47.560
But this is quite simply that same code in context

01:39:47.560 --> 01:39:50.600
rather than just seeing it statically on a slide.

01:39:50.600 --> 01:39:52.040
So let me go ahead and compile this.

01:39:52.040 --> 01:39:53.640
Make conditions.

01:39:53.640 --> 01:39:54.140
Enter.

01:39:54.140 --> 01:39:55.240
Seems to compile.

01:39:55.240 --> 01:39:58.600
Let me zoom in and do dot slash conditions.

01:39:58.600 --> 01:39:59.440
Enter.

01:39:59.440 --> 01:40:01.400
x will be, say, 2 again.

01:40:01.400 --> 01:40:03.040
y will be 10.

01:40:03.040 --> 01:40:04.480
x is indeed less than y.

01:40:04.480 --> 01:40:08.080
If I run it again and I can save time by hitting up through my history

01:40:08.080 --> 01:40:11.600
and just hitting Enter, let's do 2 and 2.

01:40:11.600 --> 01:40:13.600
And indeed, x is equal to y and so forth.

01:40:13.600 --> 01:40:16.280
So again, just the exact same kind of code as before,

01:40:16.280 --> 01:40:18.560
but now in the context of a working program.

01:40:18.560 --> 01:40:22.160
What if I actually wanted to get user input kind of like our past student

01:40:22.160 --> 01:40:26.360
did with getting yes or no answers to the Apple and the cupcake question?

01:40:26.360 --> 01:40:30.760
Well, in answer.c, it turns out you can actually get textual input

01:40:30.760 --> 01:40:36.160
from the user, perhaps a simple yes or no, or just y or n, for succinctness.

01:40:36.160 --> 01:40:38.760
And in this case, if I just get back a single character,

01:40:38.760 --> 01:40:40.800
turns out there's a separate data type for character.

01:40:40.800 --> 01:40:43.880
If you don't want a whole string, like a whole word, or a paragraph,

01:40:43.880 --> 01:40:46.040
or sentence, or whatever, you just want one character,

01:40:46.040 --> 01:40:48.960
you can actually use what's called a char, or character.

01:40:48.960 --> 01:40:54.760
And so here, I'm using one other function, appropriately named, called get char.

01:40:54.760 --> 01:40:58.760
I'm storing it in a variable called c, because it's nice and succinct,

01:40:58.760 --> 01:41:00.200
of type char.

01:41:00.200 --> 01:41:02.280
And then notice this.

01:41:02.280 --> 01:41:05.160
You might not have seen this syntax before, especially

01:41:05.160 --> 01:41:07.680
if you've never programmed before, even in Scratch,

01:41:07.680 --> 01:41:10.800
but you might have seen this block similar to this in Scratch.

01:41:10.800 --> 01:41:14.920
What does the vertical double bar probably imply here?

01:41:14.920 --> 01:41:15.760
Or that's it.

01:41:15.760 --> 01:41:17.480
So in Scratch, it's nice and user-friendly.

01:41:17.480 --> 01:41:18.760
They literally just say, or.

01:41:18.760 --> 01:41:20.640
In programming, it's often the case that you

01:41:20.640 --> 01:41:23.080
use just more cryptic sequences of characters,

01:41:23.080 --> 01:41:26.880
and two vertical bars, which are typically above the Enter key on a US

01:41:26.880 --> 01:41:32.280
keyboard, if c equals equals capital Y or c equals equals lowercase y,

01:41:32.280 --> 01:41:36.160
let's assume that the user wanted to say yes, and go ahead and say yes.

01:41:36.160 --> 01:41:39.960
Else, if the user typed in n in capitals or n in lowercase,

01:41:39.960 --> 01:41:43.080
let's assume he or she meant no, and say no accordingly.

01:41:43.080 --> 01:41:45.840
And what are we going to do otherwise?

01:41:45.840 --> 01:41:46.800
Apparently, nothing.

01:41:46.800 --> 01:41:47.640
And that's fine.

01:41:47.640 --> 01:41:50.840
You don't need to have a default case if you want the program to do nothing.

01:41:50.840 --> 01:41:55.000
Might be a little confusing, because the user is going to type in some random word

01:41:55.000 --> 01:41:57.360
and get no output, but that's a design decision.

01:41:57.360 --> 01:42:00.520
Logically, this is just how we might express this.

01:42:00.520 --> 01:42:06.920
What about actually building our own blocks?

01:42:06.920 --> 01:42:11.640
Any questions, though, before we start to create?

01:42:12.000 --> 01:42:15.640
So recall that in Scratch, we had that cough example.

01:42:15.640 --> 01:42:20.960
Let me go ahead and create a file here real quickly called cough0.c,

01:42:20.960 --> 01:42:23.360
and just kind of recreate what we did last week,

01:42:23.360 --> 01:42:28.600
include standard.io.h int main void, again, just muscle memory now,

01:42:28.600 --> 01:42:33.680
and then printf quote unquote cough backslash n semicolon.

01:42:33.680 --> 01:42:34.200
And you know what?

01:42:34.200 --> 01:42:38.440
Let me go ahead and cough not once, but twice, three times.

01:42:38.440 --> 01:42:43.200
The moment you start copying and pasting, you're probably not writing good code, right?

01:42:43.200 --> 01:42:44.280
It's not very maintainable.

01:42:44.280 --> 01:42:46.800
Now if I want to change the word or translate it to another language,

01:42:46.800 --> 01:42:48.160
I have to change it in three places.

01:42:48.160 --> 01:42:50.600
We already decided last week that was bad.

01:42:50.600 --> 01:42:56.560
So what would be better in C or in Scratch or in general than this approach?

01:42:56.560 --> 01:42:57.840
Yeah, so like a for loop.

01:42:57.840 --> 01:42:58.480
So let me do that.

01:42:58.480 --> 01:43:00.000
Let me create another file.

01:43:00.000 --> 01:43:03.640
I'm going to call this one cough1.c is my second version.

01:43:03.640 --> 01:43:07.320
Let me go ahead now and just copy and paste the original code.

01:43:07.320 --> 01:43:08.320
And let's just improve it.

01:43:08.360 --> 01:43:10.120
Let's get rid of two of these.

01:43:10.120 --> 01:43:12.000
And let's see if we can't express the four.

01:43:12.000 --> 01:43:13.880
So it was four.

01:43:13.880 --> 01:43:15.240
Let me zoom in.

01:43:15.240 --> 01:43:17.400
int i gets 0.

01:43:17.400 --> 01:43:19.000
i is less than some number.

01:43:19.000 --> 01:43:19.920
Before it was 50.

01:43:19.920 --> 01:43:21.640
Now I'm going to have it be 3.

01:43:21.640 --> 01:43:25.040
i plus plus curly braces.

01:43:25.040 --> 01:43:29.840
And now let me move the cough block inside of there and indent it just to be pretty.

01:43:29.840 --> 01:43:34.360
And notice stylistically, I've been doing this sort of instinctively for some time.

01:43:34.360 --> 01:43:37.520
Everything's nicely indented just to make it more readable,

01:43:37.520 --> 01:43:40.480
quite like the Scratch blocks, even though, again, a lot of that white space

01:43:40.480 --> 01:43:42.440
doesn't matter to the computer.

01:43:42.440 --> 01:43:46.880
So if I go ahead and run this, let me pull up the terminal window so I can see it.

01:43:46.880 --> 01:43:53.680
Make cough1 enter, looks good, dot slash cough1, cough, cough, cough.

01:43:53.680 --> 01:43:55.000
OK, that's good.

01:43:55.000 --> 01:43:59.280
But recall that we actually improved this design further by abstracting it away.

01:43:59.280 --> 01:44:01.560
Let me go ahead and make my own function now.

01:44:01.560 --> 01:44:07.800
Let me go ahead and open up a new file, cough2, cough2.c,

01:44:07.800 --> 01:44:10.800
just like I had another Scratch program.

01:44:10.800 --> 01:44:16.000
Again, include standard io.h int main void.

01:44:16.000 --> 01:44:22.400
And then in here, let me go ahead and do what?

01:44:22.400 --> 01:44:30.720
Well, for int i gets 0, i less than 3, i plus plus plus curly braces.

01:44:30.720 --> 01:44:33.360
Then let me go ahead and just call cough.

01:44:33.360 --> 01:44:35.000
It would be nice if cough existed.

01:44:35.000 --> 01:44:36.600
But unfortunately, cough does not exist.

01:44:36.600 --> 01:44:39.560
It's not in the CS50 library even, so that's not going to help us.

01:44:39.560 --> 01:44:41.680
I have to make my own function.

01:44:41.680 --> 01:44:44.600
So in Scratch, you went to the blocks thing, and you make your own block,

01:44:44.600 --> 01:44:47.160
and the big prompt comes up, and you make your new puzzle piece.

01:44:47.160 --> 01:44:49.160
Here, we're going to have to be a little more deliberate.

01:44:49.160 --> 01:44:52.680
And it turns out you can do it like this.

01:44:52.680 --> 01:44:55.080
Some of these details will be non-obvious at first.

01:44:55.080 --> 01:44:57.760
But I'm going to go ahead and call the function cough.

01:44:57.760 --> 01:45:00.640
And cough, at the moment, does not need to take any input.

01:45:00.640 --> 01:45:03.720
So the keyword there is void, and we've actually seen that before.

01:45:03.720 --> 01:45:05.560
Main also has not been taking any inputs.

01:45:05.560 --> 01:45:08.600
That's why we had the word void, but more on that another time.

01:45:08.600 --> 01:45:10.640
And cough is not going to return anything either.

01:45:10.640 --> 01:45:12.920
It's going to print on the screen, just like Brian did.

01:45:12.920 --> 01:45:15.560
But Brian recall didn't hand me anything back physically,

01:45:15.560 --> 01:45:17.160
so there's no return value.

01:45:17.160 --> 01:45:20.400
So I'm going to say void to the left of cough.

01:45:20.400 --> 01:45:24.480
So for today's purposes, this just means that cough neither takes input

01:45:24.480 --> 01:45:26.560
nor returns a value as output.

01:45:26.560 --> 01:45:27.480
That's it.

01:45:27.480 --> 01:45:28.640
Void void.

01:45:28.640 --> 01:45:31.520
Now, as the body of that function, so to speak,

01:45:31.520 --> 01:45:36.320
I'm just going to go ahead and say, quite simply, cough backslash n semicolon.

01:45:36.320 --> 01:45:37.000
That's it.

01:45:37.000 --> 01:45:39.600
So now I have a puzzle piece, if you will, whose purpose in life

01:45:39.600 --> 01:45:43.720
is to cough, which means now I can magically just call it by its name

01:45:43.720 --> 01:45:46.560
up here as many times as I want.

01:45:46.560 --> 01:45:48.480
So let's go ahead and compile this.

01:45:48.480 --> 01:45:49.600
I'm really on a good roll.

01:45:49.600 --> 01:45:51.360
Everything's been working out great so far.

01:45:51.360 --> 01:45:52.720
Make cough to enter.

01:45:52.720 --> 01:45:56.040
Ugh, ugh, red errors.

01:45:56.040 --> 01:45:59.640
So this is interesting, and this kind of reminds me of the previous error.

01:45:59.640 --> 01:46:03.120
So first of all, what line is my error on?

01:46:03.120 --> 01:46:05.240
OK, 7 in character 9, if you care.

01:46:05.240 --> 01:46:07.280
But it's 7 on line 7.

01:46:07.280 --> 01:46:10.880
Implicit declaration of function cough is invalid in C99.

01:46:10.880 --> 01:46:15.320
C99 is referring to, literally, 1999 when this version of C was invented.

01:46:15.320 --> 01:46:21.000
And so implicit declaration of function cough, but it's right here.

01:46:21.000 --> 01:46:25.320
OK, wait a minute, let me, uh, instinct, let me just move this, right?

01:46:26.120 --> 01:46:27.440
Let me just put it up top.

01:46:27.440 --> 01:46:28.800
Let's see what happens.

01:46:28.800 --> 01:46:33.280
Make cough to, oh my god, that fixed it.

01:46:33.280 --> 01:46:35.040
Why?

01:46:35.040 --> 01:46:36.840
Like, even if you've never programmed before,

01:46:36.840 --> 01:46:39.680
just kind of reason through intuitively why this solves something.

01:46:44.680 --> 01:46:45.160
Exactly.

01:46:48.720 --> 01:46:49.720
Exactly.

01:46:49.720 --> 01:46:54.400
Because I previously was trying to use cough early on on line 7,

01:46:54.440 --> 01:46:58.320
but I was only teaching the computer what cough was farther down in the file.

01:46:58.320 --> 01:46:59.560
Frankly, C is kind of dumb.

01:46:59.560 --> 01:47:02.040
It literally reads your code top to bottom, left to right.

01:47:02.040 --> 01:47:05.200
And if you try to do something before you've taught the computer how to do that,

01:47:05.200 --> 01:47:07.840
you're going to get that kind of undeclared identifier,

01:47:07.840 --> 01:47:10.280
because it just doesn't know what the word is yet.

01:47:10.280 --> 01:47:11.720
Now in Scratch, this isn't a big deal.

01:47:11.720 --> 01:47:13.640
You just move the puzzle pieces anywhere you want.

01:47:13.640 --> 01:47:16.560
Order of blocks physically on the screen does not matter.

01:47:16.560 --> 01:47:17.800
But in C, it does.

01:47:17.800 --> 01:47:22.560
But frankly, this seems a little annoying that now the main program here

01:47:22.600 --> 01:47:24.840
kind of keeps getting pushed farther and farther down.

01:47:24.840 --> 01:47:27.520
The more kind of complexity I want to add to my program.

01:47:27.520 --> 01:47:29.160
So there's another solution.

01:47:29.160 --> 01:47:31.480
Let me actually go ahead and put this back where it is,

01:47:31.480 --> 01:47:33.600
because I'm a little sort of particular.

01:47:33.600 --> 01:47:36.080
I just like, by convention, main to be at the top.

01:47:36.080 --> 01:47:38.120
And frankly, that's kind of good style.

01:47:38.120 --> 01:47:40.840
If main is the most important function in your program by default,

01:47:40.840 --> 01:47:45.000
because it is the main function, and it's what gets called, per earlier,

01:47:45.000 --> 01:47:48.760
by default by the computer, why am I going to push it all the way down

01:47:48.760 --> 01:47:51.680
just to work around this stupid detail?

01:47:51.680 --> 01:47:56.280
Well, I just need to teach the computer what the function is.

01:47:56.280 --> 01:48:01.840
And I can do that a little redundantly by just saying this.

01:48:01.840 --> 01:48:05.320
This is what we're going to call the prototype for a function.

01:48:05.320 --> 01:48:10.000
If you literally just copy the very first line of it that has its name,

01:48:10.000 --> 01:48:14.640
its inputs, if any, and its output, if any, that's a prototype, semicolon.

01:48:14.640 --> 01:48:16.920
It's literally copy-paste from the function itself.

01:48:16.920 --> 01:48:21.840
But this is now enough of a hint to say, hey, computer, this shall exist.

01:48:21.840 --> 01:48:24.480
This is enough information for you to then call it,

01:48:24.480 --> 01:48:28.840
because the computer, so long as it has seen the function's name before,

01:48:28.840 --> 01:48:34.680
it's OK if the 0s and 1s, so to speak, that implement it come a little later.

01:48:34.680 --> 01:48:38.040
And so that's the more conventional way to solve that problem.

01:48:38.040 --> 01:48:44.960
So just intuitively then, take a guess if it's not too much of an indirect leap,

01:48:45.000 --> 01:48:47.680
what is in standard.io.h?

01:48:47.680 --> 01:48:49.520
What is in CS50.h?

01:48:53.480 --> 01:48:54.800
We'll call them declarations.

01:48:54.800 --> 01:48:59.640
So literally, in standard.io.h is a line of code

01:48:59.640 --> 01:49:03.160
that teaches the computer what printf's inputs are

01:49:03.160 --> 01:49:05.320
and what printf's output is, if any.

01:49:05.320 --> 01:49:07.680
In CS50.h, there's literally an line of code

01:49:07.680 --> 01:49:11.800
that tells the computer what getString's input is and what its output is.

01:49:11.800 --> 01:49:15.720
And the same for getInt and getFloat and getChar and others.

01:49:15.720 --> 01:49:17.720
That's all that's in those header files.

01:49:17.720 --> 01:49:20.480
The 0s and 1s, so to speak, are actually in files literally called

01:49:20.480 --> 01:49:25.600
standard.io.c and CS50.c, although that's technically source code.

01:49:25.600 --> 01:49:28.880
The 0s and 1s are in a compiled file elsewhere on the system.

01:49:28.880 --> 01:49:31.400
But all of these things we've kind of been taking for granted,

01:49:31.400 --> 01:49:33.120
now hopefully it makes a little more sense,

01:49:33.120 --> 01:49:35.720
because the fact that I'm doing the sharp include at the top,

01:49:35.720 --> 01:49:37.360
that's just a solution to a problem.

01:49:37.360 --> 01:49:41.400
In that file is enough information to teach the computer what printf

01:49:41.400 --> 01:49:45.000
or what getString and other things are so that I

01:49:45.000 --> 01:49:49.840
don't need to bother moving things around myself or copying and pasting

01:49:49.840 --> 01:49:53.200
whoever wrote printf his or her code into my program.

01:49:53.200 --> 01:49:55.680
Now let's do one final example with coughing.

01:49:55.680 --> 01:49:58.600
And go ahead and call this cough3.c.

01:49:58.600 --> 01:50:01.840
And go ahead and paste my same code as a moment ago just to get us started.

01:50:01.840 --> 01:50:05.120
And recall that the last step of our cough example last week

01:50:05.120 --> 01:50:06.920
was to actually give cough an input.

01:50:06.920 --> 01:50:11.520
I'd kind of like to whittle this code down to literally cough3,

01:50:11.520 --> 01:50:13.760
because this is a really nice abstraction.

01:50:13.760 --> 01:50:17.680
I don't want main to have to think about how many times to just cough three times.

01:50:17.680 --> 01:50:20.120
That's a nice, useful human abstraction.

01:50:20.120 --> 01:50:22.680
Now let's put the functionality down here.

01:50:22.680 --> 01:50:27.160
So if I want cough to be able to tolerate an input like three,

01:50:27.160 --> 01:50:30.040
which mentions avoid presumably needs to change?

01:50:30.040 --> 01:50:32.160
The one on the left or the right?

01:50:32.160 --> 01:50:34.120
The right, the one inside the parentheses.

01:50:34.120 --> 01:50:38.600
And it turns out, just like you can declare variables inside of a function,

01:50:38.600 --> 01:50:43.560
as we've done, so can you declare arguments to a function like this.

01:50:43.560 --> 01:50:46.520
So you can call it anything you want, though the data type matters.

01:50:46.520 --> 01:50:50.720
But this is now saying, hey, computer, cough does not return a value,

01:50:50.720 --> 01:50:53.160
like Aaron did return a piece of paper.

01:50:53.160 --> 01:50:56.160
Hey, computer, cough does take one input.

01:50:56.160 --> 01:50:58.400
It's an integer, and just call it n.

01:50:58.400 --> 01:51:01.960
And now that you've done this, now you can have a line of code in here like this.

01:51:01.960 --> 01:51:10.720
For int i gets 0, i is less than n, i plus plus plus plus plus.

01:51:10.720 --> 01:51:14.120
And then, OK, off by keystrokes here.

01:51:14.120 --> 01:51:17.080
Then I can move this inside here, indent it nicely.

01:51:17.080 --> 01:51:19.960
And now notice all of the complexity of coughing

01:51:19.960 --> 01:51:23.320
has been factored out into a function, my own puzzle piece, if you will,

01:51:23.320 --> 01:51:27.240
that even takes an argument so that now you can literally,

01:51:27.240 --> 01:51:29.280
if I move this far away and out of mind,

01:51:29.280 --> 01:51:32.040
now your program is getting pretty interesting,

01:51:32.040 --> 01:51:34.360
because it really just does what it says.

01:51:34.360 --> 01:51:37.840
And this is a nice functional abstraction, if you will,

01:51:37.840 --> 01:51:43.000
so that now I have a new verb, a new action, a new function called cough.

01:51:43.000 --> 01:51:44.920
Any questions on that one?

01:51:44.920 --> 01:51:47.400
Yeah?

01:51:47.400 --> 01:51:48.120
Sorry, say again?

01:51:48.120 --> 01:51:50.000
What integer with main return?

01:51:50.000 --> 01:51:51.240
What integer with main return?

01:51:51.240 --> 01:51:52.840
It turns out, and we'll come back to this,

01:51:52.840 --> 01:51:55.080
it's going to return 0 almost always by default.

01:51:55.080 --> 01:51:58.040
But that leaves you with almost an infinite number of non-zero values,

01:51:58.040 --> 01:52:00.640
which represent all of the many things that can go wrong.

01:52:00.640 --> 01:52:03.680
So more on that when we start creating more mistakes.

01:52:03.680 --> 01:52:05.080
Let's look at one other.

01:52:05.080 --> 01:52:10.440
Let me go ahead and open this file in advance myself called positive.c.

01:52:10.440 --> 01:52:14.200
Suppose that I'm not content to just have access to get int.

01:52:14.200 --> 01:52:16.400
I want a function called get positive int,

01:52:16.400 --> 01:52:19.400
because for whatever reason, my program, my game, my whatever,

01:52:19.400 --> 01:52:20.720
needs to know a positive value.

01:52:20.720 --> 01:52:23.040
Maybe I'm asking the user how many players are there.

01:52:23.040 --> 01:52:24.320
And that shouldn't be negative.

01:52:24.320 --> 01:52:26.960
It should be a positive integer, like one or two or more.

01:52:27.000 --> 01:52:31.840
So it turns out, I could write a program, if I want, that looks like this.

01:52:31.840 --> 01:52:37.600
Call on this line here a function called get positive int, pass it in a prompt,

01:52:37.600 --> 01:52:41.080
and then store the value still in an integer on the left hand side.

01:52:41.080 --> 01:52:43.600
And then just go ahead and print it out.

01:52:43.600 --> 01:52:48.000
Get positive int has this prototype at the top of the file.

01:52:48.000 --> 01:52:51.880
Notice this is not a function that comes with CS50's library, CS50.h.

01:52:51.880 --> 01:52:54.040
The function is called get positive int, as you would hope.

01:52:54.040 --> 01:52:55.160
It returns an int.

01:52:55.160 --> 01:52:59.880
And it takes a string as its prompt, whatever words you want the human to see.

01:52:59.880 --> 01:53:01.560
Let's scroll down now.

01:53:01.560 --> 01:53:03.800
And this one looks a little more involved.

01:53:03.800 --> 01:53:07.880
And this is not a feature that Scratch has, but let's take a look.

01:53:07.880 --> 01:53:10.800
The first line is identical to the prototype,

01:53:10.800 --> 01:53:12.640
because I literally copied and pasted it.

01:53:12.640 --> 01:53:16.320
Everything between these brackets is the function itself.

01:53:16.320 --> 01:53:18.880
And here, to answer someone's question from earlier on,

01:53:18.880 --> 01:53:22.400
do you have to declare a variable and then use it right away?

01:53:22.400 --> 01:53:23.040
No.

01:53:23.040 --> 01:53:26.600
And that's actually a helpful solution to a problem that we'll see in a moment.

01:53:26.600 --> 01:53:29.440
Notice here, this new keyword, didn't see it before,

01:53:29.440 --> 01:53:33.840
do the following while n is less than 1.

01:53:33.840 --> 01:53:36.160
Previously, we saw a while loop.

01:53:36.160 --> 01:53:37.600
And we saw a for loop.

01:53:37.600 --> 01:53:39.320
We did not see a do while loop.

01:53:39.320 --> 01:53:43.160
And a do while loop, well, it sounds obviously similar to a while loop,

01:53:43.160 --> 01:53:44.920
what seems a little different?

01:53:44.920 --> 01:53:49.640
When I had that forever block earlier translated to while true,

01:53:49.640 --> 01:53:52.440
what was the order of operations?

01:53:52.440 --> 01:53:56.000
Did we check the condition, the true, and then print hello world?

01:53:56.000 --> 01:54:00.520
Or did we just print hello world and then check the condition?

01:54:00.520 --> 01:54:03.080
Yeah, you might not recall precisely, but I did actually.

01:54:03.080 --> 01:54:04.920
I checked is true, true.

01:54:04.920 --> 01:54:06.560
And we all said yes, obviously.

01:54:06.560 --> 01:54:09.680
Printf is a true, printf is a true, printf.

01:54:09.680 --> 01:54:11.840
So check the condition first.

01:54:11.840 --> 01:54:14.880
You might infer then this loop is a little different.

01:54:14.880 --> 01:54:16.680
It has another word, do.

01:54:16.680 --> 01:54:21.720
This is literally going to do this first, and then check the condition,

01:54:21.720 --> 01:54:23.960
and only do it again if the condition is true.

01:54:23.960 --> 01:54:27.240
So it's a nice way of just flipping things around in terms of order

01:54:27.240 --> 01:54:31.960
to do something at least once, rather than potentially never at all,

01:54:31.960 --> 01:54:33.360
like was the case earlier.

01:54:33.360 --> 01:54:34.800
So what are we doing?

01:54:34.800 --> 01:54:37.800
Get an int, passing in this prompt, stored an n.

01:54:37.800 --> 01:54:41.080
And if the user types in a value that's less than 1,

01:54:41.080 --> 01:54:45.120
is this going to be true or false if n is less than 1?

01:54:45.120 --> 01:54:49.960
So if n is like if the human type's in 0, is 0 less than 1?

01:54:49.960 --> 01:54:50.600
True, yes.

01:54:50.600 --> 01:54:51.560
So what happens?

01:54:51.560 --> 01:54:54.240
You go back to the do, and you do it again.

01:54:54.240 --> 01:54:57.560
If the user types in negative 1, is negative 1 less than 1?

01:54:57.560 --> 01:54:58.680
Yes, or true.

01:54:58.680 --> 01:54:59.680
So you do it again.

01:54:59.680 --> 01:55:04.240
If he or she types in negative 2, again, what if he or she types in 50?

01:55:04.240 --> 01:55:06.440
Well, 50 is not less than 1.

01:55:06.440 --> 01:55:08.120
So this is false.

01:55:08.120 --> 01:55:11.440
And so then you proceed to the next line of code altogether.

01:55:11.440 --> 01:55:13.480
But what's interesting about the next line of code

01:55:13.480 --> 01:55:18.520
is that unlike the cough example, which had void as its return type,

01:55:18.520 --> 01:55:21.200
get positive int by default is supposed to return an int.

01:55:21.200 --> 01:55:24.920
Just like, again, Aaron handed me a piece of paper with a string on it.

01:55:24.920 --> 01:55:28.880
And so here, if I want my own custom function called get positive int

01:55:28.880 --> 01:55:30.880
to return a value, there's another word in C.

01:55:30.880 --> 01:55:35.320
You literally write return, and then the name of the variable, or the value,

01:55:35.320 --> 01:55:39.200
that you want to hand back on a metaphorical piece of paper,

01:55:39.200 --> 01:55:42.160
to whatever code is using this.

01:55:42.160 --> 01:55:44.120
So what's this oddity?

01:55:44.120 --> 01:55:47.560
Why can I not do this?

01:55:47.600 --> 01:55:52.480
If I were to mimic the code we wrote earlier, like this,

01:55:52.480 --> 01:55:56.200
why does this line of code not work just logically,

01:55:56.200 --> 01:56:00.720
using some of the sort of mental model that we've had thus far?

01:56:00.720 --> 01:56:02.720
Say again?

01:56:02.720 --> 01:56:03.720
Say again?

01:56:03.720 --> 01:56:05.440
Yeah.

01:56:05.440 --> 01:56:08.640
So declaring just means creating is the fancy way in programming of saying creating.

01:56:08.640 --> 01:56:10.840
So this says, hey, computer, give me an integer.

01:56:10.840 --> 01:56:13.880
Call it n and set it equal to the return value of get in.

01:56:13.880 --> 01:56:17.760
So whatever the function, or Aaron, hands me back, put it over here.

01:56:17.760 --> 01:56:21.560
But the problem is that in C, variables have scope.

01:56:21.560 --> 01:56:27.120
Scope is a fancy way of saying they only exist in between the curly braces

01:56:27.120 --> 01:56:29.000
between which they were declared.

01:56:29.000 --> 01:56:33.440
So that means that this line, this variable, n, literally only exists

01:56:33.440 --> 01:56:36.760
between here and here, and then it just kind of goes away.

01:56:36.760 --> 01:56:38.680
The computer doesn't know about it anymore.

01:56:38.680 --> 01:56:41.520
But that's a problem, because on what line number do we actually

01:56:41.520 --> 01:56:44.880
need to know n?

01:56:44.880 --> 01:56:48.080
Looks like 21, and that's outside the curly braces.

01:56:48.080 --> 01:56:50.560
So just based on that basic definition, scope

01:56:50.560 --> 01:56:53.200
is the two curly braces between which a variable is declared.

01:56:53.200 --> 01:56:54.520
It doesn't exist outside of them.

01:56:54.520 --> 01:56:56.600
This code just won't work, and I'll fix it later

01:56:56.600 --> 01:56:58.320
so that you see the correct error message.

01:56:58.320 --> 01:56:59.640
Why does this not work?

01:56:59.640 --> 01:57:02.480
Well, you're declaring n inside of those curly braces.

01:57:02.480 --> 01:57:03.760
So how do you avoid this?

01:57:03.760 --> 01:57:06.200
Well, it turns out, as someone deposited earlier,

01:57:06.200 --> 01:57:09.760
just declare it by itself without even giving it a value.

01:57:09.800 --> 01:57:13.360
And indeed, the syntax for that is just to do half of a thought.

01:57:13.360 --> 01:57:14.840
Int n semicolon.

01:57:14.840 --> 01:57:16.760
It has no value that we know yet.

01:57:16.760 --> 01:57:19.360
It has a garbage value, but more on that another time.

01:57:19.360 --> 01:57:20.360
But it does now exist.

01:57:20.360 --> 01:57:24.840
And now notice which curly braces does it exist within this one

01:57:24.840 --> 01:57:27.920
and this one, which means now it's accessible everywhere.

01:57:27.920 --> 01:57:30.520
And if you and your Scratch programs actually used variables,

01:57:30.520 --> 01:57:32.160
you might have noticed that you had to choose.

01:57:32.160 --> 01:57:36.040
You had to make a decision for this sprite or for all sprites.

01:57:36.040 --> 01:57:41.680
That was an illusion to what's called in programming a local or a global variable.

01:57:41.680 --> 01:57:44.280
These are still local, and we'll come back to this term earlier.

01:57:44.280 --> 01:57:46.320
But it has to do with scope, because if you

01:57:46.320 --> 01:57:48.920
had specified for this sprite only, MIT

01:57:48.920 --> 01:57:52.360
would have only let you use that variable for that specific sprite,

01:57:52.360 --> 01:57:55.760
that cat, or sheep, or whatever it was you were programming.

01:57:55.760 --> 01:58:00.920
Just as in C, this now means n can be used here and here, but not elsewhere,

01:58:00.920 --> 01:58:03.240
like higher up in my program.

01:58:03.240 --> 01:58:06.200
That's the matter of scope.

01:58:06.200 --> 01:58:09.800
So let's now see what can go wrong beyond that.

01:58:09.800 --> 01:58:14.240
Let me go ahead and open up this, because it turns out, when programming,

01:58:14.240 --> 01:58:17.840
there's other issues that can happen, not just floating point in precision,

01:58:17.840 --> 01:58:19.520
as I described it as earlier.

01:58:19.520 --> 01:58:22.920
It turns out that there's other problems that can go wrong,

01:58:22.920 --> 01:58:25.880
even with integers, that we kind of avoid it all together.

01:58:25.880 --> 01:58:28.160
So recall that we started talking about 1, 2, and 3,

01:58:28.160 --> 01:58:30.560
and why it's 123 last week.

01:58:30.560 --> 01:58:34.400
Well, what happens in decimal if you add 1 to 123?

01:58:34.400 --> 01:58:35.840
What number do you get?

01:58:35.840 --> 01:58:37.000
Obviously, 124.

01:58:37.000 --> 01:58:40.520
If we do it again, 125, 26, 27, 28, 29.

01:58:40.520 --> 01:58:45.160
What happens in decimal if I add 1 to a 9?

01:58:45.160 --> 01:58:48.520
Well, I should get 10, but that's not how we would write this.

01:58:48.520 --> 01:58:51.680
You put down the 0 instead, and you carry the 1.

01:58:51.680 --> 01:58:54.040
Remember those kind of mental heuristics?

01:58:54.040 --> 01:58:55.200
So that's all we did there.

01:58:55.200 --> 01:59:00.400
And then it's 2 plus 1, so that's why 129 plus 1

01:59:00.400 --> 01:59:03.840
is 130, because you put the 0, you carry the 1, and so forth.

01:59:03.840 --> 01:59:05.720
So we just all do that intuitively now.

01:59:05.720 --> 01:59:08.440
But this has implications for what computers do, too.

01:59:08.440 --> 01:59:12.160
Because suppose that we consider a bigger number, like 999.

01:59:12.160 --> 01:59:15.920
And so what do you get when you add 1 to 999?

01:59:15.920 --> 01:59:20.280
Well, you carry the 1, you carry the 1, and you get, hopefully, 1,000.

01:59:20.280 --> 01:59:25.000
But what if your computer only has space for three digits?

01:59:25.000 --> 01:59:28.120
Or what if your phone, or what if your alarm clock, or whatever the device is,

01:59:28.120 --> 01:59:31.680
literally only has room for three digits?

01:59:31.680 --> 01:59:37.840
What is 999 plus 1 if your hardware only has three digits?

01:59:37.840 --> 01:59:39.320
Well, it's apparently 0.

01:59:39.320 --> 01:59:44.720
So you get this kind of overflow, where 998, 999, 0.

01:59:44.720 --> 01:59:46.320
It overflows, so to speak.

01:59:46.320 --> 01:59:50.360
The 1 kind of falls off conceptually, and you roll over to the next value,

01:59:50.360 --> 01:59:52.560
which is 0, 0, 0.

01:59:52.560 --> 01:59:54.560
So what about in binary?

01:59:54.560 --> 01:59:58.160
What number is this in binary if you translate it to decimal in your head?

01:59:58.160 --> 02:00:02.720
And remember, it's the 1's column, the 2's column, and the 4's column.

02:00:02.720 --> 02:00:04.600
So this was 7 in binary, 1.

02:00:04.600 --> 02:00:06.440
So it's 4 plus 2 plus 1.

02:00:06.440 --> 02:00:08.000
So 7 in binary.

02:00:08.000 --> 02:00:10.080
So how do you do arithmetic with binary?

02:00:10.080 --> 02:00:11.200
It's actually the same thing.

02:00:11.200 --> 02:00:15.280
It's just you don't have 2's, or 3's, or 9's, or anything in between.

02:00:15.280 --> 02:00:16.480
You just have 1's and 0's.

02:00:16.480 --> 02:00:20.120
So what do you get when you add 1 to 111?

02:00:20.120 --> 02:00:21.360
Well, it's the same idea.

02:00:21.360 --> 02:00:23.320
You put down a 0, and you carry the 1.

02:00:23.360 --> 02:00:26.680
Because 1 plus 1, you want to say 2 in decimal, but there is no 2.

02:00:26.680 --> 02:00:29.040
So it rolls over to 0, but you carry the 1.

02:00:29.040 --> 02:00:31.840
1 plus 1 is 2, but OK, that's 0.

02:00:31.840 --> 02:00:32.760
Carry the 1.

02:00:32.760 --> 02:00:35.600
1 plus 1, that's 2, but I don't have a 2, so I go back to 0.

02:00:35.600 --> 02:00:36.320
Carry the 1.

02:00:36.320 --> 02:00:42.520
So in binary, if you only have 3 bytes, or bits rather,

02:00:42.520 --> 02:00:47.880
if you only have 3 bits, what do you get when you add 1 to 7 in binary?

02:00:47.880 --> 02:00:49.360
You apparently get 0.

02:00:49.360 --> 02:00:50.880
And now it's getting more real.

02:00:50.920 --> 02:00:53.240
In my computer, in my phone, in all of your hardware,

02:00:53.240 --> 02:00:55.680
it's just a finite amount of memory, RAM, that little chip

02:00:55.680 --> 02:00:58.120
that I showed on the screen with all the little circuits.

02:00:58.120 --> 02:01:01.400
And that has more than 3 bits of memory, certainly.

02:01:01.400 --> 02:01:02.520
But it is finite.

02:01:02.520 --> 02:01:06.040
And if we're only using, as a matter of convention, 32 bits to represent things,

02:01:06.040 --> 02:01:09.320
or 64 bits, maybe if we use doubles, or something else called along.

02:01:09.320 --> 02:01:14.520
Along is a 64-bit integer, whereas an integer is typically 32 bits.

02:01:14.520 --> 02:01:17.920
It seems that at some point, numbers might overflow,

02:01:17.920 --> 02:01:21.360
and we're going to actually have some, so to speak, imprecision.

02:01:21.360 --> 02:01:23.280
Ergo, integer overflow.

02:01:23.280 --> 02:01:26.560
So you can actually see this or defenses against this in the real world.

02:01:26.560 --> 02:01:29.120
So this is a screenshot from a game that is

02:01:29.120 --> 02:01:30.800
common on a few different platforms.

02:01:30.800 --> 02:01:34.680
And it's a game that allows you to accumulate coins or points, really,

02:01:34.680 --> 02:01:36.080
or little Lego pieces.

02:01:36.080 --> 02:01:37.800
And if you accumulate these points, you'll

02:01:37.800 --> 02:01:40.880
notice that eventually, if you have way too much free time,

02:01:40.880 --> 02:01:43.800
you can only score so high in this game.

02:01:43.800 --> 02:01:46.520
What's the highest score, apparently, according to the screenshot

02:01:46.560 --> 02:01:49.240
from whoever took this after playing for too many hours?

02:01:49.240 --> 02:01:51.320
Wasn't me.

02:01:51.320 --> 02:01:52.440
Four million.

02:01:52.440 --> 02:01:53.480
No, four billion.

02:01:53.480 --> 02:01:54.640
Four billion.

02:01:54.640 --> 02:01:56.000
Why is that?

02:01:56.000 --> 02:01:59.520
Well, it turns out that if numbers and computers, as I've proposed,

02:01:59.520 --> 02:02:03.080
are generally stored using 32 bits, that kind of invites the question,

02:02:03.080 --> 02:02:05.000
well, how high can you count with 32 bits?

02:02:05.000 --> 02:02:08.480
Well, 32 bits means you have 32 zeros and ones.

02:02:08.480 --> 02:02:11.640
The biggest they could be is like 1, 1, 1, 1, 1, 32 ones.

02:02:11.640 --> 02:02:15.360
And if you actually do the math using our little columns and so forth,

02:02:15.360 --> 02:02:18.680
it's roughly four billion, a little bigger than four billion.

02:02:18.680 --> 02:02:21.520
So the authors of this Lego game just decided, you know what,

02:02:21.520 --> 02:02:24.240
let's just say that the maximum number of points or coins

02:02:24.240 --> 02:02:26.880
you can accumulate in this Lego game is four billion even.

02:02:26.880 --> 02:02:27.160
Why?

02:02:27.160 --> 02:02:31.200
It just looks even cleaner than whatever the actual value is.

02:02:31.200 --> 02:02:32.080
But why?

02:02:32.080 --> 02:02:36.760
How many bits are they using to store your score in this game?

02:02:36.760 --> 02:02:40.240
Presumably, 32 bits or four bytes.

02:02:40.240 --> 02:02:41.200
And that's just convention.

02:02:41.200 --> 02:02:43.400
Whatever language they program this game is,

02:02:43.400 --> 02:02:45.560
it probably has a data type called an int.

02:02:45.560 --> 02:02:48.440
And that int, by convention, uses 32 bits.

02:02:48.440 --> 02:02:51.840
So at some point, they decide we can either use more memory,

02:02:51.840 --> 02:02:53.280
as you proposed earlier, for doubles.

02:02:53.280 --> 02:02:54.320
Let's use 64 bits.

02:02:54.320 --> 02:02:56.600
Then you can have crazy numbers of hours playing the game

02:02:56.600 --> 02:02:57.840
and getting more and more points.

02:02:57.840 --> 02:03:01.120
Or we can just say, that's enough points to accumulate in the game.

02:03:01.120 --> 02:03:02.920
Now, that's when you actually anticipate this.

02:03:02.920 --> 02:03:04.880
This doesn't always actually happen.

02:03:04.880 --> 02:03:08.800
If we go ahead and take a look at some example code,

02:03:08.800 --> 02:03:12.840
let me go ahead and open up overflow.c.

02:03:12.840 --> 02:03:17.720
In this program here, you'll see on line eight this slash slash syntax.

02:03:17.720 --> 02:03:20.880
And I've had a bunch of these so far, but I haven't actually mentioned them.

02:03:20.880 --> 02:03:23.120
Turns out in C, just like in Scratch, though odds are you

02:03:23.120 --> 02:03:25.040
didn't notice this little feature of Scratch,

02:03:25.040 --> 02:03:26.600
you can have what are called comments.

02:03:26.600 --> 02:03:29.880
A comment is just a note to yourself, to your TF, to your friend,

02:03:29.880 --> 02:03:32.600
to your colleague, whatever whom you're writing code with.

02:03:32.600 --> 02:03:36.240
And it's just a note to self, like to remind yourself of what the code does.

02:03:36.240 --> 02:03:39.480
Without this line, I could, once I'm comfortable enough programming,

02:03:39.480 --> 02:03:41.560
kind of figure out what these lines of code are doing.

02:03:41.560 --> 02:03:43.040
But frankly, that's a waste of time.

02:03:43.040 --> 02:03:44.000
I wrote the code once.

02:03:44.000 --> 02:03:46.640
And if I look at it weeks or months later or someone else wrote it,

02:03:46.640 --> 02:03:47.880
just tell me what it does.

02:03:47.880 --> 02:03:52.600
So a comment in a program is just like a nice summary of like a few lines

02:03:52.600 --> 02:03:56.200
of code, or it's a summary in English or whatever spoken language that

02:03:56.200 --> 02:03:59.960
kind of describes what otherwise a cryptic looking code might actually

02:03:59.960 --> 02:04:03.360
be doing, so you don't have to think too hard about it to understand a program.

02:04:03.360 --> 02:04:05.160
So iteratively, double I.

02:04:05.160 --> 02:04:08.640
Iteratively, it just means loopingly, again and again and again.

02:04:08.640 --> 02:04:09.440
This is funky.

02:04:09.480 --> 02:04:12.640
We didn't see this before, but you might guess what it does.

02:04:12.640 --> 02:04:15.560
What does star equals do?

02:04:15.560 --> 02:04:16.280
It does double.

02:04:16.280 --> 02:04:20.680
It's like plus equals adds 1, star equals doubles if the value on the right

02:04:20.680 --> 02:04:21.400
is 2.

02:04:21.400 --> 02:04:26.880
So this is going to start printing 1, then 2, then 4, then 8, and so forth.

02:04:26.880 --> 02:04:29.360
And notice this function, it's called sleep.

02:04:29.360 --> 02:04:31.440
It literally is going to sleep for a second.

02:04:31.440 --> 02:04:34.240
And that sleep function has a prototype that someone else

02:04:34.240 --> 02:04:37.520
wrote in a file called unistandard.h.

02:04:37.520 --> 02:04:39.800
I only know that by looking it up in the documentation,

02:04:39.800 --> 02:04:42.200
but that's a new file just for sleeping.

02:04:42.200 --> 02:04:45.520
Make overflow, which is kind of apt here.

02:04:45.520 --> 02:04:48.800
And let me go ahead and make the terminal window even bigger for this one.

02:04:48.800 --> 02:04:51.960
Dot slash overflow.

02:04:51.960 --> 02:04:54.720
OK, it's going.

02:04:54.720 --> 02:04:55.280
It's going.

02:04:55.280 --> 02:04:57.200
It's going to go faster and faster, so to speak,

02:04:57.200 --> 02:05:02.480
because we're adding more and more each time by doubling.

02:05:02.480 --> 02:05:07.560
All right, 2,000, 4,000, 8,000, 16,000.

02:05:07.560 --> 02:05:10.920
Still going, 64,000, 65,000.

02:05:10.920 --> 02:05:12.680
Now we're into the millions.

02:05:12.680 --> 02:05:16.120
Two millions, four, eight, 16 million.

02:05:16.120 --> 02:05:18.240
It's getting bigger and bigger.

02:05:18.240 --> 02:05:22.120
All of these big numbers.

02:05:22.120 --> 02:05:24.080
Ooh, interesting.

02:05:24.080 --> 02:05:26.720
What just happened?

02:05:26.720 --> 02:05:29.680
So it turns out if you double numbers big enough, you get zero eventually.

02:05:29.680 --> 02:05:31.880
Also, something you probably weren't taught.

02:05:31.880 --> 02:05:32.760
So what actually happened?

02:05:32.760 --> 02:05:34.560
Control C will cancel this.

02:05:34.560 --> 02:05:35.200
What happened?

02:05:35.200 --> 02:05:39.120
I mean, the program's trying to tell me, even though it's a little cryptic,

02:05:39.120 --> 02:05:40.440
signed integer overflow.

02:05:40.440 --> 02:05:43.040
Sign just means it went from positive to negative, essentially.

02:05:43.040 --> 02:05:45.800
So what happened?

02:05:45.800 --> 02:05:46.800
What's that?

02:05:46.800 --> 02:05:47.920
Yeah, I ran out of bits.

02:05:47.920 --> 02:05:50.000
I'm doubling the number again and again and again.

02:05:50.000 --> 02:05:54.360
And at some point, we carried the one, so to speak, and it was a 33rd one,

02:05:54.360 --> 02:05:56.720
therefore past the boundaries of a 32-bit value.

02:05:56.720 --> 02:05:58.680
And it just rolled over to apparently a negative,

02:05:58.680 --> 02:06:00.760
because at some point, and we haven't talked about it,

02:06:00.760 --> 02:06:04.400
we can use the leftmost bit, in some sense, to say positive or negative.

02:06:04.400 --> 02:06:06.160
We've just talked about positive so far.

02:06:06.160 --> 02:06:08.920
And then at that point, frankly, the computer just gave up, not really

02:06:08.920 --> 02:06:10.960
knowing what you intended beyond that.

02:06:10.960 --> 02:06:14.440
So if you don't write code to handle this situation

02:06:14.440 --> 02:06:18.720
and make sure that your numbers are less than 4 billion before you roll over,

02:06:18.720 --> 02:06:20.200
just bugs will happen.

02:06:20.200 --> 02:06:24.680
And this might seem contrived here, but this happened not too long ago.

02:06:24.680 --> 02:06:28.600
So 1999 was just before a lot of people thought the world was going to end,

02:06:28.600 --> 02:06:31.240
because of the so-called Y2K bug.

02:06:31.240 --> 02:06:36.040
And it really wasn't so much a bug, as it was lack of forethought or lack of features.

02:06:36.040 --> 02:06:38.240
What was the Y2K problem in a nutshell?

02:06:42.200 --> 02:06:43.400
Someone want to propose?

02:06:43.400 --> 02:06:44.840
Even in a non-technical sense, yeah?

02:06:44.840 --> 02:06:45.340
Yeah.

02:06:45.340 --> 02:06:48.480
You're just going to display in the number 2000 a year.

02:06:48.480 --> 02:06:49.320
Yeah.

02:06:49.320 --> 02:06:51.680
Yeah, so let me summarize here.

02:06:51.680 --> 02:06:55.160
So if they are only using two digits to display values,

02:06:55.160 --> 02:07:00.080
you could confuse the year 2000 with actually the year 1900.

02:07:00.080 --> 02:07:04.280
Because long story short, what humans did kind of reasonably decades ago was,

02:07:04.280 --> 02:07:06.000
you know, space was expensive.

02:07:06.000 --> 02:07:07.440
Computers were expensive.

02:07:07.440 --> 02:07:11.400
Memory was not sort of as abundant as it is now with all the cloud storage

02:07:11.400 --> 02:07:12.040
and the like.

02:07:12.040 --> 02:07:12.920
So you know what?

02:07:12.920 --> 02:07:19.000
If it was like 1970, do we really care about 1969, 1968, let alone 1900?

02:07:19.000 --> 02:07:19.680
Not really.

02:07:19.680 --> 02:07:25.080
Let's just assume we're all in the 1900s and never show or store 19.

02:07:25.080 --> 02:07:27.200
Let's just store two digits for every year.

02:07:27.200 --> 02:07:28.720
So 70 is 70.

02:07:28.720 --> 02:07:30.840
99 is 1999.

02:07:30.840 --> 02:07:34.320
But the problem is the humans ended up running code

02:07:34.320 --> 02:07:39.400
that they wrote years ago, decades ago, way longer than humans thought they might.

02:07:39.400 --> 02:07:39.760
Why?

02:07:39.760 --> 02:07:40.560
Well, it's expensive.

02:07:40.560 --> 02:07:42.080
It's time consuming to change code.

02:07:42.080 --> 02:07:42.840
The code's working.

02:07:42.840 --> 02:07:44.120
Why try to break it?

02:07:44.120 --> 02:07:48.680
Problem is too, as people aged and passed away, there's fewer and fewer people.

02:07:48.680 --> 02:07:51.600
They'd even knew the languages in which those programs were written.

02:07:51.600 --> 02:07:53.760
And so now who's going to even update the software?

02:07:53.760 --> 02:07:56.680
So lots of problems were feared.

02:07:56.680 --> 02:08:03.560
And this really just boils down to because 1999 might have overflowed to not zero per se,

02:08:03.560 --> 02:08:06.200
but an implicit 1900.

02:08:06.200 --> 02:08:08.680
And indeed, this definitely happened, though not nearly on the scale,

02:08:08.680 --> 02:08:09.680
as people thought.

02:08:09.680 --> 02:08:12.440
But it does happen in even more real terms just a few years ago.

02:08:12.440 --> 02:08:16.160
This is a Boeing 787, an actual airplane that

02:08:16.160 --> 02:08:21.560
had to be grounded for some amount of time because it had a programming error.

02:08:21.560 --> 02:08:24.760
And it summarized here in an online article.

02:08:24.760 --> 02:08:30.720
A 787 airplane that has been powered continuously for 248 days, it turns out,

02:08:30.720 --> 02:08:36.240
was the warning, can lose all of its electrical power due to the generator

02:08:36.240 --> 02:08:38.320
going into failsafe mode.

02:08:38.320 --> 02:08:38.960
Why is that?

02:08:38.960 --> 02:08:44.080
This condition is caused by a software counter-internal to the generator

02:08:44.080 --> 02:08:49.040
that will overflow after 248 days of continuous power.

02:08:49.040 --> 02:08:50.600
So translate that.

02:08:50.640 --> 02:08:54.560
That just means there's software running in the Boeing's actual 787s.

02:08:54.560 --> 02:08:56.440
They were using 32-bit integers.

02:08:56.440 --> 02:08:59.920
They were using those integers to store hundreds of seconds.

02:08:59.920 --> 02:09:05.200
And at some point, if you leave your plane on for 248 days,

02:09:05.200 --> 02:09:10.240
each of which has 24 hours, 60 minutes in an hour, 60 seconds in a minute,

02:09:10.240 --> 02:09:15.120
and 100 tenths of a second, or 100 one hundredths of a second,

02:09:15.120 --> 02:09:20.200
in every second, that product of multiplying things out gets big pretty fast.

02:09:20.200 --> 02:09:25.080
And on day 249, planes, theoretically, would shut down even

02:09:25.080 --> 02:09:27.520
in the middle of flight for very real reasons,

02:09:27.520 --> 02:09:31.240
because a really big number rolls over to zero and that confused the generator.

02:09:31.240 --> 02:09:36.720
These are actual smart airplane engineers making these kinds of mistakes

02:09:36.720 --> 02:09:40.120
because of software, not anticipating one line of code or some number of lines

02:09:40.120 --> 02:09:43.320
of code, or as you proposed, why didn't they just use more bits?

02:09:43.320 --> 02:09:45.360
And again, these are very real concerns.

02:09:45.360 --> 02:09:48.400
So this was, thankfully, addressed and solved, but not before.

02:09:48.400 --> 02:09:50.760
Of course, there was quite the scare there.

02:09:50.760 --> 02:09:55.040
So it turns out in an older game, this was the game of civilization,

02:09:55.040 --> 02:09:58.480
turns out that one of the characters, as whom you can play, Gandhi,

02:09:58.480 --> 02:10:02.560
is actually not as peaceful a character in the game as you might think.

02:10:02.560 --> 02:10:05.320
And let's, for context, just take a look here for a second.

02:10:05.320 --> 02:10:10.040
If we actually take a look at some more binary,

02:10:10.040 --> 02:10:13.680
this in binary is what number in decimal?

02:10:13.680 --> 02:10:14.480
OK, one.

02:10:14.480 --> 02:10:15.720
And this is 8 bits.

02:10:15.720 --> 02:10:16.840
So it's a full byte.

02:10:16.840 --> 02:10:17.640
8 bits is a byte.

02:10:17.640 --> 02:10:20.000
1, 2, 3, 4, 5, 6, 7, 8.

02:10:20.000 --> 02:10:26.760
So what do you get if you subtract 1 from this?

02:10:26.760 --> 02:10:28.440
You obviously get what?

02:10:28.440 --> 02:10:29.160
OK, all 0.

02:10:29.160 --> 02:10:30.920
So 1 minus 1 is just 0.

02:10:30.920 --> 02:10:35.280
What if you subtract 2 from this value?

02:10:35.280 --> 02:10:37.360
What happens?

02:10:37.360 --> 02:10:40.440
This is actually called integer underflow, which is just the opposite.

02:10:40.440 --> 02:10:42.600
But there's really not too many options to think about this.

02:10:42.600 --> 02:10:44.440
If you only have 0s and 1s, you can probably

02:10:44.440 --> 02:10:45.920
imagine what the bad scenario is.

02:10:45.960 --> 02:10:50.640
If 0, 0, 0, 0, 0, 0, 0, 1, if you subtract 1 goes to 0s,

02:10:50.640 --> 02:10:54.360
and then you do it again, you now underflow, which just brings you

02:10:54.360 --> 02:10:55.680
around to the opposite.

02:10:55.680 --> 02:10:58.160
1, 1, 1, 1, 1, 1, 1.

02:10:58.160 --> 02:11:01.840
So if you have 8 1s, what value is that?

02:11:01.840 --> 02:11:06.720
If you do the math 1s, 2s, 4s, 8, 16s, it turns out it's 255

02:11:06.720 --> 02:11:08.360
if you actually do out all the math.

02:11:08.360 --> 02:11:10.960
So it turns out that this game's civilization

02:11:10.960 --> 02:11:15.200
was using a single byte to represent every character's level of aggressiveness

02:11:15.200 --> 02:11:15.880
in the game.

02:11:15.880 --> 02:11:19.360
And Gandhi's was, as you would expect, by default initialized to 1,

02:11:19.360 --> 02:11:21.320
like very non-aggressive.

02:11:21.320 --> 02:11:24.440
Unfortunately, in this game of civilization,

02:11:24.440 --> 02:11:28.600
when a player adopts democracy in his or her civilization,

02:11:28.600 --> 02:11:32.920
their aggression would be automatically reduced by 2.

02:11:32.920 --> 02:11:37.280
And so if Gandhi went democratic, his aggression wouldn't go to negative 1.

02:11:37.280 --> 02:11:40.840
It looped back around to the ludicrously high figure of 255,

02:11:40.840 --> 02:11:45.080
making him as aggressive as a civilization could possibly be.

02:11:45.120 --> 02:11:49.000
So less impactful, to be sure, than something like the airplane example.

02:11:49.000 --> 02:11:51.000
But these problems are omnipresent.

02:11:51.000 --> 02:11:53.240
And if you start to keep an eye out in the popular media,

02:11:53.240 --> 02:11:55.320
or when there are bugs, or hacks, or exploits,

02:11:55.320 --> 02:12:01.680
it's so often because a programmer has made a mistake in his or her code.

02:12:01.680 --> 02:12:03.000
They didn't anticipate a scenario.

02:12:03.000 --> 02:12:06.120
Or they made maybe reasonable decisions years ago,

02:12:06.120 --> 02:12:09.280
but that eventually proved to be naive, and that we're still running the same code.

02:12:09.280 --> 02:12:10.760
Numbers are getting too big.

02:12:10.760 --> 02:12:11.840
Their math is wrong.

02:12:11.840 --> 02:12:13.280
And so very real things happen.

02:12:13.280 --> 02:12:17.240
But what's most important for us is just understanding how and why those things

02:12:17.240 --> 02:12:17.880
happen.

02:12:17.880 --> 02:12:19.720
And so what will we do in the days ahead?

02:12:19.720 --> 02:12:21.480
So the next homework assignment, as with Scratch,

02:12:21.480 --> 02:12:22.520
will be to program something.

02:12:22.520 --> 02:12:25.880
But this time in C, you'll use an environment called CS50 Lab, which

02:12:25.880 --> 02:12:28.920
essentially is CS50 Sandbox, with which we've been tinkering today.

02:12:28.920 --> 02:12:32.160
But it adds to it the instructions and the specification of the problems

02:12:32.160 --> 02:12:33.080
that you'll want to solve.

02:12:33.080 --> 02:12:35.520
And it will hold your hands initially through some of these steps.

02:12:35.520 --> 02:12:38.640
You don't need to have written everything down and memorized everything I typed today,

02:12:38.640 --> 02:12:41.600
but do feel free in the meantime to go to the course's website and play

02:12:41.600 --> 02:12:42.920
with any of those examples.

02:12:42.960 --> 02:12:46.960
Among the challenges ahead will be to recreate some snippets of games

02:12:46.960 --> 02:12:49.800
from yesteryear, thinking about how things you might have seen growing up

02:12:49.800 --> 02:12:51.560
can be translated to actual code.

02:12:51.560 --> 02:12:54.880
And undoubtedly, among the first things you'll experience is frustration.

02:12:54.880 --> 02:12:57.760
You'll forget the stupid semicolon, or where does the parenthesis go,

02:12:57.760 --> 02:12:59.120
and you'll have to look back at code.

02:12:59.120 --> 02:13:01.080
But keep in mind, none of that stuff matters.

02:13:01.080 --> 02:13:02.880
It's absolutely frustrating initially.

02:13:02.880 --> 02:13:06.400
But what's most important is the idea is, and honestly, the sense of gratification

02:13:06.400 --> 02:13:08.760
that you, like all of CS50 staff before you,

02:13:08.760 --> 02:13:12.000
ultimately feel when actually building and creating something of your own.

02:13:12.000 --> 02:13:14.040
So let's call it a day there, and we'll see you next time.

