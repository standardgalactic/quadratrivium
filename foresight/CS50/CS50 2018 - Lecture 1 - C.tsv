start	end	text
0	23820	Music
23820	53740	All right, this is CS50.
53740	55300	And this is week one.
55300	60020	And by the end of today, you will know how to create programs that
60020	61340	look like this.
61340	62540	So this, of course, is binary.
62540	65300	This is the only language that machines ultimately understand.
65300	68540	But thankfully, per last week, there's so many abstractions
68540	70500	and there's so many humans that have come before us
70500	72700	that we don't actually have to write anything at this level.
72700	75540	We can abstract way above it, like we did with Scratch already,
75540	79340	and like we will starting today with C. But does anyone nonetheless
79340	84700	want to take a guess at what that program, when fed to your Mac or PC,
84700	87060	actually does?
87060	90180	Anyone recognize?
90180	92060	Anyone want to hazard a guess?
92060	94820	It's perhaps the simplest program you could write.
94820	99100	It indeed does, when fed to the brain of your computer,
99100	102100	this is all called CPU, simply print that.
102100	104020	So how do we actually get to that point?
104020	106340	Well, recall where we started this conversation last time,
106340	109140	talking about computer science more generally, and problem solving.
109140	112260	We propose can be distilled really is this, like you've got some inputs,
112260	114140	you want some outputs, and somewhere in the middle
114140	116500	you need to do something with those inputs.
116500	120660	And to get to that point, though, we had to represent those inputs and outputs.
120660	123020	We just had to decide as sort of humans, how
123020	125380	are we going to represent all the inputs to our problem
125380	127980	when it comes time to have a computer actually process them?
127980	131660	And at the end of the day, all of the phones and the computers that we're all using,
131660	133660	only end at the end of the day plug into the wall
133660	135900	to get their physical resource, electricity,
135900	138180	and they might store that temporarily in a battery.
138220	139700	But that really is our only input.
139700	142140	It's either plugged in or it's not.
142140	144820	It's either a one or a zero, true or false.
144820	148100	So the world really reduces to those two states, so to speak.
148100	150020	And so you can think of those states, then.
150020	151780	It's just being like a light bulb, on or off.
151780	155020	Or I pulled up my cell phone last time to turn the flashlight on or off,
155020	157300	one or zero, true or false.
157300	159580	Now, of course, if you only have one light bulb,
159580	161940	you can only count from zero to one.
161940	164820	But if you start to have a bunch of them back to back to back to back,
164820	167300	you can permute them like I did my fingers.
167300	171020	Zero, one, two, three, and so forth.
171020	174140	And so we started talking about binary more generally.
174140	179220	And so here, for instance, were three sequences of zeros and ones.
179220	181420	And each of those represented something.
181420	183900	But we don't need to think about the world at that level.
183900	185180	We can abstract on top of that.
185180	187780	All of us are so much more familiar with decimal, of course.
187780	191220	And indeed, recall that this was just 72, 73, and 33,
191220	194220	which, if anyone recalls, when you use ASCII, which
194220	196620	is this global standard for mapping numbers to letters,
196620	198380	we got what message?
198380	202020	Yeah, it was just high, capital H, capital I, exclamation point.
202020	206380	And so that's an abstraction on top of those otherwise binary numbers.
206380	209540	But we don't have to model just text using numbers.
209540	212540	At the end of the day, our only resource is still that electricity.
212540	215300	And the only way we think about it digitally is still zeros and ones.
215300	219140	But if we take these same values, 72, 73, 33,
219140	222900	and treat them in the context of like Photoshop or like a photo program
222900	225020	or a graphics program, we can instead interpret them
225020	228100	as like some amount of red, some amount of green, some amount of blue,
228100	230780	which gave us, last time, recall this yellowish color.
230780	234380	So now we had another abstraction on top of binary colors.
234380	235780	And this is just one pixel.
235780	237780	What can you do once you have more than one pixel?
237780	240660	What can you represent next?
240660	241980	Yeah, right, images, right?
241980	244260	So we're sort of continuing the conversation up and up and up.
244260	246940	And we could represent something like a graphical emoji on the screen,
246940	248620	which has more than just one yellow dot.
248620	251500	It's got a whole bunch of yellow dots and other colors as well.
251500	253940	And recall that if we want to animate things,
253940	256420	whether it's through silly things like an emojis on a phone
256420	259060	or just more proper videos and movies, well, those
259060	264140	are just sequences of images flying past your human eyes really quite quickly.
264140	267220	So that's where we kind of left off last time, starting at the base level
267220	270340	and abstracting away so that we could sort of stipulate thereafter.
270340	275340	We can represent inputs and we can represent outputs, whatever those happen to be.
275340	277340	And here on out, we don't need to think at that level.
277340	279660	We can just assume we all know how to do this.
279660	282580	And even if it eventually becomes kind of a distant memory,
282580	284580	we know that someone can indeed do this.
284580	286780	And that's the value of abstraction.
286780	290260	But inside of this black box, we're so-called algorithms, the sort of secret
290260	293260	sauce, this is where the problems are actually solved.
293260	297060	And we not only talked about what these algorithms are,
297060	299220	but for instance, how efficient they were.
299220	302700	So recall that this red line represented a very simple algorithm
302700	305420	of just turning the phone book page by page one at a time.
305420	307940	And the reason that it's a straight line is because there's like a one
307940	311060	to one correspondence between how many pages there are in the book
311060	312420	and how many page turns there are.
312900	315140	One more page, one more turn, and so forth.
315140	320180	If I fly through it at twice the speed, two, four, six, eight, I can do better.
320180	324060	And so that yellow line now, recall, was lower on the graph.
324060	326460	If you just kind of look at any two points, yellow and red,
326460	329020	yellow is below red, saying it takes less time.
329020	330860	But it was not quite correct.
330860	335100	There was one bug when I was looking for Mike two pages at a time.
335100	337260	What was that issue?
337260	338140	Yeah, I might miss him.
338140	340580	He might accidentally get sandwiched in between two pages.
340580	343620	It's not a huge deal because I could fix it, but I have to fix it.
343620	347300	I have to apply that additional logic and double back at least a page if I go too fast.
347300	350100	But of course, the sort of final algorithm, and frankly,
350100	353660	all of our initial intuition probably, was the dividing and conquer.
353660	356980	Open it roughly to the middle, look down, and then go left and go right.
356980	359940	And just repeat that process as the problem gets this big, to this big,
359940	362300	to this big, to this big, to just one page left.
362300	365100	So that was all about efficiency.
365100	368540	But to get to that point, we needed to express ourselves more precisely.
368540	369900	And so we introduced pseudocode.
369900	371420	There's no formal definition.
371420	372740	It can be English, English-like.
372740	375220	It's just meant to be succinct and get the point across.
375220	378540	And recall that along the way, we introduced a whole bunch of concepts,
378540	380780	many of which you probably experimented with with Scratch,
380780	386420	like loops and conditions, Boolean expressions, variables, and so forth.
386420	391060	And those were building blocks that kind of came out of this kind of demonstration here.
391060	394260	But honestly, even in this demonstration, in this pseudocode,
394260	396260	there were a whole bunch of assumptions.
396260	398060	If you read these instructions one at a time
398060	399700	and you're holding the phone book yourself,
399700	402980	odds are you can execute the pseudocode, this algorithm.
402980	408660	But what does it really mean to, say, open to the middle of the phone book?
408660	411380	All of us have an intuitive understanding of what that means.
411380	414140	But honestly, if you were sort of explaining that to a kid or someone
414140	416660	who's learning English or whatever language for the first time,
416660	418820	open to the middle of the phone book, you should probably
418820	420300	set forth some assumptions.
420300	424060	OK, this thing in front of you has 1,000 pages, pieces of paper,
424060	425940	turned to the 500th page.
425940	427740	And let's call that the middle.
427740	430420	This would very quickly get tedious if all of us humans
430420	432100	are talking at that level of detail.
432100	434740	And so we abstract away with more sweeping statements,
434740	436420	like open to the middle of the phone book.
436420	438100	But that's an abstraction.
438100	441380	And it's not quite as precise as is probably ideal, especially feeding
441380	444740	this algorithm to a newbie or to a robot or a computer.
444740	447980	But it's useful because we can then make a 12-step program instead
447980	450700	of a 20-step program by elaborating too much.
450700	453620	And for instance, throughout here, too, we had our loops and conditions
453620	455580	and so forth, but even call mic.
455580	456740	Like, what does that mean?
456740	459380	Well, if you imagine that the human knows how to use the phone,
459380	460580	then it goes without saying.
460580	463420	But if he or she also needs to be programmed to use the phone,
463420	465700	you've got to explain, pick it up, hit this button,
465700	467740	type this sequence of buttons, and so forth.
467740	470780	So call mic is also an abstraction.
470780	475620	So these abstractions are useful, but they can sometimes get in the way,
475620	481700	especially if you're not precise enough to program the computer correctly.
481700	484100	And to sort of paint this picture, thought
484100	487100	we'd begin a little lightheartedly here.
487100	490860	Brought some breakfast if you didn't quite make it next door or beyond.
490860	492300	Just need a couple of volunteers.
492300	495140	If you're comfy appearing on stage and on the internet here.
495140	497020	Let me kind of, there's a lot of lights here.
497020	500820	How about over there on the left and over here in the front?
500820	501500	Yeah, right there.
501500	502500	I think your hand was up.
502500	504500	Come on down.
504500	507340	And Brian, do you mind lending us a hand here, too?
507340	509460	Come on down.
509460	509960	Thank you.
509960	512900	If you want to take control here, let me go ahead and switch over
512900	516260	to another program for you.
516260	516980	OK, what's your name?
516980	517380	Gene.
517380	517980	Gene, David.
517980	518420	Nice to meet you.
518420	520260	Have a seat on the far left in your name.
520260	520900	Hi, I'm Abby.
520900	522140	Abby, nice to meet you as well.
522140	523420	On the far right, if you could.
523420	526900	So Gene and Abby, do you want to say a little something about yourselves
526900	528620	quickly?
528620	529340	I'm Gene.
529340	531420	I'm a Massachusetts native.
531420	533340	And I'm taking CS for the first time.
533340	534820	It's my first time coding or anything.
534820	536940	So I'm doing this, and I'm enjoying it.
536940	537300	Nice.
537300	538580	Glad to have you with us.
538580	540060	Abby?
540060	540820	Hi, I'm Abby.
540820	542300	I'm taking this as a sophomore.
542300	544940	And I know nothing about computers and computer science.
544940	546980	So I'm probably taking it sat on sat.
546980	548620	OK, well, nice to have you as well.
548620	551500	All right, so in front of us is a whole bunch of ingredients.
551500	553460	And hopefully, we can start the semester off gently.
553460	556260	And if we're successful, we'll actually have a quick bite here.
556260	557980	But we thought we'd defer to the audience here.
557980	559540	And Brian's going to scribe as we go.
559540	561500	And all we want to do this morning is just
561500	563980	make a peanut butter and jelly sandwich.
563980	567580	One instruction at a time, and each of us will just execute what we hear.
567580	568620	How's that sound?
568620	570980	All right, if someone could volunteer with the first instruction.
570980	571980	And Brian, I'll type it down.
576860	577900	Open bread, we heard.
577900	579300	Open bread is the first instruction.
579300	581100	So if you'd like to execute, open bread.
587380	589940	Don't look at me.
589940	591260	OK.
591260	593380	All right, so we're kind of on our way.
594380	599420	OK, I think Abby did it better, certainly.
599420	601500	But we did it correctly, arguably.
601500	605580	So let's move on to step two and see if we can't improve.
605580	606620	Take out bread.
611540	615180	OK, welcome to the team now.
615180	617740	Nice, all right, step three.
617740	618740	Yeah.
618740	620580	Place two pieces of bread on the table.
620620	622860	Place two pieces of bread on the table.
626860	628700	Never mind the plates.
628700	630060	OK, step four.
634820	637180	Twist cover of jelly till it opens.
637180	637660	Thank you.
642540	643260	Step five.
646060	649180	Step five, yeah.
649180	651780	Thank you, place the lid to the side.
651780	653180	I took some liberties myself.
653180	654980	Step six, take the knife.
661740	663460	Peel off the cover of the jelly.
666740	667660	No covers on ours.
672140	677420	Stick knife into the bottle.
677420	679100	From the top.
679100	679600	Stick.
682700	684660	OK, step nine.
688380	692420	Rotate hands, so jelly ends up on.
692420	692920	OK.
696260	699260	OK, step quickly, 10.
702660	705180	Yeah, step 10.
705180	706180	Pull out the knife.
706180	707940	Pull out knife, OK.
709820	716260	Step 11, jelly side down on bread.
722380	724860	All right, step 12.
729660	731020	Step 12, anyone?
731020	732700	Yes.
732700	735180	Thank you.
735180	736500	Step 13.
737500	740500	Pour jelly on bread.
744500	745740	Oh, pour jelly on bread.
745740	748220	Pour jelly, jelly.
748220	748900	All of it?
748900	750340	OK, now you're just messing with us.
755740	757220	Step 14.
760620	762820	Put jelly down, thank you.
762820	765300	15.
765340	768460	Pick up peanut butter.
768460	769700	Take lid off, thank you.
773100	775380	Peel off lid, thank you.
777900	781340	Step 18, pick up knife.
784820	788060	By blunt end.
788060	789780	Scoop, it's OK.
790380	791380	Scoop.
791380	796900	Step 20, put peanut butter on bread.
800900	802540	21.
804540	808060	Move the knife left to right, please.
808060	809500	Left to right.
814500	818180	Step 22, put peanut butter on bread.
818620	824500	Step 22, thank you.
824500	829980	23, 24, what was that?
834460	837300	Eat sandwich, OK, I think we're OK.
837300	839100	Well, how about why don't we each take a bite
839100	841500	and a round of applause if we could for our volunteers.
841500	847500	Thank you.
851500	854980	You can take some for the row if you'd like.
854980	858260	Thank you, so thank you, Brian.
858260	859540	OK, now I need a minute.
859540	862940	So thank you.
862940	868900	So suffice it to say, this obviously demonstrated even more so
868900	872260	than the phone book example where our certain assumptions are
872260	873940	and our abstractions are.
873940	875940	And honestly, almost all the time, those are useful.
875940	877420	And of course, we kind of ham things up.
877420	880100	And I think the instructions, we're kind of helping with that here.
880100	884060	But when it comes time to program with Scratch and certainly with C starting
884060	887340	this week, you can't really make as many of those assumptions anymore.
887340	889700	Because if you don't handle these sort of corner cases,
889700	892300	and if you don't think about what that instruction means,
892300	894820	you're going to get the proverbial spinning beach ball or the hour
894820	896540	glass that you're familiar with on your Mac or PC.
896540	897940	The program is going to crash.
897940	902180	Something's going to go wrong just because you missed some specificity
902180	903460	or precision.
903460	909460	Now, over, so over time, we're going to find that much like in Scratch,
909460	911460	we were able to make our own building blocks.
911460	914900	You might recall the short examples we did with the cough example, where
914900	917300	I had cough 0 and then cough 1 and cough 2,
917300	920260	where I was making my own puzzle piece within Scratch.
920260	923420	That was useful because after that example, theoretically, I never again
923420	926940	need to think about or worry about how to implement cough.
926940	928460	I can just use that abstraction.
928460	930860	But someone has to implement them, and sometimes it's
930860	934180	going to be other people who come before us, and sometimes it's going to be us.
934180	937020	So this isn't to say that programming ends up being so tedious
937020	939060	that you have to point out every little thing,
939060	943420	but you or someone does have to do that level of precision at least once.
943420	947500	And nicely enough, in Scratch, MIT did most of that legwork for you.
947500	949180	We all had the building blocks with which
949180	951740	to make our own animation or game or artwork or the like.
951740	954900	But even then, you probably had to connect several dozen puzzle pieces
954900	959980	or even more to get those fundamentals to do what it is that you wanted it to do.
959980	962420	So today, we're going to start to transition from Scratch,
962420	965700	this graphical programming language that, while targeted at younger students,
965700	968940	is typically representative of a lot of the same concepts that are now
968940	970980	going to be laced throughout the semester.
970980	974540	But we're going to introduce today an older, more traditional language that's
974540	975460	just text-based.
975460	977380	And as such, it's a lot more powerful.
977380	980340	But at first glance, it's actually going to look a lot more cryptic.
980340	983740	In fact, instead of writing 0s and 1s starting today,
983740	986140	we're instead going to write something like this.
986140	989020	Now, if you've never programmed before, odds are at first glance,
989020	990940	this does look pretty cryptic.
990940	994300	And there's a lot of symbols within it, punctuation from the keyboard.
994300	996980	There's probably some familiar English-like words.
996980	1000620	And frankly, even after doing Scratch, anyone even with no prior background
1000620	1003820	can probably hazard a guess as to what this program written
1003820	1007580	in this other language called C does when you run it.
1007580	1009180	It just prints hello world.
1009180	1012540	Now, granted, there's a decent amount of overhead syntactically.
1012540	1015220	There's a bunch of stuff you have to type to make this program do
1015220	1016380	what you want it to do.
1016380	1018980	But at the end of the day, that's all it's going to do.
1018980	1021060	And this is among the simplest of programs.
1021060	1024780	We're going to add to our puzzle pieces, so to speak, today in C,
1024780	1027900	some of those same concepts that we saw last time as well.
1027900	1029740	So let's do this first, though.
1029740	1033420	Let me take a moment to sort of compare Scratch to C,
1033420	1035380	because the most important takeaway for today
1035380	1038300	is going to be that even if the syntax doesn't look so obvious,
1038300	1042020	and frankly, even if your first minutes or hours with writing your own code
1042020	1045300	in C is frustrating because, damn it, you left off a semicolon,
1045300	1047420	or, oh, I had a parenthesis in the wrong place.
1047420	1050740	There's a lot of these stupid syntactic hangups that make you feel quite often
1050740	1053540	that you really aren't getting it, but that's not the important stuff.
1053540	1056260	A lot of the syntax is the least important.
1056260	1058700	It's not at all fundamentally intellectually interesting.
1058700	1061620	So try to see past that, and try to take comfort in the fact
1061620	1064340	that it's the principles that are going to be important.
1064340	1066420	And honestly, just through muscle memory and practice,
1066420	1069060	all of the other stuff that at first is going
1069060	1071700	to be an occasional frustration, it just starts to go away
1071700	1075780	as you start to see this for what it is and not for the syntax alone
1075780	1077660	that you see on first glance.
1077660	1083020	So this is to say, this program on the right in C is equivalent to what
1083020	1085660	we did just a week ago with two puzzle pieces in Scratch.
1085660	1088620	Now, there isn't going to be a green flag on my Mac or my PC
1088620	1090340	as we move forward that you can just click.
1090340	1092580	We're going to have to run these programs in a little different way,
1092580	1094380	but that's all the code on the right is doing.
1094380	1095820	It's equivalent to the code on the left.
1095820	1098780	So let's do this again and again for just a few of those concepts from last time,
1098780	1101220	and then we'll start writing some of our own programs.
1101220	1107060	So this was an example, this purple block of what concept in programming?
1107060	1107820	Yeah, function.
1107820	1109540	So it was a verb, it was an action, and we're
1109540	1110940	going to call those generally functions.
1110940	1112740	They just have functionality built into them.
1112740	1113980	So how do we do this in C?
1113980	1115780	Well, you might remember from just a moment ago,
1115780	1118740	because one of the lines of code was representative of this,
1118740	1120540	it had some of this syntax.
1120540	1123700	So in fact, if I were to translate the block on the left in Scratch
1123700	1126940	to the equivalent code in this other text-based language called C,
1126940	1129780	I'm going to start by writing print and then open parenthesis
1129780	1131020	and then close parenthesis.
1131020	1134260	And those parentheses kind of represent the oval, the white oval
1134260	1137140	on the left that we typed hello world into before.
1137140	1139500	Now in C, it's not quite as literal as that.
1139500	1142420	The function or the verb is actually not called print.
1142420	1145060	It's called printf, and the f stands for formatted.
1145060	1147220	And it just means that in C, you can actually
1147220	1148980	format your text in different ways.
1148980	1150540	So we'll see that before long.
1150540	1153540	And it turns out that you don't just write hello world between those
1153540	1155300	parentheses like we did in Scratch.
1155300	1158700	You also actually have to surround them with double quotes in C.
1158700	1160340	OK, not such a big deal, but something you
1160340	1161660	didn't have to do before.
1161660	1164460	But you know what, in C, you're also going to generally
1164460	1166700	want to be super specific to the computer.
1166700	1169340	And when you want the cursor, the text on the screen,
1169340	1172220	to move down to the next line, you need to tell the computer
1172220	1174540	that by literally typing backslash n.
1174540	1176900	The human is not going to see a backslash and an n.
1176900	1179740	He or she is actually going to see the cursor move to the next line
1179740	1183420	of the screen, like in Google Docs or in Microsoft Word or the like.
1183420	1185820	But this just speaks to the precision that you
1185820	1188420	need to have when talking to a computer at this level
1188420	1190060	and not just with the puzzle pieces.
1190060	1192180	And then one last thing, and I alluded to it earlier,
1192180	1194740	because it's sort of the bane of a lot of programmers early on,
1194740	1198900	most lines of code in C have to end in a semicolon.
1198900	1202780	That's the sort of code equivalent of a period in English or some other language
1202780	1203540	in sentence.
1203540	1204260	So that's it.
1204260	1207100	It took us a little while to kind of build that up, but that's all it is.
1207100	1209740	The idea on the left of saying something is the same in C
1209740	1213540	as printing something with this function called printf.
1213540	1215900	And before I forge ahead with some other comparisons,
1215900	1218460	any questions on just this translation?
1218460	1220980	How do you write backslash n?
1220980	1222260	How do you write backslash n?
1222260	1222760	Good.
1222760	1226940	So thinking ahead, this would seem to make it hard to literally show the user
1226940	1228180	backslash n.
1228180	1232780	Well, it turns out that this backslash, because it's not a terribly common character,
1232780	1235780	the programming world uses it as what's called an escape character.
1235780	1239020	It's one that you use when you want to escape information
1239020	1240820	and show it in a slightly different way.
1240820	1243380	So the way you would show literally to the human,
1243420	1249460	a actual backslash n is to actually, in your code, do backslash backslash
1249460	1253340	n, because the second backslash is like saying, treat the next character
1253340	1255620	special and actually show it to the human.
1255620	1257500	And there's other such examples of that.
1257500	1258580	So how about this one?
1258580	1263020	This orange block was an example of what concept in scratch?
1263020	1263460	Yeah.
1263460	1265940	So this was a variable, like an x and y and algebra.
1265940	1267500	This was just a placeholder for data.
1267500	1269020	And you could store numbers.
1269020	1270420	It turns out you can store words.
1270420	1272740	You can store other things, too, in other languages.
1272740	1274620	So in C, we're going to do this.
1274620	1277500	We're going to say literally the name of the variable we want, for instance,
1277500	1280780	counter, but we could call it anything we want, equals 0,
1280780	1282940	if we're setting it initially equal to 0.
1282940	1284980	But C is a little more pedantic.
1284980	1288380	You've also got to tell the computer, this type of variable I want
1288380	1292140	is specifically for an integer, otherwise abbreviated int.
1292140	1294700	So you have to tell the computer in advance what type of data you're
1294700	1296620	going to store in it and take a guess.
1296620	1300780	You've got to finish the thought and see, what more do we need to add to the?
1300780	1302100	Yeah, just a semicolon.
1302140	1303020	And that's it.
1303020	1306820	Looks a little more cryptic, but the idea is fundamentally the same.
1306820	1308820	So what if we wanted to do this in scratch?
1308820	1310220	Change counter by 1.
1310220	1314220	This was equivalent to incrementing or adding 1 to counter.
1314220	1317500	Well, let me go ahead and propose that you could literally just do this in C.
1317500	1323740	Set counter equal to whatever counter currently is, plus 1.
1323740	1325580	That seems to be kind of the right intuition.
1325580	1329300	And now notice what's key to note here is that this equal sign
1329300	1332900	isn't saying that counter equals counter plus 1,
1332900	1335460	because that just doesn't seem possible.
1335460	1339460	If you pick any value for counter, like the number 1, well, 1 definitely
1339460	1342700	does not equal 1 plus 1, which is 2.
1342700	1344180	And 1 does not equal 2.
1344180	1348220	And you can come up with an infinite number of worrisome incorrect comparisons.
1348220	1351420	So the equal sign in C, like a lot of languages we'll see in the class,
1351420	1352580	actually means assignment.
1352580	1356020	Copy the value on the right into the value on the left.
1356020	1359420	So set counter equal to whatever it is, plus 1.
1359420	1362780	Well, we've got to finish the thought, so we need a semicolon.
1362780	1365780	I don't, though, need to re-mention int.
1365780	1368460	And why might that be?
1368460	1370620	Yeah, I already told the computer it's an integer.
1370620	1372860	You don't need to repeat yourself by mentioning int again,
1372860	1376220	assuming in this context, even though we're looking at it just on the slide,
1376220	1379020	has actually been created before, just like you
1379020	1381180	did with scratch by saying make a variable.
1381180	1384780	So it turns out you can be a little more succinct in C in a lot of languages.
1384820	1388180	If you find this a little tedious to type, and it's a little verbose,
1388180	1390860	it's a bunch of keystrokes, you can actually abbreviate it with just this.
1390860	1395940	So plus equals is just syntactic sugar, as a programmer would say.
1395940	1399620	It's just a nice, fancy feature that lets you write fewer words or characters,
1399620	1400620	but do the same thing.
1400620	1402060	And frankly, we can do a little better.
1402060	1405020	And if you've taken a PCS, you might have seen this in Java as well.
1405020	1410100	You can also simplify this even more to just counter plus plus semicolon.
1410100	1411500	So that's it, all equivalent.
1411500	1412980	This is just a little more efficient.
1413020	1416620	As you get more comfortable programming, saving keystrokes just saves you time.
1416620	1420780	Now this, of course, was an example of what in scratch, by contrast.
1420780	1423700	Yeah, we called this a condition, and it had a Boolean expression
1423700	1425740	that we were asking a question of.
1425740	1428940	In this case, we're apparently asking in scratch, is x less than y.
1428940	1431220	And if so, say it on the screen.
1431220	1433060	So how might we translate this to C?
1433060	1436660	Well, it turns out we can quite simply translate this one pretty literally.
1436660	1439260	We've seen almost all of the building blocks thus far,
1439260	1441780	but we do have to introduce a little something new here.
1441820	1445740	Notice that the printf line is almost identical to what I used earlier
1445740	1446540	for just Hello World.
1446540	1450140	I've obviously just changed the words in it, but I still have the backslash n.
1450140	1452380	I still have the quotes, still have the semicolon.
1452380	1454580	So the rest of that is the same.
1454580	1457620	Now if is new, but this is a one-to-one translation.
1457620	1459340	Scratch calls it if, C calls it if.
1459340	1460940	And the only additional thing you need in C
1460940	1462940	is parentheses around the Boolean expression.
1462940	1466100	So that's what takes the place of the little green block there.
1466100	1470100	And then assuming x and y are indeed variables that we created earlier,
1470100	1471900	you can just compare them like this.
1471900	1474900	And you can use greater than and other symbols for comparison as well.
1474900	1476540	But there is something a little interesting.
1476540	1480260	And most of us don't often have occasion to even use these keys on our keyboard.
1480260	1483820	Curly braces on a US keyboard, they tend to be over on the top right
1483820	1485420	above your Enter key.
1485420	1489620	These are just kind of C's equivalent of this shape.
1489620	1492380	Notice that most of the yellow blocks in Scratch
1492380	1496180	kind of had this embracing or this embracing shape to them.
1496180	1499740	You can simulate that in C by having what's called an open curly brace
1499780	1500940	and then a closed curly brace.
1500940	1502380	So that's the same exact idea.
1502380	1506340	Now as an aside, you don't technically always need these curly braces.
1506340	1508980	If you've just got a one-liner like this, you can omit them
1508980	1510820	as you might see online or in textbooks.
1510820	1512660	But we'll just always draw them for consistency
1512660	1517380	so that the C code always looks like this.
1517380	1520300	What if you wanted to express this, though?
1520300	1523100	If x is less than y, then say x is less than y.
1523100	1525660	Else, say x is not less than y.
1525660	1527940	Well, it turns out this is almost identical.
1527940	1531580	So the first four lines perfectly the same as before.
1531580	1535740	But it turns out in C you can literally say else after that closing curly brace
1535740	1539140	and then just print out alternatively whatever it is you want to say.
1539140	1540820	So this is like the fork in the road.
1540820	1542340	If you go one way, say this.
1542340	1545340	If you go the other way, say this other thing.
1545340	1547580	Any questions on these comparisons thus far?
1547580	1548080	Yeah?
1548080	1552780	Can we put the first bracket on the same line?
1552780	1554340	Really good question.
1554340	1556940	Can you or do you put the curly brace on the same line
1556940	1557940	as the if you can?
1557940	1561180	And we're going to talk about this in the next couple of weeks, this matter of style.
1561180	1564620	There are different ways I could express this exact same code.
1564620	1569380	Frankly, I could write out all of this code with no spaces whatsoever.
1569380	1573820	In fact, just to make that point, if I go ahead and just open up a simple text
1573820	1577620	editor here, not to actually program, but to just type something,
1577620	1580020	I could actually do something like this.
1580020	1588540	If x less than y, then go ahead and print out x is less than y backslash n semicolon
1588540	1591380	curly brace else print and so forth.
1591380	1594140	Completely unreadable at the end of the day or unmaintainable,
1594140	1595860	especially when the code gets complicated.
1595860	1598660	But white space does not tend to matter to the computer,
1598660	1600060	but it does matter to the human.
1600060	1602260	And as you're alluding to in some languages,
1602260	1606540	it's actually conventional to do this, where you actually keep the curly brace
1606540	1607340	on the same line.
1607340	1610460	And indeed, you might see textbooks do this as well.
1610460	1612260	Some people will even do this.
1612260	1614300	These are all long story short matters of style.
1614300	1616900	And CS50, in the earliest weeks of the class,
1616900	1619420	we're going to insist that everyone follow the same style,
1619420	1621380	so that we have some basis for comparison.
1621380	1623180	But eventually, this is the kind of thing
1623180	1626900	that, like in your own English writing or whatever language you tend to write in,
1626900	1629940	you have your own sort of stylistic or linguistic flair to it.
1629940	1631580	Code has that as well.
1631580	1633460	Other questions?
1633460	1634460	Yeah?
1634900	1637180	Do you establish the counter variable?
1637180	1642380	Do you always have to say what is equal to or equal to the counter?
1642380	1643260	Really good question.
1643260	1645740	When you declare a variable, create a variable,
1645740	1648420	do you have to set it equal to something right away?
1648420	1649340	Short answer, no.
1649340	1652020	And we'll see examples of that before long, where you can actually say,
1652020	1656980	give me a variable called counter, but don't actually set it equal to some value.
1656980	1658780	Come back to that in a bit.
1658780	1661340	All right, so what if we want to add this logic?
1661340	1664620	Frankly, in Scratch, it's starting to look a little overwhelming,
1664620	1666540	but this is just a three-way fork in the road.
1666540	1668980	If x is less than y, say so.
1668980	1672380	Else if x is greater than y, say so.
1672380	1677140	Else if x equals y, then go ahead and say they're equal.
1677140	1680820	And in C, we can do this translation pretty directly as well.
1680820	1684620	In fact, now the first eight lines of code are identical to before,
1684620	1688580	except this middle one here, where I'm adding a second Boolean expression,
1688580	1690580	is x greater than y.
1690580	1693900	And then I have this third condition, else if x equals y.
1693900	1699420	But there seems to be a typo, perhaps, or something anomalous here.
1699420	1700180	Does anything jump out?
1700180	1702580	Yeah.
1702580	1707020	I have a double equal sign, which maybe is just a typographical error on my part.
1707020	1708180	But turns out it's not.
1708180	1709900	This is deliberate.
1709900	1710740	But why?
1710740	1713380	This seems like our first example of where Scratch doesn't really
1713380	1714780	map perfectly to C. Yeah.
1714820	1718900	So the equal sign is an assignment, and so not the equal sign,
1718900	1720780	and actually the same thing.
1720780	1721340	Exactly.
1721340	1725340	We already, a moment ago, decided as humans, really years ago,
1725340	1728260	equals is actually, in the context of C, going to be assignment.
1728260	1731020	Copy the value from the right to the value on the left.
1731020	1733140	And so we kind of painted ourselves into a corner.
1733140	1735020	We still, as humans, as programmers, want
1735020	1738300	to be able to express the notion of equality and comparing.
1738300	1740700	But if we've already used the equal sign for assignment,
1740700	1743980	we need another pattern of symbols to represent equality.
1743980	1747540	And as it turns out, humans just chose two equal signs instead.
1747540	1749260	So slightly different from Scratch.
1749260	1751420	The reason Scratch does it this way is because you don't really
1751420	1752980	want to have to get into those weeds.
1752980	1755500	Certainly when the target audience is eight-year-olds just learning
1755500	1757660	to program in the first place, it's not important.
1757660	1759820	Nor is it really important for us, but for us,
1759820	1763060	there's going to be a logical difference.
1763060	1765540	Because if we use the wrong one, the behavior is going to be wrong.
1765540	1767620	If we had just one equal sign, we would literally
1767620	1772180	be changing x to equal y rather than just comparing it.
1772180	1774260	How is their hand in here?
1774260	1774760	Yeah?
1774760	1775620	Just a quick question.
1775620	1778340	So if you wanted to express greater than or equal to,
1778340	1780380	would you write equal greater than?
1780380	1780880	Good question.
1780880	1784140	If you wanted to express greater than or equal to, how might you do that?
1784140	1786140	It turns out there are ways to do that.
1786140	1790060	And if I go ahead and just give myself some place to draw here for a moment,
1790060	1795900	you can actually, indeed, do less than or equal or greater than or equal.
1795900	1798540	There's no way on a typical keyboard to put them atop each other,
1798540	1799940	like you might recall for math class.
1799940	1801300	So you just put them next to each other.
1805180	1806060	Well, it depends.
1806060	1808900	I want the double equal sign here, because I
1808900	1815020	want to explicitly check this third case and say x is equal to y.
1815020	1816060	So that was my goal.
1816060	1817860	But logically, this is not necessary.
1817860	1820380	Let's make the program a little better designed.
1820380	1826140	How many possible cases are there when comparing two integers, x and y,
1826140	1829020	for greater than, less than, or equality?
1829220	1831580	I just answered the question, didn't I?
1831580	1832460	Is there a?
1832460	1833620	Three, excellent.
1833620	1834940	There's three scenarios there.
1834940	1838140	x is either less than or greater than or equal to.
1838140	1841260	And I'm hard pressed to think of a fourth.
1841260	1846340	So do I need this amount of specificity?
1846340	1849220	What could I do to give myself a slight optimization,
1849220	1852060	improve the code just a little bit, just to save myself a little bit of time
1852060	1854900	writing it, and maybe even the computer a little time running it?
1854900	1855380	Yeah?
1855380	1856580	You don't need the last condition.
1856580	1858740	Yeah, I don't need the last condition, because if we all
1858740	1863300	agree logically that either x is less than y or greater than y or maybe
1863300	1865940	equal to y, well, if there's only a third and final case,
1865940	1867500	that can just be my so-called else.
1867500	1869620	Just make that be the so-called default case.
1869620	1873140	And in fact, even though this is what most people would call an over
1873140	1875860	optimization, you are saving the computer some time.
1875860	1878420	Because suppose that x does, in fact, equal y,
1878420	1880260	and they're both the value number one.
1880260	1884860	So is one less than one when this line of code is executed?
1884860	1886460	True or no?
1886460	1887380	No, obviously not.
1887380	1888580	One is not less than one.
1888620	1891980	So this code does not execute, but the Boolean expression is evaluated,
1891980	1892480	so to speak.
1892480	1893860	The question is asked.
1893860	1895820	Is one greater than one?
1895820	1896580	No.
1896580	1899500	And so this code is not executed, but this Boolean expression is.
1899500	1903820	So we just spent another step or second, or however fast the computer is,
1903820	1905820	is one equal to one?
1905820	1906380	Yeah, it is.
1906380	1907860	So this actually prints.
1907860	1909980	But to your point, you don't need to ask that question.
1909980	1912900	And in fact, you just increased by a factor of 50%
1912900	1916820	how many questions you're asking, so you just wasted a little bit of time.
1916820	1919620	Now, as an aside, are Macs and PCs and phones these days?
1919620	1921700	I mean, again, they're operating at like a gigahertz speed,
1921700	1923500	one billion things per second.
1923500	1927020	So in practice, who cares if you're asking that third question?
1927020	1929980	And frankly, if it makes your code more readable,
1929980	1932900	or to your teaching fellow, or to a colleague, or a friend who's
1932900	1934900	working on the program for you, then that's great.
1934900	1938100	If it's more clear from the code what's going on, leave it that way.
1938100	1941060	But these are the kinds of design decisions that we'll now make.
1941060	1944400	And arguably, this version of the Scratch program and this version
1944400	1946680	of the C code is just a little better design,
1946680	1952200	because why write more code than you need to to express the exact same idea?
1952200	1952760	All right.
1952760	1953800	So what about this?
1953800	1955360	This was a loop in Scratch.
1955360	1958800	This was an infinite loop, because it was just forever saying hello world.
1958800	1961860	Now, in C, this gets a little less directly translated.
1961860	1964120	It turns out C uses the keyword while.
1964120	1967880	So there is no forever keyword in C, but there is the word while.
1967880	1971600	And of course, I'm going to use my curly braces, or curly braces,
1971600	1974920	or curly brackets to kind of encompass the following lines of code.
1974920	1977320	The line of code I want in there is just another printf,
1977320	1979400	so that's the exact same as before.
1979400	1981680	But it's not sufficient to just say while.
1981680	1986760	It turns out that while wants you to ask it a question every time the loop
1986760	1989000	executes, and it's going to check that question.
1989000	1991320	And if the answer is yes, it's going to run the loop.
1991320	1995720	But if the answer being asked in C is ever no or false,
1995720	1997520	it's going to not execute the code, and it's just
1997520	2000840	going to move on to any further lines of code lower down in the file.
2000840	2004600	So in C, you actually need a pair of parentheses after the keyword while.
2004600	2006880	And then you need to ask a question.
2006880	2009960	You need to ask a question like, is x less than y?
2009960	2011940	Or a question like, is x greater than y?
2011940	2013600	Or is x equal to y?
2013600	2016840	But none of those scenarios apply, because the whole purpose of this
2016840	2020160	scratch block is literally to do something forever.
2020160	2025040	So what's a question we could ask to which the answer is surely true?
2027440	2028480	Does one equal one?
2028480	2032280	We could kind of contrive an arbitrary but very mathematically correct scenario.
2032280	2034600	We could just say, does one equal equal one?
2034600	2037800	But it turns out you can be even more succinct, because in C,
2037800	2041960	there's a couple key words, one of which is true, one of which is false.
2041960	2044840	And the word true is by definition always true,
2044840	2046920	and the word false is by definition always false.
2046920	2048840	So you don't need to contrive some arbitrary,
2048840	2053720	but correct the idea of does one equal equal one, or does 50 equal equal 50.
2053720	2056000	You don't need to just come up with some arbitrary solution.
2056040	2061280	You can literally just say true, because that key word true never changes value.
2061280	2063160	So even though this is a little weird looking,
2063160	2066760	it's how you induce something to happen forever.
2066760	2068680	You ask the same question again, and assume
2068680	2071520	that the question always has the same answer of true.
2071520	2074960	Any questions on that one?
2074960	2076840	Yeah, in the back.
2076840	2080760	Do spaces matter, or do you take out the space in a while?
2080760	2081360	Good question.
2081360	2083040	Do spaces matter?
2083040	2085240	Short answer, no, not in this case.
2085240	2088320	You can add, in fact, delete all of the spaces here,
2088320	2089960	except for the one in the English phrase,
2089960	2092160	and it would still be functionally correct.
2092160	2094440	You can even add spaces anywhere you want.
2094440	2096640	You can make this taller by hitting Enter a bunch of times,
2096640	2098800	Tab, Spaces around the word true.
2098800	2102120	All of the examples I'll show here today, and you'll see in the coming weeks,
2102120	2105040	are sort of the better way to do things, because they're more readable.
2105040	2106840	But again, as you get more comfortable with code,
2106840	2108440	or if you're coming in with some prior experience,
2108440	2110040	you might already have your own opinions.
2110040	2112680	And frankly, this is just a religious debate among programmers,
2112680	2114480	which is the right way to write your code.
2114480	2115080	And that's fine.
2115080	2118240	Once you get comfy, so long as you're consistent is the most important thing.
2118240	2120800	You don't need to adhere to one person's or the other.
2120800	2122640	So how does this code work logically?
2122640	2125360	Well, the first thing the computer, your Mac or PC, or your phone,
2125360	2128080	or whatever is going to do, it's going to ask the question.
2128080	2128840	Well, true.
2128840	2132280	Well, true is always true, so it's going to proceed to execute the line of code.
2132280	2135360	But after it does, because that's the entirety of the code that's
2135360	2137560	been between the curly braces, we could have more lines.
2137560	2139520	These are just short programs.
2139520	2142440	The computer is going to check, OK, is true still true?
2142440	2144640	Yes, so it's going to execute it again.
2144640	2147000	Then it's going to ask the question again, is true still true?
2147000	2149120	Yes, so it's going to execute the code again,
2149120	2152960	and this is going to repeat literally forever.
2152960	2155240	But what if you don't want to repeat something forever?
2155240	2157120	What if you only want to repeat it 50 times?
2157120	2159400	Scratch doesn't make you think very hard about this.
2159400	2162960	It will just figure out how to keep track of 1, 2, 3, 4, 5,
2162960	2164920	it all the way up to 50, and then stop.
2164920	2165440	That's nice.
2165440	2167160	It makes it easy to use the block.
2167160	2171640	C and a lot of languages aren't quite that user-friendly.
2171640	2175040	You will see later in the semester that newer languages are a little closer
2175040	2176320	to what Scratch offers.
2176320	2178280	But in C, we need to be more explicit.
2178280	2180960	But this is a chance to use some of these more primitive building blocks.
2180960	2186400	In C, the equivalent of repeat is going to be the preposition for,
2186400	2188280	just because for now.
2188280	2192080	And then just as before, if we want to do something again and again
2192080	2194160	within this loop, we're going to use the curly braces,
2194160	2196560	similar to the little orange block there.
2196560	2197720	And then what am I going to do?
2197720	2200840	I'm going to do this every time, 50 times, hopefully.
2200840	2202400	Print out, hello, world.
2202400	2206280	So now I just need to figure out in C how to express the number of times
2206280	2208080	specifically 50.
2208080	2210920	So it turns out in C, use parentheses again.
2210920	2214120	This is going to be a pretty common characteristic of a lot of the code
2214120	2214960	rewrite.
2214960	2216840	And then you need to do three things.
2216840	2219920	The burden is now going to be on us, the programmer,
2219920	2224080	to keep track of how many times we want to execute this code,
2224080	2227240	to how many times we've already executed this code,
2227240	2230200	and then constantly make sure that one does not exceed the other.
2230200	2232280	So we stop once we hit 50.
2232280	2234840	So what's the sort of fundamental construct
2234840	2238560	that we use to keep track of anything in a program?
2238560	2240400	Counter, which was an example of a variable.
2240400	2242160	So we just need to use a variable.
2242160	2244960	Now, it's actually going to be inside of the parentheses this time.
2244960	2247320	So it's not on its own as it was just a bit ago.
2247320	2248880	But the syntax is the same.
2248880	2250120	I could call it counter.
2250120	2252360	But the reality is that the convention in programming
2252360	2255440	is just to use shorter variables when you're just doing something mundane.
2255440	2258560	And if all you're doing is looping, i stands for integer,
2258560	2261480	is sort of many programmers go to variable name rather than the more
2261480	2264000	verbose but correct counter or whatever.
2264000	2267840	So this says, hey, computer, give me a variable called i.
2267840	2272800	Let me store integers or ints in it and set the initial value to 0.
2272800	2273480	Why?
2273480	2277040	Well, almost everyone in this room probably starts counting from 1.
2277040	2279840	Computers just tend to start counting from 0.
2279840	2280320	But why?
2280320	2283680	What's the rationale for starting to count from 0, perhaps, based on last week?
2284680	2285680	Why is that kind of makes sense?
2285680	2286680	Yeah, what do you think?
2286680	2288680	Yeah, it's just 1s and 0s.
2288680	2289680	And what's the smallest number?
2289680	2291680	Negative values aside that you can represent in binary?
2291680	2294680	Well, it's just 0, 0, 0, the bunch of 0s.
2294680	2298160	So why would you waste that representation, that permutation of bits?
2298160	2300880	Let's just start counting at 0 and then add to that.
2300880	2305120	So you can start counting from 1 in C. But the convention in most languages
2305120	2305920	is count from 0.
2305920	2307680	So we'll get off on that footage.
2307680	2309680	So let's just start counting from 0.
2309680	2312680	In C, but the convention in most languages is count from 0.
2312680	2314360	So we'll get off on that foot as well.
2314360	2322200	And you might recall, even, that in our PBJ code for the phone book,
2322200	2324120	pseudocode, I actually deliberately started
2324120	2328040	numbering the lines from 0 to 1 to 2 for that same intuition.
2328040	2330280	So here's how you then say to the computer,
2330280	2332920	check, if you would, whether i is less than 50.
2332920	2334880	Now, initially, it's obviously going to be less than 50
2334880	2336320	because 0 is less than 50.
2336320	2339660	But that same condition is going to be checked again and again and again.
2339660	2341220	As this loop executes.
2341220	2346500	And then recall from before, we can just plus plus a variable to add 1 to it.
2346500	2348540	We could do this more verbosely.
2348540	2351020	We could say i equals i plus 1.
2351020	2354300	But it's just more conventional to write i plus plus just to say
2354300	2355820	the same thing more tersally.
2355820	2357380	So what happens next logically?
2357380	2358420	That's the code I've written.
2358420	2359860	What does the computer do with it?
2359860	2364140	Well, it initializes i to 0 and prepares to store integers in it.
2364140	2367820	It checks the condition just in case you initialized it to too big of a value.
2367860	2369860	You might not want the loop to execute at all.
2369860	2372060	But obviously, 0 is less than 50.
2372060	2374500	So this line of code executes.
2374500	2378020	Take a guess as to what happens next.
2378020	2380300	Yeah, you probably want to do i plus plus because you've
2380300	2383460	done executing all of the lines of code in between the curly braces,
2383460	2384660	even though there's just one.
2384660	2386140	So let's go ahead and increment i.
2386140	2387820	So i is now 1.
2387820	2389940	Let's now make sure is 1 less than 50.
2389940	2392260	Obviously, execute the code.
2392260	2394940	i plus plus is 2 less than 50.
2394940	2396900	Obviously, execute the code.
2396900	2399140	i plus plus is 3 less than 50.
2399140	2401980	Obviously, now go ahead and execute the code.
2401980	2403980	And again, and again, and again.
2403980	2408260	And at some point, we're going to get up to i equals 49.
2408260	2410340	And is 49 less than 50?
2410340	2410940	Obviously.
2410940	2413180	So we print out hello world.
2413180	2415220	And then i plus plus kicks in.
2415220	2418260	And then it's 50 less than 50.
2418260	2418900	No.
2418900	2421020	So wait, that feels like a logical error, though.
2421020	2425140	No, should I be checking if i is less than or equal to 50?
2425180	2427380	Yeah, because if I started from 0, I already
2427380	2428940	spent that one additional cycle.
2428940	2434860	So I can count from 0 through 49, which seems to work, or from 1 through 50.
2434860	2437060	But the convention in programming, honestly,
2437060	2439060	is typically to start counting at some value
2439060	2444100	and then count up to but not through some value, just because.
2444100	2446980	But logically, you can implement this in half a dozen different ways,
2446980	2448140	most likely.
2448140	2449900	All right, let's look at one final example that
2449900	2452780	allowed us to actually get user input in scratch.
2452780	2457340	Recall that we use this block to actually get the name of someone in lecture.
2457340	2460100	And we also, in the animation with the gingerbread house,
2460100	2461700	used it to get yes or no.
2461700	2463780	Do you want the cupcake or the apple or the like?
2463780	2468100	So this is an example of a function in scratch that actually takes input,
2468100	2469900	like the sentence, what's your name.
2469900	2473220	But it also returns a value, which in this case was just
2473220	2475940	hard-coded in scratch by MIT, to be called answer.
2475940	2477980	So it's like a special variable called answer.
2477980	2481220	But effectively, it's being handed back to the user.
2481260	2483300	So how might we think about this?
2483300	2487580	In C, it turns out that you can express this line of code a little more
2487580	2491180	verbose than before by using a new function called getString.
2491180	2493580	So get underscore string is the name of the function.
2493580	2496700	The underscore is convention in C. If you ever want to have a space,
2496700	2498620	you can't have spaces in the names of functions.
2498620	2500380	So people just started using underscores.
2500380	2503580	Like you might in your own social media user names and the like
2503580	2505500	is the convention there as well.
2505500	2508780	Here's the sentence I want to display.
2508780	2511260	And I'm going to start calling this more formally a string.
2511260	2514500	A string in a programming language is just a sequence of characters.
2514500	2517380	Like it's a word, it's a phrase, it's a character, it's a paragraph.
2517380	2518100	This is a string.
2518100	2520300	Anything between double quotes is a string in C.
2520300	2523780	And the backslash n is just end of line, as before.
2523780	2525580	We still already have the semicolon.
2525580	2529500	But this isn't quite a literal translation of what's going on just yet,
2529500	2533660	because I also now need to do something with the answer.
2533660	2537580	So if getString is a function that actually gets input from the user,
2537580	2540860	as via his or her keyboard, just like the blue block in Scratch.
2540860	2543780	In C, we need to be a little more explicit as to where
2543780	2547020	we're putting the return value from that function.
2547020	2549260	What it is, it's handing back.
2549260	2551700	And so I can store it in a variable, call it answer.
2551700	2553380	I could call it anything I want.
2553380	2556740	But for consistency with Scratch, let's call it answer.
2556740	2561540	But recall what we have to do in C any time we create a variable.
2561540	2564820	We have to be more precise, yeah.
2564820	2567100	We have to define it's let me call it type or class
2567100	2568580	if you've taken a previous class.
2568580	2571900	It's type, and it's not going to be an int, because probably the words being
2571900	2573100	typed in are not numbers.
2573100	2575500	It's going to be this time what I just call it a string.
2575500	2579220	And so indeed, we would declare the variable on the left by saying,
2579220	2584300	give me a string, call it answer, and assign to it whatever's on the right.
2584300	2585300	Well, what's on the right?
2585300	2589460	What is on the right is whatever this function getString comes back with
2589460	2592740	and gets stored from right to left.
2592740	2596380	So how do I now say this person's name?
2596380	2599660	Well, in Scratch, I just say say, and then I drag and drop the answer variable,
2599660	2600660	and it's done.
2600660	2604620	What's the function in C with which we can say something though on the screen?
2604620	2607260	Yeah, so printf, print a formatted string, even though we haven't really
2607260	2609220	seen any formatting it, until now.
2609220	2615380	It turns out in C, you have to actually tell printf
2615380	2619460	if you're not passing in a hard-coded string or sentence,
2619460	2624500	you have to pass to printf what's called a format code or a format string.
2624500	2626780	This first input to printf.
2626780	2629220	Now printf apparently seems to take two things.
2629220	2631300	The first is this one before the comma.
2631300	2633060	The second is the thing after the comma.
2633060	2635620	And we've not seen this before yet in C.
2635620	2641340	So printf is being told, go ahead and print out a string that looks like this.
2641340	2644780	Percent s is a placeholder, and s stands for string.
2644780	2647340	And that literally is a placeholder saying, printf,
2647340	2652060	I'm going to give you a string to plug in to this first input.
2652100	2653140	What is that string?
2653140	2654940	Literally, the answer variable.
2654940	2657100	Now it feels like we're jumping through hoops here, right?
2657100	2659860	It would have been nice to just say printf, open parenthesis, answer,
2659860	2662340	close parenthesis, semicolon, and be done with it.
2662340	2664300	That's just not the way printf works.
2664300	2667300	In older versions, you could maybe do something a little more simple like that.
2667300	2671020	But honestly, we're not typically going to be printing out just what the human typed in.
2671020	2673340	After all, this is kind of a stupid example at the moment.
2673340	2675620	I'm typing in a word, you're just saying it on the screen.
2675620	2677940	We already decided in Scratch that's kind of lame.
2677940	2682980	It'd be nice to at least have the program not just say, David, or whatever the name is,
2682980	2685340	but what did we do last time?
2685340	2687260	Like, hello, comma, David.
2687260	2691020	But this would seem to give us that capability, right?
2691020	2694940	Right now, I'm literally just printing out the human's name in C.
2694940	2698420	But let me change this ever so slightly, just as we did in Scratch.
2698420	2703020	Recall that in C, we did this green block of join,
2703020	2705460	where I literally get past join two arguments.
2705460	2708060	The first one was hello, comma, space.
2708060	2709580	The second one was answer.
2709580	2713140	And this concatenated, this combined, back to back, those two strings.
2713140	2716660	Well, in C, thanks to printf, we can do that same thing.
2716660	2718540	It's just a different syntax.
2718540	2722100	Printf still gets one argument first.
2722100	2725740	That is the string you want to format, ergo the f in printf.
2725740	2727340	But this time, I'm going to literally say,
2727340	2733020	h-e-l-l-o, comma, space, percent s for string,
2733020	2735580	and then give printf a second argument, which
2735580	2739220	is its instruction to go ahead and plug in whatever this variable is
2739220	2743140	to whatever this placeholder is.
2743140	2745900	And so here, we've now joined the two strings effectively,
2745900	2751820	and thus was born our first formatted string.
2751820	2754700	Any questions, then, on that?
2754700	2755200	Yeah?
2755560	2759120	Would you want to say something extra after?
2759120	2761240	If you want to say something extra after,
2761240	2762960	you could certainly continue the logic.
2762960	2766680	You don't have to end this quoted expression with percent s.
2766680	2771120	You could say, hello, comma, percent s, comma, nice to meet you.
2771120	2773560	And then what printf will do is it's only going
2773560	2777680	to substitute that variable called answer, where the percent s is.
2777680	2781520	And if you wanted to have 2% s's, you could just add another comma here
2781520	2784200	and pass in another variable, and a third variable, and even more,
2784200	2787440	thus formatting the string even more detailed.
2787440	2788800	Question over here?
2788800	2789560	Other questions?
2789560	2790640	Yeah, in the back.
2790640	2798360	How do you make a distinction between the placeholders if you have
2798360	2799440	different variables?
2799440	2801360	It's the ordering from left to right.
2801360	2804640	So in this case, it's a trivial example because there's only one variable
2804640	2805720	and one placeholder.
2805720	2808640	But if, as you were hinting, I had multiple, percent s, something,
2808640	2811280	something, something, percent s, something, something, something,
2811280	2815720	I would just make sure that I pass printf, the first variable, comma,
2815720	2819880	the second variable, comma, the third variable, and so forth left to right.
2819880	2820680	Other questions?
2820680	2821680	Yeah?
2821680	2824280	Why is there no comma, comma, percent s?
2824280	2826720	Damn it, because I screwed up and didn't include that,
2826720	2829680	and I was going to fix it after class quickly.
2829680	2830180	Bug.
2830180	2831240	It's a bug.
2831240	2831740	Yeah?
2831740	2835240	I bet you want to use the answer twice in the string.
2835240	2837920	Do you want to say, hello, David, hi, David?
2837920	2841260	Sure, same exact thing, comma, answer, comma, answer.
2841260	2842620	With 2% s's.
2842620	2846180	If you want to say the same variable twice in two places for whatever reason,
2846180	2849060	two placeholders, and then answer, comma, answer.
2849060	2851180	To plug that in twice.
2851180	2851460	Other question?
2851460	2851960	Yeah?
2851960	2852460	Yeah?
2852460	2855740	It's going to happen in the first place for a lot of people.
2855740	2857660	No, and we're going to see some others in just a bit.
2857660	2858660	It turns out there's others.
2858660	2861940	It's percent i for integer, and there's going to be even more than that.
2861940	2864980	Percent c for a single character and more.
2864980	2866780	Other questions?
2866780	2867280	Yeah?
2868280	2872400	Good question.
2872400	2874920	If I did have correctly, and if this weren't a PDF,
2874920	2876280	I would just edit it on the fly.
2876280	2882200	If I had the percent n, it always has to go in the formatted string,
2882200	2883760	in the first argument.
2883760	2887160	So the only thing that comes after printf's first argument
2887160	2890960	is optionally variable, comma, variable, comma, variable, comma,
2890960	2892280	variable.
2892280	2894800	Other questions?
2894800	2895320	All right.
2895360	2898960	So let's go ahead and actually do something with code.
2898960	2900920	I'm going to go ahead and open up another window,
2900920	2903280	and this is a tool called CS50 Sandbox.
2903280	2907600	And this is a tool via the web via which you can actually play with code.
2907600	2910680	And I'll show you in just a moment how I get to this particular location.
2910680	2913800	But let me first explain the user interface, much like we started off
2913800	2914960	our conversation with Scratch.
2914960	2916560	So I need a place to write code.
2916560	2918800	The reality is I could just use my own Mac.
2918800	2920440	I could just use my own PC.
2920440	2923160	Frankly, I could even use certain mobile devices these days.
2923160	2926600	But then we would have hundreds of other people in the class,
2926600	2929120	all with slightly different configurations on their Macs,
2929120	2931160	and their PCs, and their phones, and the like.
2931160	2933880	And so everyone would kind of have different software and different settings,
2933880	2935440	and that just never works very well.
2935440	2937960	So at the beginning of the course, we just standardize everything
2937960	2941200	by actually using a web-based environment, just like Scratch is,
2941200	2945640	whereby we'll all have access to the exact same computer,
2945640	2947760	but virtualized in the so-called cloud.
2947760	2949720	If you've ever wondered what the cloud is,
2949720	2952680	it just means other people's servers somewhere on the internet
2952680	2956120	that people can use for free or to rent, and now have to host
2956120	2958080	those physical servers themselves.
2958080	2962280	So CS50 Sandbox, just like Scratch, is a cloud-based application
2962280	2964960	that someone else wrote that's hosted on the internet.
2964960	2967880	And the user interface, at first glance, looks just like this.
2967880	2969720	There's only two components to it.
2969720	2973200	At the top of the user interface of CS50 Sandbox
2973200	2976600	is just a code editor, a very simple text editor, similar in spirit
2976600	2979800	to Google Docs and Microsoft Word, and so forth, but much simpler.
2979800	2980760	There's no formatting.
2980760	2982280	There's no bold-facing in centering.
2982280	2984320	You can just type words of text.
2984320	2986680	Down here is a so-called terminal window,
2986680	2988720	but we'll come back to that in just a moment.
2988720	2991280	Let me go ahead and write my first program.
2991280	3000600	Let me go ahead and write include standardio.h int main void open curly
3000600	3005880	brace printf hello world backslash n semicolon done.
3005880	3010960	OK, now, few people in this room could probably whip up a parent program
3010960	3012760	that quickly, unless you do have prior background.
3012760	3014720	And if you did take APCS or something else,
3014720	3017800	looks kind of like Java, but not quite the same.
3017800	3019480	But this is my first program.
3019480	3022400	Now, recall from earlier, this was the black and white program
3022400	3025000	we saw on the slide just a little bit ago.
3025000	3028560	And even if you didn't quite appreciate what all the funky syntax is doing,
3028560	3031760	all of us probably had the intuition of what this program does,
3031760	3035240	which is just to print out the words at the end of the day, hello world.
3035240	3039080	And we'll tease apart in just a bit what all of these various lines are doing.
3039080	3041480	But the interesting part is what's highlighted in green here.
3041480	3044880	And this is just one of the features of CS50's sandbox.
3044880	3048440	It will color code different concepts within your code
3048440	3049840	so that they just kind of jump out at you.
3049840	3050960	The colors aren't actually there.
3050960	3054640	You don't have to color code things yourself.
3054640	3057520	It just does it automatically so that you can see the different components,
3057520	3061600	just like MIT colorizes the various Scratch puzzle pieces the same.
3061600	3066560	So this is a program that I want to call hello.
3066560	3067280	It's in a file.
3067320	3069720	This is just a tab up top called hello.c.
3069720	3071960	Because it turns out when you write a program in C,
3071960	3076480	you save it in files by human convention, whatever.c,
3076480	3079080	as the file extension, so to speak.
3079080	3081720	How do I run this program?
3081720	3086560	There's no green flag to click, which Scratch gave us.
3086560	3088520	So how do I actually run the program?
3088520	3092520	And frankly, moreover, the green flag seems to be the least of my concerns.
3092520	3094840	What is the language that any computer understands,
3094840	3099080	whether it's my Mac here or the cloud server, where this thing is?
3099080	3100560	Zeros and ones.
3100560	3103720	And we started with that sort of overwhelming slide of the lots of zeros
3103720	3106600	and ones, and that is the point we need to get to.
3106600	3110480	But hopefully, we ourselves don't have to write at that level of tedium.
3110480	3114600	So we need some way of converting this code from C,
3114600	3116480	which we'll start calling source code, which
3116480	3120680	is the English-like code we see on the screen that's mildly pleasurable
3120680	3123440	to write as opposed to just zeros and ones.
3123440	3126960	But we nonetheless need to convert it somehow to zeros and ones.
3126960	3129680	And so the way we can do this is essentially as follows.
3129680	3134480	If we have what we'll start calling our source code, which
3134480	3139000	can be written, in our case, in C, but you can write source code in Java,
3139000	3141720	in C++, in Python, in dozens of other language.
3141720	3143800	Source code is a generic term that just means the code
3143800	3145160	that we humans have written.
3145160	3149760	We need some way of converting it into zeros and ones, which henceforth
3149760	3152600	we're just going to call machine code, which feels like a reasonable name.
3152600	3155360	It's the zeros and ones that a machine understands.
3155360	3158280	How does a machine know what zeros and ones to understand?
3158280	3162000	Well, that's the whole reasoning behind having CPUs, central processing units,
3162000	3163200	the brains of a computer.
3163200	3166040	They are just hardwired at the factory, so to speak.
3166040	3169760	It entails factory to understand certain patterns of zeros and ones.
3169760	3174440	But the point for us now is we need to take source code, like the C program
3174440	3176960	I wrote a moment ago that's supposed to print hello world,
3176960	3181120	and somehow convert it to machine code.
3181120	3184480	So it turns out this is the step that humans who've come before us
3184480	3185560	have solved for us.
3185560	3188320	Other humans have already written programs
3188320	3192360	that we're going to start calling a compiler that allows us to convert
3192360	3194400	source code to machine code.
3194400	3195680	It's just one additional step.
3195680	3197680	This step did not exist in Scratch, but we're
3197680	3201440	going to run a program that's generally called a compiler
3201440	3209000	that we pass our program to as input and we get as output machine code,
3209000	3212440	thereby perfectly bringing us full circle to what computer science is
3212440	3214400	in now the context of programming.
3214400	3217320	Input source code, outputs machine code, the algorithm,
3217320	3219960	or the special software we're going to use in just a moment,
3219960	3222960	is called a compiler that just converts one to the other so that none of us
3222960	3225960	have to ever think about or write in zeros and ones.
3225960	3228440	So it's a little old school how you do this.
3228440	3232160	In Scratch, you obviously just hit the green flag and MIT and all those folks
3232160	3233440	took care of it for you.
3233440	3236680	We have to be a little more manual about this.
3236680	3239880	And that's where the second piece of the CS50 Sandbox user interface
3239880	3240920	comes into play.
3240920	3243000	Notice I have a blinking prompt here.
3243000	3245720	There's a dollar sign at left, which is just a common convention.
3245720	3250800	A dollar sign tends to, in these types of computers, represent a prompt.
3250800	3252360	It's waiting for me to type something.
3252360	3255520	And indeed, it's literally blinking, waiting for me to type something.
3255520	3257880	This is an example of a terminal window.
3257880	3260840	And your own Mac and your own PC actually has or can
3260840	3262360	have this exact same feature.
3262360	3265520	It's just all of us operate with graphical user interfaces these days.
3265560	3267920	So we've got buttons and menus and things to drag and click.
3267920	3270960	But back in the day, and typically in programming,
3270960	3273280	you don't bother with these sort of aesthetics.
3273280	3277480	You actually get your hands dirtier with just the keyboard alone typing
3277480	3278680	anything you want to do.
3278680	3282720	And at first, it might feel like a regression, like why are we giving up
3282720	3286720	all these beautiful amenities of modern computers, but it's more powerful.
3286720	3287880	And it's more explicit.
3287880	3291880	It lets you do exactly what you want to do by sending commands to the computer.
3291880	3293200	So this is my terminal one.
3293200	3295320	I can create others just to have multiple windows.
3295320	3300400	But this is giving me access to the underlying server that I now have access to.
3300400	3303720	So if any of you, when it comes time to the first problem set,
3303720	3306680	log into the same tool, you don't all have the same environment.
3306680	3310440	You all have your own isolated copies of the same software,
3310440	3313040	but your own storage space, so to speak.
3313040	3318600	So I need to somehow convert hello.c to zeros and ones.
3318600	3321240	And the way I'm going to do this is like this.
3321280	3329320	Clang, which stands for C language, hello.c, enter.
3329320	3333200	And the fact that I see nothing happening is actually an amazing thing,
3333200	3336000	because there's an infinite number of things, frankly, that can go wrong.
3336000	3338960	And the computer will happily yell at you with its cryptic-looking error
3338960	3341040	messages if any of those things do go wrong.
3341040	3344640	So seeing nothing but another blinking prompt with a dollar sign
3344640	3345800	is actually a good thing.
3345800	3349080	My code has somehow been converted to zeros and ones.
3349080	3350960	Where are those zeros and ones?
3350960	3354560	Well, by convention, they are stored in a file that's
3354560	3357800	weirdly and historically just called a.out.
3357800	3358600	And we can see that.
3358600	3361520	If I click this folder icon up here, you'll actually
3361520	3366720	see my file, hello.c, and another file now called a.out.
3366720	3369720	Stands for assembly output, but for historical reasons.
3369720	3372640	Now, if I let me close the folder icon, because we're generally not
3372640	3376320	going to use the graphical user interface, how do I run that program?
3376320	3377840	I couldn't just double click on the icon.
3377840	3378560	This isn't a Mac.
3378560	3379600	This isn't a PC.
3379600	3382240	This is a cloud-based Linux environment.
3382240	3384240	Linux is a super popular operating system.
3384240	3387000	Happens to be used by lots of computer scientists, lots of websites,
3387000	3387760	lots of servers.
3387760	3390080	In fact, almost every website you visit these days
3390080	3394120	is powered, if not by Windows, by Linux and variations thereof called
3394120	3396280	Unix and other flavors still.
3396280	3398760	It's just a very popular and often free operating system
3398760	3401080	that CS50 Sandbox itself uses.
3401080	3406040	To run a file called a.out that's in this folder, so to speak,
3406040	3408040	even though you don't see a graphical version of it,
3408080	3411520	you literally just type dot slash a.out.
3411520	3415880	Completely non-obvious and kind of a stupid name for the program.
3415880	3419880	But this is the equivalent in your Mac or PC of double-clicking on an icon.
3419880	3420960	Let me go ahead and hit Enter.
3420960	3424640	And when I do, I should hopefully see what?
3424640	3425320	Hello, world.
3425320	3427000	And here we go.
3427000	3429440	Wow, that's our first program.
3429440	3433240	Like, it's not doing all that much, but it's at least doing what we promised it
3433240	3433720	would do.
3433720	3437360	And this is the equivalent in scratch of just saying on the screen, hello,
3437360	3437760	world.
3437760	3439640	Now, to be fair, there were more steps involved.
3439640	3442960	And God knows there was more cryptic-looking code to write.
3442960	3445160	But at the end of the day, all we've done now
3445160	3447920	is re-implement last week's logic in this newer language.
3447920	3451880	But we're now going to very quickly introduce new puzzle pieces, but in C.
3451880	3454440	But first, let's solve this sort of minor headache.
3454440	3457600	I don't really want to sort of tell friends, like, hey, everyone,
3457600	3459600	come run my a.out program.
3459600	3461040	Like, let's give it a real name.
3461040	3462920	Suppose I just want to call my program hello,
3462920	3465520	like you might download from the App Store or Google Play Store.
3465520	3467240	Programs have names.
3467240	3468600	So how do I do that?
3468600	3472760	Well, it turns out, in a terminal window, the so-called command line
3472760	3474880	environment, which is just a fancy way of saying you
3474880	3477280	write lines of commands with your keyboard,
3477280	3482040	you can actually pass in what are called command line arguments.
3482040	3486760	Additional inputs to programs that are just words that you type at your keyboard
3486760	3488000	that tell it how to behave.
3488000	3492160	So instead of just running clang on hello.c,
3492160	3493920	I'm actually going to be more explicit.
3493920	3498360	And I'm going to tell clang, please output, as is implied by literally
3498360	3503320	typing dash o for output, a file called hello instead.
3503320	3507880	So it's a little more verbose, hello, dash o, hello, sorry, clang,
3507880	3510080	dash o, hello, hello.c.
3510080	3514160	But what this is going to do now is still convert source code to machine code,
3514160	3517440	but it's going to save it in a file called hello.
3517440	3520720	And indeed, now I have hello.c, a.out, and hello,
3520720	3523680	as pictured in the little graphical folder there.
3523680	3527640	So now I can instead run dot slash hello.
3527640	3528280	What should it say?
3528280	3529840	Hopefully the same.
3529840	3531160	Enter.
3531160	3531960	So that's it.
3531960	3533440	Those are called command line arguments.
3533440	3537120	And it's just sort of the old school way of telling a text-based command
3537120	3539320	how to behave a little bit differently from its defaults.
3539320	3541480	But frankly, this is going to get tedious quickly.
3541480	3543920	Like, we aren't going to want to write our code.
3543920	3546880	And then every darn time we want to convert it to 0s and 1s to run it,
3546880	3551040	actually remember these sort of magical incantations of commands.
3551040	3553800	And so humans have abstracted these away too.
3553800	3556760	It turns out that if you want to make a program from source code
3556760	3559400	into machine code, there's another command you can use.
3559400	3563640	And you can literally type make hello, where hello is the name of the program
3563640	3565040	you want to make.
3565040	3570800	This program, whose name is make, will look for a file by default called
3570800	3575280	hello.c, therefore saving you the time of specifying it.
3575280	3576560	Hit Enter Now.
3576560	3578920	And oh my god, look what it just did.
3578920	3583680	It has even more configuration options that are baked into it.
3583680	3586840	And we, the CS50 staff, configured CS50 sandbox
3586840	3588360	to have these various features.
3588360	3591040	And even though we're not going to go into detail on them now,
3591040	3592960	I'm going to wave my hand at what they actually do,
3592960	3595840	they just make additional features possible that we'll eventually get to.
3595840	3598640	But this would be otherwise the command that you all do
3598640	3602240	have to type in just two or three or four weeks time.
3602240	3603840	And no one can ever remember that.
3603840	3605000	I certainly couldn't.
3605000	3607560	So make just automates that for you.
3607600	3610680	But when you run make, make is not a compiler.
3610680	3615560	Make is not the thing in the middle here, converting source code to machine code.
3615560	3619920	It's just a second program that some humans wrote years ago that
3619920	3624440	use clang in an automated way to achieve the same output.
3624440	3626480	Because people got tired of typing stuff like this,
3626480	3630840	so someone made a program called make that does it for us.
3630840	3632800	Any questions?
3632800	3635720	All right, let's add a little bit then to this program.
3635720	3639240	Instead of this version of hello, let me get some user input
3639240	3641160	and actually do something with it.
3641160	3644360	Suppose I actually want to get the user's name and then print that out.
3644360	3646800	Well, we saw the spoiler for that just a moment ago.
3646800	3649080	But let me go ahead and add it to this program here.
3649080	3650760	Now I have a second line of code.
3650760	3652720	And I want to get a string from a user.
3652720	3656800	And with what function do I get a string from the user?
3656800	3658040	Get string was the one.
3658040	3662160	And recall, I can do get underscore string, open parenthesis.
3662160	3664440	And then I have to pass in an argument, so to speak,
3665400	3666720	give me your name.
3666720	3668200	Actually, what did we say before?
3668200	3670640	What is your name, I think, was the prompt?
3670640	3671920	Backslash n?
3671920	3672880	Semicolon?
3672880	3674600	Now it's not enough to just get the string.
3674600	3676720	What do I want to do with it?
3676720	3678040	Yeah, store it in a variable.
3678040	3679640	What type of variable?
3679640	3680760	A string.
3680760	3683920	So I just need to go on the left-hand side of this line of code
3683920	3686080	and say, OK, well, give me a string.
3686080	3689200	I'll call it name, but I could call it x or y or anything.
3689200	3691320	But name feels like a good descriptor for it.
3691320	3694280	Using a single equal sign to copy from right to left.
3694280	3695840	And now I've got that.
3695840	3699640	Now it's not sufficient to just store the value in the variable.
3699640	3700920	I need to print it out.
3700920	3704760	So let me start with this.
3704760	3706920	It auto-saves the sandbox, so I don't even
3706920	3708680	have to go up to file-save or anything.
3708680	3711520	Let me go ahead and do make hello now.
3711520	3713640	Uh-oh.
3713640	3715720	Oh my god, look at all these errors already.
3715720	3718160	So clearly something is wrong, as the computer
3718160	3719560	has fond of telling me in red.
3719560	3721600	And frankly, this is where you very quickly get derailed.
3721600	3723520	They're kind of freaked out, because oh my god,
3723560	3724400	two lines of code.
3724400	3726920	How do I have 20 lines of errors somehow?
3726920	3730120	So the computer is kind of as confused as you.
3730120	3732880	And the most important thing when you face this kind of situation,
3732880	3736000	where it's just cryptic erroneous output, start at the top.
3736000	3738520	Even if your window's kind of small, and therefore a whole bunch of stuff
3738520	3740880	scrolls on the screen quickly, scroll up to the top.
3740880	3743520	Because odds are there's one mistake up at the very top,
3743520	3746480	and that one mistake just had a cascading effect on the computer,
3746480	3748640	on the compiler, that it just got really confused
3748640	3751680	and it just kept spitting out messages because it got tripped up early.
3751720	3755400	So let's scroll back up to the top here.
3755400	3759560	And here is the very long command that I said make automates for you.
3759560	3760960	So that's not erroneous.
3760960	3763080	Here seems to be the first error.
3763080	3767360	And it's a little cryptic still, but let's glean some information.
3767360	3770360	Here's a familiar phrase, hello.c.
3770360	3772360	Let me go ahead and zoom in on the bottom here.
3772360	3776560	So hello.c, you recall, is the name of my file, albeit nonobviously.
3776560	3780960	Clang is telling me, look at line five, and then your fifth character.
3780960	3784840	So this something, colon, something, means line number, character, or column number.
3784840	3787120	If you're looking from left to right, error means error.
3787120	3790840	And then this is where things get a little sophisticated.
3790840	3797000	Use of undeclared identifier string, did you mean standard in?
3797000	3801080	Now, I didn't, but I do recognize standard in, or rather,
3801080	3802640	it seems similar to standard I.O.
3802640	3803720	But no, I didn't mean that.
3803720	3806280	I'm pretty sure this code is right.
3806280	3807840	Well, why am I getting this error?
3807840	3812360	It sounds like string, on line five, fifth character, right there.
3812360	3813960	That is wrong.
3813960	3817360	Well, it turns out there is no such thing as a string.
3817360	3821560	C, the language, has integers, and it has Booleans, it turns out,
3821560	3823760	and it has characters and a few other things.
3823760	3825520	It actually doesn't have strings.
3825520	3829040	Strings is a word that's useful to describe sequences of characters,
3829040	3830080	paragraphs, words.
3830080	3831800	But string is not a type.
3831800	3834880	It's not a type of variable unless you make it so.
3834880	3838200	And in fact, this is one of the simplifications
3838200	3841560	we do in just the first couple of weeks of the course to get us off the ground.
3841560	3846200	It turns out that we need to add one line of code here.
3846200	3850080	We need to do not only include standard I.O., which we'll explain in a moment,
3850080	3854240	but also CS50, so-called library.
3854240	3856840	So CS50 has a lot of humans involved with it.
3856840	3858680	And over time, we've decided, you know what?
3858680	3861680	We could make the first hour of CS50 a little easier,
3861680	3865200	in the sort of on-ramp, a little cleaner for folks with no background,
3865200	3868400	by just inventing a few features ourselves, such as the ability
3868400	3869720	to get strings from the user.
3869720	3872600	So it turns out, getString is also not a function that comes with C.
3872600	3876360	That is a custom puzzle piece, so to speak, that CS50 made.
3876360	3882040	And where we created that function is essentially in a file called CS50.h.
3882040	3886360	And so by including CS50.h, you now get access to more puzzle pieces,
3886360	3888600	if you will, that we have created for you.
3888600	3891920	And it turns out, this line of code that has been here before
3891920	3894280	is also giving you features too.
3894280	3897720	We're just doing what everyone does in programming, which is solve a problem
3897720	3900280	once, and then let other people use that solution.
3900280	3903520	Take a guess, what functionality is actually
3903520	3908400	implemented in a file called standard I.O., input output.h?
3908400	3912640	This is just a file somewhere on the server that actually does come with C.
3912640	3916240	And it provides you with handy features, like what?
3916240	3917920	Say again?
3917920	3918880	Once more?
3918880	3919720	Printf.
3919720	3924680	It turns out that the means by which you are allowed to use a function called
3924680	3929040	printf here is you have to include the file in which it is declared.
3929040	3933040	So some humans years ago literally wrote a function, a puzzle piece called
3933040	3936480	printf, and they figured out how to actually draw characters on the screen.
3936480	3941240	They then stored information about that function in a file called standard I.O.h.
3941240	3944680	If I had not included that seemingly cryptic line of code
3944680	3948720	at the very top of my previous program, even that hello world program would not
3948720	3951520	have worked, because clang, the compiler, wouldn't
3951520	3952880	have known what I'm talking about.
3952880	3953640	What is printf?
3953640	3957840	I don't know what that is, unless you tell it to also include this file
3957840	3961640	that humans wrote years ago in which printf has been created.
3961640	3966040	And now, if I want to use getString as well as the new keyword string,
3966040	3970440	I need to tell clang, the compiler, also go ahead and look in cs50.h
3970440	3974040	for more functionality, such as string and getString.
3974080	3977360	So let me go ahead now and try this again.
3977360	3981160	I'm going to clear my terminal here and just try that same command again.
3981160	3984760	Make, hello, enter.
3984760	3985760	Damn it.
3985760	3988920	Now I've got another error, but, but, but, progress.
3988920	3990000	Well, no, well, no.
3990000	3992320	Just as many errors as before somehow.
3992320	3993720	But different ones.
3993720	3997360	Notice now, well, wait, that was before.
3997360	3998200	Oh, no, I'm sorry.
3998200	3999040	It is fewer errors.
3999040	4001160	Here's where I ran the command a moment ago.
4001160	4003640	And now I'm getting this error instead.
4003640	4005000	OK, so progress.
4005000	4006480	Now my error is not on line five.
4006480	4010400	It's on line six, though fun fact, line six used to be line five.
4010400	4013160	So it's apparently still involved in the problem.
4013160	4014880	So let's read the error message.
4014880	4018840	The problem is on line six, which not surprising is that one there.
4018840	4019880	But this time it's different.
4019880	4022960	Error, unused variable name.
4022960	4027200	OK, that one I kind of understand even without being a programmer.
4027200	4030040	What does the, what does it mean?
4030040	4031040	Yeah?
4032040	4034960	Uh, maybe declare prior to using.
4034960	4037080	But turns out this is how you declare it.
4037080	4043520	But I'm actually, yeah, yeah, I'm just kind of wasting the computer's time.
4043520	4044600	I'm creating it.
4044600	4046240	So line six on the left is correct.
4046240	4050680	Hey, computer, give me a string variable and call it name and put a value in it.
4050680	4053520	But what's the point of that exercise if you're never, as you say,
4053520	4054920	doing anything with it?
4054920	4058840	And in fact, recall from the slide a moment ago, how do I do something with it?
4058840	4060960	Well, this is not how you do something with it.
4060960	4063480	If I go ahead and run this program now successfully,
4063480	4066280	what would I actually see on the screen?
4066280	4067800	Like literally, hello name.
4067800	4071680	H-E-L-L-O comma space N-A-M-E, obviously not correct.
4071680	4073040	So how do I plug in the variable?
4073040	4075000	What was the trick?
4075000	4079960	Yeah, percent s for string, a format code, so to speak, hence the name print f.
4079960	4083200	And then I need to pass a second argument to print f.
4083200	4086840	And I do that with a comma and then the name of the variable I want to plug in.
4086840	4089120	Now notice there are two commas in this line here.
4089120	4091640	If I zoom in, notice there's two commas.
4091640	4094840	But there's only two arguments or inputs to print f.
4094840	4098000	The input to a function is just typically called an argument
4098000	4099800	or also called a parameter.
4099800	4103600	So there are two commas, but this one is an English comma,
4103600	4106440	just separating hello from the person's name.
4106440	4110560	This white comma here, color coded because the sandbox is doing that for me,
4110560	4115360	is actually separating, excuse me, the first argument from the second argument.
4115400	4119600	So now for a third time, make hello, enter.
4119600	4120800	Oh my god, thank you.
4120800	4121800	Now it worked.
4121800	4125560	It still spit out this pretty long cryptic command in white, but that's OK.
4125560	4129640	That is, again, the automated command that make is making possible for us.
4129640	4133080	But the fact that I see no red, no errors, just another blinking prompt
4133080	4135040	means that my program has been made.
4135040	4140480	So let me go ahead and do, how do I run a program if it's called hello?
4140480	4141920	Yeah, dot slash hello.
4141920	4144200	And we'll see why you have the stupid dot at the beginning.
4144200	4147560	It essentially means run the program called hello that's right here
4147560	4151080	in your current folder on the server, dot slash hello.
4151080	4151800	What is your name?
4151800	4153120	Very nice.
4153120	4155040	David, enter.
4155040	4156200	Hello, David.
4156200	4157160	Interesting.
4157160	4160600	Let's make one tweak because I did this by accident earlier, as you noted.
4160600	4163720	What if I left off, for instance, one of these backslash ends?
4163720	4166440	That's literally now not telling the computer
4166440	4168320	to move the cursor to another line.
4168320	4171560	So let me go ahead and rerun the program.
4171560	4172120	Wait a minute.
4172120	4174200	That looks the same.
4174200	4178000	I just changed the code, but it's still behaving exactly the same.
4178000	4180880	Where's my confusion?
4180880	4182080	I didn't recompile it.
4182080	4184400	Unlike Scratch, which is amazing because you just hit the green flag
4184400	4187600	and it runs the code again, we have a second intermediate step.
4187600	4189360	I have to rerun the code.
4189360	4190800	Now, how do you get out of a program?
4190800	4191560	I could just hit Enter.
4191560	4194680	You can also hit Control C for cancel, and that will just get you out
4194680	4196320	of whatever confusion you're in.
4196320	4197400	Let me go ahead and rerun.
4197400	4198760	Make hello.
4198760	4200080	Seems to be OK.
4200080	4202720	Dot slash hello, Enter.
4202720	4205720	OK, this is why I've had all those backslash ends.
4205720	4207920	Let me zoom in on what's happening.
4207920	4212160	I mean, it doesn't look horrible, but frankly, it kind of rubs me the wrong
4212160	4215320	way if this is what my program looks like when I'm typing in user input.
4215320	4216560	I mean, this just looks stupid.
4216560	4218560	Minimally, I should add a space.
4218560	4220560	Maybe I could put backslash end to move the character.
4220560	4221880	This is just user interface now.
4221880	4223080	This isn't really logic.
4223080	4225400	It's just aesthetics, but I think this looks stupid.
4225400	4228040	So that's why I've had the backslash ends there all the time,
4228040	4231640	but that's why they need to be there to tell the computer to actually put
4231640	4232800	things where you want them.
4232800	4234160	Alternatively, you know what?
4234160	4235040	OK, I don't like that.
4235040	4236440	Control C for cancel.
4236440	4237760	Let me put this one back.
4237760	4239880	What happens if I get rid of this one?
4239880	4243840	And let me go ahead and recompile the code first, as you note.
4243840	4246040	Dot slash hello, Enter.
4246040	4249080	OK, I've cleaned up that aesthetic headache.
4249080	4250400	Enter.
4250400	4255280	OK, I mean, it's not quite the same problem, but this looks stupid too,
4255280	4257320	because the dollar sign just represents my prompt,
4257320	4260640	where I'm supposed to type commands, and yet hello comma David prompt.
4260640	4261280	This is messy.
4261280	4263560	So this is why we've had all of these new lines.
4263560	4266480	Now, you asked earlier, what if you put the new line elsewhere in the string?
4266480	4267600	Well, suppose I do that.
4267600	4269080	Suppose I put a couple of them.
4269080	4270000	Let me do this.
4270000	4271680	And no space is whatsoever.
4271680	4274600	Now, this is looking a little weird, but the computer is just
4274600	4275880	going to interpret this literally.
4275880	4278720	Print H-E-L-L-L comma new line.
4278720	4282000	Substitute in the string for percent s, then another new line.
4282000	4286280	So how many lines of output is this going to display?
4286320	4287040	I heard four.
4290280	4290920	Other values?
4290920	4291640	Let's see.
4291640	4296000	Let's go ahead and make hello, and then run dot slash hello.
4296000	4298080	What is your name as before?
4298080	4300360	Enter hello comma new line David.
4300360	4305160	So four total lines, certainly, or just two lines from the computer itself.
4305160	4308640	So just to recap then, with code like this,
4308640	4315280	how many functions have I used in this particular program?
4315280	4316120	How many functions?
4319720	4320320	So it's two.
4320320	4322920	Print F, which we've been using, and get string, which is the new one.
4322920	4326120	Where is get string declared?
4326120	4331280	CS50.H, print F, meanwhile, is declared in standard IO.H, standard input output.
4331280	4335480	Meanwhile, string, this data type, also comes from CS50 itself.
4335480	4338120	And then we've used the format codes, and we've used variables
4338120	4339480	to achieve the same result.
4339480	4340800	And let's just hammer this one.
4340800	4343880	Brian and Karim, do you mind popping up for just a second?
4343880	4345040	Or who's that?
4345040	4346680	Aaron, come on up.
4346680	4350200	So just to make this clear, because there's now some terminology
4350200	4351600	that we want to use.
4351600	4354240	Let's see, do you want to be get string?
4354240	4357920	OK, so we have some name tags here, like you get it, events.
4357920	4362760	So Aaron shall be get underscore string.
4362760	4365680	If you want to go ahead and put this on.
4365680	4369440	OK, and Brian, you want to be print F.
4369440	4371760	So we won't act out all of our actual programs,
4371760	4373480	because this will quickly become obvious.
4373480	4377240	So Brian is print F. So this point, though, remains,
4377240	4380280	in that this is nice that I have some colleagues with whom I work here,
4380280	4384760	because I don't really want to do all of the hard work of making things happen.
4384760	4388000	And so if I'm instead the programmer, or the orchestrator of a whole bunch
4388000	4391920	of things happening, I can actually implement this code now more physically.
4391920	4395640	And let's focus, though, for just a moment on what the key takeaways are.
4395640	4398640	One, functions can take inputs.
4398640	4401840	Those inputs are called arguments or parameters.
4401840	4403840	And functions can return things.
4403840	4405560	They can have return values.
4405560	4406880	Print F, for instance.
4406880	4407760	Does it take inputs?
4410360	4411960	What's the input to print F, for instance?
4414600	4415680	Yeah, like hello world.
4415680	4419880	Whatever it is you want to print is, by definition, the input to print F.
4419880	4424040	Does print F return a value thus far?
4424040	4426040	It does do something on the screen, certainly.
4426040	4427320	Like it prints stuff on the screen.
4427320	4429320	But we haven't seen it return something,
4429320	4432560	because we haven't seen it with an equal sign to the left.
4432560	4434400	Now, it turns out print F does return things.
4434400	4436480	It's just not often that useful to use.
4436480	4439000	But we've only seen print F for the moment as taking inputs.
4439000	4440360	More on that another time.
4440360	4441320	Get string, meanwhile.
4441320	4444400	Does get string take inputs?
4444400	4446560	How many inputs?
4446560	4449680	Just one, the prompt that you want the human to see.
4449680	4451640	The first prompt I used was, what is your name?
4451640	4454560	I could make the prompt anything, but that's the question that get string is asking.
4454560	4456920	Does get string return a value?
4456920	4457520	It does.
4457520	4461040	That's, of course, in Scratch called answer, hard coded as answer.
4461040	4462880	We can store it in any variable we want.
4462880	4464800	So let me just go ahead and implement this program.
4464800	4470080	Aaron, go get me a string and ask the person, what is their name?
4470080	4481200	So she's writing down Elizabeth now.
4481200	4482640	But Aaron has taken input from me.
4482640	4484880	Aaron, go get someone's name and ask them, what is their name?
4484880	4486960	Now you've produced output for me.
4486960	4487960	Thank you.
4487960	4490200	This is the return value, storing the value, Elizabeth.
4490200	4492600	And I'm going to go ahead and tuck it away in a variable called name,
4492600	4493760	like this piece of paper here.
4493760	4496320	OK, Brian, could you go ahead and say hello, Elizabeth?
4509480	4511960	OK, so what's going on here?
4511960	4513720	I'm just doing less work.
4513720	4515440	Like, I kind of am writing this program.
4515440	4516520	Aaron, go get someone's name.
4516520	4517920	Brian, could you print this out?
4517920	4519880	Like, that's what I've been doing is programming,
4519880	4522920	just delegating functionality to other functions, or in this case,
4522920	4524600	other humans who know how to do that.
4524600	4527360	And honestly, I don't have to know how Aaron got that name.
4527360	4528280	She just got it.
4528280	4531320	I don't have to know how Brian wrote in that particular kind
4531320	4533320	of style of English on the screen.
4533320	4535000	I just know that he can do it.
4535000	4537240	And now my program is complete.
4537240	4539280	Thank you very much to both of these two here.
4539280	4542520	We'll continue in just a moment as follows.
4542520	4544960	So all this time, we've been taking for granted
4544960	4548640	that we have an actual computer on which we can execute code.
4548640	4550320	And I keep saying Intel inside, because that's
4550320	4554280	a sort of silly slogan that you see inside of most Macs and PCs
4554280	4555480	with the hardware they have.
4555480	4558080	But the CPU is just the brains of the computer.
4558080	4560520	And at the end of the day, recall that the goal
4560520	4564120	is to actually have the computer turn something like this, source code,
4564120	4567320	into actual machine code, 0s and 1s.
4567320	4570520	And that's all Clang was actually doing for us.
4570520	4573320	Of course, we've only just scratched the surface now of what we can do.
4573320	4576240	It turns out there's going to be not just these commands that we can run,
4576240	4580400	but other features of C. And in particular, the CS50 library.
4580400	4582320	We've only seen thus far how to get a string,
4582320	4585040	but you can get integers and characters and funky things like floats
4585040	4588120	and doubles, which actually open a can of worms as two problems that
4588120	4589440	can happen in a computer.
4589440	4592440	And it turns out you can store different types of variables,
4592440	4596360	not just integers and strings, but bool for Boolean and chars
4596360	4597080	for characters.
4597080	4599040	And you can format those things in printf.
4599040	4601240	We've only seen %i, %s.
4601240	4604640	I alluded to %i earlier, but there's a few others still.
4604640	4606760	But we've got a lot of possibilities here.
4606760	4608720	But let's go ahead and take, say, a five minute break
4608720	4611720	to give everyone a bit of a respite, turn on some music and come back in five,
4611720	4615240	and dive in deeper to more sophisticated programs in C.
4615240	4617160	All right.
4617160	4621040	So recall we began by comparing some scratch blocks
4621040	4622440	against the corresponding C code.
4622440	4625960	But we didn't actually use most of those blocks in C just yet.
4625960	4628240	So let's try out a number of examples, some of which
4628240	4632280	I'll write on the fly in typing code out on my own keyboard, some of which
4632280	4635560	we already have on the course's website, so we can just open them to save some time.
4635560	4638120	But let me just draw your attention to what CS50 Sandbox is,
4638120	4640360	because this was the step that I skipped over earlier.
4640360	4643880	CS50 Sandbox can be used to program in bunches of languages.
4643880	4646120	Will initially in the semester use it for C.
4646120	4650440	But if you've written Java before or Python or any number of languages,
4650440	4653720	when you go to sandbox.cs50.io, you can simply
4653720	4655440	choose the language you want to write in.
4655440	4658640	And then at the bottom, you'll see you can specify the name of the file
4658640	4659880	you want to pre-create.
4659880	4664320	So for instance, what I did earlier was I selected C at top.
4664320	4666720	And then at the bottom, I typed in hello.c,
4666720	4669560	because that was the name of the file I wanted, and then I clicked Start.
4669560	4674600	And what that led me to was precisely the interface in which we wrote hello.c
4674600	4677920	just a moment ago, where my code editor appears on the top here,
4677920	4680080	my terminal window appears at the bottom,
4680080	4682400	and then I'm allowed to just start writing code.
4682400	4684200	So that's how we got to where we were.
4684240	4687280	And if you want to follow along now with some of these examples,
4687280	4690000	note that on the course's website, we have all of them pre-made.
4690000	4693560	And you can actually click the links on the course's website
4693560	4696240	and open up your own copy of a sandbox with that code.
4696240	4699000	So if the Wi-Fi cooperates, you're welcome to tinker and play and run
4699000	4702400	the same commands, but everything is also on the course's website after.
4702400	4704320	So you need to type everything out.
4704320	4706200	So let's go ahead and do just a quick example.
4706200	4711040	I'm going to call this int.c just so that we can reinforce some of what we did
4711040	4712160	just a moment ago.
4712200	4715440	Rather than get a string, like we did with our hello example,
4715440	4720360	let me go ahead and just get, say, an integer, and then print it out,
4720360	4721920	just as we did print a name.
4721920	4724600	So I'm going to have to go ahead and just through muscle memory,
4724600	4727840	I kind of remember that I need standard io.h at the top,
4727840	4731440	and then int main void, and then curly braces,
4731440	4735360	and then I can do the act of actually getting the input.
4735360	4737680	So there was a function before called get string.
4737680	4739840	Turns out there's another function called get int,
4739840	4741160	if you want to get an integer.
4741160	4744480	So I can actually call get int, and I can say something like integer
4744480	4747440	is the prompt, like, hey, human, please give me an integer.
4747440	4749840	I need a semicolon at the end of this line.
4749840	4755280	And then how do I actually store the return value of get int in a variable?
4755280	4757960	Just as Aaron handed me a sheet of paper with a string,
4757960	4760680	how do if I'm handed a sheet of paper with a number,
4760680	4763240	how do I store it somewhere?
4763240	4767160	What should I literally type on line five here?
4767160	4769120	Int, space, and then number or something.
4769120	4771000	So I'm going to call it i just because it's an integer,
4771000	4773160	but I could call it number or anything else.
4773160	4775160	And then I'm going to go ahead and print this out.
4775160	4782360	So printf, let's say something like hello, i, backslash, n, semicolon.
4782360	4783800	OK, not quite correct, right?
4783800	4786080	This is going to literally print hello, comma, i.
4786080	4787760	How do I actually substitute something in?
4787760	4790040	Well, we've only seen how to substitute in a string,
4790040	4792080	but I think I spoiled earlier the answer.
4792080	4796040	Fuse, percent, i, that says, hey, computer, put an integer here.
4796040	4800840	Then I need a second argument to printf, just as we handed Brian
4800840	4802480	an argument as well.
4802480	4804640	And I said i.
4804640	4806200	I want to say i here.
4806200	4808360	But this program isn't quite correct yet.
4808360	4809800	It's in a file called int.c.
4809800	4811680	I've included standard io.h.
4811680	4813880	It's in main, and so what is main?
4813880	4816520	Well, today, we're largely going to wave our hands at that.
4816520	4820000	But int main void is perhaps the most cryptic way
4820000	4822680	you can say the equivalent of when green flag clicked.
4822680	4823800	Like, that's all that does.
4823800	4827080	And we'll come back in the weeks to come as to why it's int, why it's main,
4827080	4827880	why it's void.
4827880	4830000	But for now, humans years ago just decided
4830040	4833560	that when you're writing a program in C and you want to start the program off,
4833560	4836800	you literally have to type int main void with those parentheses,
4836800	4839800	with those curly braces, and it's the equivalent to scratches when green
4839800	4840760	flag clicked.
4840760	4842720	But this program will not compile.
4842720	4845320	And I don't even want to induce the stress of seeing those errors.
4845320	4847280	How do I void it?
4847280	4851040	Yeah, I need to teach the computer that get int exists.
4851040	4855600	And I know how to do that from before by including the so-called CS50 library.
4855600	4858320	Technically, CS50.h is a header file.
4858320	4860000	.h means header.
4860000	4863640	And it's just a file containing C code in which the functions are created.
4863640	4865080	More on that another time.
4865080	4867320	But that just gives us access to printf.
4867320	4870440	So if I've made no typos, I should be able to compile this program
4870440	4873640	by running what command?
4873640	4874360	Make int.
4874360	4875520	I could do clang.
4875520	4877200	I could do clang-o.
4877200	4880360	But for now, I'm going to do it simpler, would just make int
4880360	4884080	and let make automate the process of compiling this program.
4884080	4885800	No error messages is good.
4885800	4887600	Let me go ahead and zoom in.
4887600	4890320	.int, I think, would run the program.
4890320	4892680	Integer, how about 42?
4892680	4894080	Hello, 42.
4894080	4895440	Notice I can save time now.
4895440	4898600	If I want to run it again, I don't have to do .int all the time.
4898600	4901280	It turns out that in this kind of Linux environment,
4901280	4904560	this operating system called Linux, you can actually go up and down
4904560	4907520	and see previous commands you've typed and some others that
4907520	4909000	happen to be system specific.
4909000	4911440	And if you just hit up and enter, you can run it again.
4911440	4914880	Type in 50 this time and see another output as well.
4914880	4916440	All right, so any questions then?
4916440	4919840	On just an example like that?
4919840	4920160	No?
4920160	4922760	Well, let me go ahead and I'm going to save time in this environment.
4922760	4927280	I can actually create files in here if I want by clicking the folder icon,
4927280	4931000	clicking the plus, and then I can actually say, give me a file called float.c.
4931000	4933120	So this is equivalent to going back to the main menu
4933120	4934280	and typing in the name of the file.
4934280	4935880	I'm just going to do it a little more quickly now
4935880	4937160	in this graphical environment.
4937160	4938920	And I want to call it float.c.
4938920	4941520	It's a bit of a weird name, because at least growing up,
4941520	4944160	you probably learned maybe about integers.
4944160	4947480	You probably learned about real numbers, numbers that can have decimal points,
4947480	4949520	and then things after the decimal point in a computer.
4949520	4953680	Those things with decimal points are called floating point values, or floats.
4953680	4956720	And you can think of it as the decimal point can kind of float to the left
4956720	4958960	or the right, depending on how big or small the number is,
4958960	4961680	or how precise the numbers after the decimal point are.
4961680	4962720	That's a float.
4962720	4965120	So let me go ahead and implement a very similar program.
4965160	4971320	Include cs50.h, include standardio.h int main void.
4971320	4974520	And this is after 20 years of doing this, that you can do it so quickly.
4974520	4978840	Now, let me instead get a float from the user, so a real number that
4978840	4980920	may very well have a decimal point in it.
4980920	4982960	I'm going to do that a little differently.
4982960	4986200	I'll zoom in, and I'm going to say, hey, computer, give me a float,
4986200	4990120	as is the data type called, not int, not string, but float.
4990120	4992360	I'll call it f, just because that sounds like float,
4992360	4993840	and it's nice and succinct.
4993840	4998080	Equals get float, and then I'm just going to say float.
4998080	4998840	That's the prompt.
4998840	5001160	I could make the prompt in green anything I want.
5001160	5002440	And now I'm going to print it.
5002440	5006360	Print f, hello, f, but I don't want f.
5006360	5008480	I want to actually print out a placeholder,
5008480	5011560	and you can probably guess by now what the pattern is,
5011560	5017760	percent f for a float, new line, comma, f, semicolon.
5017760	5021080	So this is like the same program three times now with a string,
5021120	5023760	with an int and a float, but again, just for some muscle memory
5023760	5024880	and going through the pattern.
5024880	5026600	But let's see what happens differently here.
5026600	5029400	Let me go ahead and type make float, enter.
5029400	5030560	OK, good, no errors.
5030560	5039120	Let me zoom in and run this now as dot slash float.
5039120	5040520	And let me go ahead and type in a number.
5040520	5042280	I'm going to just say 42.
5042280	5045920	But the computer now has the capability of storing more precision.
5045920	5048440	Before, it was just an integer by definition of int.
5048440	5053160	Now it's a float, so even though it's pretty precise as 42.000,
5053160	5057720	that's indeed a real number now storing some amount of precision there.
5057720	5061920	So it turns out, though, that we can do more interesting math.
5061920	5065440	Let me go ahead and just open this example in advance.
5065440	5067720	This one's going to be called ints.c, so they
5067720	5069840	don't have to type everything out.
5069840	5073800	And in ints.c, we're going to see some math written in code
5073800	5076600	that I pre-created just to reinforce that you can actually
5076600	5078560	do some basic arithmetic in a program.
5078560	5081800	I can see more of the code here by just scrolling down.
5081800	5084200	And let me scroll this up so we can focus on main.
5084200	5086760	And let me zoom in on the first few lines.
5086760	5090160	On this first line, I'm just getting an int, and I'm calling it x.
5090160	5092000	We've not used a variable called x recently,
5092000	5092600	but now we are.
5092600	5095200	It's no different logically than before.
5095200	5097280	Here, give me another variable so we can see now
5097280	5100240	that you can get multiple variables from the user, just like in Scratch.
5100240	5105360	And now, in these lines, in green, are just some format strings.
5105520	5107560	What do I want printf to display?
5107560	5110000	I literally, in this highlighted line here,
5110000	5114640	want printf to display x plus y equals something.
5114640	5115600	What is that something?
5115600	5121240	Well, notice what's cool about printf is that before it is passed an input,
5121240	5123200	you can perform simple arithmetic operations.
5123200	5126360	So if you want to add x and y together, literally do x plus y,
5126360	5130760	then the sum of those numbers will get handed to printf as its input.
5130760	5133640	Just like I handed Aaron's piece of paper to Brian as input,
5133640	5139160	I'm handing not x and y to Brian in this case, but x plus y or some value,
5139160	5140120	the actual sum.
5140120	5143880	Similarly, subtraction is the hyphen on your keyboard.
5143880	5145760	For multiplication, it's not an x.
5145760	5147080	That would be weird, x, x, y.
5147080	5149840	It's instead star or an asterisk on your keyboard.
5149840	5151520	Division is a single slash.
5151520	5154400	And then this one's a little funky, but we'll come up with some uses for this.
5154400	5159040	You can actually do modular arithmetic or just more simply, remainders.
5159080	5166280	If you do x percent y, you'll get back the remainder of dividing x by y.
5166280	5167160	And what's the remainder?
5167160	5174800	So if x is 20 and y is 10, well, 20 divided by 10 goes in twice perfectly.
5174800	5177320	So remainder is 0, for instance, if it's been a while.
5177320	5179400	So notice what's curious here.
5179400	5182160	In this context, percent is not a placeholder.
5182160	5182800	It's not percent s.
5182800	5183520	It's not percent i.
5183520	5184400	It's not percent f.
5184400	5187600	Notice it's not inside of printf's format string.
5187600	5190640	This is just literally math, a math operator,
5190640	5192960	as is implied by the different color blue there.
5192960	5196320	So if I actually run this, let's go ahead and run this program.
5196320	5199960	I'm going to go ahead and make ints plural, because that's the name of the file.
5199960	5202240	Enter dot slash int.
5202240	5205120	And let me zoom in and clear the screen.
5205120	5206160	Enter.
5206160	5208000	Give me a number.
5208000	5208880	2, I heard.
5208880	5210960	And another.
5210960	5212360	10, I heard.
5212360	5216760	So fyi, 2 plus 10 is 12.
5216760	5218480	2 minus 10 is negative 8.
5218480	5219960	2 times 10 is 20.
5219960	5228240	2 divided by 10, 2 mod y, or 2, and then take the remainder when dividing by y
5228240	5230960	is what mod means, is 2.
5230960	5234800	So I get like 4 out of 5 for correctness.
5234800	5236400	What's a little funky here?
5237400	5246320	Yeah, like 2 divided by 10, I'm pretty sure that's like 2 tenths, or maybe 1
5246320	5248000	fifth, or 0.2.
5248000	5250520	I mean, I'll take any number of answers, but not 0.
5250520	5251680	So what's going on?
5251680	5253360	Well, this is a matter of representation.
5253360	5258000	It turns out in a computer program, we decided in advance, I'm going to store ints.
5258000	5260720	OK, an int is something that does not have a decimal point.
5260720	5263320	And yet here I am, rather presumptuously,
5263320	5266880	trying to do 2, an integer, divided by 10, an integer,
5266880	5269080	and expecting something other than an integer.
5269080	5273240	No, like I literally am doing integer arithmetic.
5273240	5276240	So what's the computer apparently doing, just intuitively?
5276240	5281160	Why when dividing x by y, as I did in this line here,
5281160	5284560	or specifically in this example you proposed, 2 divided by 10,
5284560	5288680	where is my 2 tenths going?
5288680	5290600	Yeah, it's as though it's technically what?
5290600	5293240	It's supposed to be 0.2, or 0.2.
5293240	5295040	OK, that's actually the solution, right?
5295040	5298880	Because if it's 0.2, but integers can't store decimal points or anything
5298880	5300640	after them, what do you have left?
5300640	5302560	Just the 0 at the beginning.
5302560	5305520	So integer arithmetic is fine if you're working with integers,
5305520	5307800	but if you want floating point arithmetic,
5307800	5309760	you're going to need to make some changes.
5309760	5311280	And so I can fix this.
5311280	5314480	In fact, let me go ahead and write a different program here.
5314480	5319920	Let me go ahead and open up from the course's website, floats.c.
5319920	5323520	And that's going to give me this example, which
5323520	5327000	is implemented using floating point values instead.
5327000	5329720	So once this loads, I'm going to see a program I wrote in advance.
5329720	5333560	It's a little shorter, because now I only care about looking at one problem.
5333560	5336720	And notice now, x and y are now floats and not ints.
5336720	5339440	Another data type that exists, and I'm using get float, which also comes
5339440	5340920	from CS50's library.
5340920	5345040	And then this line is almost the same, but let me tweak this.
5345040	5346840	Let me just make it exactly the same.
5346840	5350920	This line now that I've highlighted is exactly the same as before.
5350920	5354760	So if I do type in the same number, so let's go ahead and zoom in and do
5354760	5361040	make floats plural and dot slash floats, I'll give it 2 and 10.
5361040	5364240	And I should hopefully see what now?
5364240	5365320	0.2.
5365320	5368000	Yeah, OK, that's pretty good, pretty precise.
5368000	5370320	But you know what?
5370320	5375560	I hate to tell you, but let's look a little farther.
5375560	5378000	It turns out, by default, when you do percent F,
5378000	5381880	you only see a few decimal places, like five or so it looks, by default.
5381880	5383440	Let me see a few more.
5383440	5389920	So this was 1, 2, 3, 4, 5, 6 points after the decimal point.
5389920	5390640	So you know what?
5390640	5393280	I'm going to say, hey, computer, give me seven decimal points.
5393280	5395200	This looks completely cryptic, and you just
5395200	5397720	have to kind of remember this or look it up if you forget.
5397720	5401480	If you put a dot and a number in between the percent and the F,
5401480	5404680	that's the cryptic way of telling the computer, show me a float,
5404720	5406600	but with this many decimal places, please.
5406600	5410280	So that just gives me seven decimal places, weird as the expression looks.
5410280	5413080	All right, hopefully, I'm just going to see some more zeros.
5413080	5415440	So let me go ahead and make floats.
5415440	5420880	And let me go ahead and zoom in and do dot slash floats, 2, 10, enter.
5420880	5423600	OK, still correct.
5423600	5426080	Let me get a little curious.
5426080	5429000	Let's see a lot of zeros, like 50 of them.
5429000	5433440	Let me go down here and do make floats, because I changed the code,
5433480	5437760	dot slash floats, 2, 10.
5437760	5439480	Ha!
5439480	5442000	Your grade school teachers lied to you.
5442000	5450400	2 divided by 10 is apparently not 0.2000000 infinitely.
5450400	5461160	It's apparently 0.2000000298023223876953125, and then all of those zeros.
5461200	5463800	What the hell is going on?
5463800	5465000	Where's the bug?
5465000	5466080	Where's my mistake?
5466080	5467280	Where's my misunderstanding?
5470280	5473920	What's the explanation for this?
5473920	5479040	Well, what if I told you that inside of your computer is stuff like this?
5479040	5480560	This is RAM or memory.
5480560	5482280	And you've probably generally known this idea, right?
5482280	5485960	They store files to store music and videos, like you need memory,
5485960	5488640	some kind of space, hard disk space is permanent storage.
5488640	5491960	RAM or random access memory is temporary storage.
5491960	5495880	So when your laptop is open or your desktop computer is on or your phone is powered,
5495880	5498400	you're using RAM for all of the programs you're running at once.
5498400	5501120	So if you open a file, that file is stored in RAM,
5501120	5502840	but it's permanently stored on your hard drive.
5502840	5504320	So there's different types of memory.
5504320	5505960	But notice this is zoomed in.
5505960	5510000	In reality, this is like a couple of inches wide and maybe an inch tall.
5510000	5513080	So it's pretty small, but it doesn't really matter how big it is.
5513080	5515680	It just matters that it's finite in size.
5515680	5519080	You have physical hardware on your laps or in your pockets or at home
5519080	5522640	that only are so big and therefore only have so many parts
5522640	5527000	and therefore only have so many transistors and other pieces of hardware
5527000	5529520	that's actually doing the work of storing information.
5529520	5532920	And so if you only have a finite amount of memory,
5532920	5538960	how in the world are we going to represent an infinite number of numbers?
5538960	5540800	Because I do recall from grade school I was taught
5540800	5543360	there's an infinite number of numbers, certainly real numbers,
5543360	5545680	where the decimal point can go on forever.
5545680	5549360	That is a problem if you want to represent all possible numbers
5549360	5555400	in the universe, which is infinitely many, with a finite amount of hardware.
5555400	5559880	So at some point, the computers got to start cutting some corners.
5559880	5563600	And so what you're really seeing here is as close as the computer
5563600	5567480	can get to storing that fraction for you precisely.
5567480	5568480	And I got a little greedy.
5568480	5570680	I looked a little too far to the right.
5570680	5573720	And granted, these are infinitesimally small values.
5573720	5575760	It's not hugely, hugely off.
5575760	5578200	But it is off, because I can't expect the computer
5578200	5582120	to represent an infinite number of values using a finite amount of memory.
5582120	5587680	It's got to kind of round off here or there and be imprecise, so to speak.
5587680	5588680	So is this a problem?
5591840	5594400	I mean, we would never have known this if I hadn't gotten greedy
5594400	5599400	and looked at 50 decimal places instead of 7, which was already pretty precise.
5599440	5600200	Is this a problem?
5602680	5603180	Yeah?
5603180	5604480	Like why?
5604480	5604980	Why?
5608820	5609320	Yeah.
5609320	5610020	That's a good one.
5610020	5614160	Logically, if I start using equals equals to compare things for equality,
5614160	5617680	it's going to be really hard for me to ever compare something for too tense
5617680	5620760	as its value, because I'm going to literally have to remember or write
5620760	5623840	down or figure out this value and compare against that and not just
5623840	5625880	compare more loosely against point two.
5625880	5626640	And that's true.
5626640	5630960	You should actually never compare floating point values in code for equality.
5630960	5633960	I could probably get away with less than or greater than,
5633960	5638080	but even then, it's going to be a little off from what I expect.
5638080	5640160	Why else might this imprecision be worrisome?
5643520	5646560	When might you not want your computer being imprecise?
5646560	5647360	What domains?
5647360	5649080	What worlds outside of a classroom?
5649080	5650080	Yeah?
5650080	5652240	What's that?
5652240	5654160	Yeah, so rockets, right?
5654160	5657960	Are there anything involving math and physics and danger?
5657960	5661560	Like, you don't want numbers to be ever so slightly off.
5661560	5663720	And if you think about it, rockets is a good example,
5663720	5667040	because I don't know much about rockets, but I know they go pretty fast.
5667040	5668940	And there's probably angles involved, because you're
5668940	5670600	trying to keep them on a trajectory.
5670600	5671440	And that's fine.
5671440	5673440	But if your trajectory is ever so slightly off
5673440	5676000	and something's going really fast and really far,
5676000	5680840	I'm pretty sure that eventually, those small imprecisions start to add up.
5680840	5683560	And indeed, there's been historical incidents
5683560	5685960	where that kind of imprecision does, in fact,
5685960	5689880	add up in the realm of militaristic operations or in financial operations.
5689880	5692280	In fact, if you've ever seen Office Space or way back when,
5692280	5695040	like Superman 3, this is how some people made some money,
5695040	5699280	because they just kind of kept all of the fractions of pennies
5699280	5703160	that computer systems were just ignoring, and eventually, they start to add up.
5703160	5706920	So long story short, any time you have scientific or financial
5706920	5711040	or any sort of large data sets that involve big numbers and lots of them
5711040	5713360	and lots of time, this is a problem.
5713360	5717000	And it almost suggests you shouldn't use C or let alone computers
5717000	5718440	unless we actually address this.
5718440	5721440	Now, as a spoiler, humans have chipped away at this problem.
5721440	5726160	And you can use more and more bits, but not infinitely many bits.
5726160	5727920	At some point, you have to draw a line.
5727920	5730920	But this is why, for instance, the stock exchange might only represent
5730920	5733840	two decimal points of precision for dollars or maybe four decimal points
5733840	5736280	to the thousands place for dollars and cents.
5736280	5739000	And they just have to decide, that's all the precision we can actually
5739000	5739840	store precisely.
5739840	5743600	But you've got to decide how to handle it and not just ignore the problem.
5743600	5744960	But we can do a little better.
5744960	5745720	You know what?
5745720	5748480	It turns out that in most computers, a float,
5748480	5751360	it takes up, yes, a finite amount of space, but very specifically,
5751360	5754240	32 bits of space or four bytes.
5754240	5755680	A byte, recall, is eight bits.
5755680	5757480	So four bytes is 32 bits.
5757480	5759800	And that's just a very common unit of measure.
5759800	5760880	But there's another one.
5760880	5763680	Turns out, if you want twice as many bits,
5763680	5767240	you can literally use a data type called double.
5767240	5771800	And in the CS50 library, there is a function called get double.
5771800	5778080	And if I go ahead and do it here, I can now recompile this code, make floats,
5778080	5781080	even though they're not technically float types anymore.
5781080	5784440	And let me go ahead and do dot slash floats, enter.
5784440	5786960	And let me type in 2 and 10.
5786960	5789720	And now it's still imprecise.
5789720	5793040	But notice, instead of seven zeros, which I think I had before,
5793040	5799240	now I've got 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 zeros.
5799240	5802320	So I've kind of pushed the problem further out, so to speak.
5802320	5804440	So it's more precise, but it's not perfect.
5804440	5806760	Can't get certain values perfect if you want
5806760	5810000	to be able to represent an infinite range.
5810000	5813760	Any questions, then, about this?
5813760	5815440	We'll come back as to some implications.
5815440	5815940	Yeah?
5815940	5816480	Yeah, here.
5816480	5820920	So would it be better to double the size?
5820920	5821440	Good question.
5821440	5824120	Would it always be better to use doubles because they're more precise?
5824120	5825240	Short answer, yes.
5825240	5827720	But we're going to see thematically in this course in computer science
5827720	5829640	more generally, there's always a trade-off.
5829640	5833920	And yes, if you use a double, you will avoid this problem a bit more.
5833920	5836760	But what price will you pay, so to speak?
5836760	5839600	Maybe processing power, because it's got to deal with more bits at once.
5839600	5842920	And even more, literally, more space.
5842920	5844840	I mean, sure, we can take your solution, but I'm
5844840	5846400	going to charge you twice as many bits.
5846400	5849520	And back in the day, decades ago, when C was first being invented
5849560	5853400	and computers were really coming into play, spending twice as many bits,
5853400	5856080	even if it's only 32 more tiny zeros and ones,
5856080	5858360	that was actually expensive, literally, financially.
5858360	5859120	And it adds up.
5859120	5861840	And even today, if you want to spend more space, that's fine.
5861840	5864280	But you're going to spend more space, therefore more money,
5864280	5866520	and therefore have less space available for other things.
5866520	5867560	So it's just a trade-off.
5867560	5871760	And you have to decide as an intelligent human
5871760	5875360	where the right inflection point is between what's more important.
5875360	5878800	Let me open up a very different example now called parity.
5878800	5881360	Just as an example, and let me ask this question,
5881360	5886480	how do you know if a number is even or odd?
5886480	5888880	What's the trick?
5888880	5893200	If it's divided by 2, so 0, and 2, and 4, and 6 are even,
5893200	5895920	because if you divide by 2, you don't get a remainder.
5895920	5898360	So actually, if you just want to see a quick example of why
5898360	5900880	you might use a remainder, even though it's out of context,
5900880	5902200	here's an example for parity.
5902200	5906000	Parity is just a term referring to even or odd in this context.
5906000	5907120	How might we use this?
5907120	5910320	Well, notice I can get an in from the user up at the top.
5910320	5912240	I can then check the parity of the integer.
5912240	5914160	Is it even or odd with syntax like this?
5914160	5916640	Now I'm kind of combining some of these operators
5916640	5918360	as you might be inclined intuitively.
5918360	5923680	If n, the number the user typed in, mod 2, or divided by and then
5923680	5927240	check the remainder of, but that's a mouthful, equals equals 0,
5927240	5931600	you just said it's an even number, so print even, else print odd.
5931600	5933280	Because what's the possible other remainder?
5933280	5935800	If you do n or any value divided by 2, you
5935800	5939040	might get a remainder of 0 or 1.
5939040	5942120	I only have to check for one of those, 0, because the else
5942120	5943640	implies the other thing.
5943640	5945400	So again, very simple example.
5945400	5947920	But honestly, all of us probably have an intuitive understanding
5947920	5949080	of what's even and odd.
5949080	5951440	A computer needs to be taught that, and so there's
5951440	5953680	a program that does exactly that.
5953680	5957000	Let me open up a larger program called Conditions.
5957000	5959840	And rather than type this one out because it's a few lines of code,
5959840	5963240	let me just open it up because it concludes exactly the code we
5963240	5967840	saw a little bit ago on the slide when we compared it to a similar C block.
5967840	5970480	In this program, in my main function, let
5970480	5972560	me focus on the first few lines there.
5972560	5976560	I have an int called x that I'm getting via get int.
5976560	5979240	Another int called y that I'm getting via get int.
5979240	5981680	And then I'm just doing some simple comparisons.
5981680	5983840	We saw this again when we compared it to scratch.
5983840	5987560	But this is quite simply that same code in context
5987560	5990600	rather than just seeing it statically on a slide.
5990600	5992040	So let me go ahead and compile this.
5992040	5993640	Make conditions.
5993640	5994140	Enter.
5994140	5995240	Seems to compile.
5995240	5998600	Let me zoom in and do dot slash conditions.
5998600	5999440	Enter.
5999440	6001400	x will be, say, 2 again.
6001400	6003040	y will be 10.
6003040	6004480	x is indeed less than y.
6004480	6008080	If I run it again and I can save time by hitting up through my history
6008080	6011600	and just hitting Enter, let's do 2 and 2.
6011600	6013600	And indeed, x is equal to y and so forth.
6013600	6016280	So again, just the exact same kind of code as before,
6016280	6018560	but now in the context of a working program.
6018560	6022160	What if I actually wanted to get user input kind of like our past student
6022160	6026360	did with getting yes or no answers to the Apple and the cupcake question?
6026360	6030760	Well, in answer.c, it turns out you can actually get textual input
6030760	6036160	from the user, perhaps a simple yes or no, or just y or n, for succinctness.
6036160	6038760	And in this case, if I just get back a single character,
6038760	6040800	turns out there's a separate data type for character.
6040800	6043880	If you don't want a whole string, like a whole word, or a paragraph,
6043880	6046040	or sentence, or whatever, you just want one character,
6046040	6048960	you can actually use what's called a char, or character.
6048960	6054760	And so here, I'm using one other function, appropriately named, called get char.
6054760	6058760	I'm storing it in a variable called c, because it's nice and succinct,
6058760	6060200	of type char.
6060200	6062280	And then notice this.
6062280	6065160	You might not have seen this syntax before, especially
6065160	6067680	if you've never programmed before, even in Scratch,
6067680	6070800	but you might have seen this block similar to this in Scratch.
6070800	6074920	What does the vertical double bar probably imply here?
6074920	6075760	Or that's it.
6075760	6077480	So in Scratch, it's nice and user-friendly.
6077480	6078760	They literally just say, or.
6078760	6080640	In programming, it's often the case that you
6080640	6083080	use just more cryptic sequences of characters,
6083080	6086880	and two vertical bars, which are typically above the Enter key on a US
6086880	6092280	keyboard, if c equals equals capital Y or c equals equals lowercase y,
6092280	6096160	let's assume that the user wanted to say yes, and go ahead and say yes.
6096160	6099960	Else, if the user typed in n in capitals or n in lowercase,
6099960	6103080	let's assume he or she meant no, and say no accordingly.
6103080	6105840	And what are we going to do otherwise?
6105840	6106800	Apparently, nothing.
6106800	6107640	And that's fine.
6107640	6110840	You don't need to have a default case if you want the program to do nothing.
6110840	6115000	Might be a little confusing, because the user is going to type in some random word
6115000	6117360	and get no output, but that's a design decision.
6117360	6120520	Logically, this is just how we might express this.
6120520	6126920	What about actually building our own blocks?
6126920	6131640	Any questions, though, before we start to create?
6132000	6135640	So recall that in Scratch, we had that cough example.
6135640	6140960	Let me go ahead and create a file here real quickly called cough0.c,
6140960	6143360	and just kind of recreate what we did last week,
6143360	6148600	include standard.io.h int main void, again, just muscle memory now,
6148600	6153680	and then printf quote unquote cough backslash n semicolon.
6153680	6154200	And you know what?
6154200	6158440	Let me go ahead and cough not once, but twice, three times.
6158440	6163200	The moment you start copying and pasting, you're probably not writing good code, right?
6163200	6164280	It's not very maintainable.
6164280	6166800	Now if I want to change the word or translate it to another language,
6166800	6168160	I have to change it in three places.
6168160	6170600	We already decided last week that was bad.
6170600	6176560	So what would be better in C or in Scratch or in general than this approach?
6176560	6177840	Yeah, so like a for loop.
6177840	6178480	So let me do that.
6178480	6180000	Let me create another file.
6180000	6183640	I'm going to call this one cough1.c is my second version.
6183640	6187320	Let me go ahead now and just copy and paste the original code.
6187320	6188320	And let's just improve it.
6188360	6190120	Let's get rid of two of these.
6190120	6192000	And let's see if we can't express the four.
6192000	6193880	So it was four.
6193880	6195240	Let me zoom in.
6195240	6197400	int i gets 0.
6197400	6199000	i is less than some number.
6199000	6199920	Before it was 50.
6199920	6201640	Now I'm going to have it be 3.
6201640	6205040	i plus plus curly braces.
6205040	6209840	And now let me move the cough block inside of there and indent it just to be pretty.
6209840	6214360	And notice stylistically, I've been doing this sort of instinctively for some time.
6214360	6217520	Everything's nicely indented just to make it more readable,
6217520	6220480	quite like the Scratch blocks, even though, again, a lot of that white space
6220480	6222440	doesn't matter to the computer.
6222440	6226880	So if I go ahead and run this, let me pull up the terminal window so I can see it.
6226880	6233680	Make cough1 enter, looks good, dot slash cough1, cough, cough, cough.
6233680	6235000	OK, that's good.
6235000	6239280	But recall that we actually improved this design further by abstracting it away.
6239280	6241560	Let me go ahead and make my own function now.
6241560	6247800	Let me go ahead and open up a new file, cough2, cough2.c,
6247800	6250800	just like I had another Scratch program.
6250800	6256000	Again, include standard io.h int main void.
6256000	6262400	And then in here, let me go ahead and do what?
6262400	6270720	Well, for int i gets 0, i less than 3, i plus plus plus curly braces.
6270720	6273360	Then let me go ahead and just call cough.
6273360	6275000	It would be nice if cough existed.
6275000	6276600	But unfortunately, cough does not exist.
6276600	6279560	It's not in the CS50 library even, so that's not going to help us.
6279560	6281680	I have to make my own function.
6281680	6284600	So in Scratch, you went to the blocks thing, and you make your own block,
6284600	6287160	and the big prompt comes up, and you make your new puzzle piece.
6287160	6289160	Here, we're going to have to be a little more deliberate.
6289160	6292680	And it turns out you can do it like this.
6292680	6295080	Some of these details will be non-obvious at first.
6295080	6297760	But I'm going to go ahead and call the function cough.
6297760	6300640	And cough, at the moment, does not need to take any input.
6300640	6303720	So the keyword there is void, and we've actually seen that before.
6303720	6305560	Main also has not been taking any inputs.
6305560	6308600	That's why we had the word void, but more on that another time.
6308600	6310640	And cough is not going to return anything either.
6310640	6312920	It's going to print on the screen, just like Brian did.
6312920	6315560	But Brian recall didn't hand me anything back physically,
6315560	6317160	so there's no return value.
6317160	6320400	So I'm going to say void to the left of cough.
6320400	6324480	So for today's purposes, this just means that cough neither takes input
6324480	6326560	nor returns a value as output.
6326560	6327480	That's it.
6327480	6328640	Void void.
6328640	6331520	Now, as the body of that function, so to speak,
6331520	6336320	I'm just going to go ahead and say, quite simply, cough backslash n semicolon.
6336320	6337000	That's it.
6337000	6339600	So now I have a puzzle piece, if you will, whose purpose in life
6339600	6343720	is to cough, which means now I can magically just call it by its name
6343720	6346560	up here as many times as I want.
6346560	6348480	So let's go ahead and compile this.
6348480	6349600	I'm really on a good roll.
6349600	6351360	Everything's been working out great so far.
6351360	6352720	Make cough to enter.
6352720	6356040	Ugh, ugh, red errors.
6356040	6359640	So this is interesting, and this kind of reminds me of the previous error.
6359640	6363120	So first of all, what line is my error on?
6363120	6365240	OK, 7 in character 9, if you care.
6365240	6367280	But it's 7 on line 7.
6367280	6370880	Implicit declaration of function cough is invalid in C99.
6370880	6375320	C99 is referring to, literally, 1999 when this version of C was invented.
6375320	6381000	And so implicit declaration of function cough, but it's right here.
6381000	6385320	OK, wait a minute, let me, uh, instinct, let me just move this, right?
6386120	6387440	Let me just put it up top.
6387440	6388800	Let's see what happens.
6388800	6393280	Make cough to, oh my god, that fixed it.
6393280	6395040	Why?
6395040	6396840	Like, even if you've never programmed before,
6396840	6399680	just kind of reason through intuitively why this solves something.
6404680	6405160	Exactly.
6408720	6409720	Exactly.
6409720	6414400	Because I previously was trying to use cough early on on line 7,
6414440	6418320	but I was only teaching the computer what cough was farther down in the file.
6418320	6419560	Frankly, C is kind of dumb.
6419560	6422040	It literally reads your code top to bottom, left to right.
6422040	6425200	And if you try to do something before you've taught the computer how to do that,
6425200	6427840	you're going to get that kind of undeclared identifier,
6427840	6430280	because it just doesn't know what the word is yet.
6430280	6431720	Now in Scratch, this isn't a big deal.
6431720	6433640	You just move the puzzle pieces anywhere you want.
6433640	6436560	Order of blocks physically on the screen does not matter.
6436560	6437800	But in C, it does.
6437800	6442560	But frankly, this seems a little annoying that now the main program here
6442600	6444840	kind of keeps getting pushed farther and farther down.
6444840	6447520	The more kind of complexity I want to add to my program.
6447520	6449160	So there's another solution.
6449160	6451480	Let me actually go ahead and put this back where it is,
6451480	6453600	because I'm a little sort of particular.
6453600	6456080	I just like, by convention, main to be at the top.
6456080	6458120	And frankly, that's kind of good style.
6458120	6460840	If main is the most important function in your program by default,
6460840	6465000	because it is the main function, and it's what gets called, per earlier,
6465000	6468760	by default by the computer, why am I going to push it all the way down
6468760	6471680	just to work around this stupid detail?
6471680	6476280	Well, I just need to teach the computer what the function is.
6476280	6481840	And I can do that a little redundantly by just saying this.
6481840	6485320	This is what we're going to call the prototype for a function.
6485320	6490000	If you literally just copy the very first line of it that has its name,
6490000	6494640	its inputs, if any, and its output, if any, that's a prototype, semicolon.
6494640	6496920	It's literally copy-paste from the function itself.
6496920	6501840	But this is now enough of a hint to say, hey, computer, this shall exist.
6501840	6504480	This is enough information for you to then call it,
6504480	6508840	because the computer, so long as it has seen the function's name before,
6508840	6514680	it's OK if the 0s and 1s, so to speak, that implement it come a little later.
6514680	6518040	And so that's the more conventional way to solve that problem.
6518040	6524960	So just intuitively then, take a guess if it's not too much of an indirect leap,
6525000	6527680	what is in standard.io.h?
6527680	6529520	What is in CS50.h?
6533480	6534800	We'll call them declarations.
6534800	6539640	So literally, in standard.io.h is a line of code
6539640	6543160	that teaches the computer what printf's inputs are
6543160	6545320	and what printf's output is, if any.
6545320	6547680	In CS50.h, there's literally an line of code
6547680	6551800	that tells the computer what getString's input is and what its output is.
6551800	6555720	And the same for getInt and getFloat and getChar and others.
6555720	6557720	That's all that's in those header files.
6557720	6560480	The 0s and 1s, so to speak, are actually in files literally called
6560480	6565600	standard.io.c and CS50.c, although that's technically source code.
6565600	6568880	The 0s and 1s are in a compiled file elsewhere on the system.
6568880	6571400	But all of these things we've kind of been taking for granted,
6571400	6573120	now hopefully it makes a little more sense,
6573120	6575720	because the fact that I'm doing the sharp include at the top,
6575720	6577360	that's just a solution to a problem.
6577360	6581400	In that file is enough information to teach the computer what printf
6581400	6585000	or what getString and other things are so that I
6585000	6589840	don't need to bother moving things around myself or copying and pasting
6589840	6593200	whoever wrote printf his or her code into my program.
6593200	6595680	Now let's do one final example with coughing.
6595680	6598600	And go ahead and call this cough3.c.
6598600	6601840	And go ahead and paste my same code as a moment ago just to get us started.
6601840	6605120	And recall that the last step of our cough example last week
6605120	6606920	was to actually give cough an input.
6606920	6611520	I'd kind of like to whittle this code down to literally cough3,
6611520	6613760	because this is a really nice abstraction.
6613760	6617680	I don't want main to have to think about how many times to just cough three times.
6617680	6620120	That's a nice, useful human abstraction.
6620120	6622680	Now let's put the functionality down here.
6622680	6627160	So if I want cough to be able to tolerate an input like three,
6627160	6630040	which mentions avoid presumably needs to change?
6630040	6632160	The one on the left or the right?
6632160	6634120	The right, the one inside the parentheses.
6634120	6638600	And it turns out, just like you can declare variables inside of a function,
6638600	6643560	as we've done, so can you declare arguments to a function like this.
6643560	6646520	So you can call it anything you want, though the data type matters.
6646520	6650720	But this is now saying, hey, computer, cough does not return a value,
6650720	6653160	like Aaron did return a piece of paper.
6653160	6656160	Hey, computer, cough does take one input.
6656160	6658400	It's an integer, and just call it n.
6658400	6661960	And now that you've done this, now you can have a line of code in here like this.
6661960	6670720	For int i gets 0, i is less than n, i plus plus plus plus plus.
6670720	6674120	And then, OK, off by keystrokes here.
6674120	6677080	Then I can move this inside here, indent it nicely.
6677080	6679960	And now notice all of the complexity of coughing
6679960	6683320	has been factored out into a function, my own puzzle piece, if you will,
6683320	6687240	that even takes an argument so that now you can literally,
6687240	6689280	if I move this far away and out of mind,
6689280	6692040	now your program is getting pretty interesting,
6692040	6694360	because it really just does what it says.
6694360	6697840	And this is a nice functional abstraction, if you will,
6697840	6703000	so that now I have a new verb, a new action, a new function called cough.
6703000	6704920	Any questions on that one?
6704920	6707400	Yeah?
6707400	6708120	Sorry, say again?
6708120	6710000	What integer with main return?
6710000	6711240	What integer with main return?
6711240	6712840	It turns out, and we'll come back to this,
6712840	6715080	it's going to return 0 almost always by default.
6715080	6718040	But that leaves you with almost an infinite number of non-zero values,
6718040	6720640	which represent all of the many things that can go wrong.
6720640	6723680	So more on that when we start creating more mistakes.
6723680	6725080	Let's look at one other.
6725080	6730440	Let me go ahead and open this file in advance myself called positive.c.
6730440	6734200	Suppose that I'm not content to just have access to get int.
6734200	6736400	I want a function called get positive int,
6736400	6739400	because for whatever reason, my program, my game, my whatever,
6739400	6740720	needs to know a positive value.
6740720	6743040	Maybe I'm asking the user how many players are there.
6743040	6744320	And that shouldn't be negative.
6744320	6746960	It should be a positive integer, like one or two or more.
6747000	6751840	So it turns out, I could write a program, if I want, that looks like this.
6751840	6757600	Call on this line here a function called get positive int, pass it in a prompt,
6757600	6761080	and then store the value still in an integer on the left hand side.
6761080	6763600	And then just go ahead and print it out.
6763600	6768000	Get positive int has this prototype at the top of the file.
6768000	6771880	Notice this is not a function that comes with CS50's library, CS50.h.
6771880	6774040	The function is called get positive int, as you would hope.
6774040	6775160	It returns an int.
6775160	6779880	And it takes a string as its prompt, whatever words you want the human to see.
6779880	6781560	Let's scroll down now.
6781560	6783800	And this one looks a little more involved.
6783800	6787880	And this is not a feature that Scratch has, but let's take a look.
6787880	6790800	The first line is identical to the prototype,
6790800	6792640	because I literally copied and pasted it.
6792640	6796320	Everything between these brackets is the function itself.
6796320	6798880	And here, to answer someone's question from earlier on,
6798880	6802400	do you have to declare a variable and then use it right away?
6802400	6803040	No.
6803040	6806600	And that's actually a helpful solution to a problem that we'll see in a moment.
6806600	6809440	Notice here, this new keyword, didn't see it before,
6809440	6813840	do the following while n is less than 1.
6813840	6816160	Previously, we saw a while loop.
6816160	6817600	And we saw a for loop.
6817600	6819320	We did not see a do while loop.
6819320	6823160	And a do while loop, well, it sounds obviously similar to a while loop,
6823160	6824920	what seems a little different?
6824920	6829640	When I had that forever block earlier translated to while true,
6829640	6832440	what was the order of operations?
6832440	6836000	Did we check the condition, the true, and then print hello world?
6836000	6840520	Or did we just print hello world and then check the condition?
6840520	6843080	Yeah, you might not recall precisely, but I did actually.
6843080	6844920	I checked is true, true.
6844920	6846560	And we all said yes, obviously.
6846560	6849680	Printf is a true, printf is a true, printf.
6849680	6851840	So check the condition first.
6851840	6854880	You might infer then this loop is a little different.
6854880	6856680	It has another word, do.
6856680	6861720	This is literally going to do this first, and then check the condition,
6861720	6863960	and only do it again if the condition is true.
6863960	6867240	So it's a nice way of just flipping things around in terms of order
6867240	6871960	to do something at least once, rather than potentially never at all,
6871960	6873360	like was the case earlier.
6873360	6874800	So what are we doing?
6874800	6877800	Get an int, passing in this prompt, stored an n.
6877800	6881080	And if the user types in a value that's less than 1,
6881080	6885120	is this going to be true or false if n is less than 1?
6885120	6889960	So if n is like if the human type's in 0, is 0 less than 1?
6889960	6890600	True, yes.
6890600	6891560	So what happens?
6891560	6894240	You go back to the do, and you do it again.
6894240	6897560	If the user types in negative 1, is negative 1 less than 1?
6897560	6898680	Yes, or true.
6898680	6899680	So you do it again.
6899680	6904240	If he or she types in negative 2, again, what if he or she types in 50?
6904240	6906440	Well, 50 is not less than 1.
6906440	6908120	So this is false.
6908120	6911440	And so then you proceed to the next line of code altogether.
6911440	6913480	But what's interesting about the next line of code
6913480	6918520	is that unlike the cough example, which had void as its return type,
6918520	6921200	get positive int by default is supposed to return an int.
6921200	6924920	Just like, again, Aaron handed me a piece of paper with a string on it.
6924920	6928880	And so here, if I want my own custom function called get positive int
6928880	6930880	to return a value, there's another word in C.
6930880	6935320	You literally write return, and then the name of the variable, or the value,
6935320	6939200	that you want to hand back on a metaphorical piece of paper,
6939200	6942160	to whatever code is using this.
6942160	6944120	So what's this oddity?
6944120	6947560	Why can I not do this?
6947600	6952480	If I were to mimic the code we wrote earlier, like this,
6952480	6956200	why does this line of code not work just logically,
6956200	6960720	using some of the sort of mental model that we've had thus far?
6960720	6962720	Say again?
6962720	6963720	Say again?
6963720	6965440	Yeah.
6965440	6968640	So declaring just means creating is the fancy way in programming of saying creating.
6968640	6970840	So this says, hey, computer, give me an integer.
6970840	6973880	Call it n and set it equal to the return value of get in.
6973880	6977760	So whatever the function, or Aaron, hands me back, put it over here.
6977760	6981560	But the problem is that in C, variables have scope.
6981560	6987120	Scope is a fancy way of saying they only exist in between the curly braces
6987120	6989000	between which they were declared.
6989000	6993440	So that means that this line, this variable, n, literally only exists
6993440	6996760	between here and here, and then it just kind of goes away.
6996760	6998680	The computer doesn't know about it anymore.
6998680	7001520	But that's a problem, because on what line number do we actually
7001520	7004880	need to know n?
7004880	7008080	Looks like 21, and that's outside the curly braces.
7008080	7010560	So just based on that basic definition, scope
7010560	7013200	is the two curly braces between which a variable is declared.
7013200	7014520	It doesn't exist outside of them.
7014520	7016600	This code just won't work, and I'll fix it later
7016600	7018320	so that you see the correct error message.
7018320	7019640	Why does this not work?
7019640	7022480	Well, you're declaring n inside of those curly braces.
7022480	7023760	So how do you avoid this?
7023760	7026200	Well, it turns out, as someone deposited earlier,
7026200	7029760	just declare it by itself without even giving it a value.
7029800	7033360	And indeed, the syntax for that is just to do half of a thought.
7033360	7034840	Int n semicolon.
7034840	7036760	It has no value that we know yet.
7036760	7039360	It has a garbage value, but more on that another time.
7039360	7040360	But it does now exist.
7040360	7044840	And now notice which curly braces does it exist within this one
7044840	7047920	and this one, which means now it's accessible everywhere.
7047920	7050520	And if you and your Scratch programs actually used variables,
7050520	7052160	you might have noticed that you had to choose.
7052160	7056040	You had to make a decision for this sprite or for all sprites.
7056040	7061680	That was an illusion to what's called in programming a local or a global variable.
7061680	7064280	These are still local, and we'll come back to this term earlier.
7064280	7066320	But it has to do with scope, because if you
7066320	7068920	had specified for this sprite only, MIT
7068920	7072360	would have only let you use that variable for that specific sprite,
7072360	7075760	that cat, or sheep, or whatever it was you were programming.
7075760	7080920	Just as in C, this now means n can be used here and here, but not elsewhere,
7080920	7083240	like higher up in my program.
7083240	7086200	That's the matter of scope.
7086200	7089800	So let's now see what can go wrong beyond that.
7089800	7094240	Let me go ahead and open up this, because it turns out, when programming,
7094240	7097840	there's other issues that can happen, not just floating point in precision,
7097840	7099520	as I described it as earlier.
7099520	7102920	It turns out that there's other problems that can go wrong,
7102920	7105880	even with integers, that we kind of avoid it all together.
7105880	7108160	So recall that we started talking about 1, 2, and 3,
7108160	7110560	and why it's 123 last week.
7110560	7114400	Well, what happens in decimal if you add 1 to 123?
7114400	7115840	What number do you get?
7115840	7117000	Obviously, 124.
7117000	7120520	If we do it again, 125, 26, 27, 28, 29.
7120520	7125160	What happens in decimal if I add 1 to a 9?
7125160	7128520	Well, I should get 10, but that's not how we would write this.
7128520	7131680	You put down the 0 instead, and you carry the 1.
7131680	7134040	Remember those kind of mental heuristics?
7134040	7135200	So that's all we did there.
7135200	7140400	And then it's 2 plus 1, so that's why 129 plus 1
7140400	7143840	is 130, because you put the 0, you carry the 1, and so forth.
7143840	7145720	So we just all do that intuitively now.
7145720	7148440	But this has implications for what computers do, too.
7148440	7152160	Because suppose that we consider a bigger number, like 999.
7152160	7155920	And so what do you get when you add 1 to 999?
7155920	7160280	Well, you carry the 1, you carry the 1, and you get, hopefully, 1,000.
7160280	7165000	But what if your computer only has space for three digits?
7165000	7168120	Or what if your phone, or what if your alarm clock, or whatever the device is,
7168120	7171680	literally only has room for three digits?
7171680	7177840	What is 999 plus 1 if your hardware only has three digits?
7177840	7179320	Well, it's apparently 0.
7179320	7184720	So you get this kind of overflow, where 998, 999, 0.
7184720	7186320	It overflows, so to speak.
7186320	7190360	The 1 kind of falls off conceptually, and you roll over to the next value,
7190360	7192560	which is 0, 0, 0.
7192560	7194560	So what about in binary?
7194560	7198160	What number is this in binary if you translate it to decimal in your head?
7198160	7202720	And remember, it's the 1's column, the 2's column, and the 4's column.
7202720	7204600	So this was 7 in binary, 1.
7204600	7206440	So it's 4 plus 2 plus 1.
7206440	7208000	So 7 in binary.
7208000	7210080	So how do you do arithmetic with binary?
7210080	7211200	It's actually the same thing.
7211200	7215280	It's just you don't have 2's, or 3's, or 9's, or anything in between.
7215280	7216480	You just have 1's and 0's.
7216480	7220120	So what do you get when you add 1 to 111?
7220120	7221360	Well, it's the same idea.
7221360	7223320	You put down a 0, and you carry the 1.
7223360	7226680	Because 1 plus 1, you want to say 2 in decimal, but there is no 2.
7226680	7229040	So it rolls over to 0, but you carry the 1.
7229040	7231840	1 plus 1 is 2, but OK, that's 0.
7231840	7232760	Carry the 1.
7232760	7235600	1 plus 1, that's 2, but I don't have a 2, so I go back to 0.
7235600	7236320	Carry the 1.
7236320	7242520	So in binary, if you only have 3 bytes, or bits rather,
7242520	7247880	if you only have 3 bits, what do you get when you add 1 to 7 in binary?
7247880	7249360	You apparently get 0.
7249360	7250880	And now it's getting more real.
7250920	7253240	In my computer, in my phone, in all of your hardware,
7253240	7255680	it's just a finite amount of memory, RAM, that little chip
7255680	7258120	that I showed on the screen with all the little circuits.
7258120	7261400	And that has more than 3 bits of memory, certainly.
7261400	7262520	But it is finite.
7262520	7266040	And if we're only using, as a matter of convention, 32 bits to represent things,
7266040	7269320	or 64 bits, maybe if we use doubles, or something else called along.
7269320	7274520	Along is a 64-bit integer, whereas an integer is typically 32 bits.
7274520	7277920	It seems that at some point, numbers might overflow,
7277920	7281360	and we're going to actually have some, so to speak, imprecision.
7281360	7283280	Ergo, integer overflow.
7283280	7286560	So you can actually see this or defenses against this in the real world.
7286560	7289120	So this is a screenshot from a game that is
7289120	7290800	common on a few different platforms.
7290800	7294680	And it's a game that allows you to accumulate coins or points, really,
7294680	7296080	or little Lego pieces.
7296080	7297800	And if you accumulate these points, you'll
7297800	7300880	notice that eventually, if you have way too much free time,
7300880	7303800	you can only score so high in this game.
7303800	7306520	What's the highest score, apparently, according to the screenshot
7306560	7309240	from whoever took this after playing for too many hours?
7309240	7311320	Wasn't me.
7311320	7312440	Four million.
7312440	7313480	No, four billion.
7313480	7314640	Four billion.
7314640	7316000	Why is that?
7316000	7319520	Well, it turns out that if numbers and computers, as I've proposed,
7319520	7323080	are generally stored using 32 bits, that kind of invites the question,
7323080	7325000	well, how high can you count with 32 bits?
7325000	7328480	Well, 32 bits means you have 32 zeros and ones.
7328480	7331640	The biggest they could be is like 1, 1, 1, 1, 1, 32 ones.
7331640	7335360	And if you actually do the math using our little columns and so forth,
7335360	7338680	it's roughly four billion, a little bigger than four billion.
7338680	7341520	So the authors of this Lego game just decided, you know what,
7341520	7344240	let's just say that the maximum number of points or coins
7344240	7346880	you can accumulate in this Lego game is four billion even.
7346880	7347160	Why?
7347160	7351200	It just looks even cleaner than whatever the actual value is.
7351200	7352080	But why?
7352080	7356760	How many bits are they using to store your score in this game?
7356760	7360240	Presumably, 32 bits or four bytes.
7360240	7361200	And that's just convention.
7361200	7363400	Whatever language they program this game is,
7363400	7365560	it probably has a data type called an int.
7365560	7368440	And that int, by convention, uses 32 bits.
7368440	7371840	So at some point, they decide we can either use more memory,
7371840	7373280	as you proposed earlier, for doubles.
7373280	7374320	Let's use 64 bits.
7374320	7376600	Then you can have crazy numbers of hours playing the game
7376600	7377840	and getting more and more points.
7377840	7381120	Or we can just say, that's enough points to accumulate in the game.
7381120	7382920	Now, that's when you actually anticipate this.
7382920	7384880	This doesn't always actually happen.
7384880	7388800	If we go ahead and take a look at some example code,
7388800	7392840	let me go ahead and open up overflow.c.
7392840	7397720	In this program here, you'll see on line eight this slash slash syntax.
7397720	7400880	And I've had a bunch of these so far, but I haven't actually mentioned them.
7400880	7403120	Turns out in C, just like in Scratch, though odds are you
7403120	7405040	didn't notice this little feature of Scratch,
7405040	7406600	you can have what are called comments.
7406600	7409880	A comment is just a note to yourself, to your TF, to your friend,
7409880	7412600	to your colleague, whatever whom you're writing code with.
7412600	7416240	And it's just a note to self, like to remind yourself of what the code does.
7416240	7419480	Without this line, I could, once I'm comfortable enough programming,
7419480	7421560	kind of figure out what these lines of code are doing.
7421560	7423040	But frankly, that's a waste of time.
7423040	7424000	I wrote the code once.
7424000	7426640	And if I look at it weeks or months later or someone else wrote it,
7426640	7427880	just tell me what it does.
7427880	7432600	So a comment in a program is just like a nice summary of like a few lines
7432600	7436200	of code, or it's a summary in English or whatever spoken language that
7436200	7439960	kind of describes what otherwise a cryptic looking code might actually
7439960	7443360	be doing, so you don't have to think too hard about it to understand a program.
7443360	7445160	So iteratively, double I.
7445160	7448640	Iteratively, it just means loopingly, again and again and again.
7448640	7449440	This is funky.
7449480	7452640	We didn't see this before, but you might guess what it does.
7452640	7455560	What does star equals do?
7455560	7456280	It does double.
7456280	7460680	It's like plus equals adds 1, star equals doubles if the value on the right
7460680	7461400	is 2.
7461400	7466880	So this is going to start printing 1, then 2, then 4, then 8, and so forth.
7466880	7469360	And notice this function, it's called sleep.
7469360	7471440	It literally is going to sleep for a second.
7471440	7474240	And that sleep function has a prototype that someone else
7474240	7477520	wrote in a file called unistandard.h.
7477520	7479800	I only know that by looking it up in the documentation,
7479800	7482200	but that's a new file just for sleeping.
7482200	7485520	Make overflow, which is kind of apt here.
7485520	7488800	And let me go ahead and make the terminal window even bigger for this one.
7488800	7491960	Dot slash overflow.
7491960	7494720	OK, it's going.
7494720	7495280	It's going.
7495280	7497200	It's going to go faster and faster, so to speak,
7497200	7502480	because we're adding more and more each time by doubling.
7502480	7507560	All right, 2,000, 4,000, 8,000, 16,000.
7507560	7510920	Still going, 64,000, 65,000.
7510920	7512680	Now we're into the millions.
7512680	7516120	Two millions, four, eight, 16 million.
7516120	7518240	It's getting bigger and bigger.
7518240	7522120	All of these big numbers.
7522120	7524080	Ooh, interesting.
7524080	7526720	What just happened?
7526720	7529680	So it turns out if you double numbers big enough, you get zero eventually.
7529680	7531880	Also, something you probably weren't taught.
7531880	7532760	So what actually happened?
7532760	7534560	Control C will cancel this.
7534560	7535200	What happened?
7535200	7539120	I mean, the program's trying to tell me, even though it's a little cryptic,
7539120	7540440	signed integer overflow.
7540440	7543040	Sign just means it went from positive to negative, essentially.
7543040	7545800	So what happened?
7545800	7546800	What's that?
7546800	7547920	Yeah, I ran out of bits.
7547920	7550000	I'm doubling the number again and again and again.
7550000	7554360	And at some point, we carried the one, so to speak, and it was a 33rd one,
7554360	7556720	therefore past the boundaries of a 32-bit value.
7556720	7558680	And it just rolled over to apparently a negative,
7558680	7560760	because at some point, and we haven't talked about it,
7560760	7564400	we can use the leftmost bit, in some sense, to say positive or negative.
7564400	7566160	We've just talked about positive so far.
7566160	7568920	And then at that point, frankly, the computer just gave up, not really
7568920	7570960	knowing what you intended beyond that.
7570960	7574440	So if you don't write code to handle this situation
7574440	7578720	and make sure that your numbers are less than 4 billion before you roll over,
7578720	7580200	just bugs will happen.
7580200	7584680	And this might seem contrived here, but this happened not too long ago.
7584680	7588600	So 1999 was just before a lot of people thought the world was going to end,
7588600	7591240	because of the so-called Y2K bug.
7591240	7596040	And it really wasn't so much a bug, as it was lack of forethought or lack of features.
7596040	7598240	What was the Y2K problem in a nutshell?
7602200	7603400	Someone want to propose?
7603400	7604840	Even in a non-technical sense, yeah?
7604840	7605340	Yeah.
7605340	7608480	You're just going to display in the number 2000 a year.
7608480	7609320	Yeah.
7609320	7611680	Yeah, so let me summarize here.
7611680	7615160	So if they are only using two digits to display values,
7615160	7620080	you could confuse the year 2000 with actually the year 1900.
7620080	7624280	Because long story short, what humans did kind of reasonably decades ago was,
7624280	7626000	you know, space was expensive.
7626000	7627440	Computers were expensive.
7627440	7631400	Memory was not sort of as abundant as it is now with all the cloud storage
7631400	7632040	and the like.
7632040	7632920	So you know what?
7632920	7639000	If it was like 1970, do we really care about 1969, 1968, let alone 1900?
7639000	7639680	Not really.
7639680	7645080	Let's just assume we're all in the 1900s and never show or store 19.
7645080	7647200	Let's just store two digits for every year.
7647200	7648720	So 70 is 70.
7648720	7650840	99 is 1999.
7650840	7654320	But the problem is the humans ended up running code
7654320	7659400	that they wrote years ago, decades ago, way longer than humans thought they might.
7659400	7659760	Why?
7659760	7660560	Well, it's expensive.
7660560	7662080	It's time consuming to change code.
7662080	7662840	The code's working.
7662840	7664120	Why try to break it?
7664120	7668680	Problem is too, as people aged and passed away, there's fewer and fewer people.
7668680	7671600	They'd even knew the languages in which those programs were written.
7671600	7673760	And so now who's going to even update the software?
7673760	7676680	So lots of problems were feared.
7676680	7683560	And this really just boils down to because 1999 might have overflowed to not zero per se,
7683560	7686200	but an implicit 1900.
7686200	7688680	And indeed, this definitely happened, though not nearly on the scale,
7688680	7689680	as people thought.
7689680	7692440	But it does happen in even more real terms just a few years ago.
7692440	7696160	This is a Boeing 787, an actual airplane that
7696160	7701560	had to be grounded for some amount of time because it had a programming error.
7701560	7704760	And it summarized here in an online article.
7704760	7710720	A 787 airplane that has been powered continuously for 248 days, it turns out,
7710720	7716240	was the warning, can lose all of its electrical power due to the generator
7716240	7718320	going into failsafe mode.
7718320	7718960	Why is that?
7718960	7724080	This condition is caused by a software counter-internal to the generator
7724080	7729040	that will overflow after 248 days of continuous power.
7729040	7730600	So translate that.
7730640	7734560	That just means there's software running in the Boeing's actual 787s.
7734560	7736440	They were using 32-bit integers.
7736440	7739920	They were using those integers to store hundreds of seconds.
7739920	7745200	And at some point, if you leave your plane on for 248 days,
7745200	7750240	each of which has 24 hours, 60 minutes in an hour, 60 seconds in a minute,
7750240	7755120	and 100 tenths of a second, or 100 one hundredths of a second,
7755120	7760200	in every second, that product of multiplying things out gets big pretty fast.
7760200	7765080	And on day 249, planes, theoretically, would shut down even
7765080	7767520	in the middle of flight for very real reasons,
7767520	7771240	because a really big number rolls over to zero and that confused the generator.
7771240	7776720	These are actual smart airplane engineers making these kinds of mistakes
7776720	7780120	because of software, not anticipating one line of code or some number of lines
7780120	7783320	of code, or as you proposed, why didn't they just use more bits?
7783320	7785360	And again, these are very real concerns.
7785360	7788400	So this was, thankfully, addressed and solved, but not before.
7788400	7790760	Of course, there was quite the scare there.
7790760	7795040	So it turns out in an older game, this was the game of civilization,
7795040	7798480	turns out that one of the characters, as whom you can play, Gandhi,
7798480	7802560	is actually not as peaceful a character in the game as you might think.
7802560	7805320	And let's, for context, just take a look here for a second.
7805320	7810040	If we actually take a look at some more binary,
7810040	7813680	this in binary is what number in decimal?
7813680	7814480	OK, one.
7814480	7815720	And this is 8 bits.
7815720	7816840	So it's a full byte.
7816840	7817640	8 bits is a byte.
7817640	7820000	1, 2, 3, 4, 5, 6, 7, 8.
7820000	7826760	So what do you get if you subtract 1 from this?
7826760	7828440	You obviously get what?
7828440	7829160	OK, all 0.
7829160	7830920	So 1 minus 1 is just 0.
7830920	7835280	What if you subtract 2 from this value?
7835280	7837360	What happens?
7837360	7840440	This is actually called integer underflow, which is just the opposite.
7840440	7842600	But there's really not too many options to think about this.
7842600	7844440	If you only have 0s and 1s, you can probably
7844440	7845920	imagine what the bad scenario is.
7845960	7850640	If 0, 0, 0, 0, 0, 0, 0, 1, if you subtract 1 goes to 0s,
7850640	7854360	and then you do it again, you now underflow, which just brings you
7854360	7855680	around to the opposite.
7855680	7858160	1, 1, 1, 1, 1, 1, 1.
7858160	7861840	So if you have 8 1s, what value is that?
7861840	7866720	If you do the math 1s, 2s, 4s, 8, 16s, it turns out it's 255
7866720	7868360	if you actually do out all the math.
7868360	7870960	So it turns out that this game's civilization
7870960	7875200	was using a single byte to represent every character's level of aggressiveness
7875200	7875880	in the game.
7875880	7879360	And Gandhi's was, as you would expect, by default initialized to 1,
7879360	7881320	like very non-aggressive.
7881320	7884440	Unfortunately, in this game of civilization,
7884440	7888600	when a player adopts democracy in his or her civilization,
7888600	7892920	their aggression would be automatically reduced by 2.
7892920	7897280	And so if Gandhi went democratic, his aggression wouldn't go to negative 1.
7897280	7900840	It looped back around to the ludicrously high figure of 255,
7900840	7905080	making him as aggressive as a civilization could possibly be.
7905120	7909000	So less impactful, to be sure, than something like the airplane example.
7909000	7911000	But these problems are omnipresent.
7911000	7913240	And if you start to keep an eye out in the popular media,
7913240	7915320	or when there are bugs, or hacks, or exploits,
7915320	7921680	it's so often because a programmer has made a mistake in his or her code.
7921680	7923000	They didn't anticipate a scenario.
7923000	7926120	Or they made maybe reasonable decisions years ago,
7926120	7929280	but that eventually proved to be naive, and that we're still running the same code.
7929280	7930760	Numbers are getting too big.
7930760	7931840	Their math is wrong.
7931840	7933280	And so very real things happen.
7933280	7937240	But what's most important for us is just understanding how and why those things
7937240	7937880	happen.
7937880	7939720	And so what will we do in the days ahead?
7939720	7941480	So the next homework assignment, as with Scratch,
7941480	7942520	will be to program something.
7942520	7945880	But this time in C, you'll use an environment called CS50 Lab, which
7945880	7948920	essentially is CS50 Sandbox, with which we've been tinkering today.
7948920	7952160	But it adds to it the instructions and the specification of the problems
7952160	7953080	that you'll want to solve.
7953080	7955520	And it will hold your hands initially through some of these steps.
7955520	7958640	You don't need to have written everything down and memorized everything I typed today,
7958640	7961600	but do feel free in the meantime to go to the course's website and play
7961600	7962920	with any of those examples.
7962960	7966960	Among the challenges ahead will be to recreate some snippets of games
7966960	7969800	from yesteryear, thinking about how things you might have seen growing up
7969800	7971560	can be translated to actual code.
7971560	7974880	And undoubtedly, among the first things you'll experience is frustration.
7974880	7977760	You'll forget the stupid semicolon, or where does the parenthesis go,
7977760	7979120	and you'll have to look back at code.
7979120	7981080	But keep in mind, none of that stuff matters.
7981080	7982880	It's absolutely frustrating initially.
7982880	7986400	But what's most important is the idea is, and honestly, the sense of gratification
7986400	7988760	that you, like all of CS50 staff before you,
7988760	7992000	ultimately feel when actually building and creating something of your own.
7992000	7994040	So let's call it a day there, and we'll see you next time.
