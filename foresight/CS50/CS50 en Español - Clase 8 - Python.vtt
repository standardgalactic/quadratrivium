WEBVTT

00:00.000 --> 00:15.680
All right, so this is CS50, and this is the day before our test, of course.

00:15.680 --> 00:17.680
But this is lecture 8, in which we're actually

00:17.680 --> 00:20.720
going to finally transition from C, this lower level language that we've

00:20.720 --> 00:22.440
been spending quite some time to.

00:22.440 --> 00:25.440
And the goal today isn't so much to focus on Python, per se,

00:25.440 --> 00:28.160
but honestly, to do what we hope will be one of the most empowering

00:28.160 --> 00:31.720
aspects of the class, which is to emphasize that this is not

00:31.720 --> 00:34.840
in a semester learning C. This has been a semester learning programming,

00:34.840 --> 00:37.760
a certain type of programming called procedural or imperative programming,

00:37.760 --> 00:40.080
but more on that in another higher level class, perhaps.

00:40.080 --> 00:43.320
But really, that this class is about ultimately teaching yourself

00:43.320 --> 00:45.320
to learn new languages.

00:45.320 --> 00:48.520
And indeed, what you'll find is that as we explore some of the features

00:48.520 --> 00:52.600
and the syntax of Python, odds are today it might look as cryptic as C did

00:52.600 --> 00:55.760
just a few weeks ago, but you'll find that once you start recognizing

00:55.760 --> 00:59.200
patterns as you have with C, it'll be all the more accessible

00:59.200 --> 01:03.240
and all the more useful when solving some problems.

01:03.240 --> 01:06.520
So unrelated, just earlier this week, I happened

01:06.520 --> 01:08.760
to be in Mountain View with some of the team.

01:08.760 --> 01:11.760
And you might recall from last lecture at Harvard,

01:11.760 --> 01:15.200
we offered this glimpse of one of the earliest racks of servers

01:15.200 --> 01:16.720
that Google itself had.

01:16.720 --> 01:18.680
Well, it turns out they changed buildings,

01:18.680 --> 01:21.800
but we happened to stumble upon the actual display.

01:21.800 --> 01:25.240
So pictured here is a photo from my own phone, which was actually really

01:25.240 --> 01:26.000
cool to see.

01:26.000 --> 01:29.760
So inside of this, you'll see all of the old hard drives they've used.

01:29.760 --> 01:31.280
We actually looked at some of the labels.

01:31.280 --> 01:34.160
And indeed, hard drives manufactured in 1999, which

01:34.160 --> 01:36.360
was when Google started getting some of its momentum.

01:36.360 --> 01:38.280
I mean, you can see the green circuit boards here,

01:38.280 --> 01:41.240
on which would be CPUs and other things potentially.

01:41.240 --> 01:43.200
So if you'd like to stroll down memory lane,

01:43.200 --> 01:46.920
feel free to read up on this on Wikipedia or even on the excerpts here.

01:46.920 --> 01:50.520
And then, strangely enough, at the conference, some of us were at,

01:50.520 --> 01:53.680
did we discover this, perhaps the biggest duck debugger

01:53.680 --> 01:58.400
made up of smaller duck debuggers, one of whom was our own.

01:58.400 --> 02:00.760
So that, too, was how we spent this past week.

02:00.760 --> 02:03.600
All right, so how are we going to spend this week and the weeks to come?

02:03.600 --> 02:06.680
So you'll recall that when we transitioned from scratch to C,

02:06.680 --> 02:09.440
we drew a couple of comparisons between syntax and features.

02:09.440 --> 02:12.120
And I thought it'd be useful to take that same approach here really

02:12.120 --> 02:14.880
to emphasize that most of the ideas we're going to explore today

02:14.880 --> 02:15.960
are themselves not new.

02:15.960 --> 02:19.520
It's just how you express them and how you write the syntax in the language,

02:19.520 --> 02:23.720
known as Python, that's indeed going to be different from scratch, from C.

02:23.720 --> 02:25.280
And now here we are with Python.

02:25.280 --> 02:30.200
So back in the day, in week 0, when you wanted to say something in scratch,

02:30.200 --> 02:32.880
you would literally use this purple puzzle piece, say hello.

02:32.880 --> 02:35.240
And we called that a function or a statement.

02:35.240 --> 02:36.760
It was some kind of verb action.

02:36.760 --> 02:39.200
And in C, of course, it looked a little something like this.

02:39.200 --> 02:43.080
Henceforth, starting today in Python, it's going to look like this.

02:43.080 --> 02:47.000
So before, after, before, after.

02:47.000 --> 02:49.280
So it's pretty easy to visually diff these two things.

02:49.280 --> 02:51.360
But what are just a couple of the differences that jump out at you

02:51.360 --> 02:52.320
immediately?

02:52.320 --> 02:53.960
See?

02:53.960 --> 02:54.440
Python.

02:57.380 --> 02:59.720
So there's no more backslash N, it would seem, in this context.

02:59.720 --> 03:02.080
So that's kind of a nice relief to not have to type anymore.

03:02.080 --> 03:04.400
What else seems to be different?

03:04.400 --> 03:06.080
No semicolon, thank god, right?

03:06.080 --> 03:07.720
Perhaps the stupidest source of frustration

03:07.720 --> 03:11.920
that you might have experienced by just omitting one of those and someone over here?

03:11.920 --> 03:15.840
Yeah, so printf is now just print, which is pretty reasonable unto itself.

03:15.840 --> 03:18.160
So these are terribly minor differences.

03:18.160 --> 03:20.800
But it's sort of testament to the kinds of mental adjustments

03:20.800 --> 03:22.120
you're going to have to start to make.

03:22.120 --> 03:24.720
Fortunately, thus far, we've seen that you can start leaving things off,

03:24.720 --> 03:26.520
which is actually a guiding principle of Python

03:26.520 --> 03:29.440
and that one of its goals is meant to be easier to write than some

03:29.440 --> 03:31.400
of its predecessors among them C.

03:31.400 --> 03:35.960
So in C, we might have implemented this Hello World program that actually

03:35.960 --> 03:38.760
ran when you click the green flag using code like that at the right.

03:38.760 --> 03:42.520
And this was, if those of you had no programming experience coming in to CS50,

03:42.520 --> 03:46.240
what probably looked like the proverbial grief to you just a few weeks ago.

03:46.240 --> 03:48.480
And we teased apart what those various lines meant.

03:48.480 --> 03:49.920
But in Python, guess what?

03:49.920 --> 03:53.200
If you want to write a program whose purpose in life is to say Hello,

03:53.200 --> 03:56.440
we'll just write def main print Hello World.

03:56.440 --> 03:59.040
So it's a little similar, structurally structured.

03:59.040 --> 04:04.560
And in fact, it does not lack for some of the more arcane syntax here,

04:04.560 --> 04:07.040
but we'll see soon what this actually means.

04:07.040 --> 04:09.560
But it's a little simpler than the one before.

04:09.560 --> 04:10.600
And let's tease this apart.

04:10.600 --> 04:13.200
So def here simply means define me a function.

04:13.200 --> 04:17.120
So whereas in C, we've historically seen that you specify the type

04:17.120 --> 04:18.400
that the function should return.

04:18.400 --> 04:20.600
We're not going to do that in Python anymore.

04:20.600 --> 04:22.000
Python still has data types.

04:22.000 --> 04:25.160
But we're not going to explicitly mention what data types we're using.

04:25.160 --> 04:26.920
Meanwhile, here is the name of the function.

04:26.920 --> 04:28.120
And main would be a convention.

04:28.120 --> 04:31.400
But it's not built into the language in the same way as it is in C,

04:31.400 --> 04:32.880
as we shall see.

04:32.880 --> 04:36.040
Meanwhile, this silly incantation is just a way

04:36.040 --> 04:39.680
of ensuring that the default function to be executed in a Python program

04:39.680 --> 04:41.320
is indeed going to be called main.

04:41.320 --> 04:43.680
But more on that when we actually start creating.

04:43.680 --> 04:46.760
But this is perhaps the most subtle but most important difference,

04:46.760 --> 04:47.960
at least early on.

04:47.960 --> 04:49.520
And it's even hard to see at this scale.

04:49.520 --> 04:53.560
But notice the colons, both here and here, that I've highlighted now

04:53.560 --> 04:55.720
in yellow, and these dots, which are not to be typed,

04:55.720 --> 04:58.760
but are just meant to draw your attention to the fact that I hit the space bar four

04:58.760 --> 05:00.800
times in those locations.

05:00.800 --> 05:04.840
So if you have ever sort of gotten some feedback from your TA or TF,

05:04.840 --> 05:08.280
that your style could be better, closer to five out of five,

05:08.280 --> 05:10.920
because of lack of indentation or pretty formatting.

05:10.960 --> 05:13.000
Python's actually going to help us out with this.

05:13.000 --> 05:17.920
So Python code will not run if you have not indented things properly.

05:17.920 --> 05:22.400
So gone are the curly braces that encapsulate related lines of code

05:22.400 --> 05:25.160
within some block of functionality, and instead they're

05:25.160 --> 05:27.720
replaced generally with this general structure.

05:27.720 --> 05:30.320
You have a colon, and then below that and indented

05:30.320 --> 05:34.000
are all of the lines that are somehow related to that earlier line of code.

05:34.000 --> 05:36.000
And the indentation must be consistent.

05:36.000 --> 05:40.680
So even though your own eye might not quite distinguish four spaces from three,

05:40.680 --> 05:43.080
the Python environment will.

05:43.080 --> 05:46.720
And so this will actually help implicitly enforce better style,

05:46.720 --> 05:50.760
perhaps, than might have been easily done from the get go.

05:50.760 --> 05:53.120
So then, of course, in Scratch, we had a forever block, which

05:53.120 --> 05:54.360
says, hello world forever.

05:54.360 --> 05:56.520
Much like in C, we could implement it like this.

05:56.520 --> 05:58.560
Now there's actually pretty clean mapping in Python.

05:58.560 --> 06:01.480
We already know we can get rid of the semicolon.

06:01.480 --> 06:03.960
We already know we can get rid of the curly braces.

06:03.960 --> 06:06.480
We're going to have to add in a colon, but it turns out

06:06.480 --> 06:08.360
we can get rid of a little more too.

06:08.360 --> 06:14.440
So what more is absent from this translation of hello world to Python?

06:14.440 --> 06:17.040
This one's more subtle.

06:17.040 --> 06:18.920
So we definitely got rid of the curly braces,

06:18.920 --> 06:20.400
relying now just on indentation.

06:24.280 --> 06:26.320
OK, so there's no parentheses around while.

06:26.320 --> 06:29.440
And so this, too, is actually meant to be a feature of Python.

06:29.440 --> 06:32.240
If you don't logically need parentheses to enforce

06:32.240 --> 06:36.160
order of operations, like in arithmetic or the like, then don't use them,

06:36.160 --> 06:37.520
because they're just an distraction.

06:37.520 --> 06:38.560
They're just more to type.

06:38.560 --> 06:41.920
And the code now is just visually cleaner and easier to read.

06:41.920 --> 06:43.200
There's a minor difference, too.

06:43.200 --> 06:45.520
True and false are going to be capitalized in Python,

06:45.520 --> 06:47.520
but that's a fairly incidental detail.

06:47.520 --> 06:49.960
But notice this kind of captures already the spirit of Python.

06:49.960 --> 06:52.440
It's not a huge leap to go from one to the other,

06:52.440 --> 06:54.920
but we've just kind of started to get rid of some of the clutter

06:54.920 --> 06:57.040
and the stuff that never really intellectually added much.

06:57.040 --> 06:59.840
And if anything was annoying, to have to remember early on.

06:59.840 --> 07:01.400
So true here is Arbolian.

07:01.400 --> 07:03.840
And now we have a finite number of iterations.

07:03.840 --> 07:06.080
We might want to say hello world exactly 50 times.

07:06.080 --> 07:07.960
In C, this was a crazy mess.

07:07.960 --> 07:10.920
If you wanted to do this, you'd have to initialize a variable with which

07:10.920 --> 07:15.120
to count up to, but not including 50 plus plusing along the way and so forth.

07:15.120 --> 07:17.040
In Python, it's going to be a little cleaner.

07:17.040 --> 07:19.640
And we'll come back to what this means exactly.

07:19.640 --> 07:21.680
But if you kind of read it from left to right,

07:21.680 --> 07:24.360
it kind of says what you mean, right?

07:24.360 --> 07:26.840
For i in the range of 50.

07:26.840 --> 07:29.120
So i is probably going to be a variable.

07:29.120 --> 07:30.920
And notice we're not mentioning its type.

07:30.920 --> 07:34.160
It's going to be implied by whatever the context is, which in this case

07:34.160 --> 07:36.720
has to do apparently with numbers per the 50.

07:36.720 --> 07:39.320
Range is actually going to be a data type unto itself.

07:39.320 --> 07:40.600
It's a little funky in that sense.

07:40.600 --> 07:41.760
It's called a class.

07:41.760 --> 07:45.080
But this essentially is a special feature of Python

07:45.080 --> 07:49.160
that unlike in C, where if you want to iterate over an array of values

07:49.160 --> 07:52.800
or 50 such values, you would literally have an array of 50 values.

07:52.800 --> 07:55.360
Range is kind of cool in that it kind of stands there.

07:55.360 --> 07:58.760
And every time you iterate through a loop, it hands you the next number,

07:58.760 --> 08:00.480
but just one at a time.

08:00.520 --> 08:04.080
Thereby using maybe as little as 150th the amount of memory,

08:04.080 --> 08:06.760
because it only has to keep one number around at a time.

08:06.760 --> 08:08.440
And there's a bit more overhead than that.

08:08.440 --> 08:10.760
It's not a perfect savings quite so.

08:10.760 --> 08:16.240
But this just says for i in range 50, and that's going to implicitly

08:16.240 --> 08:19.240
count from 0 up through 49.

08:19.240 --> 08:23.000
And meanwhile, what's below it is what's going to get printed this time.

08:23.000 --> 08:26.640
So meanwhile, here is one of our bigger scratch blocks early on.

08:26.640 --> 08:30.080
And it translates pretty literally to code in C.

08:30.080 --> 08:34.360
And you can perhaps guess, if you've never seen Python before today,

08:34.360 --> 08:36.880
what the Python code might now look like.

08:36.880 --> 08:39.120
If this here on the right is the C code, what

08:39.120 --> 08:41.800
are some of the features syntactically that we're about to throw away?

08:41.800 --> 08:42.300
Yeah?

08:42.300 --> 08:44.600
You can throw it at curly braces and the parentheses.

08:44.600 --> 08:46.880
Curly braces and parentheses are going to go away.

08:46.880 --> 08:49.120
What else might go away?

08:49.120 --> 08:52.440
The semicolons are going to go away?

08:52.440 --> 08:54.840
The backslash n inside of the print statements?

08:54.840 --> 08:56.480
Great.

08:56.480 --> 08:59.800
One more thing, I think?

09:00.800 --> 09:01.440
The if?

09:01.440 --> 09:03.460
So well, we don't strictly need the parentheses

09:03.460 --> 09:06.760
because it's not like I'm combining things logically like this or that

09:06.760 --> 09:08.000
or this and that.

09:08.000 --> 09:10.040
So it should suffice to get rid of those two.

09:10.040 --> 09:12.280
And there's a couple of other tweaks we're going to have to make here.

09:12.280 --> 09:14.920
But indeed, the code is going to be a lot tighter, so to speak.

09:14.920 --> 09:16.960
Now you're just going to say what you mean here.

09:16.960 --> 09:19.920
And there is one weird thing, and it's not a typo.

09:19.920 --> 09:23.240
What apparently are you ever going to have to start knowing now?

09:23.240 --> 09:24.440
L if or whatever.

09:24.440 --> 09:26.400
So L if is not a typo.

09:26.400 --> 09:29.080
It's indeed how you express the notion of else if,

09:29.080 --> 09:31.000
but otherwise everything is exactly the same.

09:31.000 --> 09:33.960
And notice the colons, frankly, ironically, whereas previously it

09:33.960 --> 09:36.920
might have been annoying to occasionally forget a semicolon.

09:36.920 --> 09:40.000
Now the colons might take on that role, but at least everything below them

09:40.000 --> 09:41.920
is meant to be indented.

09:41.920 --> 09:45.840
So here's a fundamental difference beyond the sort of silly syntactic

09:45.840 --> 09:47.920
differences of this in, say, other languages.

09:47.920 --> 09:51.200
The flow of work that we've been using thus far

09:51.200 --> 09:54.000
has been essentially this in C. You write source code in a file,

09:54.000 --> 09:56.080
generally ending in .c.

09:56.080 --> 10:00.600
You run a compiler, which is a quick check, is called Clang.

10:00.600 --> 10:01.840
So it's not technically make.

10:01.840 --> 10:04.000
Make is just this helpful build utility that

10:04.000 --> 10:05.680
automates the process of calling Clang.

10:05.680 --> 10:07.920
So Clang is, strictly speaking, the compiler.

10:07.920 --> 10:11.440
And Clang outputs zeros and ones, otherwise known as machine code.

10:11.440 --> 10:14.600
And your computer, Mac, PC, whatever, has a CPU,

10:14.600 --> 10:18.080
central processing unit inside, made by Intel or some other company.

10:18.080 --> 10:22.160
And that CPU is hardwired to understand certain patterns of bits,

10:22.160 --> 10:25.280
zeros and ones, otherwise known as machine code.

10:25.320 --> 10:29.440
So that's been our world in C with Python.

10:29.440 --> 10:31.600
So the code that you might compile in C, for instance,

10:31.600 --> 10:34.720
might have been this, which we said you run Clang on like this.

10:34.720 --> 10:37.480
And if you don't specify a default file name as output,

10:37.480 --> 10:40.640
you'll instead just get in your file all of these zeros and ones, which

10:40.640 --> 10:45.200
can then be executed by way of .slash a.out, the default name

10:45.200 --> 10:47.120
for the assembler's output here.

10:47.120 --> 10:53.280
So in Python, though, the world gets here, too, a little simpler as well.

10:53.280 --> 10:56.720
So we just now have source code and an interpreter.

10:56.720 --> 10:59.120
So there's no machine code it would seem.

10:59.120 --> 11:00.720
There's no compiler it would seem.

11:00.720 --> 11:02.800
And frankly, there's one fewer arrow, which

11:02.800 --> 11:05.720
suggests to me that the process of running Python code itself

11:05.720 --> 11:07.120
is actually going to be a little easier.

11:07.120 --> 11:09.360
Running C code has typically been two steps.

11:09.360 --> 11:12.480
You rerun Clang, or via Mac, you run Clang.

11:12.480 --> 11:13.640
Then you run the program.

11:13.640 --> 11:14.200
And it's fine.

11:14.200 --> 11:15.840
It's not all that hard, but it's two steps.

11:15.840 --> 11:18.880
Why not reduce to two steps what you could instead do in one?

11:18.880 --> 11:20.480
And we'll see exactly what this means.

11:20.480 --> 11:22.920
Now, technically, that's a bit of an oversimplification.

11:22.920 --> 11:27.400
Technically, underneath the hood, if you wanted to run a program like this

11:27.400 --> 11:33.360
that simply prints out hello world, you would simply run Python hello.py.

11:33.360 --> 11:36.760
And the result of that would be to see hello world on the screen,

11:36.760 --> 11:37.880
as we'll soon see.

11:37.880 --> 11:41.120
But technically, underneath the hood, there is some other stuff going on.

11:41.120 --> 11:42.960
So there actually kind of is a compiler.

11:42.960 --> 11:44.760
But there's not something called machine code per se.

11:44.760 --> 11:45.680
It's called byte code.

11:45.680 --> 11:48.080
There's even something called a Python virtual machine.

11:48.080 --> 11:51.160
But all of this is abstracted away for us.

11:51.160 --> 11:53.440
Certainly for the sake of today's conversation,

11:53.440 --> 11:55.680
but also in the real world more generally.

11:55.680 --> 11:59.160
Humans have gotten better over the decades at writing software and writing

11:59.160 --> 12:01.440
tools via which we can write software.

12:01.440 --> 12:04.960
And so a lot of the more manual processes and a lot of the lower level

12:04.960 --> 12:09.120
details that we've been focusing on, if not struggling on in C, start to go away.

12:09.120 --> 12:12.800
Because much like in week zero, where we started layering on idea after idea,

12:12.800 --> 12:17.440
zeros and ones, ASCII, colors and whatnot, similarly with our actual tools,

12:17.440 --> 12:18.960
are we going to start to do the same.

12:19.000 --> 12:22.200
So whereas in the past, or whereas in actuality,

12:22.200 --> 12:26.560
what's going on underneath the hood is this process here,

12:26.560 --> 12:30.040
we can start to think about it really as something quite simpler.

12:30.040 --> 12:34.440
Now, if you're curious, and if you take some higher level class like CS61

12:34.440 --> 12:37.960
or another, you'll actually talk about things like byte code and assembly

12:37.960 --> 12:38.640
code and the like.

12:38.640 --> 12:40.720
And we saw a glimpse of the latter a bit ago.

12:40.720 --> 12:42.680
This happens to be an intermediate language

12:42.680 --> 12:46.880
that Python source code is converted into before it's run by the computer.

12:46.880 --> 12:50.920
But again, we're going to turn a blind eye to those lower level details.

12:50.920 --> 12:53.520
So here are some of the tools now in our toolkit.

12:53.520 --> 12:55.280
In Python, there are data types.

12:55.280 --> 12:57.920
Though as of now, we've not seen any examples whereby

12:57.920 --> 13:01.120
I specify what types of values are going to be in my variables

13:01.120 --> 13:03.600
or what types of values a function is going to return.

13:03.600 --> 13:05.280
But they are there.

13:05.280 --> 13:07.800
Everything is sort of loosely typed in that whatever

13:07.800 --> 13:11.280
you want a variable to be, it will just take on that data type,

13:11.280 --> 13:13.520
whether it's an int or string or the like.

13:13.520 --> 13:15.400
It's not going to be the full word string.

13:15.400 --> 13:17.560
In Python, it's literally called str.

13:17.560 --> 13:22.240
But there are some familiar types here, bool and float and int and others.

13:22.240 --> 13:26.280
And in fact, among the others, as we'll soon see, are features like range.

13:26.280 --> 13:30.400
But before that, no two that will provide for at least our first foray

13:30.400 --> 13:33.040
into Python a few familiar functions.

13:33.040 --> 13:36.600
So Python has different mechanisms than C for getting input from the user.

13:36.600 --> 13:41.480
We've abstracted some of those details away in a new CS50 library for Python

13:41.480 --> 13:44.920
that you'll really just use one or few times before we transition away

13:44.920 --> 13:45.840
from even that.

13:45.840 --> 13:48.920
But we'll give you functions like get char, get float, get int, get string

13:48.920 --> 13:52.800
that handle all the requisite error checking so that at least for your first few programs,

13:52.800 --> 13:56.200
you can just start to get some real work done without diving

13:56.200 --> 13:58.800
into underneath the hood there.

13:58.800 --> 14:01.360
And then lastly, here's some other tools in our toolkit.

14:01.360 --> 14:03.800
And we'll just scratch the surface of some of these today.

14:03.800 --> 14:08.120
But what's nice about Python and what's nice about higher level languages

14:08.120 --> 14:10.200
more generally, like more modern languages that

14:10.200 --> 14:12.600
learned lessons from older languages like C

14:12.600 --> 14:16.920
is that you get so much more for free, so much more out of the box.

14:16.920 --> 14:18.480
There's so much more of a kitchen sink.

14:18.480 --> 14:20.840
There's so many metaphors we can use here, all of which

14:20.840 --> 14:24.640
speak to the fact that Python has more features than C.

14:24.640 --> 14:29.040
Much like Java, if you took a PCS or something else, had than C,

14:29.040 --> 14:33.280
so does Python have a whole toolkit for representing complex numbers,

14:33.280 --> 14:36.640
for representing dictionaries otherwise implemented as hash tables,

14:36.640 --> 14:37.600
as you now know.

14:37.600 --> 14:39.880
Lists, which is kind of synonymous with an array,

14:39.880 --> 14:43.760
but in a list is an array that can sort of automatically grow and shrink.

14:43.760 --> 14:45.880
We don't have to jump through hoops as we did in C.

14:45.880 --> 14:47.880
Range we've seen briefly, which just hands you back,

14:47.880 --> 14:51.240
one number after another in some range, ideally for iteration.

14:51.240 --> 14:52.880
Set is the notion from mathematics, where

14:52.880 --> 14:55.400
if you want to put bunches of things into a data structure

14:55.400 --> 14:58.440
and you want to make sure you have only one of each such thing without

14:58.440 --> 15:00.200
duplicates, you can use a set.

15:00.200 --> 15:02.920
And a tuple is also a mathematical notion, typically,

15:02.920 --> 15:06.680
where you can combine related things without complicating things

15:06.680 --> 15:08.000
with actual structs.

15:08.040 --> 15:11.040
Like x comma y is a common paradigm in lots of programs,

15:11.040 --> 15:14.600
graphics or videos or certainly math and graphing itself.

15:14.600 --> 15:16.920
You don't really need a whole full-fledged data structure.

15:16.920 --> 15:19.880
You might just want to say x comma y.

15:19.880 --> 15:22.520
And so Python gives us that kind of expressiveness.

15:22.520 --> 15:26.640
So let's actually now dive in with that quick mapping from one world

15:26.640 --> 15:30.000
to the other and focus on what you can actually do with Python.

15:30.000 --> 15:33.840
So here I am in the familiar CS50 IDE, much like we have pre-installed for you,

15:33.840 --> 15:35.480
Clang and Make and other tools.

15:35.480 --> 15:38.240
We've also installed for you a program.

15:38.240 --> 15:41.760
That program is called Python, which is a little confusing at first glance,

15:41.760 --> 15:44.520
because Python is apparently the name of the language,

15:44.520 --> 15:46.240
but it's also the name of the program.

15:46.240 --> 15:47.920
And here's where Python is different.

15:47.920 --> 15:51.200
Whereas C is, again, compiled, and you use something like Clang

15:51.200 --> 15:54.360
to convert it to machine code, Python is both the name of the language

15:54.360 --> 15:58.160
and the name of the program you use to interpret the language.

15:58.160 --> 16:01.040
So pre-installed in CS50 IDE, and frankly, these days,

16:01.040 --> 16:04.200
probably on your own Macs or PCs, even if you don't know it,

16:04.200 --> 16:08.200
it is a program called Python that, if fed Python source code as input,

16:08.200 --> 16:10.080
will do what that code says.

16:10.080 --> 16:12.640
So let's go ahead and try something just like that.

16:12.640 --> 16:16.280
Let me go ahead and save a file preemptively as hello.py.

16:16.280 --> 16:19.760
So .py will be the convention now instead of .c.

16:19.760 --> 16:22.440
And I'm going to go ahead and actually keep this pretty simple.

16:22.440 --> 16:23.960
I'm just going to print the first thing.

16:23.960 --> 16:26.320
It's muscle memory, so it's not printf anymore.

16:26.320 --> 16:30.360
It's just hello, world, save, done.

16:30.360 --> 16:32.720
That's going to be my first program in Python.

16:32.720 --> 16:33.220
Why?

16:33.220 --> 16:34.480
It's one line of code.

16:34.480 --> 16:38.760
It's consistent with the features I've claimed Python has.

16:38.760 --> 16:40.360
So how do I run it?

16:40.360 --> 16:43.960
Well, in C, we would have done like make hello,

16:43.960 --> 16:47.440
but make knows nothing about this because make is typically used with C,

16:47.440 --> 16:49.680
at least in this context here.

16:49.680 --> 16:54.000
So maybe it's like dot slash hello.py.

16:54.000 --> 16:56.440
No, it seems I don't have permission there.

16:56.440 --> 17:00.880
But there's a step that I teased us with earlier on just the slide alone.

17:00.880 --> 17:05.560
How do I go about running a program, did I say?

17:05.560 --> 17:07.440
Yeah, I have to be a little more explicit.

17:07.440 --> 17:10.760
So Python, which is the name of the interpreter that understands Python,

17:10.760 --> 17:12.360
and now I need to feed it some input.

17:12.360 --> 17:15.880
And we know from our time in C that programs can take command line arguments.

17:15.880 --> 17:17.280
And indeed, this program itself does.

17:17.280 --> 17:20.240
Python, you just give it the name of a program to run.

17:20.240 --> 17:23.320
And there it is, our very first program.

17:23.320 --> 17:24.800
So that's all fine and good.

17:24.800 --> 17:27.400
But what if I wanted to do something a little more interesting,

17:27.400 --> 17:29.240
like getting a string from the user?

17:29.240 --> 17:32.800
Well, it turns out in Python, in CS50 ID especially,

17:32.800 --> 17:34.120
I can do something like this.

17:34.120 --> 17:38.280
s gets get underscore string.

17:38.280 --> 17:41.840
And I can ask someone, for instance, for their name, like this.

17:41.840 --> 17:46.840
Now, CS50 ID is already yelling at me, undefined variable get string.

17:46.840 --> 17:50.360
And let's actually see if maybe it's just buggy.

17:50.360 --> 17:53.680
No, so this is a little more arcane than usual.

17:53.680 --> 17:56.600
But trace back, most recent call last.

17:56.800 --> 17:59.520
Hello.py line 2 in module, whatever that is.

17:59.520 --> 18:01.160
So I see a line of code from line 2.

18:01.160 --> 18:03.520
Name, error, name, get string is not defined.

18:03.520 --> 18:06.080
This is not the same language we've seen before.

18:06.080 --> 18:07.760
But what does this feel reminiscent of?

18:09.760 --> 18:13.080
Yeah, when the past, when you've forgotten CS50.h,

18:13.080 --> 18:16.760
you've gotten something about an undeclared identifier, something like that.

18:16.760 --> 18:20.160
It just didn't understand something related to the CS50 library.

18:20.160 --> 18:23.800
So in C, we would have done include CS50.h.

18:23.800 --> 18:26.360
That's no longer germane, because now we're in Python.

18:26.360 --> 18:28.080
But it's somewhat similar in spirit.

18:28.080 --> 18:33.160
Now I'm going to say, instead, from CS50, import get string.

18:33.160 --> 18:35.120
And now save that.

18:35.120 --> 18:38.560
And hopefully, momentarily, the errors will go away as the IDE realizes,

18:38.560 --> 18:42.400
oh, you've now imported the CS50 library, specifically a method,

18:42.400 --> 18:45.080
or function, rather, inside of it, called get string.

18:45.080 --> 18:46.680
So there, too, it's different syntax.

18:46.680 --> 18:48.520
But it kind of says what it means, from CS50, which

18:48.520 --> 18:51.640
is apparently the name of the library, import a function called get string.

18:51.640 --> 18:54.800
Now, if I go ahead and rerun Python, hello.py,

18:54.800 --> 18:57.080
I can go ahead and type in, say, Maria's name,

18:57.080 --> 19:01.560
and ignore her altogether, because I need to make a fix here.

19:01.560 --> 19:06.160
What's the obvious bug, obvious now, to me, in the program?

19:06.160 --> 19:08.480
You need to include the variable, or s?

19:08.480 --> 19:12.640
Yeah, so I need to include s, which I got on line three,

19:12.640 --> 19:15.000
but then thereafter, use in any way.

19:15.000 --> 19:18.440
So this is going to be wrong, of course, because that's

19:18.440 --> 19:20.280
going to say, literally, hello, s.

19:20.280 --> 19:24.080
This is kind of how we used to do it, and then we would put in s.

19:24.080 --> 19:25.280
But this is not print f.

19:25.280 --> 19:27.600
This is print, so the world is a little different.

19:27.600 --> 19:30.280
And it turns out we can do this in a couple of different ways.

19:30.280 --> 19:34.120
Perhaps the easiest, if at least obvious, would

19:34.120 --> 19:41.120
be something like this, where I could simply say, hello.

19:41.120 --> 19:44.040
Open curly brace, close curly brace.

19:44.040 --> 19:47.240
And then inside of there, simply specify the name of the variable

19:47.240 --> 19:48.400
that I want to plug in.

19:48.400 --> 19:50.160
And that's not quite all the way there.

19:50.160 --> 19:52.400
Let me go ahead and run this once more.

19:52.400 --> 19:55.960
Now, if I type in Maria's name, still not quite right,

19:55.960 --> 19:59.560
I need to actually tell Python that this is a special type of string.

19:59.560 --> 20:03.280
It's a formatted string, similar in spirit to what print f expected.

20:03.280 --> 20:06.440
And the way you do this, even though it's a little different from c,

20:06.440 --> 20:07.960
is you just say f.

20:07.960 --> 20:08.800
This is an f string.

20:08.800 --> 20:11.720
So literally before the quotes, you write the letter f.

20:11.720 --> 20:14.120
And then if I now run this program here,

20:14.120 --> 20:18.120
I'm going to actually see Maria's name as hello Maria.

20:18.120 --> 20:20.040
And I'll take care of that red x later.

20:20.040 --> 20:20.880
So that's a format string.

20:20.880 --> 20:21.800
And there's one other way.

20:21.800 --> 20:26.040
And this is not very obvious, I would say.

20:26.040 --> 20:29.320
You might also see an online documentation, something like this.

20:29.320 --> 20:31.640
And let's just tease this apart for just a second.

20:31.640 --> 20:35.080
It turns out in Python that what I've highlighted in green here

20:35.080 --> 20:37.560
is known as a string, otherwise known as a stir.

20:37.560 --> 20:40.040
S-T-R is the name of this data type.

20:40.040 --> 20:43.720
Well, unlike in C, where string was kind of a white lie,

20:43.720 --> 20:45.960
where it was just a pointer at the end of the day,

20:45.960 --> 20:49.760
a string is actually a first class object in Python,

20:49.760 --> 20:52.400
which means it's not just a sequence of characters.

20:52.400 --> 20:56.160
It has built-in functionality, built-in features.

20:56.160 --> 21:00.200
So much like a struct in C had multiple things inside of it,

21:00.200 --> 21:04.280
so does a string in Python have multiple things inside of it,

21:04.280 --> 21:07.760
not just the sequence of characters, but functions

21:07.760 --> 21:09.280
that can actually do things.

21:09.280 --> 21:11.560
And it turns out you access those functions

21:11.560 --> 21:13.760
by way of the same dot operator as in C.

21:13.760 --> 21:16.400
And then you would only know from the documentation or examples

21:16.400 --> 21:19.800
in class what functions are inside of the string object.

21:19.800 --> 21:22.880
But one of them is format, and that's just a function that takes an argument.

21:22.880 --> 21:26.240
What do you want to plug into the string to the left of the dot?

21:26.240 --> 21:32.800
And so simply by specifying, hey, Python, here's a string with a placeholder.

21:32.800 --> 21:35.360
Inside of this string is a built-in function,

21:35.360 --> 21:38.560
otherwise known as a method, when a function is inside some object

21:38.560 --> 21:41.040
or structure, pass in the value s.

21:41.040 --> 21:45.600
So if I now go ahead and rerun this after saving my changes,

21:45.600 --> 21:49.480
I should now see that Maria's name is still plugged in.

21:49.480 --> 21:52.480
So that's it, but a simple idea that now even strings

21:52.480 --> 21:55.200
have things inside of them, besides the characters alone,

21:55.200 --> 21:57.280
and you can access that via the dots.

21:57.280 --> 22:01.040
So let's go ahead now and ramp things up to a more familiar example

22:01.040 --> 22:01.920
from a while back.

22:01.920 --> 22:05.120
Let me go ahead and open up two side-by-side windows

22:05.120 --> 22:07.280
and see if we can't translate one to the other.

22:07.280 --> 22:12.720
I'm going to go ahead and open up, for instance, int dot c from some time ago.

22:12.720 --> 22:15.080
So you might recall from int dot c, we had

22:15.080 --> 22:18.720
this program here whose purpose in life was to get an integer from the user

22:18.720 --> 22:22.040
and actually now plug it into printf and then print it out.

22:22.040 --> 22:24.720
So what's going to be different now in Python?

22:24.720 --> 22:28.920
Well, in Python, if I go ahead and implement this as, say, int dot pi,

22:28.920 --> 22:31.120
I'm going to go ahead and do the following.

22:31.120 --> 22:33.800
Let me scroll down to kind of line things up roughly.

22:33.800 --> 22:39.480
I can go ahead and say def, oops, def main, as I saw in the slides before.

22:39.480 --> 22:44.760
And then over here, I can say, I get int, quote unquote, integer.

22:44.760 --> 22:48.940
And then down here, I'm going to say not printf, but print, quote unquote,

22:48.940 --> 22:52.400
hello, and then the placeholder.

22:52.400 --> 22:56.040
What's the simplest way to do this now, per our past example?

22:56.040 --> 22:58.240
Curly brace?

22:58.240 --> 23:00.560
I. And then I just need to be super clear.

23:00.560 --> 23:04.440
This is a special f string or format string into which you can plug values.

23:04.440 --> 23:06.480
And now I'm going to go ahead and save that.

23:06.480 --> 23:11.200
And I've got most of the pieces together now, ignoring for now the red x.

23:11.200 --> 23:13.840
So what more remains to be done?

23:13.840 --> 23:17.480
I've made one same mistake as before.

23:17.480 --> 23:18.720
Yeah, so the get int.

23:18.720 --> 23:21.240
So up here, really, the equivalent of line 3

23:21.240 --> 23:26.440
would be from CS50 import get int this time.

23:26.440 --> 23:27.160
Saving that.

23:27.160 --> 23:35.720
And now, if in my terminal window, I go ahead and run Python of int dot pi,

23:35.720 --> 23:38.960
that seems strange.

23:38.960 --> 23:42.200
It's not an error in terms of, like, erroneous output.

23:42.200 --> 23:43.560
Just nothing happened.

23:43.760 --> 23:47.080
So why might this be?

23:47.080 --> 23:50.120
How might you go about troubleshooting this, even with very little Python

23:50.120 --> 23:52.280
under your belt?

23:52.280 --> 23:52.880
Is that a hand?

23:52.880 --> 23:53.840
I don't know.

23:53.840 --> 23:54.120
No?

23:54.120 --> 23:55.280
OK.

23:55.280 --> 23:57.440
Yeah?

23:57.440 --> 23:58.720
Is there a line break?

23:58.720 --> 23:59.400
That's OK.

23:59.400 --> 24:02.240
I was just doing that to kind of make everything line up, but it's no big deal.

24:02.240 --> 24:06.240
Everything's indented properly, which is the important aesthetic.

24:06.240 --> 24:08.440
Yeah?

24:08.440 --> 24:09.560
We didn't call the function.

24:09.560 --> 24:11.720
And this is where Python's a little different from C.

24:11.720 --> 24:14.480
In C, recall, main just gets called automatically for you.

24:14.480 --> 24:17.600
Humans years ago decided that shall be the default name of a function.

24:17.600 --> 24:21.360
In Python, line 6 here, calling something main is just a convention.

24:21.360 --> 24:24.200
I could have called it foo or bar or any other word.

24:24.200 --> 24:25.720
It has no special meaning.

24:25.720 --> 24:28.200
And so in Python, if you want to actually call main,

24:28.200 --> 24:30.360
you need to do something, frankly, that's, I think,

24:30.360 --> 24:32.680
one of the stupider distractions early on.

24:32.680 --> 24:37.280
But you have to literally say this, if the name of this file

24:37.280 --> 24:43.600
happens to equal something that's specially called main, then call main.

24:43.600 --> 24:47.720
So long story short, when you run the Python interpreter on a file,

24:47.720 --> 24:52.520
as we've been doing with Python space int.py or hello.py,

24:52.520 --> 24:57.280
there is a special global variable that your program has access to called

24:57.280 --> 25:00.240
underscore underscore name, underscore underscore.

25:00.240 --> 25:03.400
And if that default name happens to be underscore underscore main,

25:03.400 --> 25:09.880
underscore underscore, then you know that you have the ability to call

25:09.880 --> 25:11.560
any function you want by default.

25:11.560 --> 25:13.960
So for now, much like we did in week one, where

25:13.960 --> 25:17.240
we glossed over certain details that just weren't all that interesting,

25:17.240 --> 25:20.440
lines 11 and 12 for now, let's consider not all that interesting,

25:20.440 --> 25:22.920
but it's how we're going to kickstart these programs.

25:22.920 --> 25:27.760
Because now, if I run Python space int.py, type in a great number,

25:27.760 --> 25:32.840
hello, 42, the meaning of life, the universe, and everything.

25:32.880 --> 25:36.200
So let's now actually do something more powerful than just getting

25:36.200 --> 25:37.360
a single int from the user.

25:37.360 --> 25:40.640
Let me go ahead and close off this one and close off this one

25:40.640 --> 25:47.440
and open up, say, ints.c after splitting my window again into two windows here.

25:47.440 --> 25:48.960
And let's open ints.c.

25:48.960 --> 25:53.680
So this one was a little different in that we did some arithmetic.

25:53.680 --> 25:57.200
And so here's going to be another difference in Python.

25:57.200 --> 26:01.880
Here's what we did in C. And what was curious or worth noting about math

26:01.880 --> 26:03.760
in C?

26:03.760 --> 26:06.960
Which of these did not quite behave as you might expect in the real world?

26:09.960 --> 26:10.880
Division?

26:10.880 --> 26:11.280
Yeah, why?

26:11.280 --> 26:12.200
What did division do?

26:14.640 --> 26:16.560
Yeah, it chopped off or rounded down.

26:16.560 --> 26:19.800
It floored the value by throwing away everything after the decimal point.

26:19.800 --> 26:22.320
So this line here, 18, where it's such and such,

26:22.320 --> 26:24.560
divided by such and such, is such and such.

26:24.560 --> 26:27.040
And we literally just said x divided by y.

26:27.040 --> 26:30.800
If you divided, for instance, 1 divided by 2 in grade school,

26:30.800 --> 26:33.960
hopefully you would get the value 1 half or 0.5.

26:33.960 --> 26:36.360
But in C, what did we get instead?

26:36.360 --> 26:36.800
Zero.

26:36.800 --> 26:42.080
So it gets truncated to an int, the closest int without a decimal point being zero,

26:42.080 --> 26:44.000
because 0.5 is really 0.5.

26:44.000 --> 26:45.760
And thus, we had that effect.

26:45.760 --> 26:48.840
So in Python, things are going to be similar in spirit,

26:48.840 --> 26:53.800
but this is kind of a feature that was fixed or a bug that was fixed.

26:53.800 --> 26:58.920
In Python, let me go ahead here and open up an example I wrote in advance called

26:58.920 --> 27:02.720
ints.py, which is actually now going to look like this.

27:02.720 --> 27:07.360
So the Python equivalent now, which I'll roughly line up,

27:07.360 --> 27:08.920
looks a little different.

27:08.920 --> 27:11.760
And there's a few distractions, because we have all these f strings now

27:11.760 --> 27:12.640
in the way.

27:12.640 --> 27:15.120
But notice I'm just plugging in x's and y's.

27:15.120 --> 27:19.600
But what's a new feature, apparently, in Python, arithmetically?

27:19.600 --> 27:20.880
So floor division.

27:20.880 --> 27:24.520
So this was the more proper term for what C has been doing all this time.

27:24.520 --> 27:27.880
In C, when you use the slash, and you divide one number by another,

27:28.880 --> 27:31.840
it divides and then floors it to the nearest int.

27:31.840 --> 27:34.480
In Python, if you want that same old school feature,

27:34.480 --> 27:37.760
you're going to now use slash slash, not to be confused with the C comment.

27:37.760 --> 27:41.440
And if you want division to work the way you always knew it did in grade

27:41.440 --> 27:44.120
school, you continue using just the slash.

27:44.120 --> 27:47.040
So a minor point, but one of the differences to keep in mind.

27:47.040 --> 27:49.760
So if we actually run this here in Python,

27:49.760 --> 27:54.680
if I go into source 8 today, and our week's directory for week 1,

27:55.040 --> 28:00.200
and I run python ints.py, here now we're going to see 1 and 2.

28:00.200 --> 28:05.280
And there's all of the values that we would expect to see.

28:05.280 --> 28:08.840
All right, so without dwelling too much on this,

28:08.840 --> 28:12.480
let's fast forward to something more powerful, like conditions.

28:12.480 --> 28:15.920
So in Python, if we want to do something only conditionally,

28:15.920 --> 28:19.600
laying out my browser like this, let me go ahead and open up,

28:19.600 --> 28:27.360
let's say conditions.py, sorry, conditions.c, which once upon a time,

28:27.360 --> 28:28.800
looked like this.

28:28.800 --> 28:34.600
So in this example here, notice that we have a program that gets two ints

28:34.600 --> 28:38.280
from the user and then just compares x and y and x and y

28:38.280 --> 28:41.840
and prints out whether they're greater than, less than, or equal to, ultimately.

28:41.840 --> 28:44.480
So let's actually do this one from scratch over here on the right.

28:44.480 --> 28:47.480
So let me go ahead and save this as conditions.py.

28:47.480 --> 28:49.400
And then at the top, what's the very first thing

28:49.400 --> 28:52.760
I'm going to apparently now need?

28:52.760 --> 28:54.080
Yeah, so the CS50 library.

28:54.080 --> 28:58.400
So from CS50 import, it looks like get int is the one we want this time.

28:58.400 --> 29:01.720
Now, how do I go about getting an int?

29:01.720 --> 29:04.680
Or what's the translation of line nine on the left

29:04.680 --> 29:07.880
to the right-hand side of the screen?

29:07.880 --> 29:17.000
x equals get int of the same prompt.

29:17.000 --> 29:18.280
OK, what comes next?

29:18.280 --> 29:23.040
If I line it up roughly here, y gets get int of, quote unquote, y.

29:23.040 --> 29:26.120
And what's down here?

29:26.120 --> 29:31.480
The condition, so if x less than y, no parentheses are necessary.

29:31.480 --> 29:33.520
It's not wrong to put them, but it's unnecessary.

29:33.520 --> 29:36.720
And now enters a word into our terminology.

29:36.720 --> 29:38.640
It's not pythonic, so to speak.

29:38.640 --> 29:40.120
If you don't need them, don't put them.

29:40.120 --> 29:42.720
So if x is indeed less than y, what do we want to do?

29:42.720 --> 29:48.080
We want to print x is less than y, yes?

29:49.040 --> 29:49.640
All right, good.

29:49.640 --> 29:54.680
So else if x, OK, good.

29:54.680 --> 30:02.920
So kind of goofily, l if, then go ahead and print out x is greater than y.

30:02.920 --> 30:05.080
And as an aside, I actually did that accidentally.

30:05.080 --> 30:09.800
But it turns out in Python, too, you can use double quotes or single quotes.

30:09.800 --> 30:11.200
Either is fine.

30:11.200 --> 30:15.200
Whereas in C, single quotes had a very specific meaning, which went what?

30:15.200 --> 30:16.960
Char, so single characters.

30:16.960 --> 30:20.880
And double quotes meant strings, sequence of characters, which meant zero

30:20.880 --> 30:23.280
or more characters followed by backslash zero.

30:23.280 --> 30:25.080
In Python, all of that is gone.

30:25.080 --> 30:27.000
Single quotes and double quotes are equivalent.

30:27.000 --> 30:29.400
I'll almost always use double quotes just for consistency,

30:29.400 --> 30:32.800
as should you for consistency within your own files.

30:32.800 --> 30:36.040
But sometimes it's useful to drop into one or the other if you nest,

30:36.040 --> 30:39.440
for instance, quote marks, as you might have once in a while in C.

30:39.440 --> 30:45.120
OK, so finally, else print out x is equal to y.

30:45.120 --> 30:48.840
So it's cleaner, and frankly, I don't need all this white space.

30:48.840 --> 30:51.400
So let's go ahead and just make this a little tighter still.

30:51.400 --> 30:56.320
You can see that in 11 lines, we've now done what took 27 or so last time.

30:56.320 --> 30:59.160
But I have omitted something, to be fair.

30:59.160 --> 31:01.240
What did I omit?

31:01.240 --> 31:03.440
Yeah, I didn't do that whole calling a function thing.

31:03.440 --> 31:04.520
There's no mention of main.

31:04.520 --> 31:07.760
And it actually turns out that's not strictly necessary in Python.

31:07.760 --> 31:11.200
If you're going to be interpreting a file that contains Python code,

31:11.200 --> 31:13.400
and it's a simple enough program that you don't really

31:13.400 --> 31:18.440
need to factor code out and organize it into separate functions, then don't.

31:18.440 --> 31:21.280
If this is what would now be called a command line script,

31:21.280 --> 31:25.240
a program that just has lines of code, that you can execute literally

31:25.240 --> 31:25.920
at the prompt.

31:25.920 --> 31:30.320
So if I go into this directory and run Python of conditions.py enter,

31:30.320 --> 31:33.560
x will be 1, y will be 2, x is indeed less than y.

31:33.560 --> 31:34.320
And that's it.

31:34.320 --> 31:40.040
I don't need to bother doing all of this as I proposed earlier, def main.

31:40.040 --> 31:42.680
And then I could go in here, and if you've never known this,

31:42.680 --> 31:44.520
and now it's useful, especially for Python,

31:44.520 --> 31:46.880
you can highlight lines or just tab them all at once.

31:46.880 --> 31:49.760
I could do this, but then I would need this thing, which I probably

31:49.760 --> 31:54.000
have to go look up how to remember it if you're doing it for the first time.

31:54.000 --> 31:57.200
There's just no value in this case to doing that.

31:57.200 --> 32:00.760
But at least it can be there as needed.

32:00.760 --> 32:05.080
So let me go ahead and undo that, and we're back to a porting of one to the other.

32:05.080 --> 32:07.120
All right, so that might then be conditions.

32:07.120 --> 32:10.720
And let's see if we can't no switch there.

32:10.720 --> 32:12.000
Let's take a look at this one.

32:12.000 --> 32:15.040
Let me open up, rather than comparing all of them side by side,

32:15.040 --> 32:18.880
let me just open up this one now called noSwitch.py, which

32:18.880 --> 32:23.960
is reminiscent of a program we ran some time ago called noSwitch.c.

32:23.960 --> 32:28.480
And you can perhaps infer what this does from the comments alone.

32:28.480 --> 32:31.160
What does this program do in English?

32:31.160 --> 32:33.840
Because logical operators is not all that explicit at top.

32:36.960 --> 32:37.960
What's that?

32:38.920 --> 32:44.760
Yeah, so if you've ever interacted with a program that asks you for a prompt,

32:44.760 --> 32:47.520
yes or no, here's some code with which you might implement it.

32:47.520 --> 32:50.520
And we could do this in C. We're just comparing characters here.

32:50.520 --> 32:51.680
But there's a few differences.

32:51.680 --> 32:54.640
If you kind of now think back to how you might implement this in C,

32:54.640 --> 32:56.680
even if you don't recall the specific program.

32:56.680 --> 32:59.440
I'm importing my library right up here.

32:59.440 --> 33:04.120
I'm then calling getchar this time, which is also in CS50's library for Python.

33:04.120 --> 33:07.800
And then notice there's just a couple of things different down here syntactically.

33:07.800 --> 33:11.560
Besides the colons and the indentation and such, what else is noteworthy?

33:11.560 --> 33:12.060
Yeah.

33:12.060 --> 33:14.160
You can use more instead of more.

33:14.160 --> 33:15.320
Yeah, thank god.

33:15.320 --> 33:17.240
You can just say more what you mean now.

33:17.240 --> 33:20.640
If you want to do something or something, you literally say or.

33:20.640 --> 33:23.840
And if we were instead, albeit nonsensically here,

33:23.840 --> 33:28.200
trying to do the conjunction of two things, this and that, you could literally say and.

33:28.200 --> 33:30.760
So instead of the two vertical bars or the two ampersands,

33:30.760 --> 33:33.360
here's another slight difference in Python.

33:33.360 --> 33:37.160
Let's now take a look at another example, reminiscent of one's past.

33:37.200 --> 33:39.920
This one called return.py.

33:39.920 --> 33:44.640
So here is an example where it's actually more compelling to have a main function,

33:44.640 --> 33:47.880
because now I'm going to start organizing my code into different functions still.

33:47.880 --> 33:52.840
So up here, we are importing the getint function from CS50 library.

33:52.840 --> 33:58.360
Here I have my main function just saying x gets getint and then print out the square of x.

33:58.360 --> 34:02.280
So how do you go about defining your own custom function in Python that's not just main?

34:02.280 --> 34:07.080
Well, here on line 11 is how I would define a function called square

34:07.080 --> 34:10.840
that takes apparently an argument called n, though I could call this anything I want,

34:10.840 --> 34:15.000
colon return n star star 2.

34:15.000 --> 34:17.840
So a few new features here, but again, it's no big deal.

34:17.840 --> 34:21.480
Once you just kind of look these features up in a manual or in a class,

34:21.480 --> 34:23.440
what is star star probably doing?

34:23.440 --> 34:27.440
Not square root, the power of, yeah.

34:27.440 --> 34:30.360
So n star star 2 is just n raised to the power of 2.

34:30.360 --> 34:34.440
That was not a feature we had in C. So now we get this in Python.

34:34.440 --> 34:37.000
And what's this line 12 in green?

34:37.040 --> 34:40.520
With the weird use of double quotes.

34:40.520 --> 34:43.440
It's a comment, and it's a different type of comment than we've seen before.

34:43.440 --> 34:46.440
Because in my previous example, I did have a few comments.

34:46.440 --> 34:49.680
Recall that just a moment ago in conditions.py,

34:49.680 --> 34:52.200
we had a whole bunch of comments.

34:52.200 --> 34:55.440
Prompt the user for x, prompt the user for y, compare x and y.

34:55.440 --> 34:57.720
So whereas in C, we were using slash slash,

34:57.720 --> 35:01.080
Python unfortunately uses that for floor division, so to speak.

35:01.080 --> 35:06.240
So we instead just use the hashtag or the pound sign to enumerate a line,

35:06.240 --> 35:09.320
to specify a line that should be thought of as a comment.

35:09.320 --> 35:11.040
But here is something a little different.

35:11.040 --> 35:12.760
And we won't dwell too much on this for now,

35:12.760 --> 35:15.560
but Python has different types of comments, one of which is this.

35:15.560 --> 35:18.800
This is technically called a doc string or document string.

35:18.800 --> 35:23.160
And what's nice about Python, as well as languages like Java and other still,

35:23.160 --> 35:28.360
is that you can put comments in your code that special programs can read

35:28.360 --> 35:30.880
and then generate documentation for you.

35:30.880 --> 35:34.000
So if you ever took APCS and you ever saw Java doc,

35:34.040 --> 35:37.400
this was a way of commenting your methods and your code in Java using

35:37.400 --> 35:40.680
funky at signs and other syntax so that if you ran a special command,

35:40.680 --> 35:43.440
it could generate a user's manual for all of your functions

35:43.440 --> 35:47.480
until you or colleagues or friends or teachers exactly what all your functions

35:47.480 --> 35:50.480
are, what their arguments are, what their return values are, and all of that.

35:50.480 --> 35:55.880
Similarly, in Python, can you use these funky quote, quote, quote doc strings

35:55.880 --> 35:57.400
to document your function?

35:57.400 --> 36:00.840
So whereas in C, our style has been to put quotes above the functions.

36:00.840 --> 36:04.360
In Python, it's going to be to put them as the first line inside

36:04.360 --> 36:07.560
and indented within the function.

36:07.560 --> 36:12.440
All right, so now let's actually try to port a program from code again,

36:12.440 --> 36:19.560
thinking back on week one in C when we had this program here.

36:19.560 --> 36:25.280
So there's quite a bit going, oh, spoiler, don't look at that.

36:25.280 --> 36:27.240
Hopefully, that didn't sink in just yet.

36:27.240 --> 36:32.240
So in week one, we had this program in C, get positive int.

36:32.240 --> 36:35.520
And its purpose in life was to write a program that gets a positive integer

36:35.520 --> 36:37.840
from the user, in and of itself not all that interesting,

36:37.840 --> 36:40.240
but it was an opportunity to introduce a few things.

36:40.240 --> 36:44.880
One, we introduced this line six several weeks ago, which is known as a prototype.

36:44.880 --> 36:48.840
And what was the purpose of having that function prototype up there?

36:48.840 --> 36:50.920
Yeah, you declare the function, but why?

36:50.920 --> 36:54.680
Because it's already implemented down here on line 15.

36:55.680 --> 37:02.400
Yeah, because of the way the programs run, and frankly, because of how naive or dumb

37:02.400 --> 37:08.320
that Clang is by design, it does not know that a function exists until it actually sees it.

37:08.320 --> 37:12.760
So the problem is that if in C you have main, inside of which is a call to function

37:12.760 --> 37:16.440
like get positive int, but it's not implemented until a few lines later,

37:16.440 --> 37:19.040
Clang is going to be dumb and just not know that it even exists,

37:19.040 --> 37:20.640
and it's not going to compile your code.

37:20.640 --> 37:24.320
So this prototype, as we call it, is kind of a teaser, a hint

37:24.360 --> 37:25.880
that doesn't implement the whole function.

37:25.880 --> 37:31.120
It just shows the compiler its return type and its types and order of parameters

37:31.120 --> 37:33.840
so that that's enough information to then just trust

37:33.840 --> 37:36.800
that if I just blindly compile main, eventually,

37:36.800 --> 37:39.400
I'm going to see the actual implementation of the function

37:39.400 --> 37:41.600
so I can compile its bits as well.

37:41.600 --> 37:45.800
So in here, in C, we call get positive int, and then we pass it in a prompt.

37:45.800 --> 37:48.880
We stored it in a variable called i, and then printed it out.

37:48.880 --> 37:51.640
And then to implement this, we use kind of a familiar construct

37:51.640 --> 37:53.080
that you've used in other programs.

37:53.080 --> 37:56.320
Pretty much any time you want to prompt the user for inputs

37:56.320 --> 37:59.440
and you want to keep pestering him or her until they cooperate with whatever

37:59.440 --> 38:03.200
your conditions are, you would use the so-called do-while loop.

38:03.200 --> 38:06.680
And because the do-while loop recall is distinct from the while loop, how?

38:09.120 --> 38:11.480
It runs at least once, which just kind of makes intuitive sense

38:11.480 --> 38:13.520
if you want to prompt the user for something,

38:13.520 --> 38:17.320
and then if he or she doesn't cooperate, only then do you want to prompt them again.

38:17.320 --> 38:20.400
By contrast, with a while loop, it's going to happen again and again

38:21.280 --> 38:22.880
no matter what from the get go.

38:22.880 --> 38:26.560
So let's see if we can't now convert this or port this,

38:26.560 --> 38:28.440
as people would say, to Python.

38:28.440 --> 38:33.440
So here, I'm going to go ahead and save a new file called positive.py.

38:33.440 --> 38:39.440
And I'm going to go ahead and do everything here in main as before.

38:39.440 --> 38:44.400
So I'm going to go ahead and do, let's say, from cs50 import get int,

38:44.400 --> 38:45.840
because I do need that.

38:45.840 --> 38:48.400
And then I'm going to go ahead and have my main method here.

38:48.400 --> 38:51.880
And then inside of main, just like on the left-hand side,

38:51.880 --> 38:58.280
I'm going to do i get get positive int, positive integer, please.

38:58.280 --> 38:59.640
It's going to wrap a little bit now.

38:59.640 --> 39:00.520
That's fine.

39:00.520 --> 39:03.480
And then I'm going to go ahead and print this, which recall is just print,

39:03.480 --> 39:07.400
an f string where the placeholder is i.

39:07.400 --> 39:10.960
Although, frankly, this is kind of stupid to just create a string that

39:10.960 --> 39:13.080
has nothing other than the value we want to print.

39:13.080 --> 39:15.400
Nicely enough in Python, just print what you want.

39:15.400 --> 39:17.240
And so that simplifies that argument.

39:17.280 --> 39:22.800
So now it remains to implement get positive int, which

39:22.800 --> 39:25.160
is going to take some kind of prompt as its input.

39:25.160 --> 39:29.840
And notice I'm not specifying the data type of prompt, which is string.

39:29.840 --> 39:32.240
I'm not specifying the return type of this function,

39:32.240 --> 39:34.920
but both actually do exist underneath the hood.

39:34.920 --> 39:39.800
So in the past, to get a variable, I would do something like this semicolon.

39:39.800 --> 39:41.920
But I know I don't need the semicolon.

39:41.920 --> 39:43.560
I know I don't need the data type.

39:43.560 --> 39:46.800
And this just looks stupid to just put a variable there

39:46.800 --> 39:47.480
to need it.

39:47.480 --> 39:49.040
You don't need to do this in Python.

39:49.040 --> 39:52.000
If you want to use a variable, just start using it.

39:52.000 --> 39:55.480
And unfortunately, whereas almost every other feature we've seen in Python

39:55.480 --> 40:01.200
thus far kind of maps directly back to a feature in C,

40:01.200 --> 40:04.480
Python does not have a do while.

40:04.480 --> 40:07.200
So it has the for in.

40:07.200 --> 40:10.760
And it has while, and maybe it has other things we haven't told you about,

40:10.760 --> 40:12.600
but it doesn't have do while.

40:12.600 --> 40:16.000
So knowing that and knowing only what we've presented thus far,

40:16.000 --> 40:20.200
how do we still go about getting an int from the user

40:20.200 --> 40:23.960
and ensuring it's positive and re-prompting him or her if and only

40:23.960 --> 40:24.640
if it's not?

40:27.560 --> 40:28.200
Put another way.

40:28.200 --> 40:32.560
How would you do this in C if we took away from you the do while construct?

40:36.720 --> 40:37.880
Exclamation points?

40:37.880 --> 40:42.200
OK, so we could invert something maybe using that logically.

40:42.200 --> 40:43.400
We could just do a while loop.

40:43.400 --> 40:45.280
We could just use a while loop, how?

40:46.000 --> 40:50.960
So while prompt is less than 1.

40:50.960 --> 40:55.280
So while prompt is OK, so the prompt is the string we're going to input.

40:55.280 --> 40:57.040
We're going to pass display to the user.

40:57.040 --> 40:59.520
So it's not prompt, I think.

40:59.520 --> 41:04.200
So maybe i or n to be consistent with the other side.

41:04.200 --> 41:06.440
So you know what, why don't I, what about this?

41:06.440 --> 41:08.720
What if I just do, you know what, I know I need a loop.

41:08.720 --> 41:11.640
This is by far the easiest way to just get a loop, right?

41:11.640 --> 41:13.360
It's infinite, which is not good.

41:13.360 --> 41:15.480
But I can't break out of loops, recall.

41:15.480 --> 41:17.720
So what if I do something like this?

41:17.720 --> 41:22.840
What if I do n get int passing in the same prompt?

41:22.840 --> 41:25.200
And then what do I want to do next?

41:25.200 --> 41:27.720
I'm inside of an infinite loop, so this is going to keep happening,

41:27.720 --> 41:35.360
keep happening, keep happening until is positive.

41:35.360 --> 41:37.160
So Python's not quite that user friendly.

41:37.160 --> 41:39.080
We can't just say that.

41:39.080 --> 41:42.280
But we can say what?

41:42.280 --> 41:45.720
Greater than, close.

41:45.720 --> 41:46.680
Well, OK, that's fine.

41:46.680 --> 41:48.560
Greater than or equal to 1.

41:48.560 --> 41:50.120
Then what do we want to do?

41:50.120 --> 41:50.880
Great.

41:50.880 --> 41:54.240
So it's not quite as cool as like a do while loop, which kind of gives us

41:54.240 --> 41:56.800
all these features, though frankly, this was never that pretty, right?

41:56.800 --> 41:59.080
Especially the fact that you had to deal with the issue of scope

41:59.080 --> 42:00.560
by putting the variable outside.

42:00.560 --> 42:03.600
So in Python, the right way to do this would be something like this.

42:03.600 --> 42:06.200
Just induce an infinite loop, but make sure you break out of it

42:06.200 --> 42:09.200
logically when it's appropriate to do so.

42:09.200 --> 42:13.640
And so now, if I go ahead and add in that last thing that I keep needing,

42:13.640 --> 42:20.040
so if name equals main, and it's always fine to copy, paste something like that,

42:20.040 --> 42:23.800
a call main, let me go ahead now, and in my terminal window,

42:23.800 --> 42:27.160
run Python of positive dot pi.

42:27.160 --> 42:29.520
And let me go ahead and give it negative 5.

42:29.520 --> 42:31.240
How about negative 1?

42:31.240 --> 42:32.680
How about 0?

42:32.680 --> 42:33.560
Whoops, how about that?

42:33.560 --> 42:35.040
How about 0, 1?

42:36.040 --> 42:38.560
Hm.

42:38.560 --> 42:40.520
I screwed up.

42:40.520 --> 42:41.560
None is interesting.

42:41.560 --> 42:43.440
It's kind of our new null, so to speak.

42:43.440 --> 42:46.720
But whereas in C, null can potentially, if used in the wrong way,

42:46.720 --> 42:50.520
crash your program, Python might just print it, apparently.

42:50.520 --> 42:53.280
Where did I screw up?

42:53.280 --> 42:55.480
Yeah, so I didn't return an actual value.

42:55.480 --> 42:57.520
And whereas Clang might have noticed something like this,

42:57.520 --> 43:00.640
Python the interpreter is not going to be as sort of vigilant when

43:00.640 --> 43:02.960
it comes to figuring out if your code is missing something.

43:02.960 --> 43:05.640
Because after all, we never said we were going to return anything,

43:05.640 --> 43:07.360
and so we don't strictly need to.

43:07.360 --> 43:12.200
So what could I instead do here instead of break?

43:12.200 --> 43:17.080
I could just return n here, or I could equivalently do this,

43:17.080 --> 43:19.560
and then just make sure I return n here.

43:19.560 --> 43:22.920
And another difference in Python, too, is that the issue of scope

43:22.920 --> 43:26.760
isn't quite as difficult as it was in C.

43:26.760 --> 43:32.000
As soon as I've declared n to exist up here, it now exists down below.

43:32.040 --> 43:35.040
So even though it was declared inside of this indentation,

43:35.040 --> 43:38.240
it is not scoped to that while loop alone.

43:38.240 --> 43:41.880
So either way, could we actually make this work?

43:41.880 --> 43:44.600
OK, so now let's try to run this again.

43:44.600 --> 43:47.720
Positive integer, negative 1, 0, 1.

43:47.720 --> 43:49.440
And now we're actually seeing the number 1.

43:49.440 --> 43:51.160
All right, let me pause here for just a moment

43:51.160 --> 43:53.880
and see if there's any questions.

43:53.880 --> 43:54.560
No?

43:54.560 --> 43:55.060
Yes?

43:55.060 --> 43:59.200
Do you have to call the thing you can see at the library individually,

43:59.200 --> 44:01.200
or can you just import the entire one?

44:01.400 --> 44:04.080
You have to call things inside of the CS50 library individually,

44:04.080 --> 44:06.080
or can you import the whole thing?

44:06.080 --> 44:08.640
You can technically import the whole thing as follows.

44:08.640 --> 44:11.200
If you want access to everything in the CS50 library,

44:11.200 --> 44:12.520
you can literally say star.

44:12.520 --> 44:15.880
And in star in programming, well, in many computer contexts,

44:15.880 --> 44:17.840
star generally is a wild card character,

44:17.840 --> 44:21.640
and it means anything that matches this string here.

44:21.640 --> 44:23.520
This is generally considered bad practice, though,

44:23.520 --> 44:28.120
because if CS50's staff happens to give you functionality or variables

44:28.120 --> 44:30.640
that you don't want, you have now just imported

44:30.640 --> 44:34.600
into your namespace, so to speak, all of those functions.

44:34.600 --> 44:38.760
So for instance, if the CS50 library had public inside of it

44:38.760 --> 44:42.880
a variable called x and y and z, in addition to functions

44:42.880 --> 44:46.320
like getString and getInt and getChar, your program

44:46.320 --> 44:48.840
is now seeing variables x and y and z.

44:48.840 --> 44:51.200
And if you have your own variables called x and y and z,

44:51.200 --> 44:53.800
you're going to shadow those variables inside ours,

44:53.800 --> 44:55.480
and it just gets messy quickly.

44:55.480 --> 44:58.560
So generally, you want to be a little more nitpicky

44:58.560 --> 45:02.920
and just import what you want, or another convention in Python

45:02.920 --> 45:08.840
is to not specify it like this, but instead to do import CS50.

45:08.840 --> 45:12.840
This does not have the same effect of importing all of those keywords,

45:12.840 --> 45:16.640
like getInt and getString into your program's namespace,

45:16.640 --> 45:19.840
like the list of symbols you can actually type in.

45:19.840 --> 45:21.920
But what you then have to do is this.

45:21.920 --> 45:26.160
You have to now prefix any usages of the functions

45:26.160 --> 45:30.600
in that library with the now familiar or more familiar dot operator.

45:30.600 --> 45:33.000
So this is just a stylistic decision now.

45:33.000 --> 45:35.320
I have consciously chosen the other approach

45:35.320 --> 45:37.760
so that initially you can just call getInt, getString,

45:37.760 --> 45:41.320
just like we did in C. But technically and probably more conventionally

45:41.320 --> 45:44.200
would people do this to make super clear this isn't my getInt method,

45:44.200 --> 45:48.280
it's CS50's getInt function.

45:48.280 --> 45:50.640
OK, other questions?

45:50.640 --> 45:51.240
Yeah?

45:51.240 --> 45:56.760
Is it good coding practice to do the if underscore name or just because you

45:56.760 --> 45:59.240
can run Hello World without the defining main?

45:59.240 --> 46:00.480
Do you really need to do like that?

46:00.480 --> 46:01.760
Oh, it's a good question.

46:01.760 --> 46:03.120
Short answer, no.

46:03.120 --> 46:05.720
So I'm showing you this way because you'll

46:05.720 --> 46:08.680
see this in various examples online and in programs

46:08.680 --> 46:11.360
that you might look at that are open source.

46:11.360 --> 46:13.280
Strictly speaking, this is not necessary.

46:13.280 --> 46:17.760
If you end up making your own library, this tends to be a useful feature.

46:17.760 --> 46:23.600
But otherwise, I could equivalently do this, which is perfectly fine as well.

46:23.600 --> 46:25.760
I can still define getPositiveInt.

46:25.760 --> 46:28.120
I can get rid of main altogether.

46:28.120 --> 46:30.280
And I can just now do this.

46:30.280 --> 46:34.480
So this program is equivalent and just as fine for now.

46:34.480 --> 46:37.680
OK, so with that said, let's do a couple of more examples here.

46:37.680 --> 46:39.600
That kind of paints a picture of some of the things

46:39.600 --> 46:41.360
that are similar and different.

46:41.360 --> 46:44.200
And let's go ahead and open up, for instance,

46:44.240 --> 46:49.560
overflow.c from some weeks ago, splitting our windows again.

46:49.560 --> 46:53.200
And then on the right-hand side, let me open up something called overflow.pi,

46:53.200 --> 46:55.440
which I put together in advance.

46:55.440 --> 47:01.600
So here, we have on the left an example of integer overflow, whereby

47:01.600 --> 47:05.480
if I start counting at 1 and then don't even have a condition,

47:05.480 --> 47:09.240
and I just keep multiplying i by 2, by 2, by 2, doubling it, doubling it,

47:09.240 --> 47:12.240
doubling it, doubling it, we know from c that bad things happen.

47:12.280 --> 47:16.120
And if you just kind of keep incrementing something without any boundary in sight.

47:16.120 --> 47:18.680
So this program is just going to print out each of those values.

47:18.680 --> 47:20.800
And it's going to sleep one second in between.

47:20.800 --> 47:23.000
Same program in Python looks pretty similar.

47:23.000 --> 47:27.320
But notice I'm initializing i to 1, doing the following forever,

47:27.320 --> 47:32.280
printing out i, multiplying i by 2, and then sleeping for one second.

47:32.280 --> 47:35.600
But sleep is also not built into Python in the way that print is.

47:35.600 --> 47:37.280
Notice what I had to include up here.

47:37.280 --> 47:38.480
And I wasn't sure what that was.

47:38.480 --> 47:42.160
And so honestly, just a few days ago, I Googled to sleep one second

47:42.160 --> 47:46.080
in Python, saw that there's this time library inside of which is a sleep

47:46.080 --> 47:46.680
function.

47:46.680 --> 47:50.000
And that's how I knew which library to actually include.

47:50.000 --> 47:52.160
And so just as there are man pages for c,

47:52.160 --> 47:55.600
there's a whole documentation website for Python

47:55.600 --> 47:57.560
that has all of this information as well.

47:57.560 --> 47:58.800
So let me go ahead and do this.

47:58.800 --> 48:03.560
And let me actually try to create two windows here.

48:03.560 --> 48:07.320
What's the best way for me to do this?

48:07.320 --> 48:09.440
Split 1 to 2.

48:09.440 --> 48:13.640
OK, so let's do this just so I can run this in the same place.

48:13.640 --> 48:22.640
So if I go into my source 8 directory, and I go into weeks and 1,

48:22.640 --> 48:31.320
and I make overflow, nope, sorry, week 1.

48:31.320 --> 48:37.040
OK, so if I go into source 1, and I do make overflow, which is kind of cute

48:37.040 --> 48:40.880
semantically, I'm now going to be able to run a program called overflow.

48:40.880 --> 48:48.640
Meanwhile, over here, let me go ahead and split this window 2.

48:48.640 --> 48:50.360
Damn it, not there.

48:50.360 --> 48:54.640
Let's put this over here.

48:54.640 --> 48:55.320
Oh, no.

49:00.640 --> 49:02.520
OK, one second, sorry.

49:02.520 --> 49:04.000
Overflow.py.

49:04.000 --> 49:05.680
OK, so now we're back.

49:05.680 --> 49:06.560
No, I lost the other window.

49:09.760 --> 49:10.480
Oh, that's cool.

49:10.480 --> 49:14.080
OK, so let's do this.

49:14.080 --> 49:17.640
OK, now I know how to use the ID.

49:17.640 --> 49:20.840
All right, so on the left-hand side, I'm about to run overflow.

49:20.840 --> 49:23.640
And then lastly, without generating that beep again,

49:23.640 --> 49:29.800
I'm going to go in here, and I'm about to run Python of overflow.py.

49:29.800 --> 49:31.680
And so the left will run the C version.

49:31.680 --> 49:33.680
The right will run the Python version.

49:33.680 --> 49:42.200
And we'll start to see, no pun intended, what happens with these programs.

49:42.200 --> 49:43.120
Oh, damn it, I got to scroll.

49:47.680 --> 49:49.440
OK, so I'll just keep scrolling for us.

49:52.240 --> 49:52.880
This is fun.

49:59.400 --> 50:03.120
OK, next time, Google how to sleep for half a second instead.

50:03.120 --> 50:05.040
OK, so there we go.

50:05.040 --> 50:07.080
Something bad has happened here.

50:07.080 --> 50:09.320
And now C is just completely choking.

50:09.320 --> 50:11.440
Things are in a funky state.

50:11.440 --> 50:15.280
So what happened on the left before the answer scrolls away?

50:15.280 --> 50:16.280
Integer overflow, right?

50:16.280 --> 50:19.600
We had so many bits becoming ones that eventually it

50:19.600 --> 50:21.760
was mistaken for a negative number temporarily,

50:21.760 --> 50:25.280
and then the whole thing just kind of got confused and became permanently

50:25.280 --> 50:29.480
zeroes, whereas on the right-hand side, like, yeah, Python, look at you go.

50:29.480 --> 50:32.760
Like, still counting higher and higher and higher.

50:32.760 --> 50:35.400
And even though we haven't talked about the underlying representation

50:35.400 --> 50:39.200
of these types in Python, like, what can we infer from the apparent

50:39.200 --> 50:43.600
better correctness of the version on the right in Python?

50:43.600 --> 50:45.200
It's not an 8-bit representation.

50:45.200 --> 50:47.680
And even C, to be fair, uses 32 bits for its ints.

50:47.680 --> 50:50.960
And that's why we got as high as 2 billion or 4 billion in total.

50:50.960 --> 50:54.320
But same idea, how many bits must Python be using?

50:54.320 --> 50:55.320
64?

50:55.320 --> 50:56.600
Yeah, maybe 64.

50:56.600 --> 50:59.240
I don't know exactly, but I know it's not 32,

50:59.240 --> 51:01.240
because it keeps counting up and up and up.

51:01.240 --> 51:03.080
And so this is another feature of Python,

51:03.080 --> 51:06.240
whereas int in C has typically been for us 32 bits,

51:06.240 --> 51:08.760
although that is technically machine-specific.

51:08.760 --> 51:11.600
Python integers are now going to be 64, which just

51:11.600 --> 51:14.000
means we can do much bigger math, which is great for various data

51:14.000 --> 51:15.680
science applications and stats and whatnot,

51:15.680 --> 51:19.040
where you actually might have some large data sets to deal with.

51:19.040 --> 51:21.920
Unfortunately, we still have some issues of imprecision.

51:21.920 --> 51:24.480
Let me go ahead and close a whole bunch of these windows

51:24.480 --> 51:30.320
and go ahead and open up, for instance, just this one here.

51:31.040 --> 51:34.600
No, I'm going to skip this and do something slightly more fun, which

51:34.600 --> 51:35.280
is this.

51:35.280 --> 51:38.840
So in Python here, let's do a quick warm-up.

51:38.840 --> 51:41.400
This is going to print for me what?

51:41.400 --> 51:42.480
Four question marks, right?

51:42.480 --> 51:43.440
And this is reminiscent.

51:43.440 --> 51:46.560
This is a really cheap version of Super Mario Brothers.

51:46.560 --> 51:49.600
And if you think back to week one, where we explored this,

51:49.600 --> 51:51.920
there was a screenshot I had of Super Mario Brothers, one

51:51.920 --> 51:55.440
of the worlds, where we just had four question marks, which Mario could

51:55.440 --> 51:57.560
hit his head against to actually generate a coin.

51:57.600 --> 52:00.520
So we stepped up from there in C to do this instead.

52:00.520 --> 52:02.320
And this is going to give us another feature.

52:02.320 --> 52:05.960
But let's see if we can't start to infer from context what these programs do.

52:05.960 --> 52:07.320
Here's another one, Mario 1.

52:07.320 --> 52:07.920
What's this do?

52:12.080 --> 52:13.520
It's using a loop, for sure.

52:13.520 --> 52:15.960
And it's using how many iterations, apparently?

52:15.960 --> 52:18.920
Four, so from 0 to 1 to 2 to 3, total.

52:18.920 --> 52:22.000
Each time, it's going to print out, apparently, a question mark.

52:22.000 --> 52:23.800
But now, just infer from this.

52:23.800 --> 52:25.520
I haven't answered this question already.

52:25.560 --> 52:27.560
What else is going on on line four and why?

52:30.680 --> 52:32.200
Not going to a new line, right?

52:32.200 --> 52:35.400
So there's always this trade-off in programming and CS more generally,

52:35.400 --> 52:38.840
like, yay, we took away the backslash n, which was annoying to type.

52:38.840 --> 52:42.120
But now, if it's always there, how do you turn it off?

52:42.120 --> 52:44.200
So this is one way to do that.

52:44.200 --> 52:48.360
And it also reveals another fundamental feature of Python.

52:48.360 --> 52:52.320
Notice that print apparently takes, in this case, more than one argument.

52:52.320 --> 52:55.920
The first is a string, literally, quote, unquote, and a question mark.

52:55.920 --> 52:58.520
The second is a little funkier.

52:58.520 --> 53:03.920
It's like a word, and it's then an equal sign, and then it's a quote mark.

53:03.920 --> 53:05.320
So what is this here?

53:05.320 --> 53:09.560
So it turns out, Python supports what are called named parameters.

53:09.560 --> 53:12.520
So in C, any parameters you pass through a function

53:12.520 --> 53:16.080
are defined, ultimately, by way of their order.

53:16.080 --> 53:20.200
Because even if a function takes arguments that have names, like x and y

53:20.200 --> 53:23.680
or a and b or whatever, when you call the function,

53:23.680 --> 53:25.840
you do not mention those names.

53:25.840 --> 53:28.080
You know they exist, and that's how you think about them

53:28.080 --> 53:30.800
in the documentation or in the original code.

53:30.800 --> 53:35.160
But you don't name the arguments as you pass them in and call a function.

53:35.160 --> 53:38.480
You instead pass them in in the appropriate order per the man page

53:38.480 --> 53:40.480
or per the documentation.

53:40.480 --> 53:43.600
So in Python, you can actually be a little more flexible.

53:43.600 --> 53:47.640
If a function takes multiple arguments, all of which have names,

53:47.640 --> 53:51.800
you can actually mention the names explicitly, thereby freeing you

53:51.800 --> 53:55.200
from the minor inconvenience of having to remember and always get right

53:55.200 --> 53:57.600
the actual order of arguments.

53:57.600 --> 54:01.640
So in this case, print apparently takes at least two arguments in this case,

54:01.640 --> 54:03.120
one of which is called end.

54:03.120 --> 54:06.800
And if you want to use that one, which is clearly optional because I haven't

54:06.800 --> 54:10.640
used it yet, you can literally mention it by name, set an equal sign,

54:10.640 --> 54:13.040
and then specify the value that you want to pass in.

54:13.040 --> 54:17.040
So if I actually now go into this and go into weeks and one

54:17.040 --> 54:25.760
and do Python of mario1.py, whoops, I'll still get in week two.

54:25.760 --> 54:30.520
If I get mario1.py, I still get four question marks.

54:30.520 --> 54:34.920
But that's the result of printing this with a line ending of quote unquote.

54:34.920 --> 54:38.080
If I do this, meanwhile, it's a little stupid because I'm

54:38.080 --> 54:40.720
going to get that for free if I just omit it all together.

54:40.720 --> 54:42.520
But now I get four question marks here.

54:42.520 --> 54:46.200
And if you really want to be funky, you can do something

54:46.240 --> 54:52.560
like this, which is just going to be taken literally to give you that instead.

54:52.560 --> 54:59.320
Unclear utility of taking this approach, but that's all, sorry, that's going on.

54:59.320 --> 55:00.880
Let's take a look at mario2.

55:00.880 --> 55:02.640
This one works a little differently as well.

55:02.640 --> 55:05.680
And how would you describe the feature offered by this version of mario?

55:09.360 --> 55:11.280
Print any number of question marks perfectly.

55:11.280 --> 55:13.800
So it's parameterized by first getting an int from the user,

55:13.800 --> 55:15.680
using CS50's getInt function.

55:15.680 --> 55:19.760
And now I'm iterating from i to the range of n, whatever that is,

55:19.760 --> 55:22.680
and then actually printing out the question marks.

55:22.680 --> 55:26.840
Meanwhile, in mario3.py, a little fancier still,

55:26.840 --> 55:28.600
but what am I doing a little better now?

55:36.480 --> 55:38.280
Yeah, I'm just making sure that the n is positive.

55:38.280 --> 55:41.640
So I didn't bother implementing a whole function called getPositiveAnt.

55:41.640 --> 55:42.200
I don't need that.

55:42.200 --> 55:43.640
This is a super short program.

55:43.640 --> 55:45.520
I'm just using the same logic up here.

55:45.520 --> 55:48.080
Inducing deliberately an infinite loop, breaking out of it

55:48.080 --> 55:50.240
only when I've gotten back a positive integer,

55:50.240 --> 55:54.760
and then printing out that many of hashtags reminiscent of the bricks

55:54.760 --> 55:55.600
in mario.

55:55.600 --> 55:59.720
And then lastly, we have this slightly more sophisticated version that

55:59.720 --> 56:03.160
actually prints out a different shape altogether.

56:03.160 --> 56:06.000
You can infer from the comments, but focus more on why.

56:06.000 --> 56:17.240
So this first line 12 iterates from i to n, whatever n is, that the user typed in.

56:17.240 --> 56:24.160
Meanwhile, line 15, indented, iterates from j from 0 up to n as well.

56:24.160 --> 56:27.840
So this is kind of like our canonical forint i gets 0, dot, dot, dot,

56:27.840 --> 56:31.640
forint j gets 0, dot, dot, dot, where we've had nested loops in the past.

56:31.640 --> 56:34.880
So notice, now that we have this building block, which is a line of code,

56:34.880 --> 56:36.760
or kind of conceptually just a scratch piece,

56:36.760 --> 56:38.640
we can embed one inside of the other.

56:38.640 --> 56:41.600
Here, I can print out a hashtag, making sure not to put a new line

56:41.600 --> 56:46.320
after every single hashtag I print out, only printing out a new line,

56:46.320 --> 56:50.000
on line 17, on each iteration of the outer loop.

56:50.000 --> 56:54.600
And now notice, whereas in C, we would have done this historically,

56:54.600 --> 56:55.640
and that's fine.

56:55.640 --> 56:59.680
In Python, we don't need the f, and we also don't need the backslash n.

56:59.680 --> 57:01.680
So ergo, you can simply do print, and you'll

57:01.680 --> 57:05.080
get, if nothing else, a backslash n automatically,

57:05.080 --> 57:07.560
so that now, when I run this version of Mario,

57:07.560 --> 57:09.280
we now get something more interesting.

57:09.280 --> 57:11.640
And I'll increase the size of my terminal window for this,

57:11.640 --> 57:14.440
so that I can enter a positive number like this, and print 10.

57:14.440 --> 57:15.920
And now we've got a whole block.

57:15.920 --> 57:16.800
So that was a lot.

57:16.800 --> 57:19.320
Let's go ahead and take our five minute break here, and we'll come back.

57:19.320 --> 57:22.040
We'll look at some more sophisticated examples still.

57:22.040 --> 57:22.920
All right.

57:22.920 --> 57:28.040
So let's begin to start to transition to actually solving problems with Python

57:28.040 --> 57:30.360
after introducing just a couple of additional features that aren't

57:30.360 --> 57:34.120
so much syntactic, but actual features of the language.

57:34.120 --> 57:38.560
So here on the left was an old program we wrote in week three called argv0.c.

57:38.560 --> 57:41.680
And its purpose in life was simply to allow you to run a command line

57:41.680 --> 57:43.200
argument for the very first time.

57:43.200 --> 57:45.240
And that was a nice tool to have in our toolkit.

57:45.240 --> 57:47.000
So how might we go ahead and map this?

57:47.000 --> 57:50.720
Well, we actually need to know how Python works a little bit differently

57:50.720 --> 57:51.520
as follows.

57:51.520 --> 58:03.920
If I go ahead and open a new file called, let's call it argv0.py,

58:03.920 --> 58:06.880
I'm going to go ahead and translate this just as we did earlier.

58:06.880 --> 58:12.360
So I'm going to go ahead and want to use the following.

58:12.360 --> 58:16.400
So if argc, so there is no argc.

58:17.160 --> 58:21.480
So def main, there was also no argc or argv.

58:21.480 --> 58:26.320
And it's not actually correct to do this and this, as you might assume.

58:26.320 --> 58:29.840
It turns out that the feature command line arguments are provided by a Python

58:29.840 --> 58:34.040
package, so to speak, or a library, much like the CS50 library is a package

58:34.040 --> 58:36.080
that you can import in Python speak.

58:36.080 --> 58:38.440
So to do this, I actually need to do this.

58:38.440 --> 58:42.240
Import sys, which gives me access to a whole bunch of system related stuff

58:42.240 --> 58:44.560
like what the user has typed at the command prompt.

58:44.600 --> 58:48.960
And if I want to check if the number of words that the human typed at the prompt

58:48.960 --> 58:51.480
is 2, I actually am going to do this.

58:51.480 --> 58:57.600
If the length of sys.argv equals 2, then I'm

58:57.600 --> 59:03.880
going to go ahead and print out, quote unquote, hello, comma,

59:03.880 --> 59:05.920
and then a placeholder here.

59:05.920 --> 59:08.920
I know for placeholders I need to turn this into a formatted string,

59:08.920 --> 59:10.560
so an f string there.

59:10.560 --> 59:13.680
And now inside of the curly braces, it turns out

59:13.680 --> 59:18.240
I can do sys.argv bracket 1.

59:18.240 --> 59:21.600
So it's a little different from before, but notice I'm barring almost

59:21.600 --> 59:25.440
all the same ideas as earlier, including how we're printing out strings.

59:25.440 --> 59:27.320
And even though this is a little more verbose, what

59:27.320 --> 59:29.160
is between these two curly braces?

59:29.160 --> 59:33.160
Well, it's the result of looking in the system package, which has a variable

59:33.160 --> 59:34.920
called argv for argument vector.

59:34.920 --> 59:39.400
Just like in C, it is itself an array, aka a list in Python.

59:39.400 --> 59:44.160
And here we have the result of indexing into element 1 of that list.

59:44.160 --> 59:49.040
And the way that I have access to this is because I've imported that whole package.

59:49.040 --> 59:53.160
So if on the right hand side here, I go ahead after saving that file,

59:53.160 --> 59:57.880
and I do Python of argv0.py, I see nothing.

59:57.880 --> 01:00:01.680
But if I actually say, like, my name here, I see hello.david.

01:00:01.680 --> 01:00:05.760
So very similar program, but implemented a little differently.

01:00:05.760 --> 01:00:10.360
And you'll notice, too, that the length of an array, henceforth known

01:00:10.360 --> 01:00:14.700
as a list, is not something that you yourself have to remember or keep

01:00:14.700 --> 01:00:15.200
around.

01:00:15.200 --> 01:00:20.000
You can just ask a list how long it is by calling the lang, or len,

01:00:20.000 --> 01:00:23.600
for length function, passing it in as an argument.

01:00:23.600 --> 01:00:25.600
So that's one of the takeaways there.

01:00:25.600 --> 01:00:28.000
And if we actually want to do something a little more clever,

01:00:28.000 --> 01:00:32.720
like print out all of the strings in argv, well, back in the day in C,

01:00:32.720 --> 01:00:37.360
you might recall this example, argv1.c, wherein I had this for loop,

01:00:37.360 --> 01:00:40.940
and I iterated from 0 on up to argc, the argument count,

01:00:40.940 --> 01:00:44.400
printing out each of the arguments in that vector.

01:00:44.400 --> 01:00:48.120
Python actually makes even something like this even simpler.

01:00:48.120 --> 01:00:50.400
Let me go ahead and create a new file here,

01:00:50.400 --> 01:00:53.560
and I'll call this, say, argv1.py.

01:00:53.560 --> 01:00:58.480
And it turns out in Python, I can similarly just import sys, and then

01:00:58.480 --> 01:01:06.800
do, honestly, for s in sys.argv, print s, done.

01:01:06.800 --> 01:01:08.840
So again, kind of just says what it means.

01:01:08.840 --> 01:01:11.920
So I've imported the system library, sys.argv,

01:01:11.920 --> 01:01:14.520
I know to be a list, apparently, of command line arguments,

01:01:14.520 --> 01:01:18.200
for something in something is a new syntax we have for for loop.

01:01:18.200 --> 01:01:23.520
So for some variable s inside of this list, go ahead and print it.

01:01:23.520 --> 01:01:26.800
And so it's a much cleaner, much more succinct way of, honestly,

01:01:26.800 --> 01:01:29.680
getting rid of all of the complexity of this

01:01:29.680 --> 01:01:32.200
by just saying, instead, what we mean.

01:01:32.200 --> 01:01:34.240
Meanwhile, if I wanted to print out every character,

01:01:34.240 --> 01:01:35.960
I can take this one step further.

01:01:35.960 --> 01:01:38.520
So back in the day, in C, if I wanted to print out

01:01:38.520 --> 01:01:42.160
every command line argument and every character therein,

01:01:42.160 --> 01:01:43.040
I could do this.

01:01:43.040 --> 01:01:46.520
I just need a couple of nested loops wherein, via the outer loop,

01:01:46.520 --> 01:01:49.960
I iterate over all of the arguments passed in.

01:01:49.960 --> 01:01:53.400
And on the inner loop, I iterate over the current string length

01:01:53.400 --> 01:01:55.320
of whatever argument I'm printing.

01:01:55.360 --> 01:01:58.760
And this had the effect of printing out all of the command line arguments

01:01:58.760 --> 01:02:01.040
letters one at a time.

01:02:01.040 --> 01:02:03.480
I can do this in Python, honestly, so much easier.

01:02:03.480 --> 01:02:05.000
So let me go over here.

01:02:05.000 --> 01:02:10.160
Let me create a new file called argv2.py.

01:02:10.160 --> 01:02:11.840
Let me import sys as I did.

01:02:11.840 --> 01:02:21.440
So import sys and then for snsys.argv, for cns, print c, done.

01:02:21.440 --> 01:02:22.720
So what is this doing?

01:02:22.720 --> 01:02:27.760
Gone is all of the overhead of four int i and four int j and so forth.

01:02:27.760 --> 01:02:33.480
For snsys.argv, iterates over all of the elements of that list, one string at a time.

01:02:33.480 --> 01:02:38.480
For cns is a little different, because s is technically a string or a stir object,

01:02:38.480 --> 01:02:39.720
as we're going to start calling it.

01:02:39.720 --> 01:02:42.520
But at the end of the day, a string is just a sequence of characters,

01:02:42.520 --> 01:02:46.120
and turns out Python supports out of the box the ability to use a for loop,

01:02:46.120 --> 01:02:48.600
even to iterate over all of the characters in a string.

01:02:48.600 --> 01:02:50.000
And so c, I just mean char.

01:02:50.000 --> 01:02:53.360
So for cns, that gives me each of the characters.

01:02:53.360 --> 01:03:01.240
So now with the end here, if I go ahead and run Python of argv2.py with nothing,

01:03:01.240 --> 01:03:04.520
I get just the program's name, because that's, of course,

01:03:04.520 --> 01:03:06.920
the very first thing in argv as in C.

01:03:06.920 --> 01:03:09.920
And if I write, say, a word like Maria here,

01:03:09.920 --> 01:03:15.720
I get argv2.py Maria all in one long column,

01:03:15.720 --> 01:03:18.920
because of the additional prints that are happening in the implicit new lines.

01:03:18.920 --> 01:03:19.640
So any questions?

01:03:19.680 --> 01:03:25.960
Before we proceed on this use of a package called sys, using these libraries,

01:03:25.960 --> 01:03:28.080
rather using these functions therein.

01:03:28.080 --> 01:03:33.560
All right, so let me skip ahead then to something slightly familiar too.

01:03:33.560 --> 01:03:39.520
Let me go ahead, and you might recall, initials.c from some time ago,

01:03:39.520 --> 01:03:44.680
wherein we accepted as a command line argument a user rather as an input

01:03:44.680 --> 01:03:47.400
to get string, a user's name, and then we printed out their initial.

01:03:47.400 --> 01:03:48.520
So let's go ahead and do that.

01:03:48.520 --> 01:03:52.000
So from cs50, let me go ahead and import, get string.

01:03:52.000 --> 01:03:54.800
Then let me go ahead and say, get me a string,

01:03:54.800 --> 01:03:59.880
and I want the user to be prompted for their name, as we might do here.

01:03:59.880 --> 01:04:02.920
Then let me go ahead and say, all right, there are initials.

01:04:02.920 --> 01:04:06.280
I don't know what they are yet, so let me just initialize an empty string,

01:04:06.280 --> 01:04:07.320
but then do this.

01:04:07.320 --> 01:04:13.080
For c in s, which is for each character in the person's name, if,

01:04:13.080 --> 01:04:17.880
and I don't know how to say this yet, if c is an uppercase

01:04:17.880 --> 01:04:24.920
letter, then go ahead and append c to initials,

01:04:24.920 --> 01:04:26.720
and then down here, print initials.

01:04:26.720 --> 01:04:28.040
So I've left a couple of blanks.

01:04:28.040 --> 01:04:29.880
That's just pseudocode for the moment.

01:04:29.880 --> 01:04:33.480
But this line five, just to be clear, is doing what for me?

01:04:33.480 --> 01:04:35.560
What is being iterated over?

01:04:35.560 --> 01:04:36.000
The string.

01:04:36.000 --> 01:04:39.880
So for each character in the string, for c in s,

01:04:39.880 --> 01:04:41.200
I'm going to ask two questions.

01:04:41.200 --> 01:04:44.320
So in c, we did this in a couple of different ways.

01:04:44.320 --> 01:04:46.280
We can actually do it with kind of arithmetic,

01:04:46.280 --> 01:04:49.280
assuming rather with inequality checks and actually considering

01:04:49.280 --> 01:04:50.960
what the underlying ASCII values are.

01:04:50.960 --> 01:04:55.000
The c type library had that is upper function and is lower that we use.

01:04:55.000 --> 01:05:00.720
Well, it turns out, because c is itself not a char,

01:05:00.720 --> 01:05:04.080
there is no such thing technically as a char in Python.

01:05:04.080 --> 01:05:06.400
You have only strings of length one.

01:05:06.400 --> 01:05:09.480
And this is why single quotes no longer have any special meaning.

01:05:09.480 --> 01:05:13.480
It turns out c is technically just a one character string.

01:05:13.480 --> 01:05:16.160
Strings are what we've started calling objects,

01:05:16.200 --> 01:05:18.240
which is a fancier name for struct.

01:05:18.240 --> 01:05:21.880
So inside of an object, like a string, is functionality.

01:05:21.880 --> 01:05:26.080
And we saw one piece of functionality earlier, which was what?

01:05:26.080 --> 01:05:33.040
Not length, but though that is another one, it was format.

01:05:33.040 --> 01:05:34.120
We saw it briefly.

01:05:34.120 --> 01:05:36.920
But when I did the string.format, I proposed

01:05:36.920 --> 01:05:39.200
that there's actually built-in functionality to a string called

01:05:39.200 --> 01:05:39.960
format.

01:05:39.960 --> 01:05:40.680
Well, you know what?

01:05:40.680 --> 01:05:45.600
It turns out there is a method or a function inside of the string class,

01:05:45.640 --> 01:05:47.400
also called isUpper.

01:05:47.400 --> 01:05:51.800
And I can ask the very string I'm looking at that question by saying,

01:05:51.800 --> 01:05:57.640
if c.isUpper is true, then go ahead and append c to initials.

01:05:57.640 --> 01:06:03.720
So in c, if initials were technically a string,

01:06:03.720 --> 01:06:07.400
how could you go about appending another character to a string in c?

01:06:10.400 --> 01:06:12.160
C dot appends?

01:06:12.160 --> 01:06:14.200
Not in c.

01:06:14.200 --> 01:06:17.360
Oh, so in c, the language.

01:06:17.360 --> 01:06:18.680
OK, so what's a string in c?

01:06:18.680 --> 01:06:21.640
A string in c is a sequence of characters, the last one of which

01:06:21.640 --> 01:06:24.000
is backslash 0.

01:06:24.000 --> 01:06:26.640
All right, so it's an array of characters, last of which is backslash 0.

01:06:26.640 --> 01:06:29.720
So if I, for instance, typed in my first name, David,

01:06:29.720 --> 01:06:32.440
and now I want to append mail-in to the end of it,

01:06:32.440 --> 01:06:33.480
how do I do that in c?

01:06:36.120 --> 01:06:37.800
Exactly, it's like an utter pain in the neck.

01:06:37.800 --> 01:06:41.240
You have to create a new array that's bigger, that can fit both words,

01:06:41.280 --> 01:06:44.820
copy the David into the new array, then copy the last name in,

01:06:44.820 --> 01:06:46.640
then put the null terminator at the new array,

01:06:46.640 --> 01:06:48.600
then free, probably, the original memory.

01:06:48.600 --> 01:06:50.840
I mean, it's a ridiculous number of hoops to jump through.

01:06:50.840 --> 01:06:53.600
And you've done this on occasion, especially for things like, perhaps,

01:06:53.600 --> 01:06:54.800
problem set five.

01:06:54.800 --> 01:06:56.560
But my god, we're kind of past that.

01:06:56.560 --> 01:07:00.880
Just go ahead and append to the array the character you care about.

01:07:00.880 --> 01:07:03.560
So in this case, not an array, but a list.

01:07:03.560 --> 01:07:08.000
Sorry, not an array, but a string object that's initially blank.

01:07:08.000 --> 01:07:11.160
It turns out that Python supports this syntax plus equals

01:07:11.160 --> 01:07:14.440
typically means arithmetic and add one number to another,

01:07:14.440 --> 01:07:16.080
but it also means append.

01:07:16.080 --> 01:07:20.960
So you can simply append two initials by doing plus equals c,

01:07:20.960 --> 01:07:22.080
one additional character.

01:07:22.080 --> 01:07:24.920
So even though the string starts like this in this big in memory,

01:07:24.920 --> 01:07:26.560
it's then going to grow for one character,

01:07:26.560 --> 01:07:30.600
grow, grow, grow, grow until it has all of the user's initials.

01:07:30.600 --> 01:07:33.880
And as for where that memory is coming from, who cares?

01:07:33.880 --> 01:07:36.120
This is the point that we're now past.

01:07:36.120 --> 01:07:37.560
You leave it to the language.

01:07:37.560 --> 01:07:40.520
You leave it to the computer to start to manage those details.

01:07:40.520 --> 01:07:42.640
And yes, if it needs to call Malek, fine, do it.

01:07:42.640 --> 01:07:44.280
Don't bother me with that detail.

01:07:44.280 --> 01:07:46.880
We can now start thinking and writing code sort of conceptually

01:07:46.880 --> 01:07:49.480
at this level instead of at this level.

01:07:49.480 --> 01:07:52.360
So again, we're sort of abstracting away what a string even is

01:07:52.360 --> 01:07:54.400
and leaving it to the language itself.

01:07:54.400 --> 01:07:58.360
So if I now go ahead and run Python of initials.py and type in,

01:07:58.360 --> 01:08:05.000
for instance, Maria Zlatkova here with a capital M and a capital Z,

01:08:05.000 --> 01:08:08.000
I then see her names because I've plucked out the middle initials.

01:08:08.000 --> 01:08:12.080
And if we do something else like David J. Malen, even with a period in there,

01:08:12.080 --> 01:08:15.880
it infers from the capitalization what my initials should actually be.

01:08:15.880 --> 01:08:18.440
So again, a much tighter way of doing things.

01:08:18.440 --> 01:08:20.420
Let me go ahead and now open up another example.

01:08:20.420 --> 01:08:22.600
We didn't see a few weeks ago, though it was included

01:08:22.600 --> 01:08:26.160
in some of our distribution code, if you wanted to look.

01:08:26.160 --> 01:08:30.040
Some weeks ago, we had this program among the distribution code,

01:08:30.040 --> 01:08:34.800
where I declared an array of strings called book.

01:08:34.800 --> 01:08:38.600
And I proposed that there were these several names in the phone book,

01:08:38.600 --> 01:08:43.080
so to speak, all of the past instructors of CS50 sorted alphabetically.

01:08:43.080 --> 01:08:47.160
And then down below in this C program, I used that global variable called

01:08:47.160 --> 01:08:51.160
book to implement, it seems, linear search.

01:08:51.160 --> 01:08:54.680
And to implement linear search in C, I'm going to need, of course,

01:08:54.680 --> 01:08:57.080
a loop to iterate over all of the strings.

01:08:57.080 --> 01:08:59.720
This line 26 does exactly that.

01:08:59.720 --> 01:09:03.080
I then in C recall how to use stir compare because remember, we tripped over

01:09:03.080 --> 01:09:06.040
this issue early on where you can't just compare two strings in C

01:09:06.040 --> 01:09:10.320
because you'd be comparing accidentally their addresses, their pointers,

01:09:10.320 --> 01:09:11.280
not the actual value.

01:09:11.280 --> 01:09:14.680
So we use stir compare, and I can pass in the name that I'm looking for

01:09:14.680 --> 01:09:18.200
and the ith book one at a time, checking for equals zero.

01:09:18.200 --> 01:09:21.560
And then I can call Mike or David or whoever I'm trying to call,

01:09:21.560 --> 01:09:24.200
or just quit if the user isn't found.

01:09:24.200 --> 01:09:25.960
So what did this program actually do?

01:09:25.960 --> 01:09:31.080
If I go into this example, which again was from week three,

01:09:31.080 --> 01:09:36.840
and I do make linear, nope, not that make, oh, wrong directory again.

01:09:36.840 --> 01:09:40.680
If I go into source three and make linear,

01:09:40.680 --> 01:09:43.160
this program is supposed to behave as follows.

01:09:43.160 --> 01:09:47.880
So if I go ahead and run dot slash linear, look for our old friend Smith.

01:09:47.880 --> 01:09:52.600
If found Smith, if I go ahead and search for, say, Jones, who did not previously

01:09:52.600 --> 01:09:54.280
teach CS50, it says quitting.

01:09:54.280 --> 01:09:58.360
All right, so meanwhile, in Python, bless its heart,

01:09:58.360 --> 01:10:00.680
we can get rid of all of that.

01:10:00.680 --> 01:10:05.520
And in our source eight directory here and our sub directory three,

01:10:05.520 --> 01:10:08.600
let me go ahead and open this instead.

01:10:08.600 --> 01:10:13.000
In Python, I can declare an array, otherwise known as a list, almost

01:10:13.000 --> 01:10:16.720
in the same way, but what's different just to be super clear?

01:10:16.720 --> 01:10:17.920
Brackets?

01:10:17.920 --> 01:10:20.600
So the brackets are now square brackets instead of curly braces.

01:10:20.600 --> 01:10:24.200
And frankly, unless you statically initialized an array in C,

01:10:24.200 --> 01:10:26.200
like hard coded the values for your array in C,

01:10:26.200 --> 01:10:28.600
you might not even have known you could use curly braces.

01:10:28.600 --> 01:10:30.080
So that's not a huge deal here.

01:10:30.080 --> 01:10:33.240
But in Python, square brackets here and here

01:10:33.240 --> 01:10:36.080
represent a list of elements, literally.

01:10:36.080 --> 01:10:39.520
And what else is different?

01:10:39.520 --> 01:10:40.800
Didn't declare the size of the array.

01:10:40.800 --> 01:10:42.640
And I technically don't have to do that in C either

01:10:42.640 --> 01:10:45.640
if you're hard coding all of the values all at once.

01:10:45.640 --> 01:10:48.840
But there is something missing on line seven.

01:10:48.840 --> 01:10:51.200
Sorry?

01:10:51.200 --> 01:10:51.760
The type.

01:10:51.760 --> 01:10:52.920
I didn't specify string.

01:10:52.920 --> 01:10:56.280
But otherwise, this is pretty similar to what we've done in C.

01:10:56.280 --> 01:11:01.200
But what's beautiful here, and let me go ahead and hide that for just a second,

01:11:01.200 --> 01:11:05.160
let me go ahead and prompt the user for his or her name.

01:11:05.160 --> 01:11:07.120
So let's ask for the name here.

01:11:07.120 --> 01:11:10.680
And then if I want to search the book, which is just a list of names,

01:11:10.680 --> 01:11:12.320
how do I implement linear search?

01:11:12.320 --> 01:11:20.680
Well, I could just do if name in book, print, calling, name,

01:11:20.680 --> 01:11:22.520
and let's make this an F string.

01:11:22.520 --> 01:11:25.320
And then down here, that's it.

01:11:25.320 --> 01:11:27.560
So that's how you implement linear search in Python.

01:11:27.560 --> 01:11:28.600
You don't need a loop.

01:11:28.600 --> 01:11:30.840
You can just ask the question yourself.

01:11:30.840 --> 01:11:35.480
So if book is a list, and name is the string that you're looking for,

01:11:35.480 --> 01:11:37.880
just ask the language to figure this out for you.

01:11:37.880 --> 01:11:43.280
If name in book is the syntax you can use to ask literally that question.

01:11:43.280 --> 01:11:46.880
And in Python, we'll use probably linear search over that list,

01:11:46.880 --> 01:11:48.960
because it doesn't necessarily know it's sorted,

01:11:48.960 --> 01:11:50.760
even though it happens to be alphabetically.

01:11:50.760 --> 01:11:54.680
But it will find it for you, thereby saving us a lot of the complexity

01:11:54.680 --> 01:11:58.200
and time of having had to implement that ourselves.

01:11:58.200 --> 01:12:03.040
Meanwhile, if I want to compare two strings, let me propose this.

01:12:03.040 --> 01:12:04.760
Let me write a quick program here.

01:12:04.760 --> 01:12:06.520
Compare 1.py.

01:12:06.520 --> 01:12:11.080
And let me go ahead and from CS50 import, get string as before.

01:12:11.080 --> 01:12:16.220
And now let me go ahead and get one string that I'll call S.

01:12:16.220 --> 01:12:22.500
And let me get another string that I shall call T, just as we did a few weeks ago.

01:12:22.500 --> 01:12:27.140
And now in C, this was buggy.

01:12:27.140 --> 01:12:32.380
If I print same, else I print different.

01:12:32.380 --> 01:12:36.780
So in C, just to be super clear, why was this incorrect,

01:12:36.780 --> 01:12:39.540
this general idea of using equals equals?

01:12:42.940 --> 01:12:44.420
Yeah, they're comparing addresses.

01:12:44.420 --> 01:12:47.060
This was like the day before we peeled back

01:12:47.060 --> 01:12:49.340
the layer of what a string actually is.

01:12:49.340 --> 01:12:53.100
And it turns out that S and T in C were char stars or addresses,

01:12:53.100 --> 01:12:55.260
which means, certainly, if you get two different strings,

01:12:55.260 --> 01:12:56.860
even if you've typed the same characters,

01:12:56.860 --> 01:12:58.740
you're going to be comparing two different addresses.

01:12:58.740 --> 01:13:00.020
They're not going to be the same.

01:13:00.020 --> 01:13:02.820
Now you can perhaps infer from the theme of today,

01:13:02.820 --> 01:13:07.220
what is Python going to do if asked if S and T are equal?

01:13:07.220 --> 01:13:11.260
It's going to ask and answer that question as you would expect as the human.

01:13:11.260 --> 01:13:14.900
Equals equals now in Python is going to compare S and T,

01:13:14.900 --> 01:13:17.700
look at their actual values, because they are strings,

01:13:17.700 --> 01:13:21.500
and return same if you literally type the same words.

01:13:21.500 --> 01:13:26.660
So in here, if I go in here, and I do Python of compare 1.py,

01:13:26.660 --> 01:13:32.380
and I type in, for instance, Maria, and then I type in Maria,

01:13:32.380 --> 01:13:33.340
they're indeed the same.

01:13:33.340 --> 01:13:36.780
If I type in Maria and say Stelios, they're different,

01:13:36.780 --> 01:13:39.180
because it's actually now comparing the strings,

01:13:39.180 --> 01:13:41.900
as we would have hoped some time ago.

01:13:41.900 --> 01:13:44.000
So let's take a look at another that kind of led

01:13:44.000 --> 01:13:45.580
to some interesting quandaries.

01:13:45.580 --> 01:13:50.700
You might recall in week four, we had this example in C.

01:13:50.700 --> 01:13:54.780
No swap, so named, because this just did not work.

01:13:54.780 --> 01:13:57.420
It was logically, seemingly correct.

01:13:57.420 --> 01:14:02.580
But swap did not actually swap x and y, but it did swap a and b.

01:14:02.580 --> 01:14:03.080
Why?

01:14:03.840 --> 01:14:09.840
The memory locations were different.

01:14:09.840 --> 01:14:12.880
So x and y, recall, are variables in C that

01:14:12.880 --> 01:14:16.080
exist in a certain slice of memory that we called a frame on the stack,

01:14:16.080 --> 01:14:18.080
main's frame on the stack.

01:14:18.080 --> 01:14:22.120
Meanwhile, a and b are from a slightly different location in memory.

01:14:22.120 --> 01:14:23.840
We sort of kept drawing it slightly above,

01:14:23.840 --> 01:14:28.080
like a tray at the dining hall on the so-called stack.

01:14:28.080 --> 01:14:32.000
A and b had the same values of x and y, one and two,

01:14:32.000 --> 01:14:33.360
but their own copies of them.

01:14:33.360 --> 01:14:37.160
So even though we logically, as with Kate, I think with the Gatorade,

01:14:37.160 --> 01:14:41.280
swap the two values, we ultimately swap the wrong two values

01:14:41.280 --> 01:14:45.360
without actually permanently mutating the original x and y.

01:14:45.360 --> 01:14:48.600
So unfortunately, and unfortunately in Python,

01:14:48.600 --> 01:14:50.360
there is no such thing as a pointer.

01:14:50.360 --> 01:14:51.760
So those are now gone.

01:14:51.760 --> 01:14:53.880
So we no longer have the expressiveness with which

01:14:53.880 --> 01:14:55.800
to solve this problem that way.

01:14:55.800 --> 01:15:01.960
But let me propose that we do it in oh, so clever of another way.

01:15:01.960 --> 01:15:06.000
Here, let me go ahead and declare x is 1, y is 2.

01:15:06.000 --> 01:15:07.720
Let me go ahead and print out as much.

01:15:07.720 --> 01:15:13.360
So with a format string, I'm going to go ahead and say x is x, y is y,

01:15:13.360 --> 01:15:15.240
plugging in their respective values.

01:15:15.240 --> 01:15:16.680
I'm going to do that twice.

01:15:16.680 --> 01:15:19.520
But in between, I'm going to try to perform this swap.

01:15:19.520 --> 01:15:24.920
And if your mind's ready to be blown, do that in Python.

01:15:24.960 --> 01:15:27.440
Do the old switcheroo in Python.

01:15:27.440 --> 01:15:30.440
And this actually does swap the two values as you would expect.

01:15:30.440 --> 01:15:31.920
Now, this is not a very common case.

01:15:31.920 --> 01:15:34.480
And to be fair, this is an incredibly contrived example.

01:15:34.480 --> 01:15:36.760
Because if you needed them swapped, well, maybe you

01:15:36.760 --> 01:15:38.560
should have just done this in the first place.

01:15:38.560 --> 01:15:40.960
But it does speak to one of the features of Python

01:15:40.960 --> 01:15:44.160
where you can actually do something like that.

01:15:44.160 --> 01:15:49.760
Let me introduce now one additional feature that we only recently acquired in C.

01:15:49.760 --> 01:15:51.320
And that's the notion of a struct.

01:15:51.320 --> 01:15:54.200
And let me go ahead and do this in code from scratch.

01:15:54.240 --> 01:15:58.400
So let me go ahead and save this file proactively as struct0.py,

01:15:58.400 --> 01:16:00.640
reminiscent of one of our older programs.

01:16:00.640 --> 01:16:02.080
And let me go ahead and do this.

01:16:02.080 --> 01:16:05.720
From cs50, import getString.

01:16:05.720 --> 01:16:07.840
And then let me give myself an empty list.

01:16:07.840 --> 01:16:09.840
So that would be a conventional way of giving yourself

01:16:09.840 --> 01:16:11.400
an empty list in Python.

01:16:11.400 --> 01:16:14.880
And much like in C, you can declare an empty array.

01:16:14.880 --> 01:16:16.760
But in C, you have to know the size of it.

01:16:16.760 --> 01:16:18.320
Or if not, you have to use a pointer.

01:16:18.320 --> 01:16:19.320
And then you have to mallet.

01:16:19.320 --> 01:16:21.000
No, all of that is gone.

01:16:21.000 --> 01:16:22.520
Now in Python, you want a list?

01:16:22.520 --> 01:16:25.800
Just say you need a list, and it will grow and shrink as you need.

01:16:25.800 --> 01:16:30.360
Now I'm going to go ahead and just three times arbitrarily for i in the range of three.

01:16:30.360 --> 01:16:34.600
Let me go ahead and ask the user for a name using getString.

01:16:34.600 --> 01:16:36.760
And I'll ask him or her if their name.

01:16:36.760 --> 01:16:39.560
Dorm will use getString as well.

01:16:39.560 --> 01:16:40.640
Dorm here.

01:16:40.640 --> 01:16:45.200
And then I want to append to the array this student.

01:16:45.200 --> 01:16:48.280
So I could do something like this.

01:16:48.280 --> 01:16:52.240
Students.append name.

01:16:52.240 --> 01:16:54.480
And it turns out, and we've not said this yet,

01:16:54.480 --> 01:16:59.760
but there is inside of the list data type a method that is function built

01:16:59.760 --> 01:17:02.520
into it called append that literally does that.

01:17:02.520 --> 01:17:05.400
So if you've got an otherwise empty list,

01:17:05.400 --> 01:17:09.200
and you call that list's name.append, you'll add something to the end of the list.

01:17:09.200 --> 01:17:10.920
And if there's not enough memory for it, no big deal.

01:17:10.920 --> 01:17:14.240
Python will find you the memory, allocate it, move everything in it,

01:17:14.240 --> 01:17:17.160
and you move on your way without having to worry about that.

01:17:17.160 --> 01:17:19.320
But I don't want to store just the name.

01:17:19.320 --> 01:17:21.520
I want to store the name and the dorm.

01:17:21.520 --> 01:17:23.080
So I could do this.

01:17:23.080 --> 01:17:25.760
I could do, well, maybe this isn't really students.

01:17:25.760 --> 01:17:27.720
Maybe this is now dorms.

01:17:27.720 --> 01:17:32.920
And then here I could do dorms.append dorm.

01:17:32.920 --> 01:17:36.760
But why is this devolving now into bad design

01:17:36.760 --> 01:17:40.240
if my goal was to associate a student with his or her dorm

01:17:40.240 --> 01:17:42.280
and then keep those values together?

01:17:42.280 --> 01:17:46.320
Why is this not the best approach in Python or back in the day, even

01:17:46.320 --> 01:17:50.280
in C, to have two separate arrays?

01:17:50.280 --> 01:17:51.480
By struct.

01:17:51.480 --> 01:17:51.980
What's that?

01:17:51.980 --> 01:17:53.160
Struct.

01:17:53.160 --> 01:17:57.400
So well, you have to, like, twice as many things to maintain, for sure.

01:17:57.400 --> 01:17:58.400
And what else?

01:17:58.400 --> 01:17:59.960
You can't map one to the other.

01:17:59.960 --> 01:18:01.160
You can't map one to the other.

01:18:01.160 --> 01:18:03.280
It's just, it's like, it's very arbitrary.

01:18:03.280 --> 01:18:06.040
Like, it's sort of this social contract that I will just

01:18:06.040 --> 01:18:10.040
assume that student zero lives in dorm zero.

01:18:10.040 --> 01:18:12.560
And student one lives in dorm one.

01:18:12.560 --> 01:18:13.200
And that's fine.

01:18:13.200 --> 01:18:14.120
And that's true.

01:18:14.120 --> 01:18:16.800
But one of the features of programming and computer science

01:18:16.800 --> 01:18:20.240
is this idea of encapsulation, like, associate-related memory with each

01:18:20.240 --> 01:18:20.800
other.

01:18:20.800 --> 01:18:22.520
And so what did we do in C instead?

01:18:22.520 --> 01:18:25.720
We did not have two arrays.

01:18:25.720 --> 01:18:27.040
Yeah, we had a struct.

01:18:27.040 --> 01:18:30.080
And so Python doesn't have structs per se.

01:18:30.080 --> 01:18:32.000
It instead has what are called classes.

01:18:32.000 --> 01:18:34.360
And it has a few other things like tuples and name tuples,

01:18:34.360 --> 01:18:36.240
but more on those some other time.

01:18:36.240 --> 01:18:41.040
So it turns out I could actually implement my own notion of a student.

01:18:41.040 --> 01:18:43.000
And I could import it like this.

01:18:43.040 --> 01:18:46.400
The convention in Python is if you create your own struct,

01:18:46.400 --> 01:18:50.440
henceforth called a class, you capitalize the name of it by convention.

01:18:50.440 --> 01:18:52.360
So a little different from C conventions.

01:18:52.360 --> 01:18:54.360
So what is a student going to look like?

01:18:54.360 --> 01:18:57.000
This is perhaps the most complex syntax that we'll have today,

01:18:57.000 --> 01:18:59.040
but it just has a few lines.

01:18:59.040 --> 01:19:01.920
If you want to implement the notion of a student, how

01:19:01.920 --> 01:19:02.960
might you do this?

01:19:02.960 --> 01:19:08.000
Well, in Python, you literally say class student, where class is similar in spirit

01:19:08.000 --> 01:19:11.240
to, just to be clear, struct or type def struct.

01:19:11.240 --> 01:19:13.600
But in Python, we're just saying class.

01:19:13.600 --> 01:19:15.520
And then this is the funky part.

01:19:15.520 --> 01:19:19.480
You can declare a function that by convention

01:19:19.480 --> 01:19:24.360
must be called init for initialize, that takes as its first argument

01:19:24.360 --> 01:19:30.160
a keyword called self, and then any number of other arguments like this.

01:19:30.160 --> 01:19:34.600
And then, for reasons that will hopefully be clear momentarily,

01:19:34.600 --> 01:19:36.880
I can write some code inside of this method.

01:19:36.880 --> 01:19:39.080
So long story short, what am I doing?

01:19:39.080 --> 01:19:42.800
I have declared a new type of data structure called student.

01:19:42.800 --> 01:19:45.400
And implicitly inside of this data structure,

01:19:45.400 --> 01:19:49.080
there are two things inside of itself, something called name and something

01:19:49.080 --> 01:19:50.360
called dorm.

01:19:50.360 --> 01:19:53.520
And this is how you would, in a C struct, typically do things

01:19:53.520 --> 01:19:56.760
with the data types and semicolons inside of the curly braces.

01:19:56.760 --> 01:19:59.240
Meanwhile, there's this method here.

01:19:59.240 --> 01:20:02.800
And it's a method in so far as it is inside of a class.

01:20:02.800 --> 01:20:05.520
Otherwise, it's a function just by a different name.

01:20:05.520 --> 01:20:09.960
This method init takes whatever self is, more on that another time,

01:20:09.960 --> 01:20:13.000
but it then takes zero more custom arguments that you can provide.

01:20:13.000 --> 01:20:14.680
And I called it name and dorm.

01:20:14.680 --> 01:20:18.160
So it turns out this special method init is a function that's

01:20:18.160 --> 01:20:21.400
going to be called automatically for you any time you

01:20:21.400 --> 01:20:24.120
create a student object.

01:20:24.120 --> 01:20:25.960
So what does that actually mean?

01:20:25.960 --> 01:20:30.120
That means in your code, what you can actually do is this.

01:20:30.120 --> 01:20:36.840
I can create a student in memory by saying s gets capital student passing

01:20:36.840 --> 01:20:38.080
in name and dorm.

01:20:38.080 --> 01:20:41.680
And we don't have this feature in C. On the right hand side,

01:20:41.680 --> 01:20:44.240
what I've highlighted is the name of the class

01:20:44.240 --> 01:20:46.680
and its two arguments, name and dorm, which

01:20:46.680 --> 01:20:49.880
are just what the user has typed in.

01:20:49.880 --> 01:20:53.520
What this class does for me now is it allocates memory underneath the hood

01:20:53.520 --> 01:20:54.080
for a student.

01:20:54.080 --> 01:20:56.440
It's got to be big enough for their name and big enough for their dorm.

01:20:56.440 --> 01:20:58.600
So it's like yay big in memory, so to speak.

01:20:58.600 --> 01:21:02.240
It then puts in the name and the dorm strings into that object

01:21:02.240 --> 01:21:04.560
and then returns the whole object.

01:21:04.560 --> 01:21:08.720
So you can kind of think of this as a much fancier version of malloc.

01:21:08.720 --> 01:21:10.920
So this is allocating all the memory you need,

01:21:10.920 --> 01:21:14.680
but it's also installing inside of that memory the name and the dorm.

01:21:14.680 --> 01:21:18.840
And it's bundling it up inside of not just an arbitrary chunk of memory,

01:21:18.840 --> 01:21:23.920
but something you can call a student object.

01:21:23.920 --> 01:21:26.760
And all that means that now for our students,

01:21:26.760 --> 01:21:30.400
we can just go ahead and append that student to the list.

01:21:30.400 --> 01:21:36.440
So now, if later, I want to iterate over for student in students,

01:21:36.440 --> 01:21:38.480
I can go ahead and print out, for instance,

01:21:38.480 --> 01:21:47.080
that student.name lives in student.dorm, close quote.

01:21:47.080 --> 01:21:52.280
And if now over here, oops, close that, and now over here,

01:21:52.280 --> 01:21:56.480
if I go ahead and run Python on struct0.py.

01:21:56.480 --> 01:21:59.480
Oh, no.

01:21:59.480 --> 01:22:01.880
Oh, thank you.

01:22:01.880 --> 01:22:03.200
That goes there.

01:22:03.200 --> 01:22:04.480
So now, damn it.

01:22:07.400 --> 01:22:08.200
Missing curly.

01:22:08.200 --> 01:22:08.760
Oh, thank you.

01:22:11.520 --> 01:22:15.560
OK, so now if I want to go ahead and type Maria and Cabot and David and

01:22:15.560 --> 01:22:20.800
Mather and Rob and say Kirkland, now we get all three of those names.

01:22:20.800 --> 01:22:25.080
And there's other ways, too, if we want to actually store this thing on disk.

01:22:25.080 --> 01:22:27.440
But I'll defer that to an example online.

01:22:27.440 --> 01:22:31.720
Let's look at one final example that will hopefully either make you regret

01:22:31.720 --> 01:22:35.640
the past several weeks or embrace the next several instead.

01:22:35.640 --> 01:22:40.560
So you'll recall that, though the former I suppose could be true,

01:22:40.560 --> 01:22:45.280
even without my help, so if I go into now, today's distribution code,

01:22:45.280 --> 01:22:46.320
you will see this program.

01:22:46.320 --> 01:22:48.200
And we won't walk through all of its lines,

01:22:48.240 --> 01:22:51.400
but this is a program written in Python called Speller.

01:22:51.400 --> 01:22:54.840
And what I did was literally sit down with Speller.c from problem set

01:22:54.840 --> 01:22:58.840
5, and I just converted it from left to right from c to Python,

01:22:58.840 --> 01:23:03.280
implementing it in Python in as close to an identical way as I could,

01:23:03.280 --> 01:23:05.200
just using features of Python.

01:23:05.200 --> 01:23:08.440
So just skimming this, you'll see that apparently my implementation

01:23:08.440 --> 01:23:12.480
of Speller in Python has a class called dictionary, which is very similar in spirit

01:23:12.480 --> 01:23:14.360
to dictionary.h and c.

01:23:14.360 --> 01:23:17.400
Notice that I still have a constant here, or it's not technically a constant,

01:23:17.400 --> 01:23:21.120
but a variable called length equals 45, like hardcoded in dictionary

01:23:21.120 --> 01:23:23.520
slash large as Speller.c did too.

01:23:23.520 --> 01:23:26.200
I'm using command line arguments as we saw earlier,

01:23:26.200 --> 01:23:28.720
but this time in Python instead of c.

01:23:28.720 --> 01:23:31.200
Notice you can do funky things like this, which

01:23:31.200 --> 01:23:33.920
is reminiscent of our swap trick just a little bit ago.

01:23:33.920 --> 01:23:36.960
If you want to declare multiple variables all on the same line

01:23:36.960 --> 01:23:40.200
and initialize them, you can just enumerate them all with commas.

01:23:40.200 --> 01:23:42.320
Then on the other side of the equal sign,

01:23:42.320 --> 01:23:46.280
enumerate with commas the values that you want to assign to those variables.

01:23:46.280 --> 01:23:49.400
And then down here, if I keep scrolling, you'll

01:23:49.400 --> 01:23:52.960
see code that we won't get into the weeds of, but some familiar phrases.

01:23:52.960 --> 01:23:58.360
So this is the program that actually runs a student's dictionary on some input,

01:23:58.360 --> 01:24:03.760
and then prints out per all this stuff at the bottom all of the familiar phrases

01:24:03.760 --> 01:24:06.040
that you might recall from problem set five.

01:24:06.040 --> 01:24:08.760
So this took a lot of work, most likely, to implement in c.

01:24:08.760 --> 01:24:11.360
And understandably, you might have used a linked list initially,

01:24:11.360 --> 01:24:13.760
or ultimately, you might have used a hash table, or a try,

01:24:13.760 --> 01:24:15.800
or struggled with something in between those two.

01:24:15.800 --> 01:24:18.240
And that is a function of c.

01:24:18.240 --> 01:24:19.280
C is difficult.

01:24:19.280 --> 01:24:21.920
C is challenging, because you have to do everything yourself.

01:24:21.920 --> 01:24:23.760
And upside, though, of it is that you end up

01:24:23.760 --> 01:24:26.720
getting a lot of great performance, theoretically.

01:24:26.720 --> 01:24:28.640
Like, once you have implemented the code,

01:24:28.640 --> 01:24:30.760
you're kind of as close to the hardware as possible.

01:24:30.760 --> 01:24:33.920
And so your code runs pretty darn well, and is dependent only then

01:24:33.920 --> 01:24:37.440
on your algorithms, not on your choice of language.

01:24:37.440 --> 01:24:40.960
So here, let me go ahead and implement a file called dictionary.py.

01:24:41.000 --> 01:24:48.960
And let me propose that the words, the equivalent, sorry, of dictionary.h

01:24:48.960 --> 01:24:50.400
would be this file here.

01:24:50.400 --> 01:24:54.400
And it's going to have a key word, a function called check,

01:24:54.400 --> 01:24:57.040
which takes an argument called word.

01:24:57.040 --> 01:25:01.480
It's going to have a function called load, which takes in an argument called

01:25:01.480 --> 01:25:02.480
dictionary.

01:25:02.480 --> 01:25:09.600
It's going to have a method called size, which takes in no arguments other

01:25:09.600 --> 01:25:10.680
than itself.

01:25:10.680 --> 01:25:13.320
And then it's going to have a method called unload, which also takes

01:25:13.320 --> 01:25:14.960
no arguments other than itself.

01:25:14.960 --> 01:25:18.240
So if we were instead to have assigned problems at 5 in Python,

01:25:18.240 --> 01:25:21.040
we essentially would have given you a file called dictionary.py

01:25:21.040 --> 01:25:22.400
with these placeholders for you.

01:25:22.400 --> 01:25:25.240
Because recall, in pset5, those were all to dos.

01:25:25.240 --> 01:25:27.680
Strictly speaking, there would be one other here.

01:25:27.680 --> 01:25:31.240
We would probably have a def init, because every class in Python

01:25:31.240 --> 01:25:34.360
we'll see will typically have this init method, where we just

01:25:34.360 --> 01:25:38.400
are able to do something to initialize the data structure.

01:25:38.400 --> 01:25:39.720
So let me go ahead and do this.

01:25:39.720 --> 01:25:41.760
We don't know that much Python yet, and we're

01:25:41.760 --> 01:25:44.360
taking for granted that Speller, in fact, works.

01:25:44.360 --> 01:25:46.840
But let me go ahead and load some words in a dictionary.

01:25:46.840 --> 01:25:49.120
So here is my method called load.

01:25:49.120 --> 01:25:51.360
Dictionary is going to be the name of the dictionary to load.

01:25:51.360 --> 01:25:55.840
So you guys implemented this yourself by loading those files from disk.

01:25:55.840 --> 01:25:58.120
In Python, I'm going to do this as follows.

01:25:58.120 --> 01:26:02.080
Give me a file and open it in read mode.

01:26:02.080 --> 01:26:05.800
I'll iterate over each line in the file.

01:26:05.800 --> 01:26:12.000
Then go ahead and add to my set called words the result of that line

01:26:12.000 --> 01:26:16.240
by stripping off the end of it, backslash 0.

01:26:16.240 --> 01:26:20.960
Then go ahead and close the file, and then return true,

01:26:20.960 --> 01:26:23.320
because I'm done implementing load.

01:26:23.320 --> 01:26:27.800
So that is the load method in Python.

01:26:27.800 --> 01:26:28.480
Happy, yes.

01:26:28.480 --> 01:26:29.760
OK, so check.

01:26:29.760 --> 01:26:31.160
Check was a struggle too, right?

01:26:31.160 --> 01:26:33.560
Because once you had your hash table, or once you had your try,

01:26:33.560 --> 01:26:35.840
now you had to actually navigate that structure in memory,

01:26:35.840 --> 01:26:38.760
maybe recursively, maybe iteratively, following lots of pointers and the

01:26:38.760 --> 01:26:40.240
like, following a linked list.

01:26:40.240 --> 01:26:51.720
How about I just do, let's just say, if word lowercase in self.words,

01:26:51.720 --> 01:26:59.320
return true, else return false, done.

01:26:59.320 --> 01:27:01.200
So that one's done.

01:27:01.200 --> 01:27:04.160
On size, we actually can kind of infer how to do this,

01:27:04.160 --> 01:27:06.600
return the length of the words.

01:27:06.600 --> 01:27:07.600
That's done.

01:27:07.600 --> 01:27:11.400
Unload, don't have to worry about memory in Python, so that's done.

01:27:11.400 --> 01:27:14.840
And there you have problem set five.

01:27:14.840 --> 01:27:16.320
Thank you.

01:27:16.320 --> 01:27:18.960
So what then are the takeaways?

01:27:18.960 --> 01:27:21.400
Either great elation that you now have this power,

01:27:21.400 --> 01:27:24.040
or great sadness that you had to implement this first and see,

01:27:24.040 --> 01:27:26.440
but this was really ultimately meant to be thematic.

01:27:26.440 --> 01:27:29.040
Like hopefully moving forward, even if you struggled with any number

01:27:29.080 --> 01:27:31.720
of these topics, linked list, and hash tables, and pointers, and the like,

01:27:31.720 --> 01:27:34.680
like hopefully you have a general understanding of some of these fundamentals

01:27:34.680 --> 01:27:36.880
and what computers are doing underneath the hood.

01:27:36.880 --> 01:27:40.760
And now with languages like Python, and soon with JavaScript and SQL,

01:27:40.760 --> 01:27:44.080
with a little bit of HTML and CSS mixed in for our user interfaces,

01:27:44.080 --> 01:27:46.840
do you have the ability to now solve problems taking for granted

01:27:46.840 --> 01:27:49.040
both your understanding of those topics

01:27:49.040 --> 01:27:53.080
and the reality that someone else has now implemented those concepts for you

01:27:53.080 --> 01:27:55.880
so that when it comes to solving problems that's six and seven and eight,

01:27:55.880 --> 01:27:58.640
and then leaving CS50 and solving problems in your own domain,

01:27:58.640 --> 01:28:00.920
you have so many more tools in your toolkit.

01:28:00.920 --> 01:28:03.200
And the goal really for you is going to be

01:28:03.200 --> 01:28:05.720
to pick whichever one is most appropriate.

01:28:05.720 --> 01:28:06.760
So let's adjourn here.

01:28:06.760 --> 01:28:09.080
I'll stick around for questions, and we'll see you next time.

01:28:09.080 --> 01:28:11.480
Best of luck on the test.

