1
00:00:00,000 --> 00:00:15,680
All right, so this is CS50, and this is the day before our test, of course.

2
00:00:15,680 --> 00:00:17,680
But this is lecture 8, in which we're actually

3
00:00:17,680 --> 00:00:20,720
going to finally transition from C, this lower level language that we've

4
00:00:20,720 --> 00:00:22,440
been spending quite some time to.

5
00:00:22,440 --> 00:00:25,440
And the goal today isn't so much to focus on Python, per se,

6
00:00:25,440 --> 00:00:28,160
but honestly, to do what we hope will be one of the most empowering

7
00:00:28,160 --> 00:00:31,720
aspects of the class, which is to emphasize that this is not

8
00:00:31,720 --> 00:00:34,840
in a semester learning C. This has been a semester learning programming,

9
00:00:34,840 --> 00:00:37,760
a certain type of programming called procedural or imperative programming,

10
00:00:37,760 --> 00:00:40,080
but more on that in another higher level class, perhaps.

11
00:00:40,080 --> 00:00:43,320
But really, that this class is about ultimately teaching yourself

12
00:00:43,320 --> 00:00:45,320
to learn new languages.

13
00:00:45,320 --> 00:00:48,520
And indeed, what you'll find is that as we explore some of the features

14
00:00:48,520 --> 00:00:52,600
and the syntax of Python, odds are today it might look as cryptic as C did

15
00:00:52,600 --> 00:00:55,760
just a few weeks ago, but you'll find that once you start recognizing

16
00:00:55,760 --> 00:00:59,200
patterns as you have with C, it'll be all the more accessible

17
00:00:59,200 --> 00:01:03,240
and all the more useful when solving some problems.

18
00:01:03,240 --> 00:01:06,520
So unrelated, just earlier this week, I happened

19
00:01:06,520 --> 00:01:08,760
to be in Mountain View with some of the team.

20
00:01:08,760 --> 00:01:11,760
And you might recall from last lecture at Harvard,

21
00:01:11,760 --> 00:01:15,200
we offered this glimpse of one of the earliest racks of servers

22
00:01:15,200 --> 00:01:16,720
that Google itself had.

23
00:01:16,720 --> 00:01:18,680
Well, it turns out they changed buildings,

24
00:01:18,680 --> 00:01:21,800
but we happened to stumble upon the actual display.

25
00:01:21,800 --> 00:01:25,240
So pictured here is a photo from my own phone, which was actually really

26
00:01:25,240 --> 00:01:26,000
cool to see.

27
00:01:26,000 --> 00:01:29,760
So inside of this, you'll see all of the old hard drives they've used.

28
00:01:29,760 --> 00:01:31,280
We actually looked at some of the labels.

29
00:01:31,280 --> 00:01:34,160
And indeed, hard drives manufactured in 1999, which

30
00:01:34,160 --> 00:01:36,360
was when Google started getting some of its momentum.

31
00:01:36,360 --> 00:01:38,280
I mean, you can see the green circuit boards here,

32
00:01:38,280 --> 00:01:41,240
on which would be CPUs and other things potentially.

33
00:01:41,240 --> 00:01:43,200
So if you'd like to stroll down memory lane,

34
00:01:43,200 --> 00:01:46,920
feel free to read up on this on Wikipedia or even on the excerpts here.

35
00:01:46,920 --> 00:01:50,520
And then, strangely enough, at the conference, some of us were at,

36
00:01:50,520 --> 00:01:53,680
did we discover this, perhaps the biggest duck debugger

37
00:01:53,680 --> 00:01:58,400
made up of smaller duck debuggers, one of whom was our own.

38
00:01:58,400 --> 00:02:00,760
So that, too, was how we spent this past week.

39
00:02:00,760 --> 00:02:03,600
All right, so how are we going to spend this week and the weeks to come?

40
00:02:03,600 --> 00:02:06,680
So you'll recall that when we transitioned from scratch to C,

41
00:02:06,680 --> 00:02:09,440
we drew a couple of comparisons between syntax and features.

42
00:02:09,440 --> 00:02:12,120
And I thought it'd be useful to take that same approach here really

43
00:02:12,120 --> 00:02:14,880
to emphasize that most of the ideas we're going to explore today

44
00:02:14,880 --> 00:02:15,960
are themselves not new.

45
00:02:15,960 --> 00:02:19,520
It's just how you express them and how you write the syntax in the language,

46
00:02:19,520 --> 00:02:23,720
known as Python, that's indeed going to be different from scratch, from C.

47
00:02:23,720 --> 00:02:25,280
And now here we are with Python.

48
00:02:25,280 --> 00:02:30,200
So back in the day, in week 0, when you wanted to say something in scratch,

49
00:02:30,200 --> 00:02:32,880
you would literally use this purple puzzle piece, say hello.

50
00:02:32,880 --> 00:02:35,240
And we called that a function or a statement.

51
00:02:35,240 --> 00:02:36,760
It was some kind of verb action.

52
00:02:36,760 --> 00:02:39,200
And in C, of course, it looked a little something like this.

53
00:02:39,200 --> 00:02:43,080
Henceforth, starting today in Python, it's going to look like this.

54
00:02:43,080 --> 00:02:47,000
So before, after, before, after.

55
00:02:47,000 --> 00:02:49,280
So it's pretty easy to visually diff these two things.

56
00:02:49,280 --> 00:02:51,360
But what are just a couple of the differences that jump out at you

57
00:02:51,360 --> 00:02:52,320
immediately?

58
00:02:52,320 --> 00:02:53,960
See?

59
00:02:53,960 --> 00:02:54,440
Python.

60
00:02:57,380 --> 00:02:59,720
So there's no more backslash N, it would seem, in this context.

61
00:02:59,720 --> 00:03:02,080
So that's kind of a nice relief to not have to type anymore.

62
00:03:02,080 --> 00:03:04,400
What else seems to be different?

63
00:03:04,400 --> 00:03:06,080
No semicolon, thank god, right?

64
00:03:06,080 --> 00:03:07,720
Perhaps the stupidest source of frustration

65
00:03:07,720 --> 00:03:11,920
that you might have experienced by just omitting one of those and someone over here?

66
00:03:11,920 --> 00:03:15,840
Yeah, so printf is now just print, which is pretty reasonable unto itself.

67
00:03:15,840 --> 00:03:18,160
So these are terribly minor differences.

68
00:03:18,160 --> 00:03:20,800
But it's sort of testament to the kinds of mental adjustments

69
00:03:20,800 --> 00:03:22,120
you're going to have to start to make.

70
00:03:22,120 --> 00:03:24,720
Fortunately, thus far, we've seen that you can start leaving things off,

71
00:03:24,720 --> 00:03:26,520
which is actually a guiding principle of Python

72
00:03:26,520 --> 00:03:29,440
and that one of its goals is meant to be easier to write than some

73
00:03:29,440 --> 00:03:31,400
of its predecessors among them C.

74
00:03:31,400 --> 00:03:35,960
So in C, we might have implemented this Hello World program that actually

75
00:03:35,960 --> 00:03:38,760
ran when you click the green flag using code like that at the right.

76
00:03:38,760 --> 00:03:42,520
And this was, if those of you had no programming experience coming in to CS50,

77
00:03:42,520 --> 00:03:46,240
what probably looked like the proverbial grief to you just a few weeks ago.

78
00:03:46,240 --> 00:03:48,480
And we teased apart what those various lines meant.

79
00:03:48,480 --> 00:03:49,920
But in Python, guess what?

80
00:03:49,920 --> 00:03:53,200
If you want to write a program whose purpose in life is to say Hello,

81
00:03:53,200 --> 00:03:56,440
we'll just write def main print Hello World.

82
00:03:56,440 --> 00:03:59,040
So it's a little similar, structurally structured.

83
00:03:59,040 --> 00:04:04,560
And in fact, it does not lack for some of the more arcane syntax here,

84
00:04:04,560 --> 00:04:07,040
but we'll see soon what this actually means.

85
00:04:07,040 --> 00:04:09,560
But it's a little simpler than the one before.

86
00:04:09,560 --> 00:04:10,600
And let's tease this apart.

87
00:04:10,600 --> 00:04:13,200
So def here simply means define me a function.

88
00:04:13,200 --> 00:04:17,120
So whereas in C, we've historically seen that you specify the type

89
00:04:17,120 --> 00:04:18,400
that the function should return.

90
00:04:18,400 --> 00:04:20,600
We're not going to do that in Python anymore.

91
00:04:20,600 --> 00:04:22,000
Python still has data types.

92
00:04:22,000 --> 00:04:25,160
But we're not going to explicitly mention what data types we're using.

93
00:04:25,160 --> 00:04:26,920
Meanwhile, here is the name of the function.

94
00:04:26,920 --> 00:04:28,120
And main would be a convention.

95
00:04:28,120 --> 00:04:31,400
But it's not built into the language in the same way as it is in C,

96
00:04:31,400 --> 00:04:32,880
as we shall see.

97
00:04:32,880 --> 00:04:36,040
Meanwhile, this silly incantation is just a way

98
00:04:36,040 --> 00:04:39,680
of ensuring that the default function to be executed in a Python program

99
00:04:39,680 --> 00:04:41,320
is indeed going to be called main.

100
00:04:41,320 --> 00:04:43,680
But more on that when we actually start creating.

101
00:04:43,680 --> 00:04:46,760
But this is perhaps the most subtle but most important difference,

102
00:04:46,760 --> 00:04:47,960
at least early on.

103
00:04:47,960 --> 00:04:49,520
And it's even hard to see at this scale.

104
00:04:49,520 --> 00:04:53,560
But notice the colons, both here and here, that I've highlighted now

105
00:04:53,560 --> 00:04:55,720
in yellow, and these dots, which are not to be typed,

106
00:04:55,720 --> 00:04:58,760
but are just meant to draw your attention to the fact that I hit the space bar four

107
00:04:58,760 --> 00:05:00,800
times in those locations.

108
00:05:00,800 --> 00:05:04,840
So if you have ever sort of gotten some feedback from your TA or TF,

109
00:05:04,840 --> 00:05:08,280
that your style could be better, closer to five out of five,

110
00:05:08,280 --> 00:05:10,920
because of lack of indentation or pretty formatting.

111
00:05:10,960 --> 00:05:13,000
Python's actually going to help us out with this.

112
00:05:13,000 --> 00:05:17,920
So Python code will not run if you have not indented things properly.

113
00:05:17,920 --> 00:05:22,400
So gone are the curly braces that encapsulate related lines of code

114
00:05:22,400 --> 00:05:25,160
within some block of functionality, and instead they're

115
00:05:25,160 --> 00:05:27,720
replaced generally with this general structure.

116
00:05:27,720 --> 00:05:30,320
You have a colon, and then below that and indented

117
00:05:30,320 --> 00:05:34,000
are all of the lines that are somehow related to that earlier line of code.

118
00:05:34,000 --> 00:05:36,000
And the indentation must be consistent.

119
00:05:36,000 --> 00:05:40,680
So even though your own eye might not quite distinguish four spaces from three,

120
00:05:40,680 --> 00:05:43,080
the Python environment will.

121
00:05:43,080 --> 00:05:46,720
And so this will actually help implicitly enforce better style,

122
00:05:46,720 --> 00:05:50,760
perhaps, than might have been easily done from the get go.

123
00:05:50,760 --> 00:05:53,120
So then, of course, in Scratch, we had a forever block, which

124
00:05:53,120 --> 00:05:54,360
says, hello world forever.

125
00:05:54,360 --> 00:05:56,520
Much like in C, we could implement it like this.

126
00:05:56,520 --> 00:05:58,560
Now there's actually pretty clean mapping in Python.

127
00:05:58,560 --> 00:06:01,480
We already know we can get rid of the semicolon.

128
00:06:01,480 --> 00:06:03,960
We already know we can get rid of the curly braces.

129
00:06:03,960 --> 00:06:06,480
We're going to have to add in a colon, but it turns out

130
00:06:06,480 --> 00:06:08,360
we can get rid of a little more too.

131
00:06:08,360 --> 00:06:14,440
So what more is absent from this translation of hello world to Python?

132
00:06:14,440 --> 00:06:17,040
This one's more subtle.

133
00:06:17,040 --> 00:06:18,920
So we definitely got rid of the curly braces,

134
00:06:18,920 --> 00:06:20,400
relying now just on indentation.

135
00:06:24,280 --> 00:06:26,320
OK, so there's no parentheses around while.

136
00:06:26,320 --> 00:06:29,440
And so this, too, is actually meant to be a feature of Python.

137
00:06:29,440 --> 00:06:32,240
If you don't logically need parentheses to enforce

138
00:06:32,240 --> 00:06:36,160
order of operations, like in arithmetic or the like, then don't use them,

139
00:06:36,160 --> 00:06:37,520
because they're just an distraction.

140
00:06:37,520 --> 00:06:38,560
They're just more to type.

141
00:06:38,560 --> 00:06:41,920
And the code now is just visually cleaner and easier to read.

142
00:06:41,920 --> 00:06:43,200
There's a minor difference, too.

143
00:06:43,200 --> 00:06:45,520
True and false are going to be capitalized in Python,

144
00:06:45,520 --> 00:06:47,520
but that's a fairly incidental detail.

145
00:06:47,520 --> 00:06:49,960
But notice this kind of captures already the spirit of Python.

146
00:06:49,960 --> 00:06:52,440
It's not a huge leap to go from one to the other,

147
00:06:52,440 --> 00:06:54,920
but we've just kind of started to get rid of some of the clutter

148
00:06:54,920 --> 00:06:57,040
and the stuff that never really intellectually added much.

149
00:06:57,040 --> 00:06:59,840
And if anything was annoying, to have to remember early on.

150
00:06:59,840 --> 00:07:01,400
So true here is Arbolian.

151
00:07:01,400 --> 00:07:03,840
And now we have a finite number of iterations.

152
00:07:03,840 --> 00:07:06,080
We might want to say hello world exactly 50 times.

153
00:07:06,080 --> 00:07:07,960
In C, this was a crazy mess.

154
00:07:07,960 --> 00:07:10,920
If you wanted to do this, you'd have to initialize a variable with which

155
00:07:10,920 --> 00:07:15,120
to count up to, but not including 50 plus plusing along the way and so forth.

156
00:07:15,120 --> 00:07:17,040
In Python, it's going to be a little cleaner.

157
00:07:17,040 --> 00:07:19,640
And we'll come back to what this means exactly.

158
00:07:19,640 --> 00:07:21,680
But if you kind of read it from left to right,

159
00:07:21,680 --> 00:07:24,360
it kind of says what you mean, right?

160
00:07:24,360 --> 00:07:26,840
For i in the range of 50.

161
00:07:26,840 --> 00:07:29,120
So i is probably going to be a variable.

162
00:07:29,120 --> 00:07:30,920
And notice we're not mentioning its type.

163
00:07:30,920 --> 00:07:34,160
It's going to be implied by whatever the context is, which in this case

164
00:07:34,160 --> 00:07:36,720
has to do apparently with numbers per the 50.

165
00:07:36,720 --> 00:07:39,320
Range is actually going to be a data type unto itself.

166
00:07:39,320 --> 00:07:40,600
It's a little funky in that sense.

167
00:07:40,600 --> 00:07:41,760
It's called a class.

168
00:07:41,760 --> 00:07:45,080
But this essentially is a special feature of Python

169
00:07:45,080 --> 00:07:49,160
that unlike in C, where if you want to iterate over an array of values

170
00:07:49,160 --> 00:07:52,800
or 50 such values, you would literally have an array of 50 values.

171
00:07:52,800 --> 00:07:55,360
Range is kind of cool in that it kind of stands there.

172
00:07:55,360 --> 00:07:58,760
And every time you iterate through a loop, it hands you the next number,

173
00:07:58,760 --> 00:08:00,480
but just one at a time.

174
00:08:00,520 --> 00:08:04,080
Thereby using maybe as little as 150th the amount of memory,

175
00:08:04,080 --> 00:08:06,760
because it only has to keep one number around at a time.

176
00:08:06,760 --> 00:08:08,440
And there's a bit more overhead than that.

177
00:08:08,440 --> 00:08:10,760
It's not a perfect savings quite so.

178
00:08:10,760 --> 00:08:16,240
But this just says for i in range 50, and that's going to implicitly

179
00:08:16,240 --> 00:08:19,240
count from 0 up through 49.

180
00:08:19,240 --> 00:08:23,000
And meanwhile, what's below it is what's going to get printed this time.

181
00:08:23,000 --> 00:08:26,640
So meanwhile, here is one of our bigger scratch blocks early on.

182
00:08:26,640 --> 00:08:30,080
And it translates pretty literally to code in C.

183
00:08:30,080 --> 00:08:34,360
And you can perhaps guess, if you've never seen Python before today,

184
00:08:34,360 --> 00:08:36,880
what the Python code might now look like.

185
00:08:36,880 --> 00:08:39,120
If this here on the right is the C code, what

186
00:08:39,120 --> 00:08:41,800
are some of the features syntactically that we're about to throw away?

187
00:08:41,800 --> 00:08:42,300
Yeah?

188
00:08:42,300 --> 00:08:44,600
You can throw it at curly braces and the parentheses.

189
00:08:44,600 --> 00:08:46,880
Curly braces and parentheses are going to go away.

190
00:08:46,880 --> 00:08:49,120
What else might go away?

191
00:08:49,120 --> 00:08:52,440
The semicolons are going to go away?

192
00:08:52,440 --> 00:08:54,840
The backslash n inside of the print statements?

193
00:08:54,840 --> 00:08:56,480
Great.

194
00:08:56,480 --> 00:08:59,800
One more thing, I think?

195
00:09:00,800 --> 00:09:01,440
The if?

196
00:09:01,440 --> 00:09:03,460
So well, we don't strictly need the parentheses

197
00:09:03,460 --> 00:09:06,760
because it's not like I'm combining things logically like this or that

198
00:09:06,760 --> 00:09:08,000
or this and that.

199
00:09:08,000 --> 00:09:10,040
So it should suffice to get rid of those two.

200
00:09:10,040 --> 00:09:12,280
And there's a couple of other tweaks we're going to have to make here.

201
00:09:12,280 --> 00:09:14,920
But indeed, the code is going to be a lot tighter, so to speak.

202
00:09:14,920 --> 00:09:16,960
Now you're just going to say what you mean here.

203
00:09:16,960 --> 00:09:19,920
And there is one weird thing, and it's not a typo.

204
00:09:19,920 --> 00:09:23,240
What apparently are you ever going to have to start knowing now?

205
00:09:23,240 --> 00:09:24,440
L if or whatever.

206
00:09:24,440 --> 00:09:26,400
So L if is not a typo.

207
00:09:26,400 --> 00:09:29,080
It's indeed how you express the notion of else if,

208
00:09:29,080 --> 00:09:31,000
but otherwise everything is exactly the same.

209
00:09:31,000 --> 00:09:33,960
And notice the colons, frankly, ironically, whereas previously it

210
00:09:33,960 --> 00:09:36,920
might have been annoying to occasionally forget a semicolon.

211
00:09:36,920 --> 00:09:40,000
Now the colons might take on that role, but at least everything below them

212
00:09:40,000 --> 00:09:41,920
is meant to be indented.

213
00:09:41,920 --> 00:09:45,840
So here's a fundamental difference beyond the sort of silly syntactic

214
00:09:45,840 --> 00:09:47,920
differences of this in, say, other languages.

215
00:09:47,920 --> 00:09:51,200
The flow of work that we've been using thus far

216
00:09:51,200 --> 00:09:54,000
has been essentially this in C. You write source code in a file,

217
00:09:54,000 --> 00:09:56,080
generally ending in .c.

218
00:09:56,080 --> 00:10:00,600
You run a compiler, which is a quick check, is called Clang.

219
00:10:00,600 --> 00:10:01,840
So it's not technically make.

220
00:10:01,840 --> 00:10:04,000
Make is just this helpful build utility that

221
00:10:04,000 --> 00:10:05,680
automates the process of calling Clang.

222
00:10:05,680 --> 00:10:07,920
So Clang is, strictly speaking, the compiler.

223
00:10:07,920 --> 00:10:11,440
And Clang outputs zeros and ones, otherwise known as machine code.

224
00:10:11,440 --> 00:10:14,600
And your computer, Mac, PC, whatever, has a CPU,

225
00:10:14,600 --> 00:10:18,080
central processing unit inside, made by Intel or some other company.

226
00:10:18,080 --> 00:10:22,160
And that CPU is hardwired to understand certain patterns of bits,

227
00:10:22,160 --> 00:10:25,280
zeros and ones, otherwise known as machine code.

228
00:10:25,320 --> 00:10:29,440
So that's been our world in C with Python.

229
00:10:29,440 --> 00:10:31,600
So the code that you might compile in C, for instance,

230
00:10:31,600 --> 00:10:34,720
might have been this, which we said you run Clang on like this.

231
00:10:34,720 --> 00:10:37,480
And if you don't specify a default file name as output,

232
00:10:37,480 --> 00:10:40,640
you'll instead just get in your file all of these zeros and ones, which

233
00:10:40,640 --> 00:10:45,200
can then be executed by way of .slash a.out, the default name

234
00:10:45,200 --> 00:10:47,120
for the assembler's output here.

235
00:10:47,120 --> 00:10:53,280
So in Python, though, the world gets here, too, a little simpler as well.

236
00:10:53,280 --> 00:10:56,720
So we just now have source code and an interpreter.

237
00:10:56,720 --> 00:10:59,120
So there's no machine code it would seem.

238
00:10:59,120 --> 00:11:00,720
There's no compiler it would seem.

239
00:11:00,720 --> 00:11:02,800
And frankly, there's one fewer arrow, which

240
00:11:02,800 --> 00:11:05,720
suggests to me that the process of running Python code itself

241
00:11:05,720 --> 00:11:07,120
is actually going to be a little easier.

242
00:11:07,120 --> 00:11:09,360
Running C code has typically been two steps.

243
00:11:09,360 --> 00:11:12,480
You rerun Clang, or via Mac, you run Clang.

244
00:11:12,480 --> 00:11:13,640
Then you run the program.

245
00:11:13,640 --> 00:11:14,200
And it's fine.

246
00:11:14,200 --> 00:11:15,840
It's not all that hard, but it's two steps.

247
00:11:15,840 --> 00:11:18,880
Why not reduce to two steps what you could instead do in one?

248
00:11:18,880 --> 00:11:20,480
And we'll see exactly what this means.

249
00:11:20,480 --> 00:11:22,920
Now, technically, that's a bit of an oversimplification.

250
00:11:22,920 --> 00:11:27,400
Technically, underneath the hood, if you wanted to run a program like this

251
00:11:27,400 --> 00:11:33,360
that simply prints out hello world, you would simply run Python hello.py.

252
00:11:33,360 --> 00:11:36,760
And the result of that would be to see hello world on the screen,

253
00:11:36,760 --> 00:11:37,880
as we'll soon see.

254
00:11:37,880 --> 00:11:41,120
But technically, underneath the hood, there is some other stuff going on.

255
00:11:41,120 --> 00:11:42,960
So there actually kind of is a compiler.

256
00:11:42,960 --> 00:11:44,760
But there's not something called machine code per se.

257
00:11:44,760 --> 00:11:45,680
It's called byte code.

258
00:11:45,680 --> 00:11:48,080
There's even something called a Python virtual machine.

259
00:11:48,080 --> 00:11:51,160
But all of this is abstracted away for us.

260
00:11:51,160 --> 00:11:53,440
Certainly for the sake of today's conversation,

261
00:11:53,440 --> 00:11:55,680
but also in the real world more generally.

262
00:11:55,680 --> 00:11:59,160
Humans have gotten better over the decades at writing software and writing

263
00:11:59,160 --> 00:12:01,440
tools via which we can write software.

264
00:12:01,440 --> 00:12:04,960
And so a lot of the more manual processes and a lot of the lower level

265
00:12:04,960 --> 00:12:09,120
details that we've been focusing on, if not struggling on in C, start to go away.

266
00:12:09,120 --> 00:12:12,800
Because much like in week zero, where we started layering on idea after idea,

267
00:12:12,800 --> 00:12:17,440
zeros and ones, ASCII, colors and whatnot, similarly with our actual tools,

268
00:12:17,440 --> 00:12:18,960
are we going to start to do the same.

269
00:12:19,000 --> 00:12:22,200
So whereas in the past, or whereas in actuality,

270
00:12:22,200 --> 00:12:26,560
what's going on underneath the hood is this process here,

271
00:12:26,560 --> 00:12:30,040
we can start to think about it really as something quite simpler.

272
00:12:30,040 --> 00:12:34,440
Now, if you're curious, and if you take some higher level class like CS61

273
00:12:34,440 --> 00:12:37,960
or another, you'll actually talk about things like byte code and assembly

274
00:12:37,960 --> 00:12:38,640
code and the like.

275
00:12:38,640 --> 00:12:40,720
And we saw a glimpse of the latter a bit ago.

276
00:12:40,720 --> 00:12:42,680
This happens to be an intermediate language

277
00:12:42,680 --> 00:12:46,880
that Python source code is converted into before it's run by the computer.

278
00:12:46,880 --> 00:12:50,920
But again, we're going to turn a blind eye to those lower level details.

279
00:12:50,920 --> 00:12:53,520
So here are some of the tools now in our toolkit.

280
00:12:53,520 --> 00:12:55,280
In Python, there are data types.

281
00:12:55,280 --> 00:12:57,920
Though as of now, we've not seen any examples whereby

282
00:12:57,920 --> 00:13:01,120
I specify what types of values are going to be in my variables

283
00:13:01,120 --> 00:13:03,600
or what types of values a function is going to return.

284
00:13:03,600 --> 00:13:05,280
But they are there.

285
00:13:05,280 --> 00:13:07,800
Everything is sort of loosely typed in that whatever

286
00:13:07,800 --> 00:13:11,280
you want a variable to be, it will just take on that data type,

287
00:13:11,280 --> 00:13:13,520
whether it's an int or string or the like.

288
00:13:13,520 --> 00:13:15,400
It's not going to be the full word string.

289
00:13:15,400 --> 00:13:17,560
In Python, it's literally called str.

290
00:13:17,560 --> 00:13:22,240
But there are some familiar types here, bool and float and int and others.

291
00:13:22,240 --> 00:13:26,280
And in fact, among the others, as we'll soon see, are features like range.

292
00:13:26,280 --> 00:13:30,400
But before that, no two that will provide for at least our first foray

293
00:13:30,400 --> 00:13:33,040
into Python a few familiar functions.

294
00:13:33,040 --> 00:13:36,600
So Python has different mechanisms than C for getting input from the user.

295
00:13:36,600 --> 00:13:41,480
We've abstracted some of those details away in a new CS50 library for Python

296
00:13:41,480 --> 00:13:44,920
that you'll really just use one or few times before we transition away

297
00:13:44,920 --> 00:13:45,840
from even that.

298
00:13:45,840 --> 00:13:48,920
But we'll give you functions like get char, get float, get int, get string

299
00:13:48,920 --> 00:13:52,800
that handle all the requisite error checking so that at least for your first few programs,

300
00:13:52,800 --> 00:13:56,200
you can just start to get some real work done without diving

301
00:13:56,200 --> 00:13:58,800
into underneath the hood there.

302
00:13:58,800 --> 00:14:01,360
And then lastly, here's some other tools in our toolkit.

303
00:14:01,360 --> 00:14:03,800
And we'll just scratch the surface of some of these today.

304
00:14:03,800 --> 00:14:08,120
But what's nice about Python and what's nice about higher level languages

305
00:14:08,120 --> 00:14:10,200
more generally, like more modern languages that

306
00:14:10,200 --> 00:14:12,600
learned lessons from older languages like C

307
00:14:12,600 --> 00:14:16,920
is that you get so much more for free, so much more out of the box.

308
00:14:16,920 --> 00:14:18,480
There's so much more of a kitchen sink.

309
00:14:18,480 --> 00:14:20,840
There's so many metaphors we can use here, all of which

310
00:14:20,840 --> 00:14:24,640
speak to the fact that Python has more features than C.

311
00:14:24,640 --> 00:14:29,040
Much like Java, if you took a PCS or something else, had than C,

312
00:14:29,040 --> 00:14:33,280
so does Python have a whole toolkit for representing complex numbers,

313
00:14:33,280 --> 00:14:36,640
for representing dictionaries otherwise implemented as hash tables,

314
00:14:36,640 --> 00:14:37,600
as you now know.

315
00:14:37,600 --> 00:14:39,880
Lists, which is kind of synonymous with an array,

316
00:14:39,880 --> 00:14:43,760
but in a list is an array that can sort of automatically grow and shrink.

317
00:14:43,760 --> 00:14:45,880
We don't have to jump through hoops as we did in C.

318
00:14:45,880 --> 00:14:47,880
Range we've seen briefly, which just hands you back,

319
00:14:47,880 --> 00:14:51,240
one number after another in some range, ideally for iteration.

320
00:14:51,240 --> 00:14:52,880
Set is the notion from mathematics, where

321
00:14:52,880 --> 00:14:55,400
if you want to put bunches of things into a data structure

322
00:14:55,400 --> 00:14:58,440
and you want to make sure you have only one of each such thing without

323
00:14:58,440 --> 00:15:00,200
duplicates, you can use a set.

324
00:15:00,200 --> 00:15:02,920
And a tuple is also a mathematical notion, typically,

325
00:15:02,920 --> 00:15:06,680
where you can combine related things without complicating things

326
00:15:06,680 --> 00:15:08,000
with actual structs.

327
00:15:08,040 --> 00:15:11,040
Like x comma y is a common paradigm in lots of programs,

328
00:15:11,040 --> 00:15:14,600
graphics or videos or certainly math and graphing itself.

329
00:15:14,600 --> 00:15:16,920
You don't really need a whole full-fledged data structure.

330
00:15:16,920 --> 00:15:19,880
You might just want to say x comma y.

331
00:15:19,880 --> 00:15:22,520
And so Python gives us that kind of expressiveness.

332
00:15:22,520 --> 00:15:26,640
So let's actually now dive in with that quick mapping from one world

333
00:15:26,640 --> 00:15:30,000
to the other and focus on what you can actually do with Python.

334
00:15:30,000 --> 00:15:33,840
So here I am in the familiar CS50 IDE, much like we have pre-installed for you,

335
00:15:33,840 --> 00:15:35,480
Clang and Make and other tools.

336
00:15:35,480 --> 00:15:38,240
We've also installed for you a program.

337
00:15:38,240 --> 00:15:41,760
That program is called Python, which is a little confusing at first glance,

338
00:15:41,760 --> 00:15:44,520
because Python is apparently the name of the language,

339
00:15:44,520 --> 00:15:46,240
but it's also the name of the program.

340
00:15:46,240 --> 00:15:47,920
And here's where Python is different.

341
00:15:47,920 --> 00:15:51,200
Whereas C is, again, compiled, and you use something like Clang

342
00:15:51,200 --> 00:15:54,360
to convert it to machine code, Python is both the name of the language

343
00:15:54,360 --> 00:15:58,160
and the name of the program you use to interpret the language.

344
00:15:58,160 --> 00:16:01,040
So pre-installed in CS50 IDE, and frankly, these days,

345
00:16:01,040 --> 00:16:04,200
probably on your own Macs or PCs, even if you don't know it,

346
00:16:04,200 --> 00:16:08,200
it is a program called Python that, if fed Python source code as input,

347
00:16:08,200 --> 00:16:10,080
will do what that code says.

348
00:16:10,080 --> 00:16:12,640
So let's go ahead and try something just like that.

349
00:16:12,640 --> 00:16:16,280
Let me go ahead and save a file preemptively as hello.py.

350
00:16:16,280 --> 00:16:19,760
So .py will be the convention now instead of .c.

351
00:16:19,760 --> 00:16:22,440
And I'm going to go ahead and actually keep this pretty simple.

352
00:16:22,440 --> 00:16:23,960
I'm just going to print the first thing.

353
00:16:23,960 --> 00:16:26,320
It's muscle memory, so it's not printf anymore.

354
00:16:26,320 --> 00:16:30,360
It's just hello, world, save, done.

355
00:16:30,360 --> 00:16:32,720
That's going to be my first program in Python.

356
00:16:32,720 --> 00:16:33,220
Why?

357
00:16:33,220 --> 00:16:34,480
It's one line of code.

358
00:16:34,480 --> 00:16:38,760
It's consistent with the features I've claimed Python has.

359
00:16:38,760 --> 00:16:40,360
So how do I run it?

360
00:16:40,360 --> 00:16:43,960
Well, in C, we would have done like make hello,

361
00:16:43,960 --> 00:16:47,440
but make knows nothing about this because make is typically used with C,

362
00:16:47,440 --> 00:16:49,680
at least in this context here.

363
00:16:49,680 --> 00:16:54,000
So maybe it's like dot slash hello.py.

364
00:16:54,000 --> 00:16:56,440
No, it seems I don't have permission there.

365
00:16:56,440 --> 00:17:00,880
But there's a step that I teased us with earlier on just the slide alone.

366
00:17:00,880 --> 00:17:05,560
How do I go about running a program, did I say?

367
00:17:05,560 --> 00:17:07,440
Yeah, I have to be a little more explicit.

368
00:17:07,440 --> 00:17:10,760
So Python, which is the name of the interpreter that understands Python,

369
00:17:10,760 --> 00:17:12,360
and now I need to feed it some input.

370
00:17:12,360 --> 00:17:15,880
And we know from our time in C that programs can take command line arguments.

371
00:17:15,880 --> 00:17:17,280
And indeed, this program itself does.

372
00:17:17,280 --> 00:17:20,240
Python, you just give it the name of a program to run.

373
00:17:20,240 --> 00:17:23,320
And there it is, our very first program.

374
00:17:23,320 --> 00:17:24,800
So that's all fine and good.

375
00:17:24,800 --> 00:17:27,400
But what if I wanted to do something a little more interesting,

376
00:17:27,400 --> 00:17:29,240
like getting a string from the user?

377
00:17:29,240 --> 00:17:32,800
Well, it turns out in Python, in CS50 ID especially,

378
00:17:32,800 --> 00:17:34,120
I can do something like this.

379
00:17:34,120 --> 00:17:38,280
s gets get underscore string.

380
00:17:38,280 --> 00:17:41,840
And I can ask someone, for instance, for their name, like this.

381
00:17:41,840 --> 00:17:46,840
Now, CS50 ID is already yelling at me, undefined variable get string.

382
00:17:46,840 --> 00:17:50,360
And let's actually see if maybe it's just buggy.

383
00:17:50,360 --> 00:17:53,680
No, so this is a little more arcane than usual.

384
00:17:53,680 --> 00:17:56,600
But trace back, most recent call last.

385
00:17:56,800 --> 00:17:59,520
Hello.py line 2 in module, whatever that is.

386
00:17:59,520 --> 00:18:01,160
So I see a line of code from line 2.

387
00:18:01,160 --> 00:18:03,520
Name, error, name, get string is not defined.

388
00:18:03,520 --> 00:18:06,080
This is not the same language we've seen before.

389
00:18:06,080 --> 00:18:07,760
But what does this feel reminiscent of?

390
00:18:09,760 --> 00:18:13,080
Yeah, when the past, when you've forgotten CS50.h,

391
00:18:13,080 --> 00:18:16,760
you've gotten something about an undeclared identifier, something like that.

392
00:18:16,760 --> 00:18:20,160
It just didn't understand something related to the CS50 library.

393
00:18:20,160 --> 00:18:23,800
So in C, we would have done include CS50.h.

394
00:18:23,800 --> 00:18:26,360
That's no longer germane, because now we're in Python.

395
00:18:26,360 --> 00:18:28,080
But it's somewhat similar in spirit.

396
00:18:28,080 --> 00:18:33,160
Now I'm going to say, instead, from CS50, import get string.

397
00:18:33,160 --> 00:18:35,120
And now save that.

398
00:18:35,120 --> 00:18:38,560
And hopefully, momentarily, the errors will go away as the IDE realizes,

399
00:18:38,560 --> 00:18:42,400
oh, you've now imported the CS50 library, specifically a method,

400
00:18:42,400 --> 00:18:45,080
or function, rather, inside of it, called get string.

401
00:18:45,080 --> 00:18:46,680
So there, too, it's different syntax.

402
00:18:46,680 --> 00:18:48,520
But it kind of says what it means, from CS50, which

403
00:18:48,520 --> 00:18:51,640
is apparently the name of the library, import a function called get string.

404
00:18:51,640 --> 00:18:54,800
Now, if I go ahead and rerun Python, hello.py,

405
00:18:54,800 --> 00:18:57,080
I can go ahead and type in, say, Maria's name,

406
00:18:57,080 --> 00:19:01,560
and ignore her altogether, because I need to make a fix here.

407
00:19:01,560 --> 00:19:06,160
What's the obvious bug, obvious now, to me, in the program?

408
00:19:06,160 --> 00:19:08,480
You need to include the variable, or s?

409
00:19:08,480 --> 00:19:12,640
Yeah, so I need to include s, which I got on line three,

410
00:19:12,640 --> 00:19:15,000
but then thereafter, use in any way.

411
00:19:15,000 --> 00:19:18,440
So this is going to be wrong, of course, because that's

412
00:19:18,440 --> 00:19:20,280
going to say, literally, hello, s.

413
00:19:20,280 --> 00:19:24,080
This is kind of how we used to do it, and then we would put in s.

414
00:19:24,080 --> 00:19:25,280
But this is not print f.

415
00:19:25,280 --> 00:19:27,600
This is print, so the world is a little different.

416
00:19:27,600 --> 00:19:30,280
And it turns out we can do this in a couple of different ways.

417
00:19:30,280 --> 00:19:34,120
Perhaps the easiest, if at least obvious, would

418
00:19:34,120 --> 00:19:41,120
be something like this, where I could simply say, hello.

419
00:19:41,120 --> 00:19:44,040
Open curly brace, close curly brace.

420
00:19:44,040 --> 00:19:47,240
And then inside of there, simply specify the name of the variable

421
00:19:47,240 --> 00:19:48,400
that I want to plug in.

422
00:19:48,400 --> 00:19:50,160
And that's not quite all the way there.

423
00:19:50,160 --> 00:19:52,400
Let me go ahead and run this once more.

424
00:19:52,400 --> 00:19:55,960
Now, if I type in Maria's name, still not quite right,

425
00:19:55,960 --> 00:19:59,560
I need to actually tell Python that this is a special type of string.

426
00:19:59,560 --> 00:20:03,280
It's a formatted string, similar in spirit to what print f expected.

427
00:20:03,280 --> 00:20:06,440
And the way you do this, even though it's a little different from c,

428
00:20:06,440 --> 00:20:07,960
is you just say f.

429
00:20:07,960 --> 00:20:08,800
This is an f string.

430
00:20:08,800 --> 00:20:11,720
So literally before the quotes, you write the letter f.

431
00:20:11,720 --> 00:20:14,120
And then if I now run this program here,

432
00:20:14,120 --> 00:20:18,120
I'm going to actually see Maria's name as hello Maria.

433
00:20:18,120 --> 00:20:20,040
And I'll take care of that red x later.

434
00:20:20,040 --> 00:20:20,880
So that's a format string.

435
00:20:20,880 --> 00:20:21,800
And there's one other way.

436
00:20:21,800 --> 00:20:26,040
And this is not very obvious, I would say.

437
00:20:26,040 --> 00:20:29,320
You might also see an online documentation, something like this.

438
00:20:29,320 --> 00:20:31,640
And let's just tease this apart for just a second.

439
00:20:31,640 --> 00:20:35,080
It turns out in Python that what I've highlighted in green here

440
00:20:35,080 --> 00:20:37,560
is known as a string, otherwise known as a stir.

441
00:20:37,560 --> 00:20:40,040
S-T-R is the name of this data type.

442
00:20:40,040 --> 00:20:43,720
Well, unlike in C, where string was kind of a white lie,

443
00:20:43,720 --> 00:20:45,960
where it was just a pointer at the end of the day,

444
00:20:45,960 --> 00:20:49,760
a string is actually a first class object in Python,

445
00:20:49,760 --> 00:20:52,400
which means it's not just a sequence of characters.

446
00:20:52,400 --> 00:20:56,160
It has built-in functionality, built-in features.

447
00:20:56,160 --> 00:21:00,200
So much like a struct in C had multiple things inside of it,

448
00:21:00,200 --> 00:21:04,280
so does a string in Python have multiple things inside of it,

449
00:21:04,280 --> 00:21:07,760
not just the sequence of characters, but functions

450
00:21:07,760 --> 00:21:09,280
that can actually do things.

451
00:21:09,280 --> 00:21:11,560
And it turns out you access those functions

452
00:21:11,560 --> 00:21:13,760
by way of the same dot operator as in C.

453
00:21:13,760 --> 00:21:16,400
And then you would only know from the documentation or examples

454
00:21:16,400 --> 00:21:19,800
in class what functions are inside of the string object.

455
00:21:19,800 --> 00:21:22,880
But one of them is format, and that's just a function that takes an argument.

456
00:21:22,880 --> 00:21:26,240
What do you want to plug into the string to the left of the dot?

457
00:21:26,240 --> 00:21:32,800
And so simply by specifying, hey, Python, here's a string with a placeholder.

458
00:21:32,800 --> 00:21:35,360
Inside of this string is a built-in function,

459
00:21:35,360 --> 00:21:38,560
otherwise known as a method, when a function is inside some object

460
00:21:38,560 --> 00:21:41,040
or structure, pass in the value s.

461
00:21:41,040 --> 00:21:45,600
So if I now go ahead and rerun this after saving my changes,

462
00:21:45,600 --> 00:21:49,480
I should now see that Maria's name is still plugged in.

463
00:21:49,480 --> 00:21:52,480
So that's it, but a simple idea that now even strings

464
00:21:52,480 --> 00:21:55,200
have things inside of them, besides the characters alone,

465
00:21:55,200 --> 00:21:57,280
and you can access that via the dots.

466
00:21:57,280 --> 00:22:01,040
So let's go ahead now and ramp things up to a more familiar example

467
00:22:01,040 --> 00:22:01,920
from a while back.

468
00:22:01,920 --> 00:22:05,120
Let me go ahead and open up two side-by-side windows

469
00:22:05,120 --> 00:22:07,280
and see if we can't translate one to the other.

470
00:22:07,280 --> 00:22:12,720
I'm going to go ahead and open up, for instance, int dot c from some time ago.

471
00:22:12,720 --> 00:22:15,080
So you might recall from int dot c, we had

472
00:22:15,080 --> 00:22:18,720
this program here whose purpose in life was to get an integer from the user

473
00:22:18,720 --> 00:22:22,040
and actually now plug it into printf and then print it out.

474
00:22:22,040 --> 00:22:24,720
So what's going to be different now in Python?

475
00:22:24,720 --> 00:22:28,920
Well, in Python, if I go ahead and implement this as, say, int dot pi,

476
00:22:28,920 --> 00:22:31,120
I'm going to go ahead and do the following.

477
00:22:31,120 --> 00:22:33,800
Let me scroll down to kind of line things up roughly.

478
00:22:33,800 --> 00:22:39,480
I can go ahead and say def, oops, def main, as I saw in the slides before.

479
00:22:39,480 --> 00:22:44,760
And then over here, I can say, I get int, quote unquote, integer.

480
00:22:44,760 --> 00:22:48,940
And then down here, I'm going to say not printf, but print, quote unquote,

481
00:22:48,940 --> 00:22:52,400
hello, and then the placeholder.

482
00:22:52,400 --> 00:22:56,040
What's the simplest way to do this now, per our past example?

483
00:22:56,040 --> 00:22:58,240
Curly brace?

484
00:22:58,240 --> 00:23:00,560
I. And then I just need to be super clear.

485
00:23:00,560 --> 00:23:04,440
This is a special f string or format string into which you can plug values.

486
00:23:04,440 --> 00:23:06,480
And now I'm going to go ahead and save that.

487
00:23:06,480 --> 00:23:11,200
And I've got most of the pieces together now, ignoring for now the red x.

488
00:23:11,200 --> 00:23:13,840
So what more remains to be done?

489
00:23:13,840 --> 00:23:17,480
I've made one same mistake as before.

490
00:23:17,480 --> 00:23:18,720
Yeah, so the get int.

491
00:23:18,720 --> 00:23:21,240
So up here, really, the equivalent of line 3

492
00:23:21,240 --> 00:23:26,440
would be from CS50 import get int this time.

493
00:23:26,440 --> 00:23:27,160
Saving that.

494
00:23:27,160 --> 00:23:35,720
And now, if in my terminal window, I go ahead and run Python of int dot pi,

495
00:23:35,720 --> 00:23:38,960
that seems strange.

496
00:23:38,960 --> 00:23:42,200
It's not an error in terms of, like, erroneous output.

497
00:23:42,200 --> 00:23:43,560
Just nothing happened.

498
00:23:43,760 --> 00:23:47,080
So why might this be?

499
00:23:47,080 --> 00:23:50,120
How might you go about troubleshooting this, even with very little Python

500
00:23:50,120 --> 00:23:52,280
under your belt?

501
00:23:52,280 --> 00:23:52,880
Is that a hand?

502
00:23:52,880 --> 00:23:53,840
I don't know.

503
00:23:53,840 --> 00:23:54,120
No?

504
00:23:54,120 --> 00:23:55,280
OK.

505
00:23:55,280 --> 00:23:57,440
Yeah?

506
00:23:57,440 --> 00:23:58,720
Is there a line break?

507
00:23:58,720 --> 00:23:59,400
That's OK.

508
00:23:59,400 --> 00:24:02,240
I was just doing that to kind of make everything line up, but it's no big deal.

509
00:24:02,240 --> 00:24:06,240
Everything's indented properly, which is the important aesthetic.

510
00:24:06,240 --> 00:24:08,440
Yeah?

511
00:24:08,440 --> 00:24:09,560
We didn't call the function.

512
00:24:09,560 --> 00:24:11,720
And this is where Python's a little different from C.

513
00:24:11,720 --> 00:24:14,480
In C, recall, main just gets called automatically for you.

514
00:24:14,480 --> 00:24:17,600
Humans years ago decided that shall be the default name of a function.

515
00:24:17,600 --> 00:24:21,360
In Python, line 6 here, calling something main is just a convention.

516
00:24:21,360 --> 00:24:24,200
I could have called it foo or bar or any other word.

517
00:24:24,200 --> 00:24:25,720
It has no special meaning.

518
00:24:25,720 --> 00:24:28,200
And so in Python, if you want to actually call main,

519
00:24:28,200 --> 00:24:30,360
you need to do something, frankly, that's, I think,

520
00:24:30,360 --> 00:24:32,680
one of the stupider distractions early on.

521
00:24:32,680 --> 00:24:37,280
But you have to literally say this, if the name of this file

522
00:24:37,280 --> 00:24:43,600
happens to equal something that's specially called main, then call main.

523
00:24:43,600 --> 00:24:47,720
So long story short, when you run the Python interpreter on a file,

524
00:24:47,720 --> 00:24:52,520
as we've been doing with Python space int.py or hello.py,

525
00:24:52,520 --> 00:24:57,280
there is a special global variable that your program has access to called

526
00:24:57,280 --> 00:25:00,240
underscore underscore name, underscore underscore.

527
00:25:00,240 --> 00:25:03,400
And if that default name happens to be underscore underscore main,

528
00:25:03,400 --> 00:25:09,880
underscore underscore, then you know that you have the ability to call

529
00:25:09,880 --> 00:25:11,560
any function you want by default.

530
00:25:11,560 --> 00:25:13,960
So for now, much like we did in week one, where

531
00:25:13,960 --> 00:25:17,240
we glossed over certain details that just weren't all that interesting,

532
00:25:17,240 --> 00:25:20,440
lines 11 and 12 for now, let's consider not all that interesting,

533
00:25:20,440 --> 00:25:22,920
but it's how we're going to kickstart these programs.

534
00:25:22,920 --> 00:25:27,760
Because now, if I run Python space int.py, type in a great number,

535
00:25:27,760 --> 00:25:32,840
hello, 42, the meaning of life, the universe, and everything.

536
00:25:32,880 --> 00:25:36,200
So let's now actually do something more powerful than just getting

537
00:25:36,200 --> 00:25:37,360
a single int from the user.

538
00:25:37,360 --> 00:25:40,640
Let me go ahead and close off this one and close off this one

539
00:25:40,640 --> 00:25:47,440
and open up, say, ints.c after splitting my window again into two windows here.

540
00:25:47,440 --> 00:25:48,960
And let's open ints.c.

541
00:25:48,960 --> 00:25:53,680
So this one was a little different in that we did some arithmetic.

542
00:25:53,680 --> 00:25:57,200
And so here's going to be another difference in Python.

543
00:25:57,200 --> 00:26:01,880
Here's what we did in C. And what was curious or worth noting about math

544
00:26:01,880 --> 00:26:03,760
in C?

545
00:26:03,760 --> 00:26:06,960
Which of these did not quite behave as you might expect in the real world?

546
00:26:09,960 --> 00:26:10,880
Division?

547
00:26:10,880 --> 00:26:11,280
Yeah, why?

548
00:26:11,280 --> 00:26:12,200
What did division do?

549
00:26:14,640 --> 00:26:16,560
Yeah, it chopped off or rounded down.

550
00:26:16,560 --> 00:26:19,800
It floored the value by throwing away everything after the decimal point.

551
00:26:19,800 --> 00:26:22,320
So this line here, 18, where it's such and such,

552
00:26:22,320 --> 00:26:24,560
divided by such and such, is such and such.

553
00:26:24,560 --> 00:26:27,040
And we literally just said x divided by y.

554
00:26:27,040 --> 00:26:30,800
If you divided, for instance, 1 divided by 2 in grade school,

555
00:26:30,800 --> 00:26:33,960
hopefully you would get the value 1 half or 0.5.

556
00:26:33,960 --> 00:26:36,360
But in C, what did we get instead?

557
00:26:36,360 --> 00:26:36,800
Zero.

558
00:26:36,800 --> 00:26:42,080
So it gets truncated to an int, the closest int without a decimal point being zero,

559
00:26:42,080 --> 00:26:44,000
because 0.5 is really 0.5.

560
00:26:44,000 --> 00:26:45,760
And thus, we had that effect.

561
00:26:45,760 --> 00:26:48,840
So in Python, things are going to be similar in spirit,

562
00:26:48,840 --> 00:26:53,800
but this is kind of a feature that was fixed or a bug that was fixed.

563
00:26:53,800 --> 00:26:58,920
In Python, let me go ahead here and open up an example I wrote in advance called

564
00:26:58,920 --> 00:27:02,720
ints.py, which is actually now going to look like this.

565
00:27:02,720 --> 00:27:07,360
So the Python equivalent now, which I'll roughly line up,

566
00:27:07,360 --> 00:27:08,920
looks a little different.

567
00:27:08,920 --> 00:27:11,760
And there's a few distractions, because we have all these f strings now

568
00:27:11,760 --> 00:27:12,640
in the way.

569
00:27:12,640 --> 00:27:15,120
But notice I'm just plugging in x's and y's.

570
00:27:15,120 --> 00:27:19,600
But what's a new feature, apparently, in Python, arithmetically?

571
00:27:19,600 --> 00:27:20,880
So floor division.

572
00:27:20,880 --> 00:27:24,520
So this was the more proper term for what C has been doing all this time.

573
00:27:24,520 --> 00:27:27,880
In C, when you use the slash, and you divide one number by another,

574
00:27:28,880 --> 00:27:31,840
it divides and then floors it to the nearest int.

575
00:27:31,840 --> 00:27:34,480
In Python, if you want that same old school feature,

576
00:27:34,480 --> 00:27:37,760
you're going to now use slash slash, not to be confused with the C comment.

577
00:27:37,760 --> 00:27:41,440
And if you want division to work the way you always knew it did in grade

578
00:27:41,440 --> 00:27:44,120
school, you continue using just the slash.

579
00:27:44,120 --> 00:27:47,040
So a minor point, but one of the differences to keep in mind.

580
00:27:47,040 --> 00:27:49,760
So if we actually run this here in Python,

581
00:27:49,760 --> 00:27:54,680
if I go into source 8 today, and our week's directory for week 1,

582
00:27:55,040 --> 00:28:00,200
and I run python ints.py, here now we're going to see 1 and 2.

583
00:28:00,200 --> 00:28:05,280
And there's all of the values that we would expect to see.

584
00:28:05,280 --> 00:28:08,840
All right, so without dwelling too much on this,

585
00:28:08,840 --> 00:28:12,480
let's fast forward to something more powerful, like conditions.

586
00:28:12,480 --> 00:28:15,920
So in Python, if we want to do something only conditionally,

587
00:28:15,920 --> 00:28:19,600
laying out my browser like this, let me go ahead and open up,

588
00:28:19,600 --> 00:28:27,360
let's say conditions.py, sorry, conditions.c, which once upon a time,

589
00:28:27,360 --> 00:28:28,800
looked like this.

590
00:28:28,800 --> 00:28:34,600
So in this example here, notice that we have a program that gets two ints

591
00:28:34,600 --> 00:28:38,280
from the user and then just compares x and y and x and y

592
00:28:38,280 --> 00:28:41,840
and prints out whether they're greater than, less than, or equal to, ultimately.

593
00:28:41,840 --> 00:28:44,480
So let's actually do this one from scratch over here on the right.

594
00:28:44,480 --> 00:28:47,480
So let me go ahead and save this as conditions.py.

595
00:28:47,480 --> 00:28:49,400
And then at the top, what's the very first thing

596
00:28:49,400 --> 00:28:52,760
I'm going to apparently now need?

597
00:28:52,760 --> 00:28:54,080
Yeah, so the CS50 library.

598
00:28:54,080 --> 00:28:58,400
So from CS50 import, it looks like get int is the one we want this time.

599
00:28:58,400 --> 00:29:01,720
Now, how do I go about getting an int?

600
00:29:01,720 --> 00:29:04,680
Or what's the translation of line nine on the left

601
00:29:04,680 --> 00:29:07,880
to the right-hand side of the screen?

602
00:29:07,880 --> 00:29:17,000
x equals get int of the same prompt.

603
00:29:17,000 --> 00:29:18,280
OK, what comes next?

604
00:29:18,280 --> 00:29:23,040
If I line it up roughly here, y gets get int of, quote unquote, y.

605
00:29:23,040 --> 00:29:26,120
And what's down here?

606
00:29:26,120 --> 00:29:31,480
The condition, so if x less than y, no parentheses are necessary.

607
00:29:31,480 --> 00:29:33,520
It's not wrong to put them, but it's unnecessary.

608
00:29:33,520 --> 00:29:36,720
And now enters a word into our terminology.

609
00:29:36,720 --> 00:29:38,640
It's not pythonic, so to speak.

610
00:29:38,640 --> 00:29:40,120
If you don't need them, don't put them.

611
00:29:40,120 --> 00:29:42,720
So if x is indeed less than y, what do we want to do?

612
00:29:42,720 --> 00:29:48,080
We want to print x is less than y, yes?

613
00:29:49,040 --> 00:29:49,640
All right, good.

614
00:29:49,640 --> 00:29:54,680
So else if x, OK, good.

615
00:29:54,680 --> 00:30:02,920
So kind of goofily, l if, then go ahead and print out x is greater than y.

616
00:30:02,920 --> 00:30:05,080
And as an aside, I actually did that accidentally.

617
00:30:05,080 --> 00:30:09,800
But it turns out in Python, too, you can use double quotes or single quotes.

618
00:30:09,800 --> 00:30:11,200
Either is fine.

619
00:30:11,200 --> 00:30:15,200
Whereas in C, single quotes had a very specific meaning, which went what?

620
00:30:15,200 --> 00:30:16,960
Char, so single characters.

621
00:30:16,960 --> 00:30:20,880
And double quotes meant strings, sequence of characters, which meant zero

622
00:30:20,880 --> 00:30:23,280
or more characters followed by backslash zero.

623
00:30:23,280 --> 00:30:25,080
In Python, all of that is gone.

624
00:30:25,080 --> 00:30:27,000
Single quotes and double quotes are equivalent.

625
00:30:27,000 --> 00:30:29,400
I'll almost always use double quotes just for consistency,

626
00:30:29,400 --> 00:30:32,800
as should you for consistency within your own files.

627
00:30:32,800 --> 00:30:36,040
But sometimes it's useful to drop into one or the other if you nest,

628
00:30:36,040 --> 00:30:39,440
for instance, quote marks, as you might have once in a while in C.

629
00:30:39,440 --> 00:30:45,120
OK, so finally, else print out x is equal to y.

630
00:30:45,120 --> 00:30:48,840
So it's cleaner, and frankly, I don't need all this white space.

631
00:30:48,840 --> 00:30:51,400
So let's go ahead and just make this a little tighter still.

632
00:30:51,400 --> 00:30:56,320
You can see that in 11 lines, we've now done what took 27 or so last time.

633
00:30:56,320 --> 00:30:59,160
But I have omitted something, to be fair.

634
00:30:59,160 --> 00:31:01,240
What did I omit?

635
00:31:01,240 --> 00:31:03,440
Yeah, I didn't do that whole calling a function thing.

636
00:31:03,440 --> 00:31:04,520
There's no mention of main.

637
00:31:04,520 --> 00:31:07,760
And it actually turns out that's not strictly necessary in Python.

638
00:31:07,760 --> 00:31:11,200
If you're going to be interpreting a file that contains Python code,

639
00:31:11,200 --> 00:31:13,400
and it's a simple enough program that you don't really

640
00:31:13,400 --> 00:31:18,440
need to factor code out and organize it into separate functions, then don't.

641
00:31:18,440 --> 00:31:21,280
If this is what would now be called a command line script,

642
00:31:21,280 --> 00:31:25,240
a program that just has lines of code, that you can execute literally

643
00:31:25,240 --> 00:31:25,920
at the prompt.

644
00:31:25,920 --> 00:31:30,320
So if I go into this directory and run Python of conditions.py enter,

645
00:31:30,320 --> 00:31:33,560
x will be 1, y will be 2, x is indeed less than y.

646
00:31:33,560 --> 00:31:34,320
And that's it.

647
00:31:34,320 --> 00:31:40,040
I don't need to bother doing all of this as I proposed earlier, def main.

648
00:31:40,040 --> 00:31:42,680
And then I could go in here, and if you've never known this,

649
00:31:42,680 --> 00:31:44,520
and now it's useful, especially for Python,

650
00:31:44,520 --> 00:31:46,880
you can highlight lines or just tab them all at once.

651
00:31:46,880 --> 00:31:49,760
I could do this, but then I would need this thing, which I probably

652
00:31:49,760 --> 00:31:54,000
have to go look up how to remember it if you're doing it for the first time.

653
00:31:54,000 --> 00:31:57,200
There's just no value in this case to doing that.

654
00:31:57,200 --> 00:32:00,760
But at least it can be there as needed.

655
00:32:00,760 --> 00:32:05,080
So let me go ahead and undo that, and we're back to a porting of one to the other.

656
00:32:05,080 --> 00:32:07,120
All right, so that might then be conditions.

657
00:32:07,120 --> 00:32:10,720
And let's see if we can't no switch there.

658
00:32:10,720 --> 00:32:12,000
Let's take a look at this one.

659
00:32:12,000 --> 00:32:15,040
Let me open up, rather than comparing all of them side by side,

660
00:32:15,040 --> 00:32:18,880
let me just open up this one now called noSwitch.py, which

661
00:32:18,880 --> 00:32:23,960
is reminiscent of a program we ran some time ago called noSwitch.c.

662
00:32:23,960 --> 00:32:28,480
And you can perhaps infer what this does from the comments alone.

663
00:32:28,480 --> 00:32:31,160
What does this program do in English?

664
00:32:31,160 --> 00:32:33,840
Because logical operators is not all that explicit at top.

665
00:32:36,960 --> 00:32:37,960
What's that?

666
00:32:38,920 --> 00:32:44,760
Yeah, so if you've ever interacted with a program that asks you for a prompt,

667
00:32:44,760 --> 00:32:47,520
yes or no, here's some code with which you might implement it.

668
00:32:47,520 --> 00:32:50,520
And we could do this in C. We're just comparing characters here.

669
00:32:50,520 --> 00:32:51,680
But there's a few differences.

670
00:32:51,680 --> 00:32:54,640
If you kind of now think back to how you might implement this in C,

671
00:32:54,640 --> 00:32:56,680
even if you don't recall the specific program.

672
00:32:56,680 --> 00:32:59,440
I'm importing my library right up here.

673
00:32:59,440 --> 00:33:04,120
I'm then calling getchar this time, which is also in CS50's library for Python.

674
00:33:04,120 --> 00:33:07,800
And then notice there's just a couple of things different down here syntactically.

675
00:33:07,800 --> 00:33:11,560
Besides the colons and the indentation and such, what else is noteworthy?

676
00:33:11,560 --> 00:33:12,060
Yeah.

677
00:33:12,060 --> 00:33:14,160
You can use more instead of more.

678
00:33:14,160 --> 00:33:15,320
Yeah, thank god.

679
00:33:15,320 --> 00:33:17,240
You can just say more what you mean now.

680
00:33:17,240 --> 00:33:20,640
If you want to do something or something, you literally say or.

681
00:33:20,640 --> 00:33:23,840
And if we were instead, albeit nonsensically here,

682
00:33:23,840 --> 00:33:28,200
trying to do the conjunction of two things, this and that, you could literally say and.

683
00:33:28,200 --> 00:33:30,760
So instead of the two vertical bars or the two ampersands,

684
00:33:30,760 --> 00:33:33,360
here's another slight difference in Python.

685
00:33:33,360 --> 00:33:37,160
Let's now take a look at another example, reminiscent of one's past.

686
00:33:37,200 --> 00:33:39,920
This one called return.py.

687
00:33:39,920 --> 00:33:44,640
So here is an example where it's actually more compelling to have a main function,

688
00:33:44,640 --> 00:33:47,880
because now I'm going to start organizing my code into different functions still.

689
00:33:47,880 --> 00:33:52,840
So up here, we are importing the getint function from CS50 library.

690
00:33:52,840 --> 00:33:58,360
Here I have my main function just saying x gets getint and then print out the square of x.

691
00:33:58,360 --> 00:34:02,280
So how do you go about defining your own custom function in Python that's not just main?

692
00:34:02,280 --> 00:34:07,080
Well, here on line 11 is how I would define a function called square

693
00:34:07,080 --> 00:34:10,840
that takes apparently an argument called n, though I could call this anything I want,

694
00:34:10,840 --> 00:34:15,000
colon return n star star 2.

695
00:34:15,000 --> 00:34:17,840
So a few new features here, but again, it's no big deal.

696
00:34:17,840 --> 00:34:21,480
Once you just kind of look these features up in a manual or in a class,

697
00:34:21,480 --> 00:34:23,440
what is star star probably doing?

698
00:34:23,440 --> 00:34:27,440
Not square root, the power of, yeah.

699
00:34:27,440 --> 00:34:30,360
So n star star 2 is just n raised to the power of 2.

700
00:34:30,360 --> 00:34:34,440
That was not a feature we had in C. So now we get this in Python.

701
00:34:34,440 --> 00:34:37,000
And what's this line 12 in green?

702
00:34:37,040 --> 00:34:40,520
With the weird use of double quotes.

703
00:34:40,520 --> 00:34:43,440
It's a comment, and it's a different type of comment than we've seen before.

704
00:34:43,440 --> 00:34:46,440
Because in my previous example, I did have a few comments.

705
00:34:46,440 --> 00:34:49,680
Recall that just a moment ago in conditions.py,

706
00:34:49,680 --> 00:34:52,200
we had a whole bunch of comments.

707
00:34:52,200 --> 00:34:55,440
Prompt the user for x, prompt the user for y, compare x and y.

708
00:34:55,440 --> 00:34:57,720
So whereas in C, we were using slash slash,

709
00:34:57,720 --> 00:35:01,080
Python unfortunately uses that for floor division, so to speak.

710
00:35:01,080 --> 00:35:06,240
So we instead just use the hashtag or the pound sign to enumerate a line,

711
00:35:06,240 --> 00:35:09,320
to specify a line that should be thought of as a comment.

712
00:35:09,320 --> 00:35:11,040
But here is something a little different.

713
00:35:11,040 --> 00:35:12,760
And we won't dwell too much on this for now,

714
00:35:12,760 --> 00:35:15,560
but Python has different types of comments, one of which is this.

715
00:35:15,560 --> 00:35:18,800
This is technically called a doc string or document string.

716
00:35:18,800 --> 00:35:23,160
And what's nice about Python, as well as languages like Java and other still,

717
00:35:23,160 --> 00:35:28,360
is that you can put comments in your code that special programs can read

718
00:35:28,360 --> 00:35:30,880
and then generate documentation for you.

719
00:35:30,880 --> 00:35:34,000
So if you ever took APCS and you ever saw Java doc,

720
00:35:34,040 --> 00:35:37,400
this was a way of commenting your methods and your code in Java using

721
00:35:37,400 --> 00:35:40,680
funky at signs and other syntax so that if you ran a special command,

722
00:35:40,680 --> 00:35:43,440
it could generate a user's manual for all of your functions

723
00:35:43,440 --> 00:35:47,480
until you or colleagues or friends or teachers exactly what all your functions

724
00:35:47,480 --> 00:35:50,480
are, what their arguments are, what their return values are, and all of that.

725
00:35:50,480 --> 00:35:55,880
Similarly, in Python, can you use these funky quote, quote, quote doc strings

726
00:35:55,880 --> 00:35:57,400
to document your function?

727
00:35:57,400 --> 00:36:00,840
So whereas in C, our style has been to put quotes above the functions.

728
00:36:00,840 --> 00:36:04,360
In Python, it's going to be to put them as the first line inside

729
00:36:04,360 --> 00:36:07,560
and indented within the function.

730
00:36:07,560 --> 00:36:12,440
All right, so now let's actually try to port a program from code again,

731
00:36:12,440 --> 00:36:19,560
thinking back on week one in C when we had this program here.

732
00:36:19,560 --> 00:36:25,280
So there's quite a bit going, oh, spoiler, don't look at that.

733
00:36:25,280 --> 00:36:27,240
Hopefully, that didn't sink in just yet.

734
00:36:27,240 --> 00:36:32,240
So in week one, we had this program in C, get positive int.

735
00:36:32,240 --> 00:36:35,520
And its purpose in life was to write a program that gets a positive integer

736
00:36:35,520 --> 00:36:37,840
from the user, in and of itself not all that interesting,

737
00:36:37,840 --> 00:36:40,240
but it was an opportunity to introduce a few things.

738
00:36:40,240 --> 00:36:44,880
One, we introduced this line six several weeks ago, which is known as a prototype.

739
00:36:44,880 --> 00:36:48,840
And what was the purpose of having that function prototype up there?

740
00:36:48,840 --> 00:36:50,920
Yeah, you declare the function, but why?

741
00:36:50,920 --> 00:36:54,680
Because it's already implemented down here on line 15.

742
00:36:55,680 --> 00:37:02,400
Yeah, because of the way the programs run, and frankly, because of how naive or dumb

743
00:37:02,400 --> 00:37:08,320
that Clang is by design, it does not know that a function exists until it actually sees it.

744
00:37:08,320 --> 00:37:12,760
So the problem is that if in C you have main, inside of which is a call to function

745
00:37:12,760 --> 00:37:16,440
like get positive int, but it's not implemented until a few lines later,

746
00:37:16,440 --> 00:37:19,040
Clang is going to be dumb and just not know that it even exists,

747
00:37:19,040 --> 00:37:20,640
and it's not going to compile your code.

748
00:37:20,640 --> 00:37:24,320
So this prototype, as we call it, is kind of a teaser, a hint

749
00:37:24,360 --> 00:37:25,880
that doesn't implement the whole function.

750
00:37:25,880 --> 00:37:31,120
It just shows the compiler its return type and its types and order of parameters

751
00:37:31,120 --> 00:37:33,840
so that that's enough information to then just trust

752
00:37:33,840 --> 00:37:36,800
that if I just blindly compile main, eventually,

753
00:37:36,800 --> 00:37:39,400
I'm going to see the actual implementation of the function

754
00:37:39,400 --> 00:37:41,600
so I can compile its bits as well.

755
00:37:41,600 --> 00:37:45,800
So in here, in C, we call get positive int, and then we pass it in a prompt.

756
00:37:45,800 --> 00:37:48,880
We stored it in a variable called i, and then printed it out.

757
00:37:48,880 --> 00:37:51,640
And then to implement this, we use kind of a familiar construct

758
00:37:51,640 --> 00:37:53,080
that you've used in other programs.

759
00:37:53,080 --> 00:37:56,320
Pretty much any time you want to prompt the user for inputs

760
00:37:56,320 --> 00:37:59,440
and you want to keep pestering him or her until they cooperate with whatever

761
00:37:59,440 --> 00:38:03,200
your conditions are, you would use the so-called do-while loop.

762
00:38:03,200 --> 00:38:06,680
And because the do-while loop recall is distinct from the while loop, how?

763
00:38:09,120 --> 00:38:11,480
It runs at least once, which just kind of makes intuitive sense

764
00:38:11,480 --> 00:38:13,520
if you want to prompt the user for something,

765
00:38:13,520 --> 00:38:17,320
and then if he or she doesn't cooperate, only then do you want to prompt them again.

766
00:38:17,320 --> 00:38:20,400
By contrast, with a while loop, it's going to happen again and again

767
00:38:21,280 --> 00:38:22,880
no matter what from the get go.

768
00:38:22,880 --> 00:38:26,560
So let's see if we can't now convert this or port this,

769
00:38:26,560 --> 00:38:28,440
as people would say, to Python.

770
00:38:28,440 --> 00:38:33,440
So here, I'm going to go ahead and save a new file called positive.py.

771
00:38:33,440 --> 00:38:39,440
And I'm going to go ahead and do everything here in main as before.

772
00:38:39,440 --> 00:38:44,400
So I'm going to go ahead and do, let's say, from cs50 import get int,

773
00:38:44,400 --> 00:38:45,840
because I do need that.

774
00:38:45,840 --> 00:38:48,400
And then I'm going to go ahead and have my main method here.

775
00:38:48,400 --> 00:38:51,880
And then inside of main, just like on the left-hand side,

776
00:38:51,880 --> 00:38:58,280
I'm going to do i get get positive int, positive integer, please.

777
00:38:58,280 --> 00:38:59,640
It's going to wrap a little bit now.

778
00:38:59,640 --> 00:39:00,520
That's fine.

779
00:39:00,520 --> 00:39:03,480
And then I'm going to go ahead and print this, which recall is just print,

780
00:39:03,480 --> 00:39:07,400
an f string where the placeholder is i.

781
00:39:07,400 --> 00:39:10,960
Although, frankly, this is kind of stupid to just create a string that

782
00:39:10,960 --> 00:39:13,080
has nothing other than the value we want to print.

783
00:39:13,080 --> 00:39:15,400
Nicely enough in Python, just print what you want.

784
00:39:15,400 --> 00:39:17,240
And so that simplifies that argument.

785
00:39:17,280 --> 00:39:22,800
So now it remains to implement get positive int, which

786
00:39:22,800 --> 00:39:25,160
is going to take some kind of prompt as its input.

787
00:39:25,160 --> 00:39:29,840
And notice I'm not specifying the data type of prompt, which is string.

788
00:39:29,840 --> 00:39:32,240
I'm not specifying the return type of this function,

789
00:39:32,240 --> 00:39:34,920
but both actually do exist underneath the hood.

790
00:39:34,920 --> 00:39:39,800
So in the past, to get a variable, I would do something like this semicolon.

791
00:39:39,800 --> 00:39:41,920
But I know I don't need the semicolon.

792
00:39:41,920 --> 00:39:43,560
I know I don't need the data type.

793
00:39:43,560 --> 00:39:46,800
And this just looks stupid to just put a variable there

794
00:39:46,800 --> 00:39:47,480
to need it.

795
00:39:47,480 --> 00:39:49,040
You don't need to do this in Python.

796
00:39:49,040 --> 00:39:52,000
If you want to use a variable, just start using it.

797
00:39:52,000 --> 00:39:55,480
And unfortunately, whereas almost every other feature we've seen in Python

798
00:39:55,480 --> 00:40:01,200
thus far kind of maps directly back to a feature in C,

799
00:40:01,200 --> 00:40:04,480
Python does not have a do while.

800
00:40:04,480 --> 00:40:07,200
So it has the for in.

801
00:40:07,200 --> 00:40:10,760
And it has while, and maybe it has other things we haven't told you about,

802
00:40:10,760 --> 00:40:12,600
but it doesn't have do while.

803
00:40:12,600 --> 00:40:16,000
So knowing that and knowing only what we've presented thus far,

804
00:40:16,000 --> 00:40:20,200
how do we still go about getting an int from the user

805
00:40:20,200 --> 00:40:23,960
and ensuring it's positive and re-prompting him or her if and only

806
00:40:23,960 --> 00:40:24,640
if it's not?

807
00:40:27,560 --> 00:40:28,200
Put another way.

808
00:40:28,200 --> 00:40:32,560
How would you do this in C if we took away from you the do while construct?

809
00:40:36,720 --> 00:40:37,880
Exclamation points?

810
00:40:37,880 --> 00:40:42,200
OK, so we could invert something maybe using that logically.

811
00:40:42,200 --> 00:40:43,400
We could just do a while loop.

812
00:40:43,400 --> 00:40:45,280
We could just use a while loop, how?

813
00:40:46,000 --> 00:40:50,960
So while prompt is less than 1.

814
00:40:50,960 --> 00:40:55,280
So while prompt is OK, so the prompt is the string we're going to input.

815
00:40:55,280 --> 00:40:57,040
We're going to pass display to the user.

816
00:40:57,040 --> 00:40:59,520
So it's not prompt, I think.

817
00:40:59,520 --> 00:41:04,200
So maybe i or n to be consistent with the other side.

818
00:41:04,200 --> 00:41:06,440
So you know what, why don't I, what about this?

819
00:41:06,440 --> 00:41:08,720
What if I just do, you know what, I know I need a loop.

820
00:41:08,720 --> 00:41:11,640
This is by far the easiest way to just get a loop, right?

821
00:41:11,640 --> 00:41:13,360
It's infinite, which is not good.

822
00:41:13,360 --> 00:41:15,480
But I can't break out of loops, recall.

823
00:41:15,480 --> 00:41:17,720
So what if I do something like this?

824
00:41:17,720 --> 00:41:22,840
What if I do n get int passing in the same prompt?

825
00:41:22,840 --> 00:41:25,200
And then what do I want to do next?

826
00:41:25,200 --> 00:41:27,720
I'm inside of an infinite loop, so this is going to keep happening,

827
00:41:27,720 --> 00:41:35,360
keep happening, keep happening until is positive.

828
00:41:35,360 --> 00:41:37,160
So Python's not quite that user friendly.

829
00:41:37,160 --> 00:41:39,080
We can't just say that.

830
00:41:39,080 --> 00:41:42,280
But we can say what?

831
00:41:42,280 --> 00:41:45,720
Greater than, close.

832
00:41:45,720 --> 00:41:46,680
Well, OK, that's fine.

833
00:41:46,680 --> 00:41:48,560
Greater than or equal to 1.

834
00:41:48,560 --> 00:41:50,120
Then what do we want to do?

835
00:41:50,120 --> 00:41:50,880
Great.

836
00:41:50,880 --> 00:41:54,240
So it's not quite as cool as like a do while loop, which kind of gives us

837
00:41:54,240 --> 00:41:56,800
all these features, though frankly, this was never that pretty, right?

838
00:41:56,800 --> 00:41:59,080
Especially the fact that you had to deal with the issue of scope

839
00:41:59,080 --> 00:42:00,560
by putting the variable outside.

840
00:42:00,560 --> 00:42:03,600
So in Python, the right way to do this would be something like this.

841
00:42:03,600 --> 00:42:06,200
Just induce an infinite loop, but make sure you break out of it

842
00:42:06,200 --> 00:42:09,200
logically when it's appropriate to do so.

843
00:42:09,200 --> 00:42:13,640
And so now, if I go ahead and add in that last thing that I keep needing,

844
00:42:13,640 --> 00:42:20,040
so if name equals main, and it's always fine to copy, paste something like that,

845
00:42:20,040 --> 00:42:23,800
a call main, let me go ahead now, and in my terminal window,

846
00:42:23,800 --> 00:42:27,160
run Python of positive dot pi.

847
00:42:27,160 --> 00:42:29,520
And let me go ahead and give it negative 5.

848
00:42:29,520 --> 00:42:31,240
How about negative 1?

849
00:42:31,240 --> 00:42:32,680
How about 0?

850
00:42:32,680 --> 00:42:33,560
Whoops, how about that?

851
00:42:33,560 --> 00:42:35,040
How about 0, 1?

852
00:42:36,040 --> 00:42:38,560
Hm.

853
00:42:38,560 --> 00:42:40,520
I screwed up.

854
00:42:40,520 --> 00:42:41,560
None is interesting.

855
00:42:41,560 --> 00:42:43,440
It's kind of our new null, so to speak.

856
00:42:43,440 --> 00:42:46,720
But whereas in C, null can potentially, if used in the wrong way,

857
00:42:46,720 --> 00:42:50,520
crash your program, Python might just print it, apparently.

858
00:42:50,520 --> 00:42:53,280
Where did I screw up?

859
00:42:53,280 --> 00:42:55,480
Yeah, so I didn't return an actual value.

860
00:42:55,480 --> 00:42:57,520
And whereas Clang might have noticed something like this,

861
00:42:57,520 --> 00:43:00,640
Python the interpreter is not going to be as sort of vigilant when

862
00:43:00,640 --> 00:43:02,960
it comes to figuring out if your code is missing something.

863
00:43:02,960 --> 00:43:05,640
Because after all, we never said we were going to return anything,

864
00:43:05,640 --> 00:43:07,360
and so we don't strictly need to.

865
00:43:07,360 --> 00:43:12,200
So what could I instead do here instead of break?

866
00:43:12,200 --> 00:43:17,080
I could just return n here, or I could equivalently do this,

867
00:43:17,080 --> 00:43:19,560
and then just make sure I return n here.

868
00:43:19,560 --> 00:43:22,920
And another difference in Python, too, is that the issue of scope

869
00:43:22,920 --> 00:43:26,760
isn't quite as difficult as it was in C.

870
00:43:26,760 --> 00:43:32,000
As soon as I've declared n to exist up here, it now exists down below.

871
00:43:32,040 --> 00:43:35,040
So even though it was declared inside of this indentation,

872
00:43:35,040 --> 00:43:38,240
it is not scoped to that while loop alone.

873
00:43:38,240 --> 00:43:41,880
So either way, could we actually make this work?

874
00:43:41,880 --> 00:43:44,600
OK, so now let's try to run this again.

875
00:43:44,600 --> 00:43:47,720
Positive integer, negative 1, 0, 1.

876
00:43:47,720 --> 00:43:49,440
And now we're actually seeing the number 1.

877
00:43:49,440 --> 00:43:51,160
All right, let me pause here for just a moment

878
00:43:51,160 --> 00:43:53,880
and see if there's any questions.

879
00:43:53,880 --> 00:43:54,560
No?

880
00:43:54,560 --> 00:43:55,060
Yes?

881
00:43:55,060 --> 00:43:59,200
Do you have to call the thing you can see at the library individually,

882
00:43:59,200 --> 00:44:01,200
or can you just import the entire one?

883
00:44:01,400 --> 00:44:04,080
You have to call things inside of the CS50 library individually,

884
00:44:04,080 --> 00:44:06,080
or can you import the whole thing?

885
00:44:06,080 --> 00:44:08,640
You can technically import the whole thing as follows.

886
00:44:08,640 --> 00:44:11,200
If you want access to everything in the CS50 library,

887
00:44:11,200 --> 00:44:12,520
you can literally say star.

888
00:44:12,520 --> 00:44:15,880
And in star in programming, well, in many computer contexts,

889
00:44:15,880 --> 00:44:17,840
star generally is a wild card character,

890
00:44:17,840 --> 00:44:21,640
and it means anything that matches this string here.

891
00:44:21,640 --> 00:44:23,520
This is generally considered bad practice, though,

892
00:44:23,520 --> 00:44:28,120
because if CS50's staff happens to give you functionality or variables

893
00:44:28,120 --> 00:44:30,640
that you don't want, you have now just imported

894
00:44:30,640 --> 00:44:34,600
into your namespace, so to speak, all of those functions.

895
00:44:34,600 --> 00:44:38,760
So for instance, if the CS50 library had public inside of it

896
00:44:38,760 --> 00:44:42,880
a variable called x and y and z, in addition to functions

897
00:44:42,880 --> 00:44:46,320
like getString and getInt and getChar, your program

898
00:44:46,320 --> 00:44:48,840
is now seeing variables x and y and z.

899
00:44:48,840 --> 00:44:51,200
And if you have your own variables called x and y and z,

900
00:44:51,200 --> 00:44:53,800
you're going to shadow those variables inside ours,

901
00:44:53,800 --> 00:44:55,480
and it just gets messy quickly.

902
00:44:55,480 --> 00:44:58,560
So generally, you want to be a little more nitpicky

903
00:44:58,560 --> 00:45:02,920
and just import what you want, or another convention in Python

904
00:45:02,920 --> 00:45:08,840
is to not specify it like this, but instead to do import CS50.

905
00:45:08,840 --> 00:45:12,840
This does not have the same effect of importing all of those keywords,

906
00:45:12,840 --> 00:45:16,640
like getInt and getString into your program's namespace,

907
00:45:16,640 --> 00:45:19,840
like the list of symbols you can actually type in.

908
00:45:19,840 --> 00:45:21,920
But what you then have to do is this.

909
00:45:21,920 --> 00:45:26,160
You have to now prefix any usages of the functions

910
00:45:26,160 --> 00:45:30,600
in that library with the now familiar or more familiar dot operator.

911
00:45:30,600 --> 00:45:33,000
So this is just a stylistic decision now.

912
00:45:33,000 --> 00:45:35,320
I have consciously chosen the other approach

913
00:45:35,320 --> 00:45:37,760
so that initially you can just call getInt, getString,

914
00:45:37,760 --> 00:45:41,320
just like we did in C. But technically and probably more conventionally

915
00:45:41,320 --> 00:45:44,200
would people do this to make super clear this isn't my getInt method,

916
00:45:44,200 --> 00:45:48,280
it's CS50's getInt function.

917
00:45:48,280 --> 00:45:50,640
OK, other questions?

918
00:45:50,640 --> 00:45:51,240
Yeah?

919
00:45:51,240 --> 00:45:56,760
Is it good coding practice to do the if underscore name or just because you

920
00:45:56,760 --> 00:45:59,240
can run Hello World without the defining main?

921
00:45:59,240 --> 00:46:00,480
Do you really need to do like that?

922
00:46:00,480 --> 00:46:01,760
Oh, it's a good question.

923
00:46:01,760 --> 00:46:03,120
Short answer, no.

924
00:46:03,120 --> 00:46:05,720
So I'm showing you this way because you'll

925
00:46:05,720 --> 00:46:08,680
see this in various examples online and in programs

926
00:46:08,680 --> 00:46:11,360
that you might look at that are open source.

927
00:46:11,360 --> 00:46:13,280
Strictly speaking, this is not necessary.

928
00:46:13,280 --> 00:46:17,760
If you end up making your own library, this tends to be a useful feature.

929
00:46:17,760 --> 00:46:23,600
But otherwise, I could equivalently do this, which is perfectly fine as well.

930
00:46:23,600 --> 00:46:25,760
I can still define getPositiveInt.

931
00:46:25,760 --> 00:46:28,120
I can get rid of main altogether.

932
00:46:28,120 --> 00:46:30,280
And I can just now do this.

933
00:46:30,280 --> 00:46:34,480
So this program is equivalent and just as fine for now.

934
00:46:34,480 --> 00:46:37,680
OK, so with that said, let's do a couple of more examples here.

935
00:46:37,680 --> 00:46:39,600
That kind of paints a picture of some of the things

936
00:46:39,600 --> 00:46:41,360
that are similar and different.

937
00:46:41,360 --> 00:46:44,200
And let's go ahead and open up, for instance,

938
00:46:44,240 --> 00:46:49,560
overflow.c from some weeks ago, splitting our windows again.

939
00:46:49,560 --> 00:46:53,200
And then on the right-hand side, let me open up something called overflow.pi,

940
00:46:53,200 --> 00:46:55,440
which I put together in advance.

941
00:46:55,440 --> 00:47:01,600
So here, we have on the left an example of integer overflow, whereby

942
00:47:01,600 --> 00:47:05,480
if I start counting at 1 and then don't even have a condition,

943
00:47:05,480 --> 00:47:09,240
and I just keep multiplying i by 2, by 2, by 2, doubling it, doubling it,

944
00:47:09,240 --> 00:47:12,240
doubling it, doubling it, we know from c that bad things happen.

945
00:47:12,280 --> 00:47:16,120
And if you just kind of keep incrementing something without any boundary in sight.

946
00:47:16,120 --> 00:47:18,680
So this program is just going to print out each of those values.

947
00:47:18,680 --> 00:47:20,800
And it's going to sleep one second in between.

948
00:47:20,800 --> 00:47:23,000
Same program in Python looks pretty similar.

949
00:47:23,000 --> 00:47:27,320
But notice I'm initializing i to 1, doing the following forever,

950
00:47:27,320 --> 00:47:32,280
printing out i, multiplying i by 2, and then sleeping for one second.

951
00:47:32,280 --> 00:47:35,600
But sleep is also not built into Python in the way that print is.

952
00:47:35,600 --> 00:47:37,280
Notice what I had to include up here.

953
00:47:37,280 --> 00:47:38,480
And I wasn't sure what that was.

954
00:47:38,480 --> 00:47:42,160
And so honestly, just a few days ago, I Googled to sleep one second

955
00:47:42,160 --> 00:47:46,080
in Python, saw that there's this time library inside of which is a sleep

956
00:47:46,080 --> 00:47:46,680
function.

957
00:47:46,680 --> 00:47:50,000
And that's how I knew which library to actually include.

958
00:47:50,000 --> 00:47:52,160
And so just as there are man pages for c,

959
00:47:52,160 --> 00:47:55,600
there's a whole documentation website for Python

960
00:47:55,600 --> 00:47:57,560
that has all of this information as well.

961
00:47:57,560 --> 00:47:58,800
So let me go ahead and do this.

962
00:47:58,800 --> 00:48:03,560
And let me actually try to create two windows here.

963
00:48:03,560 --> 00:48:07,320
What's the best way for me to do this?

964
00:48:07,320 --> 00:48:09,440
Split 1 to 2.

965
00:48:09,440 --> 00:48:13,640
OK, so let's do this just so I can run this in the same place.

966
00:48:13,640 --> 00:48:22,640
So if I go into my source 8 directory, and I go into weeks and 1,

967
00:48:22,640 --> 00:48:31,320
and I make overflow, nope, sorry, week 1.

968
00:48:31,320 --> 00:48:37,040
OK, so if I go into source 1, and I do make overflow, which is kind of cute

969
00:48:37,040 --> 00:48:40,880
semantically, I'm now going to be able to run a program called overflow.

970
00:48:40,880 --> 00:48:48,640
Meanwhile, over here, let me go ahead and split this window 2.

971
00:48:48,640 --> 00:48:50,360
Damn it, not there.

972
00:48:50,360 --> 00:48:54,640
Let's put this over here.

973
00:48:54,640 --> 00:48:55,320
Oh, no.

974
00:49:00,640 --> 00:49:02,520
OK, one second, sorry.

975
00:49:02,520 --> 00:49:04,000
Overflow.py.

976
00:49:04,000 --> 00:49:05,680
OK, so now we're back.

977
00:49:05,680 --> 00:49:06,560
No, I lost the other window.

978
00:49:09,760 --> 00:49:10,480
Oh, that's cool.

979
00:49:10,480 --> 00:49:14,080
OK, so let's do this.

980
00:49:14,080 --> 00:49:17,640
OK, now I know how to use the ID.

981
00:49:17,640 --> 00:49:20,840
All right, so on the left-hand side, I'm about to run overflow.

982
00:49:20,840 --> 00:49:23,640
And then lastly, without generating that beep again,

983
00:49:23,640 --> 00:49:29,800
I'm going to go in here, and I'm about to run Python of overflow.py.

984
00:49:29,800 --> 00:49:31,680
And so the left will run the C version.

985
00:49:31,680 --> 00:49:33,680
The right will run the Python version.

986
00:49:33,680 --> 00:49:42,200
And we'll start to see, no pun intended, what happens with these programs.

987
00:49:42,200 --> 00:49:43,120
Oh, damn it, I got to scroll.

988
00:49:47,680 --> 00:49:49,440
OK, so I'll just keep scrolling for us.

989
00:49:52,240 --> 00:49:52,880
This is fun.

990
00:49:59,400 --> 00:50:03,120
OK, next time, Google how to sleep for half a second instead.

991
00:50:03,120 --> 00:50:05,040
OK, so there we go.

992
00:50:05,040 --> 00:50:07,080
Something bad has happened here.

993
00:50:07,080 --> 00:50:09,320
And now C is just completely choking.

994
00:50:09,320 --> 00:50:11,440
Things are in a funky state.

995
00:50:11,440 --> 00:50:15,280
So what happened on the left before the answer scrolls away?

996
00:50:15,280 --> 00:50:16,280
Integer overflow, right?

997
00:50:16,280 --> 00:50:19,600
We had so many bits becoming ones that eventually it

998
00:50:19,600 --> 00:50:21,760
was mistaken for a negative number temporarily,

999
00:50:21,760 --> 00:50:25,280
and then the whole thing just kind of got confused and became permanently

1000
00:50:25,280 --> 00:50:29,480
zeroes, whereas on the right-hand side, like, yeah, Python, look at you go.

1001
00:50:29,480 --> 00:50:32,760
Like, still counting higher and higher and higher.

1002
00:50:32,760 --> 00:50:35,400
And even though we haven't talked about the underlying representation

1003
00:50:35,400 --> 00:50:39,200
of these types in Python, like, what can we infer from the apparent

1004
00:50:39,200 --> 00:50:43,600
better correctness of the version on the right in Python?

1005
00:50:43,600 --> 00:50:45,200
It's not an 8-bit representation.

1006
00:50:45,200 --> 00:50:47,680
And even C, to be fair, uses 32 bits for its ints.

1007
00:50:47,680 --> 00:50:50,960
And that's why we got as high as 2 billion or 4 billion in total.

1008
00:50:50,960 --> 00:50:54,320
But same idea, how many bits must Python be using?

1009
00:50:54,320 --> 00:50:55,320
64?

1010
00:50:55,320 --> 00:50:56,600
Yeah, maybe 64.

1011
00:50:56,600 --> 00:50:59,240
I don't know exactly, but I know it's not 32,

1012
00:50:59,240 --> 00:51:01,240
because it keeps counting up and up and up.

1013
00:51:01,240 --> 00:51:03,080
And so this is another feature of Python,

1014
00:51:03,080 --> 00:51:06,240
whereas int in C has typically been for us 32 bits,

1015
00:51:06,240 --> 00:51:08,760
although that is technically machine-specific.

1016
00:51:08,760 --> 00:51:11,600
Python integers are now going to be 64, which just

1017
00:51:11,600 --> 00:51:14,000
means we can do much bigger math, which is great for various data

1018
00:51:14,000 --> 00:51:15,680
science applications and stats and whatnot,

1019
00:51:15,680 --> 00:51:19,040
where you actually might have some large data sets to deal with.

1020
00:51:19,040 --> 00:51:21,920
Unfortunately, we still have some issues of imprecision.

1021
00:51:21,920 --> 00:51:24,480
Let me go ahead and close a whole bunch of these windows

1022
00:51:24,480 --> 00:51:30,320
and go ahead and open up, for instance, just this one here.

1023
00:51:31,040 --> 00:51:34,600
No, I'm going to skip this and do something slightly more fun, which

1024
00:51:34,600 --> 00:51:35,280
is this.

1025
00:51:35,280 --> 00:51:38,840
So in Python here, let's do a quick warm-up.

1026
00:51:38,840 --> 00:51:41,400
This is going to print for me what?

1027
00:51:41,400 --> 00:51:42,480
Four question marks, right?

1028
00:51:42,480 --> 00:51:43,440
And this is reminiscent.

1029
00:51:43,440 --> 00:51:46,560
This is a really cheap version of Super Mario Brothers.

1030
00:51:46,560 --> 00:51:49,600
And if you think back to week one, where we explored this,

1031
00:51:49,600 --> 00:51:51,920
there was a screenshot I had of Super Mario Brothers, one

1032
00:51:51,920 --> 00:51:55,440
of the worlds, where we just had four question marks, which Mario could

1033
00:51:55,440 --> 00:51:57,560
hit his head against to actually generate a coin.

1034
00:51:57,600 --> 00:52:00,520
So we stepped up from there in C to do this instead.

1035
00:52:00,520 --> 00:52:02,320
And this is going to give us another feature.

1036
00:52:02,320 --> 00:52:05,960
But let's see if we can't start to infer from context what these programs do.

1037
00:52:05,960 --> 00:52:07,320
Here's another one, Mario 1.

1038
00:52:07,320 --> 00:52:07,920
What's this do?

1039
00:52:12,080 --> 00:52:13,520
It's using a loop, for sure.

1040
00:52:13,520 --> 00:52:15,960
And it's using how many iterations, apparently?

1041
00:52:15,960 --> 00:52:18,920
Four, so from 0 to 1 to 2 to 3, total.

1042
00:52:18,920 --> 00:52:22,000
Each time, it's going to print out, apparently, a question mark.

1043
00:52:22,000 --> 00:52:23,800
But now, just infer from this.

1044
00:52:23,800 --> 00:52:25,520
I haven't answered this question already.

1045
00:52:25,560 --> 00:52:27,560
What else is going on on line four and why?

1046
00:52:30,680 --> 00:52:32,200
Not going to a new line, right?

1047
00:52:32,200 --> 00:52:35,400
So there's always this trade-off in programming and CS more generally,

1048
00:52:35,400 --> 00:52:38,840
like, yay, we took away the backslash n, which was annoying to type.

1049
00:52:38,840 --> 00:52:42,120
But now, if it's always there, how do you turn it off?

1050
00:52:42,120 --> 00:52:44,200
So this is one way to do that.

1051
00:52:44,200 --> 00:52:48,360
And it also reveals another fundamental feature of Python.

1052
00:52:48,360 --> 00:52:52,320
Notice that print apparently takes, in this case, more than one argument.

1053
00:52:52,320 --> 00:52:55,920
The first is a string, literally, quote, unquote, and a question mark.

1054
00:52:55,920 --> 00:52:58,520
The second is a little funkier.

1055
00:52:58,520 --> 00:53:03,920
It's like a word, and it's then an equal sign, and then it's a quote mark.

1056
00:53:03,920 --> 00:53:05,320
So what is this here?

1057
00:53:05,320 --> 00:53:09,560
So it turns out, Python supports what are called named parameters.

1058
00:53:09,560 --> 00:53:12,520
So in C, any parameters you pass through a function

1059
00:53:12,520 --> 00:53:16,080
are defined, ultimately, by way of their order.

1060
00:53:16,080 --> 00:53:20,200
Because even if a function takes arguments that have names, like x and y

1061
00:53:20,200 --> 00:53:23,680
or a and b or whatever, when you call the function,

1062
00:53:23,680 --> 00:53:25,840
you do not mention those names.

1063
00:53:25,840 --> 00:53:28,080
You know they exist, and that's how you think about them

1064
00:53:28,080 --> 00:53:30,800
in the documentation or in the original code.

1065
00:53:30,800 --> 00:53:35,160
But you don't name the arguments as you pass them in and call a function.

1066
00:53:35,160 --> 00:53:38,480
You instead pass them in in the appropriate order per the man page

1067
00:53:38,480 --> 00:53:40,480
or per the documentation.

1068
00:53:40,480 --> 00:53:43,600
So in Python, you can actually be a little more flexible.

1069
00:53:43,600 --> 00:53:47,640
If a function takes multiple arguments, all of which have names,

1070
00:53:47,640 --> 00:53:51,800
you can actually mention the names explicitly, thereby freeing you

1071
00:53:51,800 --> 00:53:55,200
from the minor inconvenience of having to remember and always get right

1072
00:53:55,200 --> 00:53:57,600
the actual order of arguments.

1073
00:53:57,600 --> 00:54:01,640
So in this case, print apparently takes at least two arguments in this case,

1074
00:54:01,640 --> 00:54:03,120
one of which is called end.

1075
00:54:03,120 --> 00:54:06,800
And if you want to use that one, which is clearly optional because I haven't

1076
00:54:06,800 --> 00:54:10,640
used it yet, you can literally mention it by name, set an equal sign,

1077
00:54:10,640 --> 00:54:13,040
and then specify the value that you want to pass in.

1078
00:54:13,040 --> 00:54:17,040
So if I actually now go into this and go into weeks and one

1079
00:54:17,040 --> 00:54:25,760
and do Python of mario1.py, whoops, I'll still get in week two.

1080
00:54:25,760 --> 00:54:30,520
If I get mario1.py, I still get four question marks.

1081
00:54:30,520 --> 00:54:34,920
But that's the result of printing this with a line ending of quote unquote.

1082
00:54:34,920 --> 00:54:38,080
If I do this, meanwhile, it's a little stupid because I'm

1083
00:54:38,080 --> 00:54:40,720
going to get that for free if I just omit it all together.

1084
00:54:40,720 --> 00:54:42,520
But now I get four question marks here.

1085
00:54:42,520 --> 00:54:46,200
And if you really want to be funky, you can do something

1086
00:54:46,240 --> 00:54:52,560
like this, which is just going to be taken literally to give you that instead.

1087
00:54:52,560 --> 00:54:59,320
Unclear utility of taking this approach, but that's all, sorry, that's going on.

1088
00:54:59,320 --> 00:55:00,880
Let's take a look at mario2.

1089
00:55:00,880 --> 00:55:02,640
This one works a little differently as well.

1090
00:55:02,640 --> 00:55:05,680
And how would you describe the feature offered by this version of mario?

1091
00:55:09,360 --> 00:55:11,280
Print any number of question marks perfectly.

1092
00:55:11,280 --> 00:55:13,800
So it's parameterized by first getting an int from the user,

1093
00:55:13,800 --> 00:55:15,680
using CS50's getInt function.

1094
00:55:15,680 --> 00:55:19,760
And now I'm iterating from i to the range of n, whatever that is,

1095
00:55:19,760 --> 00:55:22,680
and then actually printing out the question marks.

1096
00:55:22,680 --> 00:55:26,840
Meanwhile, in mario3.py, a little fancier still,

1097
00:55:26,840 --> 00:55:28,600
but what am I doing a little better now?

1098
00:55:36,480 --> 00:55:38,280
Yeah, I'm just making sure that the n is positive.

1099
00:55:38,280 --> 00:55:41,640
So I didn't bother implementing a whole function called getPositiveAnt.

1100
00:55:41,640 --> 00:55:42,200
I don't need that.

1101
00:55:42,200 --> 00:55:43,640
This is a super short program.

1102
00:55:43,640 --> 00:55:45,520
I'm just using the same logic up here.

1103
00:55:45,520 --> 00:55:48,080
Inducing deliberately an infinite loop, breaking out of it

1104
00:55:48,080 --> 00:55:50,240
only when I've gotten back a positive integer,

1105
00:55:50,240 --> 00:55:54,760
and then printing out that many of hashtags reminiscent of the bricks

1106
00:55:54,760 --> 00:55:55,600
in mario.

1107
00:55:55,600 --> 00:55:59,720
And then lastly, we have this slightly more sophisticated version that

1108
00:55:59,720 --> 00:56:03,160
actually prints out a different shape altogether.

1109
00:56:03,160 --> 00:56:06,000
You can infer from the comments, but focus more on why.

1110
00:56:06,000 --> 00:56:17,240
So this first line 12 iterates from i to n, whatever n is, that the user typed in.

1111
00:56:17,240 --> 00:56:24,160
Meanwhile, line 15, indented, iterates from j from 0 up to n as well.

1112
00:56:24,160 --> 00:56:27,840
So this is kind of like our canonical forint i gets 0, dot, dot, dot,

1113
00:56:27,840 --> 00:56:31,640
forint j gets 0, dot, dot, dot, where we've had nested loops in the past.

1114
00:56:31,640 --> 00:56:34,880
So notice, now that we have this building block, which is a line of code,

1115
00:56:34,880 --> 00:56:36,760
or kind of conceptually just a scratch piece,

1116
00:56:36,760 --> 00:56:38,640
we can embed one inside of the other.

1117
00:56:38,640 --> 00:56:41,600
Here, I can print out a hashtag, making sure not to put a new line

1118
00:56:41,600 --> 00:56:46,320
after every single hashtag I print out, only printing out a new line,

1119
00:56:46,320 --> 00:56:50,000
on line 17, on each iteration of the outer loop.

1120
00:56:50,000 --> 00:56:54,600
And now notice, whereas in C, we would have done this historically,

1121
00:56:54,600 --> 00:56:55,640
and that's fine.

1122
00:56:55,640 --> 00:56:59,680
In Python, we don't need the f, and we also don't need the backslash n.

1123
00:56:59,680 --> 00:57:01,680
So ergo, you can simply do print, and you'll

1124
00:57:01,680 --> 00:57:05,080
get, if nothing else, a backslash n automatically,

1125
00:57:05,080 --> 00:57:07,560
so that now, when I run this version of Mario,

1126
00:57:07,560 --> 00:57:09,280
we now get something more interesting.

1127
00:57:09,280 --> 00:57:11,640
And I'll increase the size of my terminal window for this,

1128
00:57:11,640 --> 00:57:14,440
so that I can enter a positive number like this, and print 10.

1129
00:57:14,440 --> 00:57:15,920
And now we've got a whole block.

1130
00:57:15,920 --> 00:57:16,800
So that was a lot.

1131
00:57:16,800 --> 00:57:19,320
Let's go ahead and take our five minute break here, and we'll come back.

1132
00:57:19,320 --> 00:57:22,040
We'll look at some more sophisticated examples still.

1133
00:57:22,040 --> 00:57:22,920
All right.

1134
00:57:22,920 --> 00:57:28,040
So let's begin to start to transition to actually solving problems with Python

1135
00:57:28,040 --> 00:57:30,360
after introducing just a couple of additional features that aren't

1136
00:57:30,360 --> 00:57:34,120
so much syntactic, but actual features of the language.

1137
00:57:34,120 --> 00:57:38,560
So here on the left was an old program we wrote in week three called argv0.c.

1138
00:57:38,560 --> 00:57:41,680
And its purpose in life was simply to allow you to run a command line

1139
00:57:41,680 --> 00:57:43,200
argument for the very first time.

1140
00:57:43,200 --> 00:57:45,240
And that was a nice tool to have in our toolkit.

1141
00:57:45,240 --> 00:57:47,000
So how might we go ahead and map this?

1142
00:57:47,000 --> 00:57:50,720
Well, we actually need to know how Python works a little bit differently

1143
00:57:50,720 --> 00:57:51,520
as follows.

1144
00:57:51,520 --> 00:58:03,920
If I go ahead and open a new file called, let's call it argv0.py,

1145
00:58:03,920 --> 00:58:06,880
I'm going to go ahead and translate this just as we did earlier.

1146
00:58:06,880 --> 00:58:12,360
So I'm going to go ahead and want to use the following.

1147
00:58:12,360 --> 00:58:16,400
So if argc, so there is no argc.

1148
00:58:17,160 --> 00:58:21,480
So def main, there was also no argc or argv.

1149
00:58:21,480 --> 00:58:26,320
And it's not actually correct to do this and this, as you might assume.

1150
00:58:26,320 --> 00:58:29,840
It turns out that the feature command line arguments are provided by a Python

1151
00:58:29,840 --> 00:58:34,040
package, so to speak, or a library, much like the CS50 library is a package

1152
00:58:34,040 --> 00:58:36,080
that you can import in Python speak.

1153
00:58:36,080 --> 00:58:38,440
So to do this, I actually need to do this.

1154
00:58:38,440 --> 00:58:42,240
Import sys, which gives me access to a whole bunch of system related stuff

1155
00:58:42,240 --> 00:58:44,560
like what the user has typed at the command prompt.

1156
00:58:44,600 --> 00:58:48,960
And if I want to check if the number of words that the human typed at the prompt

1157
00:58:48,960 --> 00:58:51,480
is 2, I actually am going to do this.

1158
00:58:51,480 --> 00:58:57,600
If the length of sys.argv equals 2, then I'm

1159
00:58:57,600 --> 00:59:03,880
going to go ahead and print out, quote unquote, hello, comma,

1160
00:59:03,880 --> 00:59:05,920
and then a placeholder here.

1161
00:59:05,920 --> 00:59:08,920
I know for placeholders I need to turn this into a formatted string,

1162
00:59:08,920 --> 00:59:10,560
so an f string there.

1163
00:59:10,560 --> 00:59:13,680
And now inside of the curly braces, it turns out

1164
00:59:13,680 --> 00:59:18,240
I can do sys.argv bracket 1.

1165
00:59:18,240 --> 00:59:21,600
So it's a little different from before, but notice I'm barring almost

1166
00:59:21,600 --> 00:59:25,440
all the same ideas as earlier, including how we're printing out strings.

1167
00:59:25,440 --> 00:59:27,320
And even though this is a little more verbose, what

1168
00:59:27,320 --> 00:59:29,160
is between these two curly braces?

1169
00:59:29,160 --> 00:59:33,160
Well, it's the result of looking in the system package, which has a variable

1170
00:59:33,160 --> 00:59:34,920
called argv for argument vector.

1171
00:59:34,920 --> 00:59:39,400
Just like in C, it is itself an array, aka a list in Python.

1172
00:59:39,400 --> 00:59:44,160
And here we have the result of indexing into element 1 of that list.

1173
00:59:44,160 --> 00:59:49,040
And the way that I have access to this is because I've imported that whole package.

1174
00:59:49,040 --> 00:59:53,160
So if on the right hand side here, I go ahead after saving that file,

1175
00:59:53,160 --> 00:59:57,880
and I do Python of argv0.py, I see nothing.

1176
00:59:57,880 --> 01:00:01,680
But if I actually say, like, my name here, I see hello.david.

1177
01:00:01,680 --> 01:00:05,760
So very similar program, but implemented a little differently.

1178
01:00:05,760 --> 01:00:10,360
And you'll notice, too, that the length of an array, henceforth known

1179
01:00:10,360 --> 01:00:14,700
as a list, is not something that you yourself have to remember or keep

1180
01:00:14,700 --> 01:00:15,200
around.

1181
01:00:15,200 --> 01:00:20,000
You can just ask a list how long it is by calling the lang, or len,

1182
01:00:20,000 --> 01:00:23,600
for length function, passing it in as an argument.

1183
01:00:23,600 --> 01:00:25,600
So that's one of the takeaways there.

1184
01:00:25,600 --> 01:00:28,000
And if we actually want to do something a little more clever,

1185
01:00:28,000 --> 01:00:32,720
like print out all of the strings in argv, well, back in the day in C,

1186
01:00:32,720 --> 01:00:37,360
you might recall this example, argv1.c, wherein I had this for loop,

1187
01:00:37,360 --> 01:00:40,940
and I iterated from 0 on up to argc, the argument count,

1188
01:00:40,940 --> 01:00:44,400
printing out each of the arguments in that vector.

1189
01:00:44,400 --> 01:00:48,120
Python actually makes even something like this even simpler.

1190
01:00:48,120 --> 01:00:50,400
Let me go ahead and create a new file here,

1191
01:00:50,400 --> 01:00:53,560
and I'll call this, say, argv1.py.

1192
01:00:53,560 --> 01:00:58,480
And it turns out in Python, I can similarly just import sys, and then

1193
01:00:58,480 --> 01:01:06,800
do, honestly, for s in sys.argv, print s, done.

1194
01:01:06,800 --> 01:01:08,840
So again, kind of just says what it means.

1195
01:01:08,840 --> 01:01:11,920
So I've imported the system library, sys.argv,

1196
01:01:11,920 --> 01:01:14,520
I know to be a list, apparently, of command line arguments,

1197
01:01:14,520 --> 01:01:18,200
for something in something is a new syntax we have for for loop.

1198
01:01:18,200 --> 01:01:23,520
So for some variable s inside of this list, go ahead and print it.

1199
01:01:23,520 --> 01:01:26,800
And so it's a much cleaner, much more succinct way of, honestly,

1200
01:01:26,800 --> 01:01:29,680
getting rid of all of the complexity of this

1201
01:01:29,680 --> 01:01:32,200
by just saying, instead, what we mean.

1202
01:01:32,200 --> 01:01:34,240
Meanwhile, if I wanted to print out every character,

1203
01:01:34,240 --> 01:01:35,960
I can take this one step further.

1204
01:01:35,960 --> 01:01:38,520
So back in the day, in C, if I wanted to print out

1205
01:01:38,520 --> 01:01:42,160
every command line argument and every character therein,

1206
01:01:42,160 --> 01:01:43,040
I could do this.

1207
01:01:43,040 --> 01:01:46,520
I just need a couple of nested loops wherein, via the outer loop,

1208
01:01:46,520 --> 01:01:49,960
I iterate over all of the arguments passed in.

1209
01:01:49,960 --> 01:01:53,400
And on the inner loop, I iterate over the current string length

1210
01:01:53,400 --> 01:01:55,320
of whatever argument I'm printing.

1211
01:01:55,360 --> 01:01:58,760
And this had the effect of printing out all of the command line arguments

1212
01:01:58,760 --> 01:02:01,040
letters one at a time.

1213
01:02:01,040 --> 01:02:03,480
I can do this in Python, honestly, so much easier.

1214
01:02:03,480 --> 01:02:05,000
So let me go over here.

1215
01:02:05,000 --> 01:02:10,160
Let me create a new file called argv2.py.

1216
01:02:10,160 --> 01:02:11,840
Let me import sys as I did.

1217
01:02:11,840 --> 01:02:21,440
So import sys and then for snsys.argv, for cns, print c, done.

1218
01:02:21,440 --> 01:02:22,720
So what is this doing?

1219
01:02:22,720 --> 01:02:27,760
Gone is all of the overhead of four int i and four int j and so forth.

1220
01:02:27,760 --> 01:02:33,480
For snsys.argv, iterates over all of the elements of that list, one string at a time.

1221
01:02:33,480 --> 01:02:38,480
For cns is a little different, because s is technically a string or a stir object,

1222
01:02:38,480 --> 01:02:39,720
as we're going to start calling it.

1223
01:02:39,720 --> 01:02:42,520
But at the end of the day, a string is just a sequence of characters,

1224
01:02:42,520 --> 01:02:46,120
and turns out Python supports out of the box the ability to use a for loop,

1225
01:02:46,120 --> 01:02:48,600
even to iterate over all of the characters in a string.

1226
01:02:48,600 --> 01:02:50,000
And so c, I just mean char.

1227
01:02:50,000 --> 01:02:53,360
So for cns, that gives me each of the characters.

1228
01:02:53,360 --> 01:03:01,240
So now with the end here, if I go ahead and run Python of argv2.py with nothing,

1229
01:03:01,240 --> 01:03:04,520
I get just the program's name, because that's, of course,

1230
01:03:04,520 --> 01:03:06,920
the very first thing in argv as in C.

1231
01:03:06,920 --> 01:03:09,920
And if I write, say, a word like Maria here,

1232
01:03:09,920 --> 01:03:15,720
I get argv2.py Maria all in one long column,

1233
01:03:15,720 --> 01:03:18,920
because of the additional prints that are happening in the implicit new lines.

1234
01:03:18,920 --> 01:03:19,640
So any questions?

1235
01:03:19,680 --> 01:03:25,960
Before we proceed on this use of a package called sys, using these libraries,

1236
01:03:25,960 --> 01:03:28,080
rather using these functions therein.

1237
01:03:28,080 --> 01:03:33,560
All right, so let me skip ahead then to something slightly familiar too.

1238
01:03:33,560 --> 01:03:39,520
Let me go ahead, and you might recall, initials.c from some time ago,

1239
01:03:39,520 --> 01:03:44,680
wherein we accepted as a command line argument a user rather as an input

1240
01:03:44,680 --> 01:03:47,400
to get string, a user's name, and then we printed out their initial.

1241
01:03:47,400 --> 01:03:48,520
So let's go ahead and do that.

1242
01:03:48,520 --> 01:03:52,000
So from cs50, let me go ahead and import, get string.

1243
01:03:52,000 --> 01:03:54,800
Then let me go ahead and say, get me a string,

1244
01:03:54,800 --> 01:03:59,880
and I want the user to be prompted for their name, as we might do here.

1245
01:03:59,880 --> 01:04:02,920
Then let me go ahead and say, all right, there are initials.

1246
01:04:02,920 --> 01:04:06,280
I don't know what they are yet, so let me just initialize an empty string,

1247
01:04:06,280 --> 01:04:07,320
but then do this.

1248
01:04:07,320 --> 01:04:13,080
For c in s, which is for each character in the person's name, if,

1249
01:04:13,080 --> 01:04:17,880
and I don't know how to say this yet, if c is an uppercase

1250
01:04:17,880 --> 01:04:24,920
letter, then go ahead and append c to initials,

1251
01:04:24,920 --> 01:04:26,720
and then down here, print initials.

1252
01:04:26,720 --> 01:04:28,040
So I've left a couple of blanks.

1253
01:04:28,040 --> 01:04:29,880
That's just pseudocode for the moment.

1254
01:04:29,880 --> 01:04:33,480
But this line five, just to be clear, is doing what for me?

1255
01:04:33,480 --> 01:04:35,560
What is being iterated over?

1256
01:04:35,560 --> 01:04:36,000
The string.

1257
01:04:36,000 --> 01:04:39,880
So for each character in the string, for c in s,

1258
01:04:39,880 --> 01:04:41,200
I'm going to ask two questions.

1259
01:04:41,200 --> 01:04:44,320
So in c, we did this in a couple of different ways.

1260
01:04:44,320 --> 01:04:46,280
We can actually do it with kind of arithmetic,

1261
01:04:46,280 --> 01:04:49,280
assuming rather with inequality checks and actually considering

1262
01:04:49,280 --> 01:04:50,960
what the underlying ASCII values are.

1263
01:04:50,960 --> 01:04:55,000
The c type library had that is upper function and is lower that we use.

1264
01:04:55,000 --> 01:05:00,720
Well, it turns out, because c is itself not a char,

1265
01:05:00,720 --> 01:05:04,080
there is no such thing technically as a char in Python.

1266
01:05:04,080 --> 01:05:06,400
You have only strings of length one.

1267
01:05:06,400 --> 01:05:09,480
And this is why single quotes no longer have any special meaning.

1268
01:05:09,480 --> 01:05:13,480
It turns out c is technically just a one character string.

1269
01:05:13,480 --> 01:05:16,160
Strings are what we've started calling objects,

1270
01:05:16,200 --> 01:05:18,240
which is a fancier name for struct.

1271
01:05:18,240 --> 01:05:21,880
So inside of an object, like a string, is functionality.

1272
01:05:21,880 --> 01:05:26,080
And we saw one piece of functionality earlier, which was what?

1273
01:05:26,080 --> 01:05:33,040
Not length, but though that is another one, it was format.

1274
01:05:33,040 --> 01:05:34,120
We saw it briefly.

1275
01:05:34,120 --> 01:05:36,920
But when I did the string.format, I proposed

1276
01:05:36,920 --> 01:05:39,200
that there's actually built-in functionality to a string called

1277
01:05:39,200 --> 01:05:39,960
format.

1278
01:05:39,960 --> 01:05:40,680
Well, you know what?

1279
01:05:40,680 --> 01:05:45,600
It turns out there is a method or a function inside of the string class,

1280
01:05:45,640 --> 01:05:47,400
also called isUpper.

1281
01:05:47,400 --> 01:05:51,800
And I can ask the very string I'm looking at that question by saying,

1282
01:05:51,800 --> 01:05:57,640
if c.isUpper is true, then go ahead and append c to initials.

1283
01:05:57,640 --> 01:06:03,720
So in c, if initials were technically a string,

1284
01:06:03,720 --> 01:06:07,400
how could you go about appending another character to a string in c?

1285
01:06:10,400 --> 01:06:12,160
C dot appends?

1286
01:06:12,160 --> 01:06:14,200
Not in c.

1287
01:06:14,200 --> 01:06:17,360
Oh, so in c, the language.

1288
01:06:17,360 --> 01:06:18,680
OK, so what's a string in c?

1289
01:06:18,680 --> 01:06:21,640
A string in c is a sequence of characters, the last one of which

1290
01:06:21,640 --> 01:06:24,000
is backslash 0.

1291
01:06:24,000 --> 01:06:26,640
All right, so it's an array of characters, last of which is backslash 0.

1292
01:06:26,640 --> 01:06:29,720
So if I, for instance, typed in my first name, David,

1293
01:06:29,720 --> 01:06:32,440
and now I want to append mail-in to the end of it,

1294
01:06:32,440 --> 01:06:33,480
how do I do that in c?

1295
01:06:36,120 --> 01:06:37,800
Exactly, it's like an utter pain in the neck.

1296
01:06:37,800 --> 01:06:41,240
You have to create a new array that's bigger, that can fit both words,

1297
01:06:41,280 --> 01:06:44,820
copy the David into the new array, then copy the last name in,

1298
01:06:44,820 --> 01:06:46,640
then put the null terminator at the new array,

1299
01:06:46,640 --> 01:06:48,600
then free, probably, the original memory.

1300
01:06:48,600 --> 01:06:50,840
I mean, it's a ridiculous number of hoops to jump through.

1301
01:06:50,840 --> 01:06:53,600
And you've done this on occasion, especially for things like, perhaps,

1302
01:06:53,600 --> 01:06:54,800
problem set five.

1303
01:06:54,800 --> 01:06:56,560
But my god, we're kind of past that.

1304
01:06:56,560 --> 01:07:00,880
Just go ahead and append to the array the character you care about.

1305
01:07:00,880 --> 01:07:03,560
So in this case, not an array, but a list.

1306
01:07:03,560 --> 01:07:08,000
Sorry, not an array, but a string object that's initially blank.

1307
01:07:08,000 --> 01:07:11,160
It turns out that Python supports this syntax plus equals

1308
01:07:11,160 --> 01:07:14,440
typically means arithmetic and add one number to another,

1309
01:07:14,440 --> 01:07:16,080
but it also means append.

1310
01:07:16,080 --> 01:07:20,960
So you can simply append two initials by doing plus equals c,

1311
01:07:20,960 --> 01:07:22,080
one additional character.

1312
01:07:22,080 --> 01:07:24,920
So even though the string starts like this in this big in memory,

1313
01:07:24,920 --> 01:07:26,560
it's then going to grow for one character,

1314
01:07:26,560 --> 01:07:30,600
grow, grow, grow, grow until it has all of the user's initials.

1315
01:07:30,600 --> 01:07:33,880
And as for where that memory is coming from, who cares?

1316
01:07:33,880 --> 01:07:36,120
This is the point that we're now past.

1317
01:07:36,120 --> 01:07:37,560
You leave it to the language.

1318
01:07:37,560 --> 01:07:40,520
You leave it to the computer to start to manage those details.

1319
01:07:40,520 --> 01:07:42,640
And yes, if it needs to call Malek, fine, do it.

1320
01:07:42,640 --> 01:07:44,280
Don't bother me with that detail.

1321
01:07:44,280 --> 01:07:46,880
We can now start thinking and writing code sort of conceptually

1322
01:07:46,880 --> 01:07:49,480
at this level instead of at this level.

1323
01:07:49,480 --> 01:07:52,360
So again, we're sort of abstracting away what a string even is

1324
01:07:52,360 --> 01:07:54,400
and leaving it to the language itself.

1325
01:07:54,400 --> 01:07:58,360
So if I now go ahead and run Python of initials.py and type in,

1326
01:07:58,360 --> 01:08:05,000
for instance, Maria Zlatkova here with a capital M and a capital Z,

1327
01:08:05,000 --> 01:08:08,000
I then see her names because I've plucked out the middle initials.

1328
01:08:08,000 --> 01:08:12,080
And if we do something else like David J. Malen, even with a period in there,

1329
01:08:12,080 --> 01:08:15,880
it infers from the capitalization what my initials should actually be.

1330
01:08:15,880 --> 01:08:18,440
So again, a much tighter way of doing things.

1331
01:08:18,440 --> 01:08:20,420
Let me go ahead and now open up another example.

1332
01:08:20,420 --> 01:08:22,600
We didn't see a few weeks ago, though it was included

1333
01:08:22,600 --> 01:08:26,160
in some of our distribution code, if you wanted to look.

1334
01:08:26,160 --> 01:08:30,040
Some weeks ago, we had this program among the distribution code,

1335
01:08:30,040 --> 01:08:34,800
where I declared an array of strings called book.

1336
01:08:34,800 --> 01:08:38,600
And I proposed that there were these several names in the phone book,

1337
01:08:38,600 --> 01:08:43,080
so to speak, all of the past instructors of CS50 sorted alphabetically.

1338
01:08:43,080 --> 01:08:47,160
And then down below in this C program, I used that global variable called

1339
01:08:47,160 --> 01:08:51,160
book to implement, it seems, linear search.

1340
01:08:51,160 --> 01:08:54,680
And to implement linear search in C, I'm going to need, of course,

1341
01:08:54,680 --> 01:08:57,080
a loop to iterate over all of the strings.

1342
01:08:57,080 --> 01:08:59,720
This line 26 does exactly that.

1343
01:08:59,720 --> 01:09:03,080
I then in C recall how to use stir compare because remember, we tripped over

1344
01:09:03,080 --> 01:09:06,040
this issue early on where you can't just compare two strings in C

1345
01:09:06,040 --> 01:09:10,320
because you'd be comparing accidentally their addresses, their pointers,

1346
01:09:10,320 --> 01:09:11,280
not the actual value.

1347
01:09:11,280 --> 01:09:14,680
So we use stir compare, and I can pass in the name that I'm looking for

1348
01:09:14,680 --> 01:09:18,200
and the ith book one at a time, checking for equals zero.

1349
01:09:18,200 --> 01:09:21,560
And then I can call Mike or David or whoever I'm trying to call,

1350
01:09:21,560 --> 01:09:24,200
or just quit if the user isn't found.

1351
01:09:24,200 --> 01:09:25,960
So what did this program actually do?

1352
01:09:25,960 --> 01:09:31,080
If I go into this example, which again was from week three,

1353
01:09:31,080 --> 01:09:36,840
and I do make linear, nope, not that make, oh, wrong directory again.

1354
01:09:36,840 --> 01:09:40,680
If I go into source three and make linear,

1355
01:09:40,680 --> 01:09:43,160
this program is supposed to behave as follows.

1356
01:09:43,160 --> 01:09:47,880
So if I go ahead and run dot slash linear, look for our old friend Smith.

1357
01:09:47,880 --> 01:09:52,600
If found Smith, if I go ahead and search for, say, Jones, who did not previously

1358
01:09:52,600 --> 01:09:54,280
teach CS50, it says quitting.

1359
01:09:54,280 --> 01:09:58,360
All right, so meanwhile, in Python, bless its heart,

1360
01:09:58,360 --> 01:10:00,680
we can get rid of all of that.

1361
01:10:00,680 --> 01:10:05,520
And in our source eight directory here and our sub directory three,

1362
01:10:05,520 --> 01:10:08,600
let me go ahead and open this instead.

1363
01:10:08,600 --> 01:10:13,000
In Python, I can declare an array, otherwise known as a list, almost

1364
01:10:13,000 --> 01:10:16,720
in the same way, but what's different just to be super clear?

1365
01:10:16,720 --> 01:10:17,920
Brackets?

1366
01:10:17,920 --> 01:10:20,600
So the brackets are now square brackets instead of curly braces.

1367
01:10:20,600 --> 01:10:24,200
And frankly, unless you statically initialized an array in C,

1368
01:10:24,200 --> 01:10:26,200
like hard coded the values for your array in C,

1369
01:10:26,200 --> 01:10:28,600
you might not even have known you could use curly braces.

1370
01:10:28,600 --> 01:10:30,080
So that's not a huge deal here.

1371
01:10:30,080 --> 01:10:33,240
But in Python, square brackets here and here

1372
01:10:33,240 --> 01:10:36,080
represent a list of elements, literally.

1373
01:10:36,080 --> 01:10:39,520
And what else is different?

1374
01:10:39,520 --> 01:10:40,800
Didn't declare the size of the array.

1375
01:10:40,800 --> 01:10:42,640
And I technically don't have to do that in C either

1376
01:10:42,640 --> 01:10:45,640
if you're hard coding all of the values all at once.

1377
01:10:45,640 --> 01:10:48,840
But there is something missing on line seven.

1378
01:10:48,840 --> 01:10:51,200
Sorry?

1379
01:10:51,200 --> 01:10:51,760
The type.

1380
01:10:51,760 --> 01:10:52,920
I didn't specify string.

1381
01:10:52,920 --> 01:10:56,280
But otherwise, this is pretty similar to what we've done in C.

1382
01:10:56,280 --> 01:11:01,200
But what's beautiful here, and let me go ahead and hide that for just a second,

1383
01:11:01,200 --> 01:11:05,160
let me go ahead and prompt the user for his or her name.

1384
01:11:05,160 --> 01:11:07,120
So let's ask for the name here.

1385
01:11:07,120 --> 01:11:10,680
And then if I want to search the book, which is just a list of names,

1386
01:11:10,680 --> 01:11:12,320
how do I implement linear search?

1387
01:11:12,320 --> 01:11:20,680
Well, I could just do if name in book, print, calling, name,

1388
01:11:20,680 --> 01:11:22,520
and let's make this an F string.

1389
01:11:22,520 --> 01:11:25,320
And then down here, that's it.

1390
01:11:25,320 --> 01:11:27,560
So that's how you implement linear search in Python.

1391
01:11:27,560 --> 01:11:28,600
You don't need a loop.

1392
01:11:28,600 --> 01:11:30,840
You can just ask the question yourself.

1393
01:11:30,840 --> 01:11:35,480
So if book is a list, and name is the string that you're looking for,

1394
01:11:35,480 --> 01:11:37,880
just ask the language to figure this out for you.

1395
01:11:37,880 --> 01:11:43,280
If name in book is the syntax you can use to ask literally that question.

1396
01:11:43,280 --> 01:11:46,880
And in Python, we'll use probably linear search over that list,

1397
01:11:46,880 --> 01:11:48,960
because it doesn't necessarily know it's sorted,

1398
01:11:48,960 --> 01:11:50,760
even though it happens to be alphabetically.

1399
01:11:50,760 --> 01:11:54,680
But it will find it for you, thereby saving us a lot of the complexity

1400
01:11:54,680 --> 01:11:58,200
and time of having had to implement that ourselves.

1401
01:11:58,200 --> 01:12:03,040
Meanwhile, if I want to compare two strings, let me propose this.

1402
01:12:03,040 --> 01:12:04,760
Let me write a quick program here.

1403
01:12:04,760 --> 01:12:06,520
Compare 1.py.

1404
01:12:06,520 --> 01:12:11,080
And let me go ahead and from CS50 import, get string as before.

1405
01:12:11,080 --> 01:12:16,220
And now let me go ahead and get one string that I'll call S.

1406
01:12:16,220 --> 01:12:22,500
And let me get another string that I shall call T, just as we did a few weeks ago.

1407
01:12:22,500 --> 01:12:27,140
And now in C, this was buggy.

1408
01:12:27,140 --> 01:12:32,380
If I print same, else I print different.

1409
01:12:32,380 --> 01:12:36,780
So in C, just to be super clear, why was this incorrect,

1410
01:12:36,780 --> 01:12:39,540
this general idea of using equals equals?

1411
01:12:42,940 --> 01:12:44,420
Yeah, they're comparing addresses.

1412
01:12:44,420 --> 01:12:47,060
This was like the day before we peeled back

1413
01:12:47,060 --> 01:12:49,340
the layer of what a string actually is.

1414
01:12:49,340 --> 01:12:53,100
And it turns out that S and T in C were char stars or addresses,

1415
01:12:53,100 --> 01:12:55,260
which means, certainly, if you get two different strings,

1416
01:12:55,260 --> 01:12:56,860
even if you've typed the same characters,

1417
01:12:56,860 --> 01:12:58,740
you're going to be comparing two different addresses.

1418
01:12:58,740 --> 01:13:00,020
They're not going to be the same.

1419
01:13:00,020 --> 01:13:02,820
Now you can perhaps infer from the theme of today,

1420
01:13:02,820 --> 01:13:07,220
what is Python going to do if asked if S and T are equal?

1421
01:13:07,220 --> 01:13:11,260
It's going to ask and answer that question as you would expect as the human.

1422
01:13:11,260 --> 01:13:14,900
Equals equals now in Python is going to compare S and T,

1423
01:13:14,900 --> 01:13:17,700
look at their actual values, because they are strings,

1424
01:13:17,700 --> 01:13:21,500
and return same if you literally type the same words.

1425
01:13:21,500 --> 01:13:26,660
So in here, if I go in here, and I do Python of compare 1.py,

1426
01:13:26,660 --> 01:13:32,380
and I type in, for instance, Maria, and then I type in Maria,

1427
01:13:32,380 --> 01:13:33,340
they're indeed the same.

1428
01:13:33,340 --> 01:13:36,780
If I type in Maria and say Stelios, they're different,

1429
01:13:36,780 --> 01:13:39,180
because it's actually now comparing the strings,

1430
01:13:39,180 --> 01:13:41,900
as we would have hoped some time ago.

1431
01:13:41,900 --> 01:13:44,000
So let's take a look at another that kind of led

1432
01:13:44,000 --> 01:13:45,580
to some interesting quandaries.

1433
01:13:45,580 --> 01:13:50,700
You might recall in week four, we had this example in C.

1434
01:13:50,700 --> 01:13:54,780
No swap, so named, because this just did not work.

1435
01:13:54,780 --> 01:13:57,420
It was logically, seemingly correct.

1436
01:13:57,420 --> 01:14:02,580
But swap did not actually swap x and y, but it did swap a and b.

1437
01:14:02,580 --> 01:14:03,080
Why?

1438
01:14:03,840 --> 01:14:09,840
The memory locations were different.

1439
01:14:09,840 --> 01:14:12,880
So x and y, recall, are variables in C that

1440
01:14:12,880 --> 01:14:16,080
exist in a certain slice of memory that we called a frame on the stack,

1441
01:14:16,080 --> 01:14:18,080
main's frame on the stack.

1442
01:14:18,080 --> 01:14:22,120
Meanwhile, a and b are from a slightly different location in memory.

1443
01:14:22,120 --> 01:14:23,840
We sort of kept drawing it slightly above,

1444
01:14:23,840 --> 01:14:28,080
like a tray at the dining hall on the so-called stack.

1445
01:14:28,080 --> 01:14:32,000
A and b had the same values of x and y, one and two,

1446
01:14:32,000 --> 01:14:33,360
but their own copies of them.

1447
01:14:33,360 --> 01:14:37,160
So even though we logically, as with Kate, I think with the Gatorade,

1448
01:14:37,160 --> 01:14:41,280
swap the two values, we ultimately swap the wrong two values

1449
01:14:41,280 --> 01:14:45,360
without actually permanently mutating the original x and y.

1450
01:14:45,360 --> 01:14:48,600
So unfortunately, and unfortunately in Python,

1451
01:14:48,600 --> 01:14:50,360
there is no such thing as a pointer.

1452
01:14:50,360 --> 01:14:51,760
So those are now gone.

1453
01:14:51,760 --> 01:14:53,880
So we no longer have the expressiveness with which

1454
01:14:53,880 --> 01:14:55,800
to solve this problem that way.

1455
01:14:55,800 --> 01:15:01,960
But let me propose that we do it in oh, so clever of another way.

1456
01:15:01,960 --> 01:15:06,000
Here, let me go ahead and declare x is 1, y is 2.

1457
01:15:06,000 --> 01:15:07,720
Let me go ahead and print out as much.

1458
01:15:07,720 --> 01:15:13,360
So with a format string, I'm going to go ahead and say x is x, y is y,

1459
01:15:13,360 --> 01:15:15,240
plugging in their respective values.

1460
01:15:15,240 --> 01:15:16,680
I'm going to do that twice.

1461
01:15:16,680 --> 01:15:19,520
But in between, I'm going to try to perform this swap.

1462
01:15:19,520 --> 01:15:24,920
And if your mind's ready to be blown, do that in Python.

1463
01:15:24,960 --> 01:15:27,440
Do the old switcheroo in Python.

1464
01:15:27,440 --> 01:15:30,440
And this actually does swap the two values as you would expect.

1465
01:15:30,440 --> 01:15:31,920
Now, this is not a very common case.

1466
01:15:31,920 --> 01:15:34,480
And to be fair, this is an incredibly contrived example.

1467
01:15:34,480 --> 01:15:36,760
Because if you needed them swapped, well, maybe you

1468
01:15:36,760 --> 01:15:38,560
should have just done this in the first place.

1469
01:15:38,560 --> 01:15:40,960
But it does speak to one of the features of Python

1470
01:15:40,960 --> 01:15:44,160
where you can actually do something like that.

1471
01:15:44,160 --> 01:15:49,760
Let me introduce now one additional feature that we only recently acquired in C.

1472
01:15:49,760 --> 01:15:51,320
And that's the notion of a struct.

1473
01:15:51,320 --> 01:15:54,200
And let me go ahead and do this in code from scratch.

1474
01:15:54,240 --> 01:15:58,400
So let me go ahead and save this file proactively as struct0.py,

1475
01:15:58,400 --> 01:16:00,640
reminiscent of one of our older programs.

1476
01:16:00,640 --> 01:16:02,080
And let me go ahead and do this.

1477
01:16:02,080 --> 01:16:05,720
From cs50, import getString.

1478
01:16:05,720 --> 01:16:07,840
And then let me give myself an empty list.

1479
01:16:07,840 --> 01:16:09,840
So that would be a conventional way of giving yourself

1480
01:16:09,840 --> 01:16:11,400
an empty list in Python.

1481
01:16:11,400 --> 01:16:14,880
And much like in C, you can declare an empty array.

1482
01:16:14,880 --> 01:16:16,760
But in C, you have to know the size of it.

1483
01:16:16,760 --> 01:16:18,320
Or if not, you have to use a pointer.

1484
01:16:18,320 --> 01:16:19,320
And then you have to mallet.

1485
01:16:19,320 --> 01:16:21,000
No, all of that is gone.

1486
01:16:21,000 --> 01:16:22,520
Now in Python, you want a list?

1487
01:16:22,520 --> 01:16:25,800
Just say you need a list, and it will grow and shrink as you need.

1488
01:16:25,800 --> 01:16:30,360
Now I'm going to go ahead and just three times arbitrarily for i in the range of three.

1489
01:16:30,360 --> 01:16:34,600
Let me go ahead and ask the user for a name using getString.

1490
01:16:34,600 --> 01:16:36,760
And I'll ask him or her if their name.

1491
01:16:36,760 --> 01:16:39,560
Dorm will use getString as well.

1492
01:16:39,560 --> 01:16:40,640
Dorm here.

1493
01:16:40,640 --> 01:16:45,200
And then I want to append to the array this student.

1494
01:16:45,200 --> 01:16:48,280
So I could do something like this.

1495
01:16:48,280 --> 01:16:52,240
Students.append name.

1496
01:16:52,240 --> 01:16:54,480
And it turns out, and we've not said this yet,

1497
01:16:54,480 --> 01:16:59,760
but there is inside of the list data type a method that is function built

1498
01:16:59,760 --> 01:17:02,520
into it called append that literally does that.

1499
01:17:02,520 --> 01:17:05,400
So if you've got an otherwise empty list,

1500
01:17:05,400 --> 01:17:09,200
and you call that list's name.append, you'll add something to the end of the list.

1501
01:17:09,200 --> 01:17:10,920
And if there's not enough memory for it, no big deal.

1502
01:17:10,920 --> 01:17:14,240
Python will find you the memory, allocate it, move everything in it,

1503
01:17:14,240 --> 01:17:17,160
and you move on your way without having to worry about that.

1504
01:17:17,160 --> 01:17:19,320
But I don't want to store just the name.

1505
01:17:19,320 --> 01:17:21,520
I want to store the name and the dorm.

1506
01:17:21,520 --> 01:17:23,080
So I could do this.

1507
01:17:23,080 --> 01:17:25,760
I could do, well, maybe this isn't really students.

1508
01:17:25,760 --> 01:17:27,720
Maybe this is now dorms.

1509
01:17:27,720 --> 01:17:32,920
And then here I could do dorms.append dorm.

1510
01:17:32,920 --> 01:17:36,760
But why is this devolving now into bad design

1511
01:17:36,760 --> 01:17:40,240
if my goal was to associate a student with his or her dorm

1512
01:17:40,240 --> 01:17:42,280
and then keep those values together?

1513
01:17:42,280 --> 01:17:46,320
Why is this not the best approach in Python or back in the day, even

1514
01:17:46,320 --> 01:17:50,280
in C, to have two separate arrays?

1515
01:17:50,280 --> 01:17:51,480
By struct.

1516
01:17:51,480 --> 01:17:51,980
What's that?

1517
01:17:51,980 --> 01:17:53,160
Struct.

1518
01:17:53,160 --> 01:17:57,400
So well, you have to, like, twice as many things to maintain, for sure.

1519
01:17:57,400 --> 01:17:58,400
And what else?

1520
01:17:58,400 --> 01:17:59,960
You can't map one to the other.

1521
01:17:59,960 --> 01:18:01,160
You can't map one to the other.

1522
01:18:01,160 --> 01:18:03,280
It's just, it's like, it's very arbitrary.

1523
01:18:03,280 --> 01:18:06,040
Like, it's sort of this social contract that I will just

1524
01:18:06,040 --> 01:18:10,040
assume that student zero lives in dorm zero.

1525
01:18:10,040 --> 01:18:12,560
And student one lives in dorm one.

1526
01:18:12,560 --> 01:18:13,200
And that's fine.

1527
01:18:13,200 --> 01:18:14,120
And that's true.

1528
01:18:14,120 --> 01:18:16,800
But one of the features of programming and computer science

1529
01:18:16,800 --> 01:18:20,240
is this idea of encapsulation, like, associate-related memory with each

1530
01:18:20,240 --> 01:18:20,800
other.

1531
01:18:20,800 --> 01:18:22,520
And so what did we do in C instead?

1532
01:18:22,520 --> 01:18:25,720
We did not have two arrays.

1533
01:18:25,720 --> 01:18:27,040
Yeah, we had a struct.

1534
01:18:27,040 --> 01:18:30,080
And so Python doesn't have structs per se.

1535
01:18:30,080 --> 01:18:32,000
It instead has what are called classes.

1536
01:18:32,000 --> 01:18:34,360
And it has a few other things like tuples and name tuples,

1537
01:18:34,360 --> 01:18:36,240
but more on those some other time.

1538
01:18:36,240 --> 01:18:41,040
So it turns out I could actually implement my own notion of a student.

1539
01:18:41,040 --> 01:18:43,000
And I could import it like this.

1540
01:18:43,040 --> 01:18:46,400
The convention in Python is if you create your own struct,

1541
01:18:46,400 --> 01:18:50,440
henceforth called a class, you capitalize the name of it by convention.

1542
01:18:50,440 --> 01:18:52,360
So a little different from C conventions.

1543
01:18:52,360 --> 01:18:54,360
So what is a student going to look like?

1544
01:18:54,360 --> 01:18:57,000
This is perhaps the most complex syntax that we'll have today,

1545
01:18:57,000 --> 01:18:59,040
but it just has a few lines.

1546
01:18:59,040 --> 01:19:01,920
If you want to implement the notion of a student, how

1547
01:19:01,920 --> 01:19:02,960
might you do this?

1548
01:19:02,960 --> 01:19:08,000
Well, in Python, you literally say class student, where class is similar in spirit

1549
01:19:08,000 --> 01:19:11,240
to, just to be clear, struct or type def struct.

1550
01:19:11,240 --> 01:19:13,600
But in Python, we're just saying class.

1551
01:19:13,600 --> 01:19:15,520
And then this is the funky part.

1552
01:19:15,520 --> 01:19:19,480
You can declare a function that by convention

1553
01:19:19,480 --> 01:19:24,360
must be called init for initialize, that takes as its first argument

1554
01:19:24,360 --> 01:19:30,160
a keyword called self, and then any number of other arguments like this.

1555
01:19:30,160 --> 01:19:34,600
And then, for reasons that will hopefully be clear momentarily,

1556
01:19:34,600 --> 01:19:36,880
I can write some code inside of this method.

1557
01:19:36,880 --> 01:19:39,080
So long story short, what am I doing?

1558
01:19:39,080 --> 01:19:42,800
I have declared a new type of data structure called student.

1559
01:19:42,800 --> 01:19:45,400
And implicitly inside of this data structure,

1560
01:19:45,400 --> 01:19:49,080
there are two things inside of itself, something called name and something

1561
01:19:49,080 --> 01:19:50,360
called dorm.

1562
01:19:50,360 --> 01:19:53,520
And this is how you would, in a C struct, typically do things

1563
01:19:53,520 --> 01:19:56,760
with the data types and semicolons inside of the curly braces.

1564
01:19:56,760 --> 01:19:59,240
Meanwhile, there's this method here.

1565
01:19:59,240 --> 01:20:02,800
And it's a method in so far as it is inside of a class.

1566
01:20:02,800 --> 01:20:05,520
Otherwise, it's a function just by a different name.

1567
01:20:05,520 --> 01:20:09,960
This method init takes whatever self is, more on that another time,

1568
01:20:09,960 --> 01:20:13,000
but it then takes zero more custom arguments that you can provide.

1569
01:20:13,000 --> 01:20:14,680
And I called it name and dorm.

1570
01:20:14,680 --> 01:20:18,160
So it turns out this special method init is a function that's

1571
01:20:18,160 --> 01:20:21,400
going to be called automatically for you any time you

1572
01:20:21,400 --> 01:20:24,120
create a student object.

1573
01:20:24,120 --> 01:20:25,960
So what does that actually mean?

1574
01:20:25,960 --> 01:20:30,120
That means in your code, what you can actually do is this.

1575
01:20:30,120 --> 01:20:36,840
I can create a student in memory by saying s gets capital student passing

1576
01:20:36,840 --> 01:20:38,080
in name and dorm.

1577
01:20:38,080 --> 01:20:41,680
And we don't have this feature in C. On the right hand side,

1578
01:20:41,680 --> 01:20:44,240
what I've highlighted is the name of the class

1579
01:20:44,240 --> 01:20:46,680
and its two arguments, name and dorm, which

1580
01:20:46,680 --> 01:20:49,880
are just what the user has typed in.

1581
01:20:49,880 --> 01:20:53,520
What this class does for me now is it allocates memory underneath the hood

1582
01:20:53,520 --> 01:20:54,080
for a student.

1583
01:20:54,080 --> 01:20:56,440
It's got to be big enough for their name and big enough for their dorm.

1584
01:20:56,440 --> 01:20:58,600
So it's like yay big in memory, so to speak.

1585
01:20:58,600 --> 01:21:02,240
It then puts in the name and the dorm strings into that object

1586
01:21:02,240 --> 01:21:04,560
and then returns the whole object.

1587
01:21:04,560 --> 01:21:08,720
So you can kind of think of this as a much fancier version of malloc.

1588
01:21:08,720 --> 01:21:10,920
So this is allocating all the memory you need,

1589
01:21:10,920 --> 01:21:14,680
but it's also installing inside of that memory the name and the dorm.

1590
01:21:14,680 --> 01:21:18,840
And it's bundling it up inside of not just an arbitrary chunk of memory,

1591
01:21:18,840 --> 01:21:23,920
but something you can call a student object.

1592
01:21:23,920 --> 01:21:26,760
And all that means that now for our students,

1593
01:21:26,760 --> 01:21:30,400
we can just go ahead and append that student to the list.

1594
01:21:30,400 --> 01:21:36,440
So now, if later, I want to iterate over for student in students,

1595
01:21:36,440 --> 01:21:38,480
I can go ahead and print out, for instance,

1596
01:21:38,480 --> 01:21:47,080
that student.name lives in student.dorm, close quote.

1597
01:21:47,080 --> 01:21:52,280
And if now over here, oops, close that, and now over here,

1598
01:21:52,280 --> 01:21:56,480
if I go ahead and run Python on struct0.py.

1599
01:21:56,480 --> 01:21:59,480
Oh, no.

1600
01:21:59,480 --> 01:22:01,880
Oh, thank you.

1601
01:22:01,880 --> 01:22:03,200
That goes there.

1602
01:22:03,200 --> 01:22:04,480
So now, damn it.

1603
01:22:07,400 --> 01:22:08,200
Missing curly.

1604
01:22:08,200 --> 01:22:08,760
Oh, thank you.

1605
01:22:11,520 --> 01:22:15,560
OK, so now if I want to go ahead and type Maria and Cabot and David and

1606
01:22:15,560 --> 01:22:20,800
Mather and Rob and say Kirkland, now we get all three of those names.

1607
01:22:20,800 --> 01:22:25,080
And there's other ways, too, if we want to actually store this thing on disk.

1608
01:22:25,080 --> 01:22:27,440
But I'll defer that to an example online.

1609
01:22:27,440 --> 01:22:31,720
Let's look at one final example that will hopefully either make you regret

1610
01:22:31,720 --> 01:22:35,640
the past several weeks or embrace the next several instead.

1611
01:22:35,640 --> 01:22:40,560
So you'll recall that, though the former I suppose could be true,

1612
01:22:40,560 --> 01:22:45,280
even without my help, so if I go into now, today's distribution code,

1613
01:22:45,280 --> 01:22:46,320
you will see this program.

1614
01:22:46,320 --> 01:22:48,200
And we won't walk through all of its lines,

1615
01:22:48,240 --> 01:22:51,400
but this is a program written in Python called Speller.

1616
01:22:51,400 --> 01:22:54,840
And what I did was literally sit down with Speller.c from problem set

1617
01:22:54,840 --> 01:22:58,840
5, and I just converted it from left to right from c to Python,

1618
01:22:58,840 --> 01:23:03,280
implementing it in Python in as close to an identical way as I could,

1619
01:23:03,280 --> 01:23:05,200
just using features of Python.

1620
01:23:05,200 --> 01:23:08,440
So just skimming this, you'll see that apparently my implementation

1621
01:23:08,440 --> 01:23:12,480
of Speller in Python has a class called dictionary, which is very similar in spirit

1622
01:23:12,480 --> 01:23:14,360
to dictionary.h and c.

1623
01:23:14,360 --> 01:23:17,400
Notice that I still have a constant here, or it's not technically a constant,

1624
01:23:17,400 --> 01:23:21,120
but a variable called length equals 45, like hardcoded in dictionary

1625
01:23:21,120 --> 01:23:23,520
slash large as Speller.c did too.

1626
01:23:23,520 --> 01:23:26,200
I'm using command line arguments as we saw earlier,

1627
01:23:26,200 --> 01:23:28,720
but this time in Python instead of c.

1628
01:23:28,720 --> 01:23:31,200
Notice you can do funky things like this, which

1629
01:23:31,200 --> 01:23:33,920
is reminiscent of our swap trick just a little bit ago.

1630
01:23:33,920 --> 01:23:36,960
If you want to declare multiple variables all on the same line

1631
01:23:36,960 --> 01:23:40,200
and initialize them, you can just enumerate them all with commas.

1632
01:23:40,200 --> 01:23:42,320
Then on the other side of the equal sign,

1633
01:23:42,320 --> 01:23:46,280
enumerate with commas the values that you want to assign to those variables.

1634
01:23:46,280 --> 01:23:49,400
And then down here, if I keep scrolling, you'll

1635
01:23:49,400 --> 01:23:52,960
see code that we won't get into the weeds of, but some familiar phrases.

1636
01:23:52,960 --> 01:23:58,360
So this is the program that actually runs a student's dictionary on some input,

1637
01:23:58,360 --> 01:24:03,760
and then prints out per all this stuff at the bottom all of the familiar phrases

1638
01:24:03,760 --> 01:24:06,040
that you might recall from problem set five.

1639
01:24:06,040 --> 01:24:08,760
So this took a lot of work, most likely, to implement in c.

1640
01:24:08,760 --> 01:24:11,360
And understandably, you might have used a linked list initially,

1641
01:24:11,360 --> 01:24:13,760
or ultimately, you might have used a hash table, or a try,

1642
01:24:13,760 --> 01:24:15,800
or struggled with something in between those two.

1643
01:24:15,800 --> 01:24:18,240
And that is a function of c.

1644
01:24:18,240 --> 01:24:19,280
C is difficult.

1645
01:24:19,280 --> 01:24:21,920
C is challenging, because you have to do everything yourself.

1646
01:24:21,920 --> 01:24:23,760
And upside, though, of it is that you end up

1647
01:24:23,760 --> 01:24:26,720
getting a lot of great performance, theoretically.

1648
01:24:26,720 --> 01:24:28,640
Like, once you have implemented the code,

1649
01:24:28,640 --> 01:24:30,760
you're kind of as close to the hardware as possible.

1650
01:24:30,760 --> 01:24:33,920
And so your code runs pretty darn well, and is dependent only then

1651
01:24:33,920 --> 01:24:37,440
on your algorithms, not on your choice of language.

1652
01:24:37,440 --> 01:24:40,960
So here, let me go ahead and implement a file called dictionary.py.

1653
01:24:41,000 --> 01:24:48,960
And let me propose that the words, the equivalent, sorry, of dictionary.h

1654
01:24:48,960 --> 01:24:50,400
would be this file here.

1655
01:24:50,400 --> 01:24:54,400
And it's going to have a key word, a function called check,

1656
01:24:54,400 --> 01:24:57,040
which takes an argument called word.

1657
01:24:57,040 --> 01:25:01,480
It's going to have a function called load, which takes in an argument called

1658
01:25:01,480 --> 01:25:02,480
dictionary.

1659
01:25:02,480 --> 01:25:09,600
It's going to have a method called size, which takes in no arguments other

1660
01:25:09,600 --> 01:25:10,680
than itself.

1661
01:25:10,680 --> 01:25:13,320
And then it's going to have a method called unload, which also takes

1662
01:25:13,320 --> 01:25:14,960
no arguments other than itself.

1663
01:25:14,960 --> 01:25:18,240
So if we were instead to have assigned problems at 5 in Python,

1664
01:25:18,240 --> 01:25:21,040
we essentially would have given you a file called dictionary.py

1665
01:25:21,040 --> 01:25:22,400
with these placeholders for you.

1666
01:25:22,400 --> 01:25:25,240
Because recall, in pset5, those were all to dos.

1667
01:25:25,240 --> 01:25:27,680
Strictly speaking, there would be one other here.

1668
01:25:27,680 --> 01:25:31,240
We would probably have a def init, because every class in Python

1669
01:25:31,240 --> 01:25:34,360
we'll see will typically have this init method, where we just

1670
01:25:34,360 --> 01:25:38,400
are able to do something to initialize the data structure.

1671
01:25:38,400 --> 01:25:39,720
So let me go ahead and do this.

1672
01:25:39,720 --> 01:25:41,760
We don't know that much Python yet, and we're

1673
01:25:41,760 --> 01:25:44,360
taking for granted that Speller, in fact, works.

1674
01:25:44,360 --> 01:25:46,840
But let me go ahead and load some words in a dictionary.

1675
01:25:46,840 --> 01:25:49,120
So here is my method called load.

1676
01:25:49,120 --> 01:25:51,360
Dictionary is going to be the name of the dictionary to load.

1677
01:25:51,360 --> 01:25:55,840
So you guys implemented this yourself by loading those files from disk.

1678
01:25:55,840 --> 01:25:58,120
In Python, I'm going to do this as follows.

1679
01:25:58,120 --> 01:26:02,080
Give me a file and open it in read mode.

1680
01:26:02,080 --> 01:26:05,800
I'll iterate over each line in the file.

1681
01:26:05,800 --> 01:26:12,000
Then go ahead and add to my set called words the result of that line

1682
01:26:12,000 --> 01:26:16,240
by stripping off the end of it, backslash 0.

1683
01:26:16,240 --> 01:26:20,960
Then go ahead and close the file, and then return true,

1684
01:26:20,960 --> 01:26:23,320
because I'm done implementing load.

1685
01:26:23,320 --> 01:26:27,800
So that is the load method in Python.

1686
01:26:27,800 --> 01:26:28,480
Happy, yes.

1687
01:26:28,480 --> 01:26:29,760
OK, so check.

1688
01:26:29,760 --> 01:26:31,160
Check was a struggle too, right?

1689
01:26:31,160 --> 01:26:33,560
Because once you had your hash table, or once you had your try,

1690
01:26:33,560 --> 01:26:35,840
now you had to actually navigate that structure in memory,

1691
01:26:35,840 --> 01:26:38,760
maybe recursively, maybe iteratively, following lots of pointers and the

1692
01:26:38,760 --> 01:26:40,240
like, following a linked list.

1693
01:26:40,240 --> 01:26:51,720
How about I just do, let's just say, if word lowercase in self.words,

1694
01:26:51,720 --> 01:26:59,320
return true, else return false, done.

1695
01:26:59,320 --> 01:27:01,200
So that one's done.

1696
01:27:01,200 --> 01:27:04,160
On size, we actually can kind of infer how to do this,

1697
01:27:04,160 --> 01:27:06,600
return the length of the words.

1698
01:27:06,600 --> 01:27:07,600
That's done.

1699
01:27:07,600 --> 01:27:11,400
Unload, don't have to worry about memory in Python, so that's done.

1700
01:27:11,400 --> 01:27:14,840
And there you have problem set five.

1701
01:27:14,840 --> 01:27:16,320
Thank you.

1702
01:27:16,320 --> 01:27:18,960
So what then are the takeaways?

1703
01:27:18,960 --> 01:27:21,400
Either great elation that you now have this power,

1704
01:27:21,400 --> 01:27:24,040
or great sadness that you had to implement this first and see,

1705
01:27:24,040 --> 01:27:26,440
but this was really ultimately meant to be thematic.

1706
01:27:26,440 --> 01:27:29,040
Like hopefully moving forward, even if you struggled with any number

1707
01:27:29,080 --> 01:27:31,720
of these topics, linked list, and hash tables, and pointers, and the like,

1708
01:27:31,720 --> 01:27:34,680
like hopefully you have a general understanding of some of these fundamentals

1709
01:27:34,680 --> 01:27:36,880
and what computers are doing underneath the hood.

1710
01:27:36,880 --> 01:27:40,760
And now with languages like Python, and soon with JavaScript and SQL,

1711
01:27:40,760 --> 01:27:44,080
with a little bit of HTML and CSS mixed in for our user interfaces,

1712
01:27:44,080 --> 01:27:46,840
do you have the ability to now solve problems taking for granted

1713
01:27:46,840 --> 01:27:49,040
both your understanding of those topics

1714
01:27:49,040 --> 01:27:53,080
and the reality that someone else has now implemented those concepts for you

1715
01:27:53,080 --> 01:27:55,880
so that when it comes to solving problems that's six and seven and eight,

1716
01:27:55,880 --> 01:27:58,640
and then leaving CS50 and solving problems in your own domain,

1717
01:27:58,640 --> 01:28:00,920
you have so many more tools in your toolkit.

1718
01:28:00,920 --> 01:28:03,200
And the goal really for you is going to be

1719
01:28:03,200 --> 01:28:05,720
to pick whichever one is most appropriate.

1720
01:28:05,720 --> 01:28:06,760
So let's adjourn here.

1721
01:28:06,760 --> 01:28:09,080
I'll stick around for questions, and we'll see you next time.

1722
01:28:09,080 --> 01:28:11,480
Best of luck on the test.

