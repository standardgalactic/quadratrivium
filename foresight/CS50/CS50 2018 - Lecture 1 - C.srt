1
00:00:00,000 --> 00:00:23,820
Music

2
00:00:23,820 --> 00:00:53,740
All right, this is CS50.

3
00:00:53,740 --> 00:00:55,300
And this is week one.

4
00:00:55,300 --> 00:01:00,020
And by the end of today, you will know how to create programs that

5
00:01:00,020 --> 00:01:01,340
look like this.

6
00:01:01,340 --> 00:01:02,540
So this, of course, is binary.

7
00:01:02,540 --> 00:01:05,300
This is the only language that machines ultimately understand.

8
00:01:05,300 --> 00:01:08,540
But thankfully, per last week, there's so many abstractions

9
00:01:08,540 --> 00:01:10,500
and there's so many humans that have come before us

10
00:01:10,500 --> 00:01:12,700
that we don't actually have to write anything at this level.

11
00:01:12,700 --> 00:01:15,540
We can abstract way above it, like we did with Scratch already,

12
00:01:15,540 --> 00:01:19,340
and like we will starting today with C. But does anyone nonetheless

13
00:01:19,340 --> 00:01:24,700
want to take a guess at what that program, when fed to your Mac or PC,

14
00:01:24,700 --> 00:01:27,060
actually does?

15
00:01:27,060 --> 00:01:30,180
Anyone recognize?

16
00:01:30,180 --> 00:01:32,060
Anyone want to hazard a guess?

17
00:01:32,060 --> 00:01:34,820
It's perhaps the simplest program you could write.

18
00:01:34,820 --> 00:01:39,100
It indeed does, when fed to the brain of your computer,

19
00:01:39,100 --> 00:01:42,100
this is all called CPU, simply print that.

20
00:01:42,100 --> 00:01:44,020
So how do we actually get to that point?

21
00:01:44,020 --> 00:01:46,340
Well, recall where we started this conversation last time,

22
00:01:46,340 --> 00:01:49,140
talking about computer science more generally, and problem solving.

23
00:01:49,140 --> 00:01:52,260
We propose can be distilled really is this, like you've got some inputs,

24
00:01:52,260 --> 00:01:54,140
you want some outputs, and somewhere in the middle

25
00:01:54,140 --> 00:01:56,500
you need to do something with those inputs.

26
00:01:56,500 --> 00:02:00,660
And to get to that point, though, we had to represent those inputs and outputs.

27
00:02:00,660 --> 00:02:03,020
We just had to decide as sort of humans, how

28
00:02:03,020 --> 00:02:05,380
are we going to represent all the inputs to our problem

29
00:02:05,380 --> 00:02:07,980
when it comes time to have a computer actually process them?

30
00:02:07,980 --> 00:02:11,660
And at the end of the day, all of the phones and the computers that we're all using,

31
00:02:11,660 --> 00:02:13,660
only end at the end of the day plug into the wall

32
00:02:13,660 --> 00:02:15,900
to get their physical resource, electricity,

33
00:02:15,900 --> 00:02:18,180
and they might store that temporarily in a battery.

34
00:02:18,220 --> 00:02:19,700
But that really is our only input.

35
00:02:19,700 --> 00:02:22,140
It's either plugged in or it's not.

36
00:02:22,140 --> 00:02:24,820
It's either a one or a zero, true or false.

37
00:02:24,820 --> 00:02:28,100
So the world really reduces to those two states, so to speak.

38
00:02:28,100 --> 00:02:30,020
And so you can think of those states, then.

39
00:02:30,020 --> 00:02:31,780
It's just being like a light bulb, on or off.

40
00:02:31,780 --> 00:02:35,020
Or I pulled up my cell phone last time to turn the flashlight on or off,

41
00:02:35,020 --> 00:02:37,300
one or zero, true or false.

42
00:02:37,300 --> 00:02:39,580
Now, of course, if you only have one light bulb,

43
00:02:39,580 --> 00:02:41,940
you can only count from zero to one.

44
00:02:41,940 --> 00:02:44,820
But if you start to have a bunch of them back to back to back to back,

45
00:02:44,820 --> 00:02:47,300
you can permute them like I did my fingers.

46
00:02:47,300 --> 00:02:51,020
Zero, one, two, three, and so forth.

47
00:02:51,020 --> 00:02:54,140
And so we started talking about binary more generally.

48
00:02:54,140 --> 00:02:59,220
And so here, for instance, were three sequences of zeros and ones.

49
00:02:59,220 --> 00:03:01,420
And each of those represented something.

50
00:03:01,420 --> 00:03:03,900
But we don't need to think about the world at that level.

51
00:03:03,900 --> 00:03:05,180
We can abstract on top of that.

52
00:03:05,180 --> 00:03:07,780
All of us are so much more familiar with decimal, of course.

53
00:03:07,780 --> 00:03:11,220
And indeed, recall that this was just 72, 73, and 33,

54
00:03:11,220 --> 00:03:14,220
which, if anyone recalls, when you use ASCII, which

55
00:03:14,220 --> 00:03:16,620
is this global standard for mapping numbers to letters,

56
00:03:16,620 --> 00:03:18,380
we got what message?

57
00:03:18,380 --> 00:03:22,020
Yeah, it was just high, capital H, capital I, exclamation point.

58
00:03:22,020 --> 00:03:26,380
And so that's an abstraction on top of those otherwise binary numbers.

59
00:03:26,380 --> 00:03:29,540
But we don't have to model just text using numbers.

60
00:03:29,540 --> 00:03:32,540
At the end of the day, our only resource is still that electricity.

61
00:03:32,540 --> 00:03:35,300
And the only way we think about it digitally is still zeros and ones.

62
00:03:35,300 --> 00:03:39,140
But if we take these same values, 72, 73, 33,

63
00:03:39,140 --> 00:03:42,900
and treat them in the context of like Photoshop or like a photo program

64
00:03:42,900 --> 00:03:45,020
or a graphics program, we can instead interpret them

65
00:03:45,020 --> 00:03:48,100
as like some amount of red, some amount of green, some amount of blue,

66
00:03:48,100 --> 00:03:50,780
which gave us, last time, recall this yellowish color.

67
00:03:50,780 --> 00:03:54,380
So now we had another abstraction on top of binary colors.

68
00:03:54,380 --> 00:03:55,780
And this is just one pixel.

69
00:03:55,780 --> 00:03:57,780
What can you do once you have more than one pixel?

70
00:03:57,780 --> 00:04:00,660
What can you represent next?

71
00:04:00,660 --> 00:04:01,980
Yeah, right, images, right?

72
00:04:01,980 --> 00:04:04,260
So we're sort of continuing the conversation up and up and up.

73
00:04:04,260 --> 00:04:06,940
And we could represent something like a graphical emoji on the screen,

74
00:04:06,940 --> 00:04:08,620
which has more than just one yellow dot.

75
00:04:08,620 --> 00:04:11,500
It's got a whole bunch of yellow dots and other colors as well.

76
00:04:11,500 --> 00:04:13,940
And recall that if we want to animate things,

77
00:04:13,940 --> 00:04:16,420
whether it's through silly things like an emojis on a phone

78
00:04:16,420 --> 00:04:19,060
or just more proper videos and movies, well, those

79
00:04:19,060 --> 00:04:24,140
are just sequences of images flying past your human eyes really quite quickly.

80
00:04:24,140 --> 00:04:27,220
So that's where we kind of left off last time, starting at the base level

81
00:04:27,220 --> 00:04:30,340
and abstracting away so that we could sort of stipulate thereafter.

82
00:04:30,340 --> 00:04:35,340
We can represent inputs and we can represent outputs, whatever those happen to be.

83
00:04:35,340 --> 00:04:37,340
And here on out, we don't need to think at that level.

84
00:04:37,340 --> 00:04:39,660
We can just assume we all know how to do this.

85
00:04:39,660 --> 00:04:42,580
And even if it eventually becomes kind of a distant memory,

86
00:04:42,580 --> 00:04:44,580
we know that someone can indeed do this.

87
00:04:44,580 --> 00:04:46,780
And that's the value of abstraction.

88
00:04:46,780 --> 00:04:50,260
But inside of this black box, we're so-called algorithms, the sort of secret

89
00:04:50,260 --> 00:04:53,260
sauce, this is where the problems are actually solved.

90
00:04:53,260 --> 00:04:57,060
And we not only talked about what these algorithms are,

91
00:04:57,060 --> 00:04:59,220
but for instance, how efficient they were.

92
00:04:59,220 --> 00:05:02,700
So recall that this red line represented a very simple algorithm

93
00:05:02,700 --> 00:05:05,420
of just turning the phone book page by page one at a time.

94
00:05:05,420 --> 00:05:07,940
And the reason that it's a straight line is because there's like a one

95
00:05:07,940 --> 00:05:11,060
to one correspondence between how many pages there are in the book

96
00:05:11,060 --> 00:05:12,420
and how many page turns there are.

97
00:05:12,900 --> 00:05:15,140
One more page, one more turn, and so forth.

98
00:05:15,140 --> 00:05:20,180
If I fly through it at twice the speed, two, four, six, eight, I can do better.

99
00:05:20,180 --> 00:05:24,060
And so that yellow line now, recall, was lower on the graph.

100
00:05:24,060 --> 00:05:26,460
If you just kind of look at any two points, yellow and red,

101
00:05:26,460 --> 00:05:29,020
yellow is below red, saying it takes less time.

102
00:05:29,020 --> 00:05:30,860
But it was not quite correct.

103
00:05:30,860 --> 00:05:35,100
There was one bug when I was looking for Mike two pages at a time.

104
00:05:35,100 --> 00:05:37,260
What was that issue?

105
00:05:37,260 --> 00:05:38,140
Yeah, I might miss him.

106
00:05:38,140 --> 00:05:40,580
He might accidentally get sandwiched in between two pages.

107
00:05:40,580 --> 00:05:43,620
It's not a huge deal because I could fix it, but I have to fix it.

108
00:05:43,620 --> 00:05:47,300
I have to apply that additional logic and double back at least a page if I go too fast.

109
00:05:47,300 --> 00:05:50,100
But of course, the sort of final algorithm, and frankly,

110
00:05:50,100 --> 00:05:53,660
all of our initial intuition probably, was the dividing and conquer.

111
00:05:53,660 --> 00:05:56,980
Open it roughly to the middle, look down, and then go left and go right.

112
00:05:56,980 --> 00:05:59,940
And just repeat that process as the problem gets this big, to this big,

113
00:05:59,940 --> 00:06:02,300
to this big, to this big, to just one page left.

114
00:06:02,300 --> 00:06:05,100
So that was all about efficiency.

115
00:06:05,100 --> 00:06:08,540
But to get to that point, we needed to express ourselves more precisely.

116
00:06:08,540 --> 00:06:09,900
And so we introduced pseudocode.

117
00:06:09,900 --> 00:06:11,420
There's no formal definition.

118
00:06:11,420 --> 00:06:12,740
It can be English, English-like.

119
00:06:12,740 --> 00:06:15,220
It's just meant to be succinct and get the point across.

120
00:06:15,220 --> 00:06:18,540
And recall that along the way, we introduced a whole bunch of concepts,

121
00:06:18,540 --> 00:06:20,780
many of which you probably experimented with with Scratch,

122
00:06:20,780 --> 00:06:26,420
like loops and conditions, Boolean expressions, variables, and so forth.

123
00:06:26,420 --> 00:06:31,060
And those were building blocks that kind of came out of this kind of demonstration here.

124
00:06:31,060 --> 00:06:34,260
But honestly, even in this demonstration, in this pseudocode,

125
00:06:34,260 --> 00:06:36,260
there were a whole bunch of assumptions.

126
00:06:36,260 --> 00:06:38,060
If you read these instructions one at a time

127
00:06:38,060 --> 00:06:39,700
and you're holding the phone book yourself,

128
00:06:39,700 --> 00:06:42,980
odds are you can execute the pseudocode, this algorithm.

129
00:06:42,980 --> 00:06:48,660
But what does it really mean to, say, open to the middle of the phone book?

130
00:06:48,660 --> 00:06:51,380
All of us have an intuitive understanding of what that means.

131
00:06:51,380 --> 00:06:54,140
But honestly, if you were sort of explaining that to a kid or someone

132
00:06:54,140 --> 00:06:56,660
who's learning English or whatever language for the first time,

133
00:06:56,660 --> 00:06:58,820
open to the middle of the phone book, you should probably

134
00:06:58,820 --> 00:07:00,300
set forth some assumptions.

135
00:07:00,300 --> 00:07:04,060
OK, this thing in front of you has 1,000 pages, pieces of paper,

136
00:07:04,060 --> 00:07:05,940
turned to the 500th page.

137
00:07:05,940 --> 00:07:07,740
And let's call that the middle.

138
00:07:07,740 --> 00:07:10,420
This would very quickly get tedious if all of us humans

139
00:07:10,420 --> 00:07:12,100
are talking at that level of detail.

140
00:07:12,100 --> 00:07:14,740
And so we abstract away with more sweeping statements,

141
00:07:14,740 --> 00:07:16,420
like open to the middle of the phone book.

142
00:07:16,420 --> 00:07:18,100
But that's an abstraction.

143
00:07:18,100 --> 00:07:21,380
And it's not quite as precise as is probably ideal, especially feeding

144
00:07:21,380 --> 00:07:24,740
this algorithm to a newbie or to a robot or a computer.

145
00:07:24,740 --> 00:07:27,980
But it's useful because we can then make a 12-step program instead

146
00:07:27,980 --> 00:07:30,700
of a 20-step program by elaborating too much.

147
00:07:30,700 --> 00:07:33,620
And for instance, throughout here, too, we had our loops and conditions

148
00:07:33,620 --> 00:07:35,580
and so forth, but even call mic.

149
00:07:35,580 --> 00:07:36,740
Like, what does that mean?

150
00:07:36,740 --> 00:07:39,380
Well, if you imagine that the human knows how to use the phone,

151
00:07:39,380 --> 00:07:40,580
then it goes without saying.

152
00:07:40,580 --> 00:07:43,420
But if he or she also needs to be programmed to use the phone,

153
00:07:43,420 --> 00:07:45,700
you've got to explain, pick it up, hit this button,

154
00:07:45,700 --> 00:07:47,740
type this sequence of buttons, and so forth.

155
00:07:47,740 --> 00:07:50,780
So call mic is also an abstraction.

156
00:07:50,780 --> 00:07:55,620
So these abstractions are useful, but they can sometimes get in the way,

157
00:07:55,620 --> 00:08:01,700
especially if you're not precise enough to program the computer correctly.

158
00:08:01,700 --> 00:08:04,100
And to sort of paint this picture, thought

159
00:08:04,100 --> 00:08:07,100
we'd begin a little lightheartedly here.

160
00:08:07,100 --> 00:08:10,860
Brought some breakfast if you didn't quite make it next door or beyond.

161
00:08:10,860 --> 00:08:12,300
Just need a couple of volunteers.

162
00:08:12,300 --> 00:08:15,140
If you're comfy appearing on stage and on the internet here.

163
00:08:15,140 --> 00:08:17,020
Let me kind of, there's a lot of lights here.

164
00:08:17,020 --> 00:08:20,820
How about over there on the left and over here in the front?

165
00:08:20,820 --> 00:08:21,500
Yeah, right there.

166
00:08:21,500 --> 00:08:22,500
I think your hand was up.

167
00:08:22,500 --> 00:08:24,500
Come on down.

168
00:08:24,500 --> 00:08:27,340
And Brian, do you mind lending us a hand here, too?

169
00:08:27,340 --> 00:08:29,460
Come on down.

170
00:08:29,460 --> 00:08:29,960
Thank you.

171
00:08:29,960 --> 00:08:32,900
If you want to take control here, let me go ahead and switch over

172
00:08:32,900 --> 00:08:36,260
to another program for you.

173
00:08:36,260 --> 00:08:36,980
OK, what's your name?

174
00:08:36,980 --> 00:08:37,380
Gene.

175
00:08:37,380 --> 00:08:37,980
Gene, David.

176
00:08:37,980 --> 00:08:38,420
Nice to meet you.

177
00:08:38,420 --> 00:08:40,260
Have a seat on the far left in your name.

178
00:08:40,260 --> 00:08:40,900
Hi, I'm Abby.

179
00:08:40,900 --> 00:08:42,140
Abby, nice to meet you as well.

180
00:08:42,140 --> 00:08:43,420
On the far right, if you could.

181
00:08:43,420 --> 00:08:46,900
So Gene and Abby, do you want to say a little something about yourselves

182
00:08:46,900 --> 00:08:48,620
quickly?

183
00:08:48,620 --> 00:08:49,340
I'm Gene.

184
00:08:49,340 --> 00:08:51,420
I'm a Massachusetts native.

185
00:08:51,420 --> 00:08:53,340
And I'm taking CS for the first time.

186
00:08:53,340 --> 00:08:54,820
It's my first time coding or anything.

187
00:08:54,820 --> 00:08:56,940
So I'm doing this, and I'm enjoying it.

188
00:08:56,940 --> 00:08:57,300
Nice.

189
00:08:57,300 --> 00:08:58,580
Glad to have you with us.

190
00:08:58,580 --> 00:09:00,060
Abby?

191
00:09:00,060 --> 00:09:00,820
Hi, I'm Abby.

192
00:09:00,820 --> 00:09:02,300
I'm taking this as a sophomore.

193
00:09:02,300 --> 00:09:04,940
And I know nothing about computers and computer science.

194
00:09:04,940 --> 00:09:06,980
So I'm probably taking it sat on sat.

195
00:09:06,980 --> 00:09:08,620
OK, well, nice to have you as well.

196
00:09:08,620 --> 00:09:11,500
All right, so in front of us is a whole bunch of ingredients.

197
00:09:11,500 --> 00:09:13,460
And hopefully, we can start the semester off gently.

198
00:09:13,460 --> 00:09:16,260
And if we're successful, we'll actually have a quick bite here.

199
00:09:16,260 --> 00:09:17,980
But we thought we'd defer to the audience here.

200
00:09:17,980 --> 00:09:19,540
And Brian's going to scribe as we go.

201
00:09:19,540 --> 00:09:21,500
And all we want to do this morning is just

202
00:09:21,500 --> 00:09:23,980
make a peanut butter and jelly sandwich.

203
00:09:23,980 --> 00:09:27,580
One instruction at a time, and each of us will just execute what we hear.

204
00:09:27,580 --> 00:09:28,620
How's that sound?

205
00:09:28,620 --> 00:09:30,980
All right, if someone could volunteer with the first instruction.

206
00:09:30,980 --> 00:09:31,980
And Brian, I'll type it down.

207
00:09:36,860 --> 00:09:37,900
Open bread, we heard.

208
00:09:37,900 --> 00:09:39,300
Open bread is the first instruction.

209
00:09:39,300 --> 00:09:41,100
So if you'd like to execute, open bread.

210
00:09:47,380 --> 00:09:49,940
Don't look at me.

211
00:09:49,940 --> 00:09:51,260
OK.

212
00:09:51,260 --> 00:09:53,380
All right, so we're kind of on our way.

213
00:09:54,380 --> 00:09:59,420
OK, I think Abby did it better, certainly.

214
00:09:59,420 --> 00:10:01,500
But we did it correctly, arguably.

215
00:10:01,500 --> 00:10:05,580
So let's move on to step two and see if we can't improve.

216
00:10:05,580 --> 00:10:06,620
Take out bread.

217
00:10:11,540 --> 00:10:15,180
OK, welcome to the team now.

218
00:10:15,180 --> 00:10:17,740
Nice, all right, step three.

219
00:10:17,740 --> 00:10:18,740
Yeah.

220
00:10:18,740 --> 00:10:20,580
Place two pieces of bread on the table.

221
00:10:20,620 --> 00:10:22,860
Place two pieces of bread on the table.

222
00:10:26,860 --> 00:10:28,700
Never mind the plates.

223
00:10:28,700 --> 00:10:30,060
OK, step four.

224
00:10:34,820 --> 00:10:37,180
Twist cover of jelly till it opens.

225
00:10:37,180 --> 00:10:37,660
Thank you.

226
00:10:42,540 --> 00:10:43,260
Step five.

227
00:10:46,060 --> 00:10:49,180
Step five, yeah.

228
00:10:49,180 --> 00:10:51,780
Thank you, place the lid to the side.

229
00:10:51,780 --> 00:10:53,180
I took some liberties myself.

230
00:10:53,180 --> 00:10:54,980
Step six, take the knife.

231
00:11:01,740 --> 00:11:03,460
Peel off the cover of the jelly.

232
00:11:06,740 --> 00:11:07,660
No covers on ours.

233
00:11:12,140 --> 00:11:17,420
Stick knife into the bottle.

234
00:11:17,420 --> 00:11:19,100
From the top.

235
00:11:19,100 --> 00:11:19,600
Stick.

236
00:11:22,700 --> 00:11:24,660
OK, step nine.

237
00:11:28,380 --> 00:11:32,420
Rotate hands, so jelly ends up on.

238
00:11:32,420 --> 00:11:32,920
OK.

239
00:11:36,260 --> 00:11:39,260
OK, step quickly, 10.

240
00:11:42,660 --> 00:11:45,180
Yeah, step 10.

241
00:11:45,180 --> 00:11:46,180
Pull out the knife.

242
00:11:46,180 --> 00:11:47,940
Pull out knife, OK.

243
00:11:49,820 --> 00:11:56,260
Step 11, jelly side down on bread.

244
00:12:02,380 --> 00:12:04,860
All right, step 12.

245
00:12:09,660 --> 00:12:11,020
Step 12, anyone?

246
00:12:11,020 --> 00:12:12,700
Yes.

247
00:12:12,700 --> 00:12:15,180
Thank you.

248
00:12:15,180 --> 00:12:16,500
Step 13.

249
00:12:17,500 --> 00:12:20,500
Pour jelly on bread.

250
00:12:24,500 --> 00:12:25,740
Oh, pour jelly on bread.

251
00:12:25,740 --> 00:12:28,220
Pour jelly, jelly.

252
00:12:28,220 --> 00:12:28,900
All of it?

253
00:12:28,900 --> 00:12:30,340
OK, now you're just messing with us.

254
00:12:35,740 --> 00:12:37,220
Step 14.

255
00:12:40,620 --> 00:12:42,820
Put jelly down, thank you.

256
00:12:42,820 --> 00:12:45,300
15.

257
00:12:45,340 --> 00:12:48,460
Pick up peanut butter.

258
00:12:48,460 --> 00:12:49,700
Take lid off, thank you.

259
00:12:53,100 --> 00:12:55,380
Peel off lid, thank you.

260
00:12:57,900 --> 00:13:01,340
Step 18, pick up knife.

261
00:13:04,820 --> 00:13:08,060
By blunt end.

262
00:13:08,060 --> 00:13:09,780
Scoop, it's OK.

263
00:13:10,380 --> 00:13:11,380
Scoop.

264
00:13:11,380 --> 00:13:16,900
Step 20, put peanut butter on bread.

265
00:13:20,900 --> 00:13:22,540
21.

266
00:13:24,540 --> 00:13:28,060
Move the knife left to right, please.

267
00:13:28,060 --> 00:13:29,500
Left to right.

268
00:13:34,500 --> 00:13:38,180
Step 22, put peanut butter on bread.

269
00:13:38,620 --> 00:13:44,500
Step 22, thank you.

270
00:13:44,500 --> 00:13:49,980
23, 24, what was that?

271
00:13:54,460 --> 00:13:57,300
Eat sandwich, OK, I think we're OK.

272
00:13:57,300 --> 00:13:59,100
Well, how about why don't we each take a bite

273
00:13:59,100 --> 00:14:01,500
and a round of applause if we could for our volunteers.

274
00:14:01,500 --> 00:14:07,500
Thank you.

275
00:14:11,500 --> 00:14:14,980
You can take some for the row if you'd like.

276
00:14:14,980 --> 00:14:18,260
Thank you, so thank you, Brian.

277
00:14:18,260 --> 00:14:19,540
OK, now I need a minute.

278
00:14:19,540 --> 00:14:22,940
So thank you.

279
00:14:22,940 --> 00:14:28,900
So suffice it to say, this obviously demonstrated even more so

280
00:14:28,900 --> 00:14:32,260
than the phone book example where our certain assumptions are

281
00:14:32,260 --> 00:14:33,940
and our abstractions are.

282
00:14:33,940 --> 00:14:35,940
And honestly, almost all the time, those are useful.

283
00:14:35,940 --> 00:14:37,420
And of course, we kind of ham things up.

284
00:14:37,420 --> 00:14:40,100
And I think the instructions, we're kind of helping with that here.

285
00:14:40,100 --> 00:14:44,060
But when it comes time to program with Scratch and certainly with C starting

286
00:14:44,060 --> 00:14:47,340
this week, you can't really make as many of those assumptions anymore.

287
00:14:47,340 --> 00:14:49,700
Because if you don't handle these sort of corner cases,

288
00:14:49,700 --> 00:14:52,300
and if you don't think about what that instruction means,

289
00:14:52,300 --> 00:14:54,820
you're going to get the proverbial spinning beach ball or the hour

290
00:14:54,820 --> 00:14:56,540
glass that you're familiar with on your Mac or PC.

291
00:14:56,540 --> 00:14:57,940
The program is going to crash.

292
00:14:57,940 --> 00:15:02,180
Something's going to go wrong just because you missed some specificity

293
00:15:02,180 --> 00:15:03,460
or precision.

294
00:15:03,460 --> 00:15:09,460
Now, over, so over time, we're going to find that much like in Scratch,

295
00:15:09,460 --> 00:15:11,460
we were able to make our own building blocks.

296
00:15:11,460 --> 00:15:14,900
You might recall the short examples we did with the cough example, where

297
00:15:14,900 --> 00:15:17,300
I had cough 0 and then cough 1 and cough 2,

298
00:15:17,300 --> 00:15:20,260
where I was making my own puzzle piece within Scratch.

299
00:15:20,260 --> 00:15:23,420
That was useful because after that example, theoretically, I never again

300
00:15:23,420 --> 00:15:26,940
need to think about or worry about how to implement cough.

301
00:15:26,940 --> 00:15:28,460
I can just use that abstraction.

302
00:15:28,460 --> 00:15:30,860
But someone has to implement them, and sometimes it's

303
00:15:30,860 --> 00:15:34,180
going to be other people who come before us, and sometimes it's going to be us.

304
00:15:34,180 --> 00:15:37,020
So this isn't to say that programming ends up being so tedious

305
00:15:37,020 --> 00:15:39,060
that you have to point out every little thing,

306
00:15:39,060 --> 00:15:43,420
but you or someone does have to do that level of precision at least once.

307
00:15:43,420 --> 00:15:47,500
And nicely enough, in Scratch, MIT did most of that legwork for you.

308
00:15:47,500 --> 00:15:49,180
We all had the building blocks with which

309
00:15:49,180 --> 00:15:51,740
to make our own animation or game or artwork or the like.

310
00:15:51,740 --> 00:15:54,900
But even then, you probably had to connect several dozen puzzle pieces

311
00:15:54,900 --> 00:15:59,980
or even more to get those fundamentals to do what it is that you wanted it to do.

312
00:15:59,980 --> 00:16:02,420
So today, we're going to start to transition from Scratch,

313
00:16:02,420 --> 00:16:05,700
this graphical programming language that, while targeted at younger students,

314
00:16:05,700 --> 00:16:08,940
is typically representative of a lot of the same concepts that are now

315
00:16:08,940 --> 00:16:10,980
going to be laced throughout the semester.

316
00:16:10,980 --> 00:16:14,540
But we're going to introduce today an older, more traditional language that's

317
00:16:14,540 --> 00:16:15,460
just text-based.

318
00:16:15,460 --> 00:16:17,380
And as such, it's a lot more powerful.

319
00:16:17,380 --> 00:16:20,340
But at first glance, it's actually going to look a lot more cryptic.

320
00:16:20,340 --> 00:16:23,740
In fact, instead of writing 0s and 1s starting today,

321
00:16:23,740 --> 00:16:26,140
we're instead going to write something like this.

322
00:16:26,140 --> 00:16:29,020
Now, if you've never programmed before, odds are at first glance,

323
00:16:29,020 --> 00:16:30,940
this does look pretty cryptic.

324
00:16:30,940 --> 00:16:34,300
And there's a lot of symbols within it, punctuation from the keyboard.

325
00:16:34,300 --> 00:16:36,980
There's probably some familiar English-like words.

326
00:16:36,980 --> 00:16:40,620
And frankly, even after doing Scratch, anyone even with no prior background

327
00:16:40,620 --> 00:16:43,820
can probably hazard a guess as to what this program written

328
00:16:43,820 --> 00:16:47,580
in this other language called C does when you run it.

329
00:16:47,580 --> 00:16:49,180
It just prints hello world.

330
00:16:49,180 --> 00:16:52,540
Now, granted, there's a decent amount of overhead syntactically.

331
00:16:52,540 --> 00:16:55,220
There's a bunch of stuff you have to type to make this program do

332
00:16:55,220 --> 00:16:56,380
what you want it to do.

333
00:16:56,380 --> 00:16:58,980
But at the end of the day, that's all it's going to do.

334
00:16:58,980 --> 00:17:01,060
And this is among the simplest of programs.

335
00:17:01,060 --> 00:17:04,780
We're going to add to our puzzle pieces, so to speak, today in C,

336
00:17:04,780 --> 00:17:07,900
some of those same concepts that we saw last time as well.

337
00:17:07,900 --> 00:17:09,740
So let's do this first, though.

338
00:17:09,740 --> 00:17:13,420
Let me take a moment to sort of compare Scratch to C,

339
00:17:13,420 --> 00:17:15,380
because the most important takeaway for today

340
00:17:15,380 --> 00:17:18,300
is going to be that even if the syntax doesn't look so obvious,

341
00:17:18,300 --> 00:17:22,020
and frankly, even if your first minutes or hours with writing your own code

342
00:17:22,020 --> 00:17:25,300
in C is frustrating because, damn it, you left off a semicolon,

343
00:17:25,300 --> 00:17:27,420
or, oh, I had a parenthesis in the wrong place.

344
00:17:27,420 --> 00:17:30,740
There's a lot of these stupid syntactic hangups that make you feel quite often

345
00:17:30,740 --> 00:17:33,540
that you really aren't getting it, but that's not the important stuff.

346
00:17:33,540 --> 00:17:36,260
A lot of the syntax is the least important.

347
00:17:36,260 --> 00:17:38,700
It's not at all fundamentally intellectually interesting.

348
00:17:38,700 --> 00:17:41,620
So try to see past that, and try to take comfort in the fact

349
00:17:41,620 --> 00:17:44,340
that it's the principles that are going to be important.

350
00:17:44,340 --> 00:17:46,420
And honestly, just through muscle memory and practice,

351
00:17:46,420 --> 00:17:49,060
all of the other stuff that at first is going

352
00:17:49,060 --> 00:17:51,700
to be an occasional frustration, it just starts to go away

353
00:17:51,700 --> 00:17:55,780
as you start to see this for what it is and not for the syntax alone

354
00:17:55,780 --> 00:17:57,660
that you see on first glance.

355
00:17:57,660 --> 00:18:03,020
So this is to say, this program on the right in C is equivalent to what

356
00:18:03,020 --> 00:18:05,660
we did just a week ago with two puzzle pieces in Scratch.

357
00:18:05,660 --> 00:18:08,620
Now, there isn't going to be a green flag on my Mac or my PC

358
00:18:08,620 --> 00:18:10,340
as we move forward that you can just click.

359
00:18:10,340 --> 00:18:12,580
We're going to have to run these programs in a little different way,

360
00:18:12,580 --> 00:18:14,380
but that's all the code on the right is doing.

361
00:18:14,380 --> 00:18:15,820
It's equivalent to the code on the left.

362
00:18:15,820 --> 00:18:18,780
So let's do this again and again for just a few of those concepts from last time,

363
00:18:18,780 --> 00:18:21,220
and then we'll start writing some of our own programs.

364
00:18:21,220 --> 00:18:27,060
So this was an example, this purple block of what concept in programming?

365
00:18:27,060 --> 00:18:27,820
Yeah, function.

366
00:18:27,820 --> 00:18:29,540
So it was a verb, it was an action, and we're

367
00:18:29,540 --> 00:18:30,940
going to call those generally functions.

368
00:18:30,940 --> 00:18:32,740
They just have functionality built into them.

369
00:18:32,740 --> 00:18:33,980
So how do we do this in C?

370
00:18:33,980 --> 00:18:35,780
Well, you might remember from just a moment ago,

371
00:18:35,780 --> 00:18:38,740
because one of the lines of code was representative of this,

372
00:18:38,740 --> 00:18:40,540
it had some of this syntax.

373
00:18:40,540 --> 00:18:43,700
So in fact, if I were to translate the block on the left in Scratch

374
00:18:43,700 --> 00:18:46,940
to the equivalent code in this other text-based language called C,

375
00:18:46,940 --> 00:18:49,780
I'm going to start by writing print and then open parenthesis

376
00:18:49,780 --> 00:18:51,020
and then close parenthesis.

377
00:18:51,020 --> 00:18:54,260
And those parentheses kind of represent the oval, the white oval

378
00:18:54,260 --> 00:18:57,140
on the left that we typed hello world into before.

379
00:18:57,140 --> 00:18:59,500
Now in C, it's not quite as literal as that.

380
00:18:59,500 --> 00:19:02,420
The function or the verb is actually not called print.

381
00:19:02,420 --> 00:19:05,060
It's called printf, and the f stands for formatted.

382
00:19:05,060 --> 00:19:07,220
And it just means that in C, you can actually

383
00:19:07,220 --> 00:19:08,980
format your text in different ways.

384
00:19:08,980 --> 00:19:10,540
So we'll see that before long.

385
00:19:10,540 --> 00:19:13,540
And it turns out that you don't just write hello world between those

386
00:19:13,540 --> 00:19:15,300
parentheses like we did in Scratch.

387
00:19:15,300 --> 00:19:18,700
You also actually have to surround them with double quotes in C.

388
00:19:18,700 --> 00:19:20,340
OK, not such a big deal, but something you

389
00:19:20,340 --> 00:19:21,660
didn't have to do before.

390
00:19:21,660 --> 00:19:24,460
But you know what, in C, you're also going to generally

391
00:19:24,460 --> 00:19:26,700
want to be super specific to the computer.

392
00:19:26,700 --> 00:19:29,340
And when you want the cursor, the text on the screen,

393
00:19:29,340 --> 00:19:32,220
to move down to the next line, you need to tell the computer

394
00:19:32,220 --> 00:19:34,540
that by literally typing backslash n.

395
00:19:34,540 --> 00:19:36,900
The human is not going to see a backslash and an n.

396
00:19:36,900 --> 00:19:39,740
He or she is actually going to see the cursor move to the next line

397
00:19:39,740 --> 00:19:43,420
of the screen, like in Google Docs or in Microsoft Word or the like.

398
00:19:43,420 --> 00:19:45,820
But this just speaks to the precision that you

399
00:19:45,820 --> 00:19:48,420
need to have when talking to a computer at this level

400
00:19:48,420 --> 00:19:50,060
and not just with the puzzle pieces.

401
00:19:50,060 --> 00:19:52,180
And then one last thing, and I alluded to it earlier,

402
00:19:52,180 --> 00:19:54,740
because it's sort of the bane of a lot of programmers early on,

403
00:19:54,740 --> 00:19:58,900
most lines of code in C have to end in a semicolon.

404
00:19:58,900 --> 00:20:02,780
That's the sort of code equivalent of a period in English or some other language

405
00:20:02,780 --> 00:20:03,540
in sentence.

406
00:20:03,540 --> 00:20:04,260
So that's it.

407
00:20:04,260 --> 00:20:07,100
It took us a little while to kind of build that up, but that's all it is.

408
00:20:07,100 --> 00:20:09,740
The idea on the left of saying something is the same in C

409
00:20:09,740 --> 00:20:13,540
as printing something with this function called printf.

410
00:20:13,540 --> 00:20:15,900
And before I forge ahead with some other comparisons,

411
00:20:15,900 --> 00:20:18,460
any questions on just this translation?

412
00:20:18,460 --> 00:20:20,980
How do you write backslash n?

413
00:20:20,980 --> 00:20:22,260
How do you write backslash n?

414
00:20:22,260 --> 00:20:22,760
Good.

415
00:20:22,760 --> 00:20:26,940
So thinking ahead, this would seem to make it hard to literally show the user

416
00:20:26,940 --> 00:20:28,180
backslash n.

417
00:20:28,180 --> 00:20:32,780
Well, it turns out that this backslash, because it's not a terribly common character,

418
00:20:32,780 --> 00:20:35,780
the programming world uses it as what's called an escape character.

419
00:20:35,780 --> 00:20:39,020
It's one that you use when you want to escape information

420
00:20:39,020 --> 00:20:40,820
and show it in a slightly different way.

421
00:20:40,820 --> 00:20:43,380
So the way you would show literally to the human,

422
00:20:43,420 --> 00:20:49,460
a actual backslash n is to actually, in your code, do backslash backslash

423
00:20:49,460 --> 00:20:53,340
n, because the second backslash is like saying, treat the next character

424
00:20:53,340 --> 00:20:55,620
special and actually show it to the human.

425
00:20:55,620 --> 00:20:57,500
And there's other such examples of that.

426
00:20:57,500 --> 00:20:58,580
So how about this one?

427
00:20:58,580 --> 00:21:03,020
This orange block was an example of what concept in scratch?

428
00:21:03,020 --> 00:21:03,460
Yeah.

429
00:21:03,460 --> 00:21:05,940
So this was a variable, like an x and y and algebra.

430
00:21:05,940 --> 00:21:07,500
This was just a placeholder for data.

431
00:21:07,500 --> 00:21:09,020
And you could store numbers.

432
00:21:09,020 --> 00:21:10,420
It turns out you can store words.

433
00:21:10,420 --> 00:21:12,740
You can store other things, too, in other languages.

434
00:21:12,740 --> 00:21:14,620
So in C, we're going to do this.

435
00:21:14,620 --> 00:21:17,500
We're going to say literally the name of the variable we want, for instance,

436
00:21:17,500 --> 00:21:20,780
counter, but we could call it anything we want, equals 0,

437
00:21:20,780 --> 00:21:22,940
if we're setting it initially equal to 0.

438
00:21:22,940 --> 00:21:24,980
But C is a little more pedantic.

439
00:21:24,980 --> 00:21:28,380
You've also got to tell the computer, this type of variable I want

440
00:21:28,380 --> 00:21:32,140
is specifically for an integer, otherwise abbreviated int.

441
00:21:32,140 --> 00:21:34,700
So you have to tell the computer in advance what type of data you're

442
00:21:34,700 --> 00:21:36,620
going to store in it and take a guess.

443
00:21:36,620 --> 00:21:40,780
You've got to finish the thought and see, what more do we need to add to the?

444
00:21:40,780 --> 00:21:42,100
Yeah, just a semicolon.

445
00:21:42,140 --> 00:21:43,020
And that's it.

446
00:21:43,020 --> 00:21:46,820
Looks a little more cryptic, but the idea is fundamentally the same.

447
00:21:46,820 --> 00:21:48,820
So what if we wanted to do this in scratch?

448
00:21:48,820 --> 00:21:50,220
Change counter by 1.

449
00:21:50,220 --> 00:21:54,220
This was equivalent to incrementing or adding 1 to counter.

450
00:21:54,220 --> 00:21:57,500
Well, let me go ahead and propose that you could literally just do this in C.

451
00:21:57,500 --> 00:22:03,740
Set counter equal to whatever counter currently is, plus 1.

452
00:22:03,740 --> 00:22:05,580
That seems to be kind of the right intuition.

453
00:22:05,580 --> 00:22:09,300
And now notice what's key to note here is that this equal sign

454
00:22:09,300 --> 00:22:12,900
isn't saying that counter equals counter plus 1,

455
00:22:12,900 --> 00:22:15,460
because that just doesn't seem possible.

456
00:22:15,460 --> 00:22:19,460
If you pick any value for counter, like the number 1, well, 1 definitely

457
00:22:19,460 --> 00:22:22,700
does not equal 1 plus 1, which is 2.

458
00:22:22,700 --> 00:22:24,180
And 1 does not equal 2.

459
00:22:24,180 --> 00:22:28,220
And you can come up with an infinite number of worrisome incorrect comparisons.

460
00:22:28,220 --> 00:22:31,420
So the equal sign in C, like a lot of languages we'll see in the class,

461
00:22:31,420 --> 00:22:32,580
actually means assignment.

462
00:22:32,580 --> 00:22:36,020
Copy the value on the right into the value on the left.

463
00:22:36,020 --> 00:22:39,420
So set counter equal to whatever it is, plus 1.

464
00:22:39,420 --> 00:22:42,780
Well, we've got to finish the thought, so we need a semicolon.

465
00:22:42,780 --> 00:22:45,780
I don't, though, need to re-mention int.

466
00:22:45,780 --> 00:22:48,460
And why might that be?

467
00:22:48,460 --> 00:22:50,620
Yeah, I already told the computer it's an integer.

468
00:22:50,620 --> 00:22:52,860
You don't need to repeat yourself by mentioning int again,

469
00:22:52,860 --> 00:22:56,220
assuming in this context, even though we're looking at it just on the slide,

470
00:22:56,220 --> 00:22:59,020
has actually been created before, just like you

471
00:22:59,020 --> 00:23:01,180
did with scratch by saying make a variable.

472
00:23:01,180 --> 00:23:04,780
So it turns out you can be a little more succinct in C in a lot of languages.

473
00:23:04,820 --> 00:23:08,180
If you find this a little tedious to type, and it's a little verbose,

474
00:23:08,180 --> 00:23:10,860
it's a bunch of keystrokes, you can actually abbreviate it with just this.

475
00:23:10,860 --> 00:23:15,940
So plus equals is just syntactic sugar, as a programmer would say.

476
00:23:15,940 --> 00:23:19,620
It's just a nice, fancy feature that lets you write fewer words or characters,

477
00:23:19,620 --> 00:23:20,620
but do the same thing.

478
00:23:20,620 --> 00:23:22,060
And frankly, we can do a little better.

479
00:23:22,060 --> 00:23:25,020
And if you've taken a PCS, you might have seen this in Java as well.

480
00:23:25,020 --> 00:23:30,100
You can also simplify this even more to just counter plus plus semicolon.

481
00:23:30,100 --> 00:23:31,500
So that's it, all equivalent.

482
00:23:31,500 --> 00:23:32,980
This is just a little more efficient.

483
00:23:33,020 --> 00:23:36,620
As you get more comfortable programming, saving keystrokes just saves you time.

484
00:23:36,620 --> 00:23:40,780
Now this, of course, was an example of what in scratch, by contrast.

485
00:23:40,780 --> 00:23:43,700
Yeah, we called this a condition, and it had a Boolean expression

486
00:23:43,700 --> 00:23:45,740
that we were asking a question of.

487
00:23:45,740 --> 00:23:48,940
In this case, we're apparently asking in scratch, is x less than y.

488
00:23:48,940 --> 00:23:51,220
And if so, say it on the screen.

489
00:23:51,220 --> 00:23:53,060
So how might we translate this to C?

490
00:23:53,060 --> 00:23:56,660
Well, it turns out we can quite simply translate this one pretty literally.

491
00:23:56,660 --> 00:23:59,260
We've seen almost all of the building blocks thus far,

492
00:23:59,260 --> 00:24:01,780
but we do have to introduce a little something new here.

493
00:24:01,820 --> 00:24:05,740
Notice that the printf line is almost identical to what I used earlier

494
00:24:05,740 --> 00:24:06,540
for just Hello World.

495
00:24:06,540 --> 00:24:10,140
I've obviously just changed the words in it, but I still have the backslash n.

496
00:24:10,140 --> 00:24:12,380
I still have the quotes, still have the semicolon.

497
00:24:12,380 --> 00:24:14,580
So the rest of that is the same.

498
00:24:14,580 --> 00:24:17,620
Now if is new, but this is a one-to-one translation.

499
00:24:17,620 --> 00:24:19,340
Scratch calls it if, C calls it if.

500
00:24:19,340 --> 00:24:20,940
And the only additional thing you need in C

501
00:24:20,940 --> 00:24:22,940
is parentheses around the Boolean expression.

502
00:24:22,940 --> 00:24:26,100
So that's what takes the place of the little green block there.

503
00:24:26,100 --> 00:24:30,100
And then assuming x and y are indeed variables that we created earlier,

504
00:24:30,100 --> 00:24:31,900
you can just compare them like this.

505
00:24:31,900 --> 00:24:34,900
And you can use greater than and other symbols for comparison as well.

506
00:24:34,900 --> 00:24:36,540
But there is something a little interesting.

507
00:24:36,540 --> 00:24:40,260
And most of us don't often have occasion to even use these keys on our keyboard.

508
00:24:40,260 --> 00:24:43,820
Curly braces on a US keyboard, they tend to be over on the top right

509
00:24:43,820 --> 00:24:45,420
above your Enter key.

510
00:24:45,420 --> 00:24:49,620
These are just kind of C's equivalent of this shape.

511
00:24:49,620 --> 00:24:52,380
Notice that most of the yellow blocks in Scratch

512
00:24:52,380 --> 00:24:56,180
kind of had this embracing or this embracing shape to them.

513
00:24:56,180 --> 00:24:59,740
You can simulate that in C by having what's called an open curly brace

514
00:24:59,780 --> 00:25:00,940
and then a closed curly brace.

515
00:25:00,940 --> 00:25:02,380
So that's the same exact idea.

516
00:25:02,380 --> 00:25:06,340
Now as an aside, you don't technically always need these curly braces.

517
00:25:06,340 --> 00:25:08,980
If you've just got a one-liner like this, you can omit them

518
00:25:08,980 --> 00:25:10,820
as you might see online or in textbooks.

519
00:25:10,820 --> 00:25:12,660
But we'll just always draw them for consistency

520
00:25:12,660 --> 00:25:17,380
so that the C code always looks like this.

521
00:25:17,380 --> 00:25:20,300
What if you wanted to express this, though?

522
00:25:20,300 --> 00:25:23,100
If x is less than y, then say x is less than y.

523
00:25:23,100 --> 00:25:25,660
Else, say x is not less than y.

524
00:25:25,660 --> 00:25:27,940
Well, it turns out this is almost identical.

525
00:25:27,940 --> 00:25:31,580
So the first four lines perfectly the same as before.

526
00:25:31,580 --> 00:25:35,740
But it turns out in C you can literally say else after that closing curly brace

527
00:25:35,740 --> 00:25:39,140
and then just print out alternatively whatever it is you want to say.

528
00:25:39,140 --> 00:25:40,820
So this is like the fork in the road.

529
00:25:40,820 --> 00:25:42,340
If you go one way, say this.

530
00:25:42,340 --> 00:25:45,340
If you go the other way, say this other thing.

531
00:25:45,340 --> 00:25:47,580
Any questions on these comparisons thus far?

532
00:25:47,580 --> 00:25:48,080
Yeah?

533
00:25:48,080 --> 00:25:52,780
Can we put the first bracket on the same line?

534
00:25:52,780 --> 00:25:54,340
Really good question.

535
00:25:54,340 --> 00:25:56,940
Can you or do you put the curly brace on the same line

536
00:25:56,940 --> 00:25:57,940
as the if you can?

537
00:25:57,940 --> 00:26:01,180
And we're going to talk about this in the next couple of weeks, this matter of style.

538
00:26:01,180 --> 00:26:04,620
There are different ways I could express this exact same code.

539
00:26:04,620 --> 00:26:09,380
Frankly, I could write out all of this code with no spaces whatsoever.

540
00:26:09,380 --> 00:26:13,820
In fact, just to make that point, if I go ahead and just open up a simple text

541
00:26:13,820 --> 00:26:17,620
editor here, not to actually program, but to just type something,

542
00:26:17,620 --> 00:26:20,020
I could actually do something like this.

543
00:26:20,020 --> 00:26:28,540
If x less than y, then go ahead and print out x is less than y backslash n semicolon

544
00:26:28,540 --> 00:26:31,380
curly brace else print and so forth.

545
00:26:31,380 --> 00:26:34,140
Completely unreadable at the end of the day or unmaintainable,

546
00:26:34,140 --> 00:26:35,860
especially when the code gets complicated.

547
00:26:35,860 --> 00:26:38,660
But white space does not tend to matter to the computer,

548
00:26:38,660 --> 00:26:40,060
but it does matter to the human.

549
00:26:40,060 --> 00:26:42,260
And as you're alluding to in some languages,

550
00:26:42,260 --> 00:26:46,540
it's actually conventional to do this, where you actually keep the curly brace

551
00:26:46,540 --> 00:26:47,340
on the same line.

552
00:26:47,340 --> 00:26:50,460
And indeed, you might see textbooks do this as well.

553
00:26:50,460 --> 00:26:52,260
Some people will even do this.

554
00:26:52,260 --> 00:26:54,300
These are all long story short matters of style.

555
00:26:54,300 --> 00:26:56,900
And CS50, in the earliest weeks of the class,

556
00:26:56,900 --> 00:26:59,420
we're going to insist that everyone follow the same style,

557
00:26:59,420 --> 00:27:01,380
so that we have some basis for comparison.

558
00:27:01,380 --> 00:27:03,180
But eventually, this is the kind of thing

559
00:27:03,180 --> 00:27:06,900
that, like in your own English writing or whatever language you tend to write in,

560
00:27:06,900 --> 00:27:09,940
you have your own sort of stylistic or linguistic flair to it.

561
00:27:09,940 --> 00:27:11,580
Code has that as well.

562
00:27:11,580 --> 00:27:13,460
Other questions?

563
00:27:13,460 --> 00:27:14,460
Yeah?

564
00:27:14,900 --> 00:27:17,180
Do you establish the counter variable?

565
00:27:17,180 --> 00:27:22,380
Do you always have to say what is equal to or equal to the counter?

566
00:27:22,380 --> 00:27:23,260
Really good question.

567
00:27:23,260 --> 00:27:25,740
When you declare a variable, create a variable,

568
00:27:25,740 --> 00:27:28,420
do you have to set it equal to something right away?

569
00:27:28,420 --> 00:27:29,340
Short answer, no.

570
00:27:29,340 --> 00:27:32,020
And we'll see examples of that before long, where you can actually say,

571
00:27:32,020 --> 00:27:36,980
give me a variable called counter, but don't actually set it equal to some value.

572
00:27:36,980 --> 00:27:38,780
Come back to that in a bit.

573
00:27:38,780 --> 00:27:41,340
All right, so what if we want to add this logic?

574
00:27:41,340 --> 00:27:44,620
Frankly, in Scratch, it's starting to look a little overwhelming,

575
00:27:44,620 --> 00:27:46,540
but this is just a three-way fork in the road.

576
00:27:46,540 --> 00:27:48,980
If x is less than y, say so.

577
00:27:48,980 --> 00:27:52,380
Else if x is greater than y, say so.

578
00:27:52,380 --> 00:27:57,140
Else if x equals y, then go ahead and say they're equal.

579
00:27:57,140 --> 00:28:00,820
And in C, we can do this translation pretty directly as well.

580
00:28:00,820 --> 00:28:04,620
In fact, now the first eight lines of code are identical to before,

581
00:28:04,620 --> 00:28:08,580
except this middle one here, where I'm adding a second Boolean expression,

582
00:28:08,580 --> 00:28:10,580
is x greater than y.

583
00:28:10,580 --> 00:28:13,900
And then I have this third condition, else if x equals y.

584
00:28:13,900 --> 00:28:19,420
But there seems to be a typo, perhaps, or something anomalous here.

585
00:28:19,420 --> 00:28:20,180
Does anything jump out?

586
00:28:20,180 --> 00:28:22,580
Yeah.

587
00:28:22,580 --> 00:28:27,020
I have a double equal sign, which maybe is just a typographical error on my part.

588
00:28:27,020 --> 00:28:28,180
But turns out it's not.

589
00:28:28,180 --> 00:28:29,900
This is deliberate.

590
00:28:29,900 --> 00:28:30,740
But why?

591
00:28:30,740 --> 00:28:33,380
This seems like our first example of where Scratch doesn't really

592
00:28:33,380 --> 00:28:34,780
map perfectly to C. Yeah.

593
00:28:34,820 --> 00:28:38,900
So the equal sign is an assignment, and so not the equal sign,

594
00:28:38,900 --> 00:28:40,780
and actually the same thing.

595
00:28:40,780 --> 00:28:41,340
Exactly.

596
00:28:41,340 --> 00:28:45,340
We already, a moment ago, decided as humans, really years ago,

597
00:28:45,340 --> 00:28:48,260
equals is actually, in the context of C, going to be assignment.

598
00:28:48,260 --> 00:28:51,020
Copy the value from the right to the value on the left.

599
00:28:51,020 --> 00:28:53,140
And so we kind of painted ourselves into a corner.

600
00:28:53,140 --> 00:28:55,020
We still, as humans, as programmers, want

601
00:28:55,020 --> 00:28:58,300
to be able to express the notion of equality and comparing.

602
00:28:58,300 --> 00:29:00,700
But if we've already used the equal sign for assignment,

603
00:29:00,700 --> 00:29:03,980
we need another pattern of symbols to represent equality.

604
00:29:03,980 --> 00:29:07,540
And as it turns out, humans just chose two equal signs instead.

605
00:29:07,540 --> 00:29:09,260
So slightly different from Scratch.

606
00:29:09,260 --> 00:29:11,420
The reason Scratch does it this way is because you don't really

607
00:29:11,420 --> 00:29:12,980
want to have to get into those weeds.

608
00:29:12,980 --> 00:29:15,500
Certainly when the target audience is eight-year-olds just learning

609
00:29:15,500 --> 00:29:17,660
to program in the first place, it's not important.

610
00:29:17,660 --> 00:29:19,820
Nor is it really important for us, but for us,

611
00:29:19,820 --> 00:29:23,060
there's going to be a logical difference.

612
00:29:23,060 --> 00:29:25,540
Because if we use the wrong one, the behavior is going to be wrong.

613
00:29:25,540 --> 00:29:27,620
If we had just one equal sign, we would literally

614
00:29:27,620 --> 00:29:32,180
be changing x to equal y rather than just comparing it.

615
00:29:32,180 --> 00:29:34,260
How is their hand in here?

616
00:29:34,260 --> 00:29:34,760
Yeah?

617
00:29:34,760 --> 00:29:35,620
Just a quick question.

618
00:29:35,620 --> 00:29:38,340
So if you wanted to express greater than or equal to,

619
00:29:38,340 --> 00:29:40,380
would you write equal greater than?

620
00:29:40,380 --> 00:29:40,880
Good question.

621
00:29:40,880 --> 00:29:44,140
If you wanted to express greater than or equal to, how might you do that?

622
00:29:44,140 --> 00:29:46,140
It turns out there are ways to do that.

623
00:29:46,140 --> 00:29:50,060
And if I go ahead and just give myself some place to draw here for a moment,

624
00:29:50,060 --> 00:29:55,900
you can actually, indeed, do less than or equal or greater than or equal.

625
00:29:55,900 --> 00:29:58,540
There's no way on a typical keyboard to put them atop each other,

626
00:29:58,540 --> 00:29:59,940
like you might recall for math class.

627
00:29:59,940 --> 00:30:01,300
So you just put them next to each other.

628
00:30:05,180 --> 00:30:06,060
Well, it depends.

629
00:30:06,060 --> 00:30:08,900
I want the double equal sign here, because I

630
00:30:08,900 --> 00:30:15,020
want to explicitly check this third case and say x is equal to y.

631
00:30:15,020 --> 00:30:16,060
So that was my goal.

632
00:30:16,060 --> 00:30:17,860
But logically, this is not necessary.

633
00:30:17,860 --> 00:30:20,380
Let's make the program a little better designed.

634
00:30:20,380 --> 00:30:26,140
How many possible cases are there when comparing two integers, x and y,

635
00:30:26,140 --> 00:30:29,020
for greater than, less than, or equality?

636
00:30:29,220 --> 00:30:31,580
I just answered the question, didn't I?

637
00:30:31,580 --> 00:30:32,460
Is there a?

638
00:30:32,460 --> 00:30:33,620
Three, excellent.

639
00:30:33,620 --> 00:30:34,940
There's three scenarios there.

640
00:30:34,940 --> 00:30:38,140
x is either less than or greater than or equal to.

641
00:30:38,140 --> 00:30:41,260
And I'm hard pressed to think of a fourth.

642
00:30:41,260 --> 00:30:46,340
So do I need this amount of specificity?

643
00:30:46,340 --> 00:30:49,220
What could I do to give myself a slight optimization,

644
00:30:49,220 --> 00:30:52,060
improve the code just a little bit, just to save myself a little bit of time

645
00:30:52,060 --> 00:30:54,900
writing it, and maybe even the computer a little time running it?

646
00:30:54,900 --> 00:30:55,380
Yeah?

647
00:30:55,380 --> 00:30:56,580
You don't need the last condition.

648
00:30:56,580 --> 00:30:58,740
Yeah, I don't need the last condition, because if we all

649
00:30:58,740 --> 00:31:03,300
agree logically that either x is less than y or greater than y or maybe

650
00:31:03,300 --> 00:31:05,940
equal to y, well, if there's only a third and final case,

651
00:31:05,940 --> 00:31:07,500
that can just be my so-called else.

652
00:31:07,500 --> 00:31:09,620
Just make that be the so-called default case.

653
00:31:09,620 --> 00:31:13,140
And in fact, even though this is what most people would call an over

654
00:31:13,140 --> 00:31:15,860
optimization, you are saving the computer some time.

655
00:31:15,860 --> 00:31:18,420
Because suppose that x does, in fact, equal y,

656
00:31:18,420 --> 00:31:20,260
and they're both the value number one.

657
00:31:20,260 --> 00:31:24,860
So is one less than one when this line of code is executed?

658
00:31:24,860 --> 00:31:26,460
True or no?

659
00:31:26,460 --> 00:31:27,380
No, obviously not.

660
00:31:27,380 --> 00:31:28,580
One is not less than one.

661
00:31:28,620 --> 00:31:31,980
So this code does not execute, but the Boolean expression is evaluated,

662
00:31:31,980 --> 00:31:32,480
so to speak.

663
00:31:32,480 --> 00:31:33,860
The question is asked.

664
00:31:33,860 --> 00:31:35,820
Is one greater than one?

665
00:31:35,820 --> 00:31:36,580
No.

666
00:31:36,580 --> 00:31:39,500
And so this code is not executed, but this Boolean expression is.

667
00:31:39,500 --> 00:31:43,820
So we just spent another step or second, or however fast the computer is,

668
00:31:43,820 --> 00:31:45,820
is one equal to one?

669
00:31:45,820 --> 00:31:46,380
Yeah, it is.

670
00:31:46,380 --> 00:31:47,860
So this actually prints.

671
00:31:47,860 --> 00:31:49,980
But to your point, you don't need to ask that question.

672
00:31:49,980 --> 00:31:52,900
And in fact, you just increased by a factor of 50%

673
00:31:52,900 --> 00:31:56,820
how many questions you're asking, so you just wasted a little bit of time.

674
00:31:56,820 --> 00:31:59,620
Now, as an aside, are Macs and PCs and phones these days?

675
00:31:59,620 --> 00:32:01,700
I mean, again, they're operating at like a gigahertz speed,

676
00:32:01,700 --> 00:32:03,500
one billion things per second.

677
00:32:03,500 --> 00:32:07,020
So in practice, who cares if you're asking that third question?

678
00:32:07,020 --> 00:32:09,980
And frankly, if it makes your code more readable,

679
00:32:09,980 --> 00:32:12,900
or to your teaching fellow, or to a colleague, or a friend who's

680
00:32:12,900 --> 00:32:14,900
working on the program for you, then that's great.

681
00:32:14,900 --> 00:32:18,100
If it's more clear from the code what's going on, leave it that way.

682
00:32:18,100 --> 00:32:21,060
But these are the kinds of design decisions that we'll now make.

683
00:32:21,060 --> 00:32:24,400
And arguably, this version of the Scratch program and this version

684
00:32:24,400 --> 00:32:26,680
of the C code is just a little better design,

685
00:32:26,680 --> 00:32:32,200
because why write more code than you need to to express the exact same idea?

686
00:32:32,200 --> 00:32:32,760
All right.

687
00:32:32,760 --> 00:32:33,800
So what about this?

688
00:32:33,800 --> 00:32:35,360
This was a loop in Scratch.

689
00:32:35,360 --> 00:32:38,800
This was an infinite loop, because it was just forever saying hello world.

690
00:32:38,800 --> 00:32:41,860
Now, in C, this gets a little less directly translated.

691
00:32:41,860 --> 00:32:44,120
It turns out C uses the keyword while.

692
00:32:44,120 --> 00:32:47,880
So there is no forever keyword in C, but there is the word while.

693
00:32:47,880 --> 00:32:51,600
And of course, I'm going to use my curly braces, or curly braces,

694
00:32:51,600 --> 00:32:54,920
or curly brackets to kind of encompass the following lines of code.

695
00:32:54,920 --> 00:32:57,320
The line of code I want in there is just another printf,

696
00:32:57,320 --> 00:32:59,400
so that's the exact same as before.

697
00:32:59,400 --> 00:33:01,680
But it's not sufficient to just say while.

698
00:33:01,680 --> 00:33:06,760
It turns out that while wants you to ask it a question every time the loop

699
00:33:06,760 --> 00:33:09,000
executes, and it's going to check that question.

700
00:33:09,000 --> 00:33:11,320
And if the answer is yes, it's going to run the loop.

701
00:33:11,320 --> 00:33:15,720
But if the answer being asked in C is ever no or false,

702
00:33:15,720 --> 00:33:17,520
it's going to not execute the code, and it's just

703
00:33:17,520 --> 00:33:20,840
going to move on to any further lines of code lower down in the file.

704
00:33:20,840 --> 00:33:24,600
So in C, you actually need a pair of parentheses after the keyword while.

705
00:33:24,600 --> 00:33:26,880
And then you need to ask a question.

706
00:33:26,880 --> 00:33:29,960
You need to ask a question like, is x less than y?

707
00:33:29,960 --> 00:33:31,940
Or a question like, is x greater than y?

708
00:33:31,940 --> 00:33:33,600
Or is x equal to y?

709
00:33:33,600 --> 00:33:36,840
But none of those scenarios apply, because the whole purpose of this

710
00:33:36,840 --> 00:33:40,160
scratch block is literally to do something forever.

711
00:33:40,160 --> 00:33:45,040
So what's a question we could ask to which the answer is surely true?

712
00:33:47,440 --> 00:33:48,480
Does one equal one?

713
00:33:48,480 --> 00:33:52,280
We could kind of contrive an arbitrary but very mathematically correct scenario.

714
00:33:52,280 --> 00:33:54,600
We could just say, does one equal equal one?

715
00:33:54,600 --> 00:33:57,800
But it turns out you can be even more succinct, because in C,

716
00:33:57,800 --> 00:34:01,960
there's a couple key words, one of which is true, one of which is false.

717
00:34:01,960 --> 00:34:04,840
And the word true is by definition always true,

718
00:34:04,840 --> 00:34:06,920
and the word false is by definition always false.

719
00:34:06,920 --> 00:34:08,840
So you don't need to contrive some arbitrary,

720
00:34:08,840 --> 00:34:13,720
but correct the idea of does one equal equal one, or does 50 equal equal 50.

721
00:34:13,720 --> 00:34:16,000
You don't need to just come up with some arbitrary solution.

722
00:34:16,040 --> 00:34:21,280
You can literally just say true, because that key word true never changes value.

723
00:34:21,280 --> 00:34:23,160
So even though this is a little weird looking,

724
00:34:23,160 --> 00:34:26,760
it's how you induce something to happen forever.

725
00:34:26,760 --> 00:34:28,680
You ask the same question again, and assume

726
00:34:28,680 --> 00:34:31,520
that the question always has the same answer of true.

727
00:34:31,520 --> 00:34:34,960
Any questions on that one?

728
00:34:34,960 --> 00:34:36,840
Yeah, in the back.

729
00:34:36,840 --> 00:34:40,760
Do spaces matter, or do you take out the space in a while?

730
00:34:40,760 --> 00:34:41,360
Good question.

731
00:34:41,360 --> 00:34:43,040
Do spaces matter?

732
00:34:43,040 --> 00:34:45,240
Short answer, no, not in this case.

733
00:34:45,240 --> 00:34:48,320
You can add, in fact, delete all of the spaces here,

734
00:34:48,320 --> 00:34:49,960
except for the one in the English phrase,

735
00:34:49,960 --> 00:34:52,160
and it would still be functionally correct.

736
00:34:52,160 --> 00:34:54,440
You can even add spaces anywhere you want.

737
00:34:54,440 --> 00:34:56,640
You can make this taller by hitting Enter a bunch of times,

738
00:34:56,640 --> 00:34:58,800
Tab, Spaces around the word true.

739
00:34:58,800 --> 00:35:02,120
All of the examples I'll show here today, and you'll see in the coming weeks,

740
00:35:02,120 --> 00:35:05,040
are sort of the better way to do things, because they're more readable.

741
00:35:05,040 --> 00:35:06,840
But again, as you get more comfortable with code,

742
00:35:06,840 --> 00:35:08,440
or if you're coming in with some prior experience,

743
00:35:08,440 --> 00:35:10,040
you might already have your own opinions.

744
00:35:10,040 --> 00:35:12,680
And frankly, this is just a religious debate among programmers,

745
00:35:12,680 --> 00:35:14,480
which is the right way to write your code.

746
00:35:14,480 --> 00:35:15,080
And that's fine.

747
00:35:15,080 --> 00:35:18,240
Once you get comfy, so long as you're consistent is the most important thing.

748
00:35:18,240 --> 00:35:20,800
You don't need to adhere to one person's or the other.

749
00:35:20,800 --> 00:35:22,640
So how does this code work logically?

750
00:35:22,640 --> 00:35:25,360
Well, the first thing the computer, your Mac or PC, or your phone,

751
00:35:25,360 --> 00:35:28,080
or whatever is going to do, it's going to ask the question.

752
00:35:28,080 --> 00:35:28,840
Well, true.

753
00:35:28,840 --> 00:35:32,280
Well, true is always true, so it's going to proceed to execute the line of code.

754
00:35:32,280 --> 00:35:35,360
But after it does, because that's the entirety of the code that's

755
00:35:35,360 --> 00:35:37,560
been between the curly braces, we could have more lines.

756
00:35:37,560 --> 00:35:39,520
These are just short programs.

757
00:35:39,520 --> 00:35:42,440
The computer is going to check, OK, is true still true?

758
00:35:42,440 --> 00:35:44,640
Yes, so it's going to execute it again.

759
00:35:44,640 --> 00:35:47,000
Then it's going to ask the question again, is true still true?

760
00:35:47,000 --> 00:35:49,120
Yes, so it's going to execute the code again,

761
00:35:49,120 --> 00:35:52,960
and this is going to repeat literally forever.

762
00:35:52,960 --> 00:35:55,240
But what if you don't want to repeat something forever?

763
00:35:55,240 --> 00:35:57,120
What if you only want to repeat it 50 times?

764
00:35:57,120 --> 00:35:59,400
Scratch doesn't make you think very hard about this.

765
00:35:59,400 --> 00:36:02,960
It will just figure out how to keep track of 1, 2, 3, 4, 5,

766
00:36:02,960 --> 00:36:04,920
it all the way up to 50, and then stop.

767
00:36:04,920 --> 00:36:05,440
That's nice.

768
00:36:05,440 --> 00:36:07,160
It makes it easy to use the block.

769
00:36:07,160 --> 00:36:11,640
C and a lot of languages aren't quite that user-friendly.

770
00:36:11,640 --> 00:36:15,040
You will see later in the semester that newer languages are a little closer

771
00:36:15,040 --> 00:36:16,320
to what Scratch offers.

772
00:36:16,320 --> 00:36:18,280
But in C, we need to be more explicit.

773
00:36:18,280 --> 00:36:20,960
But this is a chance to use some of these more primitive building blocks.

774
00:36:20,960 --> 00:36:26,400
In C, the equivalent of repeat is going to be the preposition for,

775
00:36:26,400 --> 00:36:28,280
just because for now.

776
00:36:28,280 --> 00:36:32,080
And then just as before, if we want to do something again and again

777
00:36:32,080 --> 00:36:34,160
within this loop, we're going to use the curly braces,

778
00:36:34,160 --> 00:36:36,560
similar to the little orange block there.

779
00:36:36,560 --> 00:36:37,720
And then what am I going to do?

780
00:36:37,720 --> 00:36:40,840
I'm going to do this every time, 50 times, hopefully.

781
00:36:40,840 --> 00:36:42,400
Print out, hello, world.

782
00:36:42,400 --> 00:36:46,280
So now I just need to figure out in C how to express the number of times

783
00:36:46,280 --> 00:36:48,080
specifically 50.

784
00:36:48,080 --> 00:36:50,920
So it turns out in C, use parentheses again.

785
00:36:50,920 --> 00:36:54,120
This is going to be a pretty common characteristic of a lot of the code

786
00:36:54,120 --> 00:36:54,960
rewrite.

787
00:36:54,960 --> 00:36:56,840
And then you need to do three things.

788
00:36:56,840 --> 00:36:59,920
The burden is now going to be on us, the programmer,

789
00:36:59,920 --> 00:37:04,080
to keep track of how many times we want to execute this code,

790
00:37:04,080 --> 00:37:07,240
to how many times we've already executed this code,

791
00:37:07,240 --> 00:37:10,200
and then constantly make sure that one does not exceed the other.

792
00:37:10,200 --> 00:37:12,280
So we stop once we hit 50.

793
00:37:12,280 --> 00:37:14,840
So what's the sort of fundamental construct

794
00:37:14,840 --> 00:37:18,560
that we use to keep track of anything in a program?

795
00:37:18,560 --> 00:37:20,400
Counter, which was an example of a variable.

796
00:37:20,400 --> 00:37:22,160
So we just need to use a variable.

797
00:37:22,160 --> 00:37:24,960
Now, it's actually going to be inside of the parentheses this time.

798
00:37:24,960 --> 00:37:27,320
So it's not on its own as it was just a bit ago.

799
00:37:27,320 --> 00:37:28,880
But the syntax is the same.

800
00:37:28,880 --> 00:37:30,120
I could call it counter.

801
00:37:30,120 --> 00:37:32,360
But the reality is that the convention in programming

802
00:37:32,360 --> 00:37:35,440
is just to use shorter variables when you're just doing something mundane.

803
00:37:35,440 --> 00:37:38,560
And if all you're doing is looping, i stands for integer,

804
00:37:38,560 --> 00:37:41,480
is sort of many programmers go to variable name rather than the more

805
00:37:41,480 --> 00:37:44,000
verbose but correct counter or whatever.

806
00:37:44,000 --> 00:37:47,840
So this says, hey, computer, give me a variable called i.

807
00:37:47,840 --> 00:37:52,800
Let me store integers or ints in it and set the initial value to 0.

808
00:37:52,800 --> 00:37:53,480
Why?

809
00:37:53,480 --> 00:37:57,040
Well, almost everyone in this room probably starts counting from 1.

810
00:37:57,040 --> 00:37:59,840
Computers just tend to start counting from 0.

811
00:37:59,840 --> 00:38:00,320
But why?

812
00:38:00,320 --> 00:38:03,680
What's the rationale for starting to count from 0, perhaps, based on last week?

813
00:38:04,680 --> 00:38:05,680
Why is that kind of makes sense?

814
00:38:05,680 --> 00:38:06,680
Yeah, what do you think?

815
00:38:06,680 --> 00:38:08,680
Yeah, it's just 1s and 0s.

816
00:38:08,680 --> 00:38:09,680
And what's the smallest number?

817
00:38:09,680 --> 00:38:11,680
Negative values aside that you can represent in binary?

818
00:38:11,680 --> 00:38:14,680
Well, it's just 0, 0, 0, the bunch of 0s.

819
00:38:14,680 --> 00:38:18,160
So why would you waste that representation, that permutation of bits?

820
00:38:18,160 --> 00:38:20,880
Let's just start counting at 0 and then add to that.

821
00:38:20,880 --> 00:38:25,120
So you can start counting from 1 in C. But the convention in most languages

822
00:38:25,120 --> 00:38:25,920
is count from 0.

823
00:38:25,920 --> 00:38:27,680
So we'll get off on that footage.

824
00:38:27,680 --> 00:38:29,680
So let's just start counting from 0.

825
00:38:29,680 --> 00:38:32,680
In C, but the convention in most languages is count from 0.

826
00:38:32,680 --> 00:38:34,360
So we'll get off on that foot as well.

827
00:38:34,360 --> 00:38:42,200
And you might recall, even, that in our PBJ code for the phone book,

828
00:38:42,200 --> 00:38:44,120
pseudocode, I actually deliberately started

829
00:38:44,120 --> 00:38:48,040
numbering the lines from 0 to 1 to 2 for that same intuition.

830
00:38:48,040 --> 00:38:50,280
So here's how you then say to the computer,

831
00:38:50,280 --> 00:38:52,920
check, if you would, whether i is less than 50.

832
00:38:52,920 --> 00:38:54,880
Now, initially, it's obviously going to be less than 50

833
00:38:54,880 --> 00:38:56,320
because 0 is less than 50.

834
00:38:56,320 --> 00:38:59,660
But that same condition is going to be checked again and again and again.

835
00:38:59,660 --> 00:39:01,220
As this loop executes.

836
00:39:01,220 --> 00:39:06,500
And then recall from before, we can just plus plus a variable to add 1 to it.

837
00:39:06,500 --> 00:39:08,540
We could do this more verbosely.

838
00:39:08,540 --> 00:39:11,020
We could say i equals i plus 1.

839
00:39:11,020 --> 00:39:14,300
But it's just more conventional to write i plus plus just to say

840
00:39:14,300 --> 00:39:15,820
the same thing more tersally.

841
00:39:15,820 --> 00:39:17,380
So what happens next logically?

842
00:39:17,380 --> 00:39:18,420
That's the code I've written.

843
00:39:18,420 --> 00:39:19,860
What does the computer do with it?

844
00:39:19,860 --> 00:39:24,140
Well, it initializes i to 0 and prepares to store integers in it.

845
00:39:24,140 --> 00:39:27,820
It checks the condition just in case you initialized it to too big of a value.

846
00:39:27,860 --> 00:39:29,860
You might not want the loop to execute at all.

847
00:39:29,860 --> 00:39:32,060
But obviously, 0 is less than 50.

848
00:39:32,060 --> 00:39:34,500
So this line of code executes.

849
00:39:34,500 --> 00:39:38,020
Take a guess as to what happens next.

850
00:39:38,020 --> 00:39:40,300
Yeah, you probably want to do i plus plus because you've

851
00:39:40,300 --> 00:39:43,460
done executing all of the lines of code in between the curly braces,

852
00:39:43,460 --> 00:39:44,660
even though there's just one.

853
00:39:44,660 --> 00:39:46,140
So let's go ahead and increment i.

854
00:39:46,140 --> 00:39:47,820
So i is now 1.

855
00:39:47,820 --> 00:39:49,940
Let's now make sure is 1 less than 50.

856
00:39:49,940 --> 00:39:52,260
Obviously, execute the code.

857
00:39:52,260 --> 00:39:54,940
i plus plus is 2 less than 50.

858
00:39:54,940 --> 00:39:56,900
Obviously, execute the code.

859
00:39:56,900 --> 00:39:59,140
i plus plus is 3 less than 50.

860
00:39:59,140 --> 00:40:01,980
Obviously, now go ahead and execute the code.

861
00:40:01,980 --> 00:40:03,980
And again, and again, and again.

862
00:40:03,980 --> 00:40:08,260
And at some point, we're going to get up to i equals 49.

863
00:40:08,260 --> 00:40:10,340
And is 49 less than 50?

864
00:40:10,340 --> 00:40:10,940
Obviously.

865
00:40:10,940 --> 00:40:13,180
So we print out hello world.

866
00:40:13,180 --> 00:40:15,220
And then i plus plus kicks in.

867
00:40:15,220 --> 00:40:18,260
And then it's 50 less than 50.

868
00:40:18,260 --> 00:40:18,900
No.

869
00:40:18,900 --> 00:40:21,020
So wait, that feels like a logical error, though.

870
00:40:21,020 --> 00:40:25,140
No, should I be checking if i is less than or equal to 50?

871
00:40:25,180 --> 00:40:27,380
Yeah, because if I started from 0, I already

872
00:40:27,380 --> 00:40:28,940
spent that one additional cycle.

873
00:40:28,940 --> 00:40:34,860
So I can count from 0 through 49, which seems to work, or from 1 through 50.

874
00:40:34,860 --> 00:40:37,060
But the convention in programming, honestly,

875
00:40:37,060 --> 00:40:39,060
is typically to start counting at some value

876
00:40:39,060 --> 00:40:44,100
and then count up to but not through some value, just because.

877
00:40:44,100 --> 00:40:46,980
But logically, you can implement this in half a dozen different ways,

878
00:40:46,980 --> 00:40:48,140
most likely.

879
00:40:48,140 --> 00:40:49,900
All right, let's look at one final example that

880
00:40:49,900 --> 00:40:52,780
allowed us to actually get user input in scratch.

881
00:40:52,780 --> 00:40:57,340
Recall that we use this block to actually get the name of someone in lecture.

882
00:40:57,340 --> 00:41:00,100
And we also, in the animation with the gingerbread house,

883
00:41:00,100 --> 00:41:01,700
used it to get yes or no.

884
00:41:01,700 --> 00:41:03,780
Do you want the cupcake or the apple or the like?

885
00:41:03,780 --> 00:41:08,100
So this is an example of a function in scratch that actually takes input,

886
00:41:08,100 --> 00:41:09,900
like the sentence, what's your name.

887
00:41:09,900 --> 00:41:13,220
But it also returns a value, which in this case was just

888
00:41:13,220 --> 00:41:15,940
hard-coded in scratch by MIT, to be called answer.

889
00:41:15,940 --> 00:41:17,980
So it's like a special variable called answer.

890
00:41:17,980 --> 00:41:21,220
But effectively, it's being handed back to the user.

891
00:41:21,260 --> 00:41:23,300
So how might we think about this?

892
00:41:23,300 --> 00:41:27,580
In C, it turns out that you can express this line of code a little more

893
00:41:27,580 --> 00:41:31,180
verbose than before by using a new function called getString.

894
00:41:31,180 --> 00:41:33,580
So get underscore string is the name of the function.

895
00:41:33,580 --> 00:41:36,700
The underscore is convention in C. If you ever want to have a space,

896
00:41:36,700 --> 00:41:38,620
you can't have spaces in the names of functions.

897
00:41:38,620 --> 00:41:40,380
So people just started using underscores.

898
00:41:40,380 --> 00:41:43,580
Like you might in your own social media user names and the like

899
00:41:43,580 --> 00:41:45,500
is the convention there as well.

900
00:41:45,500 --> 00:41:48,780
Here's the sentence I want to display.

901
00:41:48,780 --> 00:41:51,260
And I'm going to start calling this more formally a string.

902
00:41:51,260 --> 00:41:54,500
A string in a programming language is just a sequence of characters.

903
00:41:54,500 --> 00:41:57,380
Like it's a word, it's a phrase, it's a character, it's a paragraph.

904
00:41:57,380 --> 00:41:58,100
This is a string.

905
00:41:58,100 --> 00:42:00,300
Anything between double quotes is a string in C.

906
00:42:00,300 --> 00:42:03,780
And the backslash n is just end of line, as before.

907
00:42:03,780 --> 00:42:05,580
We still already have the semicolon.

908
00:42:05,580 --> 00:42:09,500
But this isn't quite a literal translation of what's going on just yet,

909
00:42:09,500 --> 00:42:13,660
because I also now need to do something with the answer.

910
00:42:13,660 --> 00:42:17,580
So if getString is a function that actually gets input from the user,

911
00:42:17,580 --> 00:42:20,860
as via his or her keyboard, just like the blue block in Scratch.

912
00:42:20,860 --> 00:42:23,780
In C, we need to be a little more explicit as to where

913
00:42:23,780 --> 00:42:27,020
we're putting the return value from that function.

914
00:42:27,020 --> 00:42:29,260
What it is, it's handing back.

915
00:42:29,260 --> 00:42:31,700
And so I can store it in a variable, call it answer.

916
00:42:31,700 --> 00:42:33,380
I could call it anything I want.

917
00:42:33,380 --> 00:42:36,740
But for consistency with Scratch, let's call it answer.

918
00:42:36,740 --> 00:42:41,540
But recall what we have to do in C any time we create a variable.

919
00:42:41,540 --> 00:42:44,820
We have to be more precise, yeah.

920
00:42:44,820 --> 00:42:47,100
We have to define it's let me call it type or class

921
00:42:47,100 --> 00:42:48,580
if you've taken a previous class.

922
00:42:48,580 --> 00:42:51,900
It's type, and it's not going to be an int, because probably the words being

923
00:42:51,900 --> 00:42:53,100
typed in are not numbers.

924
00:42:53,100 --> 00:42:55,500
It's going to be this time what I just call it a string.

925
00:42:55,500 --> 00:42:59,220
And so indeed, we would declare the variable on the left by saying,

926
00:42:59,220 --> 00:43:04,300
give me a string, call it answer, and assign to it whatever's on the right.

927
00:43:04,300 --> 00:43:05,300
Well, what's on the right?

928
00:43:05,300 --> 00:43:09,460
What is on the right is whatever this function getString comes back with

929
00:43:09,460 --> 00:43:12,740
and gets stored from right to left.

930
00:43:12,740 --> 00:43:16,380
So how do I now say this person's name?

931
00:43:16,380 --> 00:43:19,660
Well, in Scratch, I just say say, and then I drag and drop the answer variable,

932
00:43:19,660 --> 00:43:20,660
and it's done.

933
00:43:20,660 --> 00:43:24,620
What's the function in C with which we can say something though on the screen?

934
00:43:24,620 --> 00:43:27,260
Yeah, so printf, print a formatted string, even though we haven't really

935
00:43:27,260 --> 00:43:29,220
seen any formatting it, until now.

936
00:43:29,220 --> 00:43:35,380
It turns out in C, you have to actually tell printf

937
00:43:35,380 --> 00:43:39,460
if you're not passing in a hard-coded string or sentence,

938
00:43:39,460 --> 00:43:44,500
you have to pass to printf what's called a format code or a format string.

939
00:43:44,500 --> 00:43:46,780
This first input to printf.

940
00:43:46,780 --> 00:43:49,220
Now printf apparently seems to take two things.

941
00:43:49,220 --> 00:43:51,300
The first is this one before the comma.

942
00:43:51,300 --> 00:43:53,060
The second is the thing after the comma.

943
00:43:53,060 --> 00:43:55,620
And we've not seen this before yet in C.

944
00:43:55,620 --> 00:44:01,340
So printf is being told, go ahead and print out a string that looks like this.

945
00:44:01,340 --> 00:44:04,780
Percent s is a placeholder, and s stands for string.

946
00:44:04,780 --> 00:44:07,340
And that literally is a placeholder saying, printf,

947
00:44:07,340 --> 00:44:12,060
I'm going to give you a string to plug in to this first input.

948
00:44:12,100 --> 00:44:13,140
What is that string?

949
00:44:13,140 --> 00:44:14,940
Literally, the answer variable.

950
00:44:14,940 --> 00:44:17,100
Now it feels like we're jumping through hoops here, right?

951
00:44:17,100 --> 00:44:19,860
It would have been nice to just say printf, open parenthesis, answer,

952
00:44:19,860 --> 00:44:22,340
close parenthesis, semicolon, and be done with it.

953
00:44:22,340 --> 00:44:24,300
That's just not the way printf works.

954
00:44:24,300 --> 00:44:27,300
In older versions, you could maybe do something a little more simple like that.

955
00:44:27,300 --> 00:44:31,020
But honestly, we're not typically going to be printing out just what the human typed in.

956
00:44:31,020 --> 00:44:33,340
After all, this is kind of a stupid example at the moment.

957
00:44:33,340 --> 00:44:35,620
I'm typing in a word, you're just saying it on the screen.

958
00:44:35,620 --> 00:44:37,940
We already decided in Scratch that's kind of lame.

959
00:44:37,940 --> 00:44:42,980
It'd be nice to at least have the program not just say, David, or whatever the name is,

960
00:44:42,980 --> 00:44:45,340
but what did we do last time?

961
00:44:45,340 --> 00:44:47,260
Like, hello, comma, David.

962
00:44:47,260 --> 00:44:51,020
But this would seem to give us that capability, right?

963
00:44:51,020 --> 00:44:54,940
Right now, I'm literally just printing out the human's name in C.

964
00:44:54,940 --> 00:44:58,420
But let me change this ever so slightly, just as we did in Scratch.

965
00:44:58,420 --> 00:45:03,020
Recall that in C, we did this green block of join,

966
00:45:03,020 --> 00:45:05,460
where I literally get past join two arguments.

967
00:45:05,460 --> 00:45:08,060
The first one was hello, comma, space.

968
00:45:08,060 --> 00:45:09,580
The second one was answer.

969
00:45:09,580 --> 00:45:13,140
And this concatenated, this combined, back to back, those two strings.

970
00:45:13,140 --> 00:45:16,660
Well, in C, thanks to printf, we can do that same thing.

971
00:45:16,660 --> 00:45:18,540
It's just a different syntax.

972
00:45:18,540 --> 00:45:22,100
Printf still gets one argument first.

973
00:45:22,100 --> 00:45:25,740
That is the string you want to format, ergo the f in printf.

974
00:45:25,740 --> 00:45:27,340
But this time, I'm going to literally say,

975
00:45:27,340 --> 00:45:33,020
h-e-l-l-o, comma, space, percent s for string,

976
00:45:33,020 --> 00:45:35,580
and then give printf a second argument, which

977
00:45:35,580 --> 00:45:39,220
is its instruction to go ahead and plug in whatever this variable is

978
00:45:39,220 --> 00:45:43,140
to whatever this placeholder is.

979
00:45:43,140 --> 00:45:45,900
And so here, we've now joined the two strings effectively,

980
00:45:45,900 --> 00:45:51,820
and thus was born our first formatted string.

981
00:45:51,820 --> 00:45:54,700
Any questions, then, on that?

982
00:45:54,700 --> 00:45:55,200
Yeah?

983
00:45:55,560 --> 00:45:59,120
Would you want to say something extra after?

984
00:45:59,120 --> 00:46:01,240
If you want to say something extra after,

985
00:46:01,240 --> 00:46:02,960
you could certainly continue the logic.

986
00:46:02,960 --> 00:46:06,680
You don't have to end this quoted expression with percent s.

987
00:46:06,680 --> 00:46:11,120
You could say, hello, comma, percent s, comma, nice to meet you.

988
00:46:11,120 --> 00:46:13,560
And then what printf will do is it's only going

989
00:46:13,560 --> 00:46:17,680
to substitute that variable called answer, where the percent s is.

990
00:46:17,680 --> 00:46:21,520
And if you wanted to have 2% s's, you could just add another comma here

991
00:46:21,520 --> 00:46:24,200
and pass in another variable, and a third variable, and even more,

992
00:46:24,200 --> 00:46:27,440
thus formatting the string even more detailed.

993
00:46:27,440 --> 00:46:28,800
Question over here?

994
00:46:28,800 --> 00:46:29,560
Other questions?

995
00:46:29,560 --> 00:46:30,640
Yeah, in the back.

996
00:46:30,640 --> 00:46:38,360
How do you make a distinction between the placeholders if you have

997
00:46:38,360 --> 00:46:39,440
different variables?

998
00:46:39,440 --> 00:46:41,360
It's the ordering from left to right.

999
00:46:41,360 --> 00:46:44,640
So in this case, it's a trivial example because there's only one variable

1000
00:46:44,640 --> 00:46:45,720
and one placeholder.

1001
00:46:45,720 --> 00:46:48,640
But if, as you were hinting, I had multiple, percent s, something,

1002
00:46:48,640 --> 00:46:51,280
something, something, percent s, something, something, something,

1003
00:46:51,280 --> 00:46:55,720
I would just make sure that I pass printf, the first variable, comma,

1004
00:46:55,720 --> 00:46:59,880
the second variable, comma, the third variable, and so forth left to right.

1005
00:46:59,880 --> 00:47:00,680
Other questions?

1006
00:47:00,680 --> 00:47:01,680
Yeah?

1007
00:47:01,680 --> 00:47:04,280
Why is there no comma, comma, percent s?

1008
00:47:04,280 --> 00:47:06,720
Damn it, because I screwed up and didn't include that,

1009
00:47:06,720 --> 00:47:09,680
and I was going to fix it after class quickly.

1010
00:47:09,680 --> 00:47:10,180
Bug.

1011
00:47:10,180 --> 00:47:11,240
It's a bug.

1012
00:47:11,240 --> 00:47:11,740
Yeah?

1013
00:47:11,740 --> 00:47:15,240
I bet you want to use the answer twice in the string.

1014
00:47:15,240 --> 00:47:17,920
Do you want to say, hello, David, hi, David?

1015
00:47:17,920 --> 00:47:21,260
Sure, same exact thing, comma, answer, comma, answer.

1016
00:47:21,260 --> 00:47:22,620
With 2% s's.

1017
00:47:22,620 --> 00:47:26,180
If you want to say the same variable twice in two places for whatever reason,

1018
00:47:26,180 --> 00:47:29,060
two placeholders, and then answer, comma, answer.

1019
00:47:29,060 --> 00:47:31,180
To plug that in twice.

1020
00:47:31,180 --> 00:47:31,460
Other question?

1021
00:47:31,460 --> 00:47:31,960
Yeah?

1022
00:47:31,960 --> 00:47:32,460
Yeah?

1023
00:47:32,460 --> 00:47:35,740
It's going to happen in the first place for a lot of people.

1024
00:47:35,740 --> 00:47:37,660
No, and we're going to see some others in just a bit.

1025
00:47:37,660 --> 00:47:38,660
It turns out there's others.

1026
00:47:38,660 --> 00:47:41,940
It's percent i for integer, and there's going to be even more than that.

1027
00:47:41,940 --> 00:47:44,980
Percent c for a single character and more.

1028
00:47:44,980 --> 00:47:46,780
Other questions?

1029
00:47:46,780 --> 00:47:47,280
Yeah?

1030
00:47:48,280 --> 00:47:52,400
Good question.

1031
00:47:52,400 --> 00:47:54,920
If I did have correctly, and if this weren't a PDF,

1032
00:47:54,920 --> 00:47:56,280
I would just edit it on the fly.

1033
00:47:56,280 --> 00:48:02,200
If I had the percent n, it always has to go in the formatted string,

1034
00:48:02,200 --> 00:48:03,760
in the first argument.

1035
00:48:03,760 --> 00:48:07,160
So the only thing that comes after printf's first argument

1036
00:48:07,160 --> 00:48:10,960
is optionally variable, comma, variable, comma, variable, comma,

1037
00:48:10,960 --> 00:48:12,280
variable.

1038
00:48:12,280 --> 00:48:14,800
Other questions?

1039
00:48:14,800 --> 00:48:15,320
All right.

1040
00:48:15,360 --> 00:48:18,960
So let's go ahead and actually do something with code.

1041
00:48:18,960 --> 00:48:20,920
I'm going to go ahead and open up another window,

1042
00:48:20,920 --> 00:48:23,280
and this is a tool called CS50 Sandbox.

1043
00:48:23,280 --> 00:48:27,600
And this is a tool via the web via which you can actually play with code.

1044
00:48:27,600 --> 00:48:30,680
And I'll show you in just a moment how I get to this particular location.

1045
00:48:30,680 --> 00:48:33,800
But let me first explain the user interface, much like we started off

1046
00:48:33,800 --> 00:48:34,960
our conversation with Scratch.

1047
00:48:34,960 --> 00:48:36,560
So I need a place to write code.

1048
00:48:36,560 --> 00:48:38,800
The reality is I could just use my own Mac.

1049
00:48:38,800 --> 00:48:40,440
I could just use my own PC.

1050
00:48:40,440 --> 00:48:43,160
Frankly, I could even use certain mobile devices these days.

1051
00:48:43,160 --> 00:48:46,600
But then we would have hundreds of other people in the class,

1052
00:48:46,600 --> 00:48:49,120
all with slightly different configurations on their Macs,

1053
00:48:49,120 --> 00:48:51,160
and their PCs, and their phones, and the like.

1054
00:48:51,160 --> 00:48:53,880
And so everyone would kind of have different software and different settings,

1055
00:48:53,880 --> 00:48:55,440
and that just never works very well.

1056
00:48:55,440 --> 00:48:57,960
So at the beginning of the course, we just standardize everything

1057
00:48:57,960 --> 00:49:01,200
by actually using a web-based environment, just like Scratch is,

1058
00:49:01,200 --> 00:49:05,640
whereby we'll all have access to the exact same computer,

1059
00:49:05,640 --> 00:49:07,760
but virtualized in the so-called cloud.

1060
00:49:07,760 --> 00:49:09,720
If you've ever wondered what the cloud is,

1061
00:49:09,720 --> 00:49:12,680
it just means other people's servers somewhere on the internet

1062
00:49:12,680 --> 00:49:16,120
that people can use for free or to rent, and now have to host

1063
00:49:16,120 --> 00:49:18,080
those physical servers themselves.

1064
00:49:18,080 --> 00:49:22,280
So CS50 Sandbox, just like Scratch, is a cloud-based application

1065
00:49:22,280 --> 00:49:24,960
that someone else wrote that's hosted on the internet.

1066
00:49:24,960 --> 00:49:27,880
And the user interface, at first glance, looks just like this.

1067
00:49:27,880 --> 00:49:29,720
There's only two components to it.

1068
00:49:29,720 --> 00:49:33,200
At the top of the user interface of CS50 Sandbox

1069
00:49:33,200 --> 00:49:36,600
is just a code editor, a very simple text editor, similar in spirit

1070
00:49:36,600 --> 00:49:39,800
to Google Docs and Microsoft Word, and so forth, but much simpler.

1071
00:49:39,800 --> 00:49:40,760
There's no formatting.

1072
00:49:40,760 --> 00:49:42,280
There's no bold-facing in centering.

1073
00:49:42,280 --> 00:49:44,320
You can just type words of text.

1074
00:49:44,320 --> 00:49:46,680
Down here is a so-called terminal window,

1075
00:49:46,680 --> 00:49:48,720
but we'll come back to that in just a moment.

1076
00:49:48,720 --> 00:49:51,280
Let me go ahead and write my first program.

1077
00:49:51,280 --> 00:50:00,600
Let me go ahead and write include standardio.h int main void open curly

1078
00:50:00,600 --> 00:50:05,880
brace printf hello world backslash n semicolon done.

1079
00:50:05,880 --> 00:50:10,960
OK, now, few people in this room could probably whip up a parent program

1080
00:50:10,960 --> 00:50:12,760
that quickly, unless you do have prior background.

1081
00:50:12,760 --> 00:50:14,720
And if you did take APCS or something else,

1082
00:50:14,720 --> 00:50:17,800
looks kind of like Java, but not quite the same.

1083
00:50:17,800 --> 00:50:19,480
But this is my first program.

1084
00:50:19,480 --> 00:50:22,400
Now, recall from earlier, this was the black and white program

1085
00:50:22,400 --> 00:50:25,000
we saw on the slide just a little bit ago.

1086
00:50:25,000 --> 00:50:28,560
And even if you didn't quite appreciate what all the funky syntax is doing,

1087
00:50:28,560 --> 00:50:31,760
all of us probably had the intuition of what this program does,

1088
00:50:31,760 --> 00:50:35,240
which is just to print out the words at the end of the day, hello world.

1089
00:50:35,240 --> 00:50:39,080
And we'll tease apart in just a bit what all of these various lines are doing.

1090
00:50:39,080 --> 00:50:41,480
But the interesting part is what's highlighted in green here.

1091
00:50:41,480 --> 00:50:44,880
And this is just one of the features of CS50's sandbox.

1092
00:50:44,880 --> 00:50:48,440
It will color code different concepts within your code

1093
00:50:48,440 --> 00:50:49,840
so that they just kind of jump out at you.

1094
00:50:49,840 --> 00:50:50,960
The colors aren't actually there.

1095
00:50:50,960 --> 00:50:54,640
You don't have to color code things yourself.

1096
00:50:54,640 --> 00:50:57,520
It just does it automatically so that you can see the different components,

1097
00:50:57,520 --> 00:51:01,600
just like MIT colorizes the various Scratch puzzle pieces the same.

1098
00:51:01,600 --> 00:51:06,560
So this is a program that I want to call hello.

1099
00:51:06,560 --> 00:51:07,280
It's in a file.

1100
00:51:07,320 --> 00:51:09,720
This is just a tab up top called hello.c.

1101
00:51:09,720 --> 00:51:11,960
Because it turns out when you write a program in C,

1102
00:51:11,960 --> 00:51:16,480
you save it in files by human convention, whatever.c,

1103
00:51:16,480 --> 00:51:19,080
as the file extension, so to speak.

1104
00:51:19,080 --> 00:51:21,720
How do I run this program?

1105
00:51:21,720 --> 00:51:26,560
There's no green flag to click, which Scratch gave us.

1106
00:51:26,560 --> 00:51:28,520
So how do I actually run the program?

1107
00:51:28,520 --> 00:51:32,520
And frankly, moreover, the green flag seems to be the least of my concerns.

1108
00:51:32,520 --> 00:51:34,840
What is the language that any computer understands,

1109
00:51:34,840 --> 00:51:39,080
whether it's my Mac here or the cloud server, where this thing is?

1110
00:51:39,080 --> 00:51:40,560
Zeros and ones.

1111
00:51:40,560 --> 00:51:43,720
And we started with that sort of overwhelming slide of the lots of zeros

1112
00:51:43,720 --> 00:51:46,600
and ones, and that is the point we need to get to.

1113
00:51:46,600 --> 00:51:50,480
But hopefully, we ourselves don't have to write at that level of tedium.

1114
00:51:50,480 --> 00:51:54,600
So we need some way of converting this code from C,

1115
00:51:54,600 --> 00:51:56,480
which we'll start calling source code, which

1116
00:51:56,480 --> 00:52:00,680
is the English-like code we see on the screen that's mildly pleasurable

1117
00:52:00,680 --> 00:52:03,440
to write as opposed to just zeros and ones.

1118
00:52:03,440 --> 00:52:06,960
But we nonetheless need to convert it somehow to zeros and ones.

1119
00:52:06,960 --> 00:52:09,680
And so the way we can do this is essentially as follows.

1120
00:52:09,680 --> 00:52:14,480
If we have what we'll start calling our source code, which

1121
00:52:14,480 --> 00:52:19,000
can be written, in our case, in C, but you can write source code in Java,

1122
00:52:19,000 --> 00:52:21,720
in C++, in Python, in dozens of other language.

1123
00:52:21,720 --> 00:52:23,800
Source code is a generic term that just means the code

1124
00:52:23,800 --> 00:52:25,160
that we humans have written.

1125
00:52:25,160 --> 00:52:29,760
We need some way of converting it into zeros and ones, which henceforth

1126
00:52:29,760 --> 00:52:32,600
we're just going to call machine code, which feels like a reasonable name.

1127
00:52:32,600 --> 00:52:35,360
It's the zeros and ones that a machine understands.

1128
00:52:35,360 --> 00:52:38,280
How does a machine know what zeros and ones to understand?

1129
00:52:38,280 --> 00:52:42,000
Well, that's the whole reasoning behind having CPUs, central processing units,

1130
00:52:42,000 --> 00:52:43,200
the brains of a computer.

1131
00:52:43,200 --> 00:52:46,040
They are just hardwired at the factory, so to speak.

1132
00:52:46,040 --> 00:52:49,760
It entails factory to understand certain patterns of zeros and ones.

1133
00:52:49,760 --> 00:52:54,440
But the point for us now is we need to take source code, like the C program

1134
00:52:54,440 --> 00:52:56,960
I wrote a moment ago that's supposed to print hello world,

1135
00:52:56,960 --> 00:53:01,120
and somehow convert it to machine code.

1136
00:53:01,120 --> 00:53:04,480
So it turns out this is the step that humans who've come before us

1137
00:53:04,480 --> 00:53:05,560
have solved for us.

1138
00:53:05,560 --> 00:53:08,320
Other humans have already written programs

1139
00:53:08,320 --> 00:53:12,360
that we're going to start calling a compiler that allows us to convert

1140
00:53:12,360 --> 00:53:14,400
source code to machine code.

1141
00:53:14,400 --> 00:53:15,680
It's just one additional step.

1142
00:53:15,680 --> 00:53:17,680
This step did not exist in Scratch, but we're

1143
00:53:17,680 --> 00:53:21,440
going to run a program that's generally called a compiler

1144
00:53:21,440 --> 00:53:29,000
that we pass our program to as input and we get as output machine code,

1145
00:53:29,000 --> 00:53:32,440
thereby perfectly bringing us full circle to what computer science is

1146
00:53:32,440 --> 00:53:34,400
in now the context of programming.

1147
00:53:34,400 --> 00:53:37,320
Input source code, outputs machine code, the algorithm,

1148
00:53:37,320 --> 00:53:39,960
or the special software we're going to use in just a moment,

1149
00:53:39,960 --> 00:53:42,960
is called a compiler that just converts one to the other so that none of us

1150
00:53:42,960 --> 00:53:45,960
have to ever think about or write in zeros and ones.

1151
00:53:45,960 --> 00:53:48,440
So it's a little old school how you do this.

1152
00:53:48,440 --> 00:53:52,160
In Scratch, you obviously just hit the green flag and MIT and all those folks

1153
00:53:52,160 --> 00:53:53,440
took care of it for you.

1154
00:53:53,440 --> 00:53:56,680
We have to be a little more manual about this.

1155
00:53:56,680 --> 00:53:59,880
And that's where the second piece of the CS50 Sandbox user interface

1156
00:53:59,880 --> 00:54:00,920
comes into play.

1157
00:54:00,920 --> 00:54:03,000
Notice I have a blinking prompt here.

1158
00:54:03,000 --> 00:54:05,720
There's a dollar sign at left, which is just a common convention.

1159
00:54:05,720 --> 00:54:10,800
A dollar sign tends to, in these types of computers, represent a prompt.

1160
00:54:10,800 --> 00:54:12,360
It's waiting for me to type something.

1161
00:54:12,360 --> 00:54:15,520
And indeed, it's literally blinking, waiting for me to type something.

1162
00:54:15,520 --> 00:54:17,880
This is an example of a terminal window.

1163
00:54:17,880 --> 00:54:20,840
And your own Mac and your own PC actually has or can

1164
00:54:20,840 --> 00:54:22,360
have this exact same feature.

1165
00:54:22,360 --> 00:54:25,520
It's just all of us operate with graphical user interfaces these days.

1166
00:54:25,560 --> 00:54:27,920
So we've got buttons and menus and things to drag and click.

1167
00:54:27,920 --> 00:54:30,960
But back in the day, and typically in programming,

1168
00:54:30,960 --> 00:54:33,280
you don't bother with these sort of aesthetics.

1169
00:54:33,280 --> 00:54:37,480
You actually get your hands dirtier with just the keyboard alone typing

1170
00:54:37,480 --> 00:54:38,680
anything you want to do.

1171
00:54:38,680 --> 00:54:42,720
And at first, it might feel like a regression, like why are we giving up

1172
00:54:42,720 --> 00:54:46,720
all these beautiful amenities of modern computers, but it's more powerful.

1173
00:54:46,720 --> 00:54:47,880
And it's more explicit.

1174
00:54:47,880 --> 00:54:51,880
It lets you do exactly what you want to do by sending commands to the computer.

1175
00:54:51,880 --> 00:54:53,200
So this is my terminal one.

1176
00:54:53,200 --> 00:54:55,320
I can create others just to have multiple windows.

1177
00:54:55,320 --> 00:55:00,400
But this is giving me access to the underlying server that I now have access to.

1178
00:55:00,400 --> 00:55:03,720
So if any of you, when it comes time to the first problem set,

1179
00:55:03,720 --> 00:55:06,680
log into the same tool, you don't all have the same environment.

1180
00:55:06,680 --> 00:55:10,440
You all have your own isolated copies of the same software,

1181
00:55:10,440 --> 00:55:13,040
but your own storage space, so to speak.

1182
00:55:13,040 --> 00:55:18,600
So I need to somehow convert hello.c to zeros and ones.

1183
00:55:18,600 --> 00:55:21,240
And the way I'm going to do this is like this.

1184
00:55:21,280 --> 00:55:29,320
Clang, which stands for C language, hello.c, enter.

1185
00:55:29,320 --> 00:55:33,200
And the fact that I see nothing happening is actually an amazing thing,

1186
00:55:33,200 --> 00:55:36,000
because there's an infinite number of things, frankly, that can go wrong.

1187
00:55:36,000 --> 00:55:38,960
And the computer will happily yell at you with its cryptic-looking error

1188
00:55:38,960 --> 00:55:41,040
messages if any of those things do go wrong.

1189
00:55:41,040 --> 00:55:44,640
So seeing nothing but another blinking prompt with a dollar sign

1190
00:55:44,640 --> 00:55:45,800
is actually a good thing.

1191
00:55:45,800 --> 00:55:49,080
My code has somehow been converted to zeros and ones.

1192
00:55:49,080 --> 00:55:50,960
Where are those zeros and ones?

1193
00:55:50,960 --> 00:55:54,560
Well, by convention, they are stored in a file that's

1194
00:55:54,560 --> 00:55:57,800
weirdly and historically just called a.out.

1195
00:55:57,800 --> 00:55:58,600
And we can see that.

1196
00:55:58,600 --> 00:56:01,520
If I click this folder icon up here, you'll actually

1197
00:56:01,520 --> 00:56:06,720
see my file, hello.c, and another file now called a.out.

1198
00:56:06,720 --> 00:56:09,720
Stands for assembly output, but for historical reasons.

1199
00:56:09,720 --> 00:56:12,640
Now, if I let me close the folder icon, because we're generally not

1200
00:56:12,640 --> 00:56:16,320
going to use the graphical user interface, how do I run that program?

1201
00:56:16,320 --> 00:56:17,840
I couldn't just double click on the icon.

1202
00:56:17,840 --> 00:56:18,560
This isn't a Mac.

1203
00:56:18,560 --> 00:56:19,600
This isn't a PC.

1204
00:56:19,600 --> 00:56:22,240
This is a cloud-based Linux environment.

1205
00:56:22,240 --> 00:56:24,240
Linux is a super popular operating system.

1206
00:56:24,240 --> 00:56:27,000
Happens to be used by lots of computer scientists, lots of websites,

1207
00:56:27,000 --> 00:56:27,760
lots of servers.

1208
00:56:27,760 --> 00:56:30,080
In fact, almost every website you visit these days

1209
00:56:30,080 --> 00:56:34,120
is powered, if not by Windows, by Linux and variations thereof called

1210
00:56:34,120 --> 00:56:36,280
Unix and other flavors still.

1211
00:56:36,280 --> 00:56:38,760
It's just a very popular and often free operating system

1212
00:56:38,760 --> 00:56:41,080
that CS50 Sandbox itself uses.

1213
00:56:41,080 --> 00:56:46,040
To run a file called a.out that's in this folder, so to speak,

1214
00:56:46,040 --> 00:56:48,040
even though you don't see a graphical version of it,

1215
00:56:48,080 --> 00:56:51,520
you literally just type dot slash a.out.

1216
00:56:51,520 --> 00:56:55,880
Completely non-obvious and kind of a stupid name for the program.

1217
00:56:55,880 --> 00:56:59,880
But this is the equivalent in your Mac or PC of double-clicking on an icon.

1218
00:56:59,880 --> 00:57:00,960
Let me go ahead and hit Enter.

1219
00:57:00,960 --> 00:57:04,640
And when I do, I should hopefully see what?

1220
00:57:04,640 --> 00:57:05,320
Hello, world.

1221
00:57:05,320 --> 00:57:07,000
And here we go.

1222
00:57:07,000 --> 00:57:09,440
Wow, that's our first program.

1223
00:57:09,440 --> 00:57:13,240
Like, it's not doing all that much, but it's at least doing what we promised it

1224
00:57:13,240 --> 00:57:13,720
would do.

1225
00:57:13,720 --> 00:57:17,360
And this is the equivalent in scratch of just saying on the screen, hello,

1226
00:57:17,360 --> 00:57:17,760
world.

1227
00:57:17,760 --> 00:57:19,640
Now, to be fair, there were more steps involved.

1228
00:57:19,640 --> 00:57:22,960
And God knows there was more cryptic-looking code to write.

1229
00:57:22,960 --> 00:57:25,160
But at the end of the day, all we've done now

1230
00:57:25,160 --> 00:57:27,920
is re-implement last week's logic in this newer language.

1231
00:57:27,920 --> 00:57:31,880
But we're now going to very quickly introduce new puzzle pieces, but in C.

1232
00:57:31,880 --> 00:57:34,440
But first, let's solve this sort of minor headache.

1233
00:57:34,440 --> 00:57:37,600
I don't really want to sort of tell friends, like, hey, everyone,

1234
00:57:37,600 --> 00:57:39,600
come run my a.out program.

1235
00:57:39,600 --> 00:57:41,040
Like, let's give it a real name.

1236
00:57:41,040 --> 00:57:42,920
Suppose I just want to call my program hello,

1237
00:57:42,920 --> 00:57:45,520
like you might download from the App Store or Google Play Store.

1238
00:57:45,520 --> 00:57:47,240
Programs have names.

1239
00:57:47,240 --> 00:57:48,600
So how do I do that?

1240
00:57:48,600 --> 00:57:52,760
Well, it turns out, in a terminal window, the so-called command line

1241
00:57:52,760 --> 00:57:54,880
environment, which is just a fancy way of saying you

1242
00:57:54,880 --> 00:57:57,280
write lines of commands with your keyboard,

1243
00:57:57,280 --> 00:58:02,040
you can actually pass in what are called command line arguments.

1244
00:58:02,040 --> 00:58:06,760
Additional inputs to programs that are just words that you type at your keyboard

1245
00:58:06,760 --> 00:58:08,000
that tell it how to behave.

1246
00:58:08,000 --> 00:58:12,160
So instead of just running clang on hello.c,

1247
00:58:12,160 --> 00:58:13,920
I'm actually going to be more explicit.

1248
00:58:13,920 --> 00:58:18,360
And I'm going to tell clang, please output, as is implied by literally

1249
00:58:18,360 --> 00:58:23,320
typing dash o for output, a file called hello instead.

1250
00:58:23,320 --> 00:58:27,880
So it's a little more verbose, hello, dash o, hello, sorry, clang,

1251
00:58:27,880 --> 00:58:30,080
dash o, hello, hello.c.

1252
00:58:30,080 --> 00:58:34,160
But what this is going to do now is still convert source code to machine code,

1253
00:58:34,160 --> 00:58:37,440
but it's going to save it in a file called hello.

1254
00:58:37,440 --> 00:58:40,720
And indeed, now I have hello.c, a.out, and hello,

1255
00:58:40,720 --> 00:58:43,680
as pictured in the little graphical folder there.

1256
00:58:43,680 --> 00:58:47,640
So now I can instead run dot slash hello.

1257
00:58:47,640 --> 00:58:48,280
What should it say?

1258
00:58:48,280 --> 00:58:49,840
Hopefully the same.

1259
00:58:49,840 --> 00:58:51,160
Enter.

1260
00:58:51,160 --> 00:58:51,960
So that's it.

1261
00:58:51,960 --> 00:58:53,440
Those are called command line arguments.

1262
00:58:53,440 --> 00:58:57,120
And it's just sort of the old school way of telling a text-based command

1263
00:58:57,120 --> 00:58:59,320
how to behave a little bit differently from its defaults.

1264
00:58:59,320 --> 00:59:01,480
But frankly, this is going to get tedious quickly.

1265
00:59:01,480 --> 00:59:03,920
Like, we aren't going to want to write our code.

1266
00:59:03,920 --> 00:59:06,880
And then every darn time we want to convert it to 0s and 1s to run it,

1267
00:59:06,880 --> 00:59:11,040
actually remember these sort of magical incantations of commands.

1268
00:59:11,040 --> 00:59:13,800
And so humans have abstracted these away too.

1269
00:59:13,800 --> 00:59:16,760
It turns out that if you want to make a program from source code

1270
00:59:16,760 --> 00:59:19,400
into machine code, there's another command you can use.

1271
00:59:19,400 --> 00:59:23,640
And you can literally type make hello, where hello is the name of the program

1272
00:59:23,640 --> 00:59:25,040
you want to make.

1273
00:59:25,040 --> 00:59:30,800
This program, whose name is make, will look for a file by default called

1274
00:59:30,800 --> 00:59:35,280
hello.c, therefore saving you the time of specifying it.

1275
00:59:35,280 --> 00:59:36,560
Hit Enter Now.

1276
00:59:36,560 --> 00:59:38,920
And oh my god, look what it just did.

1277
00:59:38,920 --> 00:59:43,680
It has even more configuration options that are baked into it.

1278
00:59:43,680 --> 00:59:46,840
And we, the CS50 staff, configured CS50 sandbox

1279
00:59:46,840 --> 00:59:48,360
to have these various features.

1280
00:59:48,360 --> 00:59:51,040
And even though we're not going to go into detail on them now,

1281
00:59:51,040 --> 00:59:52,960
I'm going to wave my hand at what they actually do,

1282
00:59:52,960 --> 00:59:55,840
they just make additional features possible that we'll eventually get to.

1283
00:59:55,840 --> 00:59:58,640
But this would be otherwise the command that you all do

1284
00:59:58,640 --> 01:00:02,240
have to type in just two or three or four weeks time.

1285
01:00:02,240 --> 01:00:03,840
And no one can ever remember that.

1286
01:00:03,840 --> 01:00:05,000
I certainly couldn't.

1287
01:00:05,000 --> 01:00:07,560
So make just automates that for you.

1288
01:00:07,600 --> 01:00:10,680
But when you run make, make is not a compiler.

1289
01:00:10,680 --> 01:00:15,560
Make is not the thing in the middle here, converting source code to machine code.

1290
01:00:15,560 --> 01:00:19,920
It's just a second program that some humans wrote years ago that

1291
01:00:19,920 --> 01:00:24,440
use clang in an automated way to achieve the same output.

1292
01:00:24,440 --> 01:00:26,480
Because people got tired of typing stuff like this,

1293
01:00:26,480 --> 01:00:30,840
so someone made a program called make that does it for us.

1294
01:00:30,840 --> 01:00:32,800
Any questions?

1295
01:00:32,800 --> 01:00:35,720
All right, let's add a little bit then to this program.

1296
01:00:35,720 --> 01:00:39,240
Instead of this version of hello, let me get some user input

1297
01:00:39,240 --> 01:00:41,160
and actually do something with it.

1298
01:00:41,160 --> 01:00:44,360
Suppose I actually want to get the user's name and then print that out.

1299
01:00:44,360 --> 01:00:46,800
Well, we saw the spoiler for that just a moment ago.

1300
01:00:46,800 --> 01:00:49,080
But let me go ahead and add it to this program here.

1301
01:00:49,080 --> 01:00:50,760
Now I have a second line of code.

1302
01:00:50,760 --> 01:00:52,720
And I want to get a string from a user.

1303
01:00:52,720 --> 01:00:56,800
And with what function do I get a string from the user?

1304
01:00:56,800 --> 01:00:58,040
Get string was the one.

1305
01:00:58,040 --> 01:01:02,160
And recall, I can do get underscore string, open parenthesis.

1306
01:01:02,160 --> 01:01:04,440
And then I have to pass in an argument, so to speak,

1307
01:01:05,400 --> 01:01:06,720
give me your name.

1308
01:01:06,720 --> 01:01:08,200
Actually, what did we say before?

1309
01:01:08,200 --> 01:01:10,640
What is your name, I think, was the prompt?

1310
01:01:10,640 --> 01:01:11,920
Backslash n?

1311
01:01:11,920 --> 01:01:12,880
Semicolon?

1312
01:01:12,880 --> 01:01:14,600
Now it's not enough to just get the string.

1313
01:01:14,600 --> 01:01:16,720
What do I want to do with it?

1314
01:01:16,720 --> 01:01:18,040
Yeah, store it in a variable.

1315
01:01:18,040 --> 01:01:19,640
What type of variable?

1316
01:01:19,640 --> 01:01:20,760
A string.

1317
01:01:20,760 --> 01:01:23,920
So I just need to go on the left-hand side of this line of code

1318
01:01:23,920 --> 01:01:26,080
and say, OK, well, give me a string.

1319
01:01:26,080 --> 01:01:29,200
I'll call it name, but I could call it x or y or anything.

1320
01:01:29,200 --> 01:01:31,320
But name feels like a good descriptor for it.

1321
01:01:31,320 --> 01:01:34,280
Using a single equal sign to copy from right to left.

1322
01:01:34,280 --> 01:01:35,840
And now I've got that.

1323
01:01:35,840 --> 01:01:39,640
Now it's not sufficient to just store the value in the variable.

1324
01:01:39,640 --> 01:01:40,920
I need to print it out.

1325
01:01:40,920 --> 01:01:44,760
So let me start with this.

1326
01:01:44,760 --> 01:01:46,920
It auto-saves the sandbox, so I don't even

1327
01:01:46,920 --> 01:01:48,680
have to go up to file-save or anything.

1328
01:01:48,680 --> 01:01:51,520
Let me go ahead and do make hello now.

1329
01:01:51,520 --> 01:01:53,640
Uh-oh.

1330
01:01:53,640 --> 01:01:55,720
Oh my god, look at all these errors already.

1331
01:01:55,720 --> 01:01:58,160
So clearly something is wrong, as the computer

1332
01:01:58,160 --> 01:01:59,560
has fond of telling me in red.

1333
01:01:59,560 --> 01:02:01,600
And frankly, this is where you very quickly get derailed.

1334
01:02:01,600 --> 01:02:03,520
They're kind of freaked out, because oh my god,

1335
01:02:03,560 --> 01:02:04,400
two lines of code.

1336
01:02:04,400 --> 01:02:06,920
How do I have 20 lines of errors somehow?

1337
01:02:06,920 --> 01:02:10,120
So the computer is kind of as confused as you.

1338
01:02:10,120 --> 01:02:12,880
And the most important thing when you face this kind of situation,

1339
01:02:12,880 --> 01:02:16,000
where it's just cryptic erroneous output, start at the top.

1340
01:02:16,000 --> 01:02:18,520
Even if your window's kind of small, and therefore a whole bunch of stuff

1341
01:02:18,520 --> 01:02:20,880
scrolls on the screen quickly, scroll up to the top.

1342
01:02:20,880 --> 01:02:23,520
Because odds are there's one mistake up at the very top,

1343
01:02:23,520 --> 01:02:26,480
and that one mistake just had a cascading effect on the computer,

1344
01:02:26,480 --> 01:02:28,640
on the compiler, that it just got really confused

1345
01:02:28,640 --> 01:02:31,680
and it just kept spitting out messages because it got tripped up early.

1346
01:02:31,720 --> 01:02:35,400
So let's scroll back up to the top here.

1347
01:02:35,400 --> 01:02:39,560
And here is the very long command that I said make automates for you.

1348
01:02:39,560 --> 01:02:40,960
So that's not erroneous.

1349
01:02:40,960 --> 01:02:43,080
Here seems to be the first error.

1350
01:02:43,080 --> 01:02:47,360
And it's a little cryptic still, but let's glean some information.

1351
01:02:47,360 --> 01:02:50,360
Here's a familiar phrase, hello.c.

1352
01:02:50,360 --> 01:02:52,360
Let me go ahead and zoom in on the bottom here.

1353
01:02:52,360 --> 01:02:56,560
So hello.c, you recall, is the name of my file, albeit nonobviously.

1354
01:02:56,560 --> 01:03:00,960
Clang is telling me, look at line five, and then your fifth character.

1355
01:03:00,960 --> 01:03:04,840
So this something, colon, something, means line number, character, or column number.

1356
01:03:04,840 --> 01:03:07,120
If you're looking from left to right, error means error.

1357
01:03:07,120 --> 01:03:10,840
And then this is where things get a little sophisticated.

1358
01:03:10,840 --> 01:03:17,000
Use of undeclared identifier string, did you mean standard in?

1359
01:03:17,000 --> 01:03:21,080
Now, I didn't, but I do recognize standard in, or rather,

1360
01:03:21,080 --> 01:03:22,640
it seems similar to standard I.O.

1361
01:03:22,640 --> 01:03:23,720
But no, I didn't mean that.

1362
01:03:23,720 --> 01:03:26,280
I'm pretty sure this code is right.

1363
01:03:26,280 --> 01:03:27,840
Well, why am I getting this error?

1364
01:03:27,840 --> 01:03:32,360
It sounds like string, on line five, fifth character, right there.

1365
01:03:32,360 --> 01:03:33,960
That is wrong.

1366
01:03:33,960 --> 01:03:37,360
Well, it turns out there is no such thing as a string.

1367
01:03:37,360 --> 01:03:41,560
C, the language, has integers, and it has Booleans, it turns out,

1368
01:03:41,560 --> 01:03:43,760
and it has characters and a few other things.

1369
01:03:43,760 --> 01:03:45,520
It actually doesn't have strings.

1370
01:03:45,520 --> 01:03:49,040
Strings is a word that's useful to describe sequences of characters,

1371
01:03:49,040 --> 01:03:50,080
paragraphs, words.

1372
01:03:50,080 --> 01:03:51,800
But string is not a type.

1373
01:03:51,800 --> 01:03:54,880
It's not a type of variable unless you make it so.

1374
01:03:54,880 --> 01:03:58,200
And in fact, this is one of the simplifications

1375
01:03:58,200 --> 01:04:01,560
we do in just the first couple of weeks of the course to get us off the ground.

1376
01:04:01,560 --> 01:04:06,200
It turns out that we need to add one line of code here.

1377
01:04:06,200 --> 01:04:10,080
We need to do not only include standard I.O., which we'll explain in a moment,

1378
01:04:10,080 --> 01:04:14,240
but also CS50, so-called library.

1379
01:04:14,240 --> 01:04:16,840
So CS50 has a lot of humans involved with it.

1380
01:04:16,840 --> 01:04:18,680
And over time, we've decided, you know what?

1381
01:04:18,680 --> 01:04:21,680
We could make the first hour of CS50 a little easier,

1382
01:04:21,680 --> 01:04:25,200
in the sort of on-ramp, a little cleaner for folks with no background,

1383
01:04:25,200 --> 01:04:28,400
by just inventing a few features ourselves, such as the ability

1384
01:04:28,400 --> 01:04:29,720
to get strings from the user.

1385
01:04:29,720 --> 01:04:32,600
So it turns out, getString is also not a function that comes with C.

1386
01:04:32,600 --> 01:04:36,360
That is a custom puzzle piece, so to speak, that CS50 made.

1387
01:04:36,360 --> 01:04:42,040
And where we created that function is essentially in a file called CS50.h.

1388
01:04:42,040 --> 01:04:46,360
And so by including CS50.h, you now get access to more puzzle pieces,

1389
01:04:46,360 --> 01:04:48,600
if you will, that we have created for you.

1390
01:04:48,600 --> 01:04:51,920
And it turns out, this line of code that has been here before

1391
01:04:51,920 --> 01:04:54,280
is also giving you features too.

1392
01:04:54,280 --> 01:04:57,720
We're just doing what everyone does in programming, which is solve a problem

1393
01:04:57,720 --> 01:05:00,280
once, and then let other people use that solution.

1394
01:05:00,280 --> 01:05:03,520
Take a guess, what functionality is actually

1395
01:05:03,520 --> 01:05:08,400
implemented in a file called standard I.O., input output.h?

1396
01:05:08,400 --> 01:05:12,640
This is just a file somewhere on the server that actually does come with C.

1397
01:05:12,640 --> 01:05:16,240
And it provides you with handy features, like what?

1398
01:05:16,240 --> 01:05:17,920
Say again?

1399
01:05:17,920 --> 01:05:18,880
Once more?

1400
01:05:18,880 --> 01:05:19,720
Printf.

1401
01:05:19,720 --> 01:05:24,680
It turns out that the means by which you are allowed to use a function called

1402
01:05:24,680 --> 01:05:29,040
printf here is you have to include the file in which it is declared.

1403
01:05:29,040 --> 01:05:33,040
So some humans years ago literally wrote a function, a puzzle piece called

1404
01:05:33,040 --> 01:05:36,480
printf, and they figured out how to actually draw characters on the screen.

1405
01:05:36,480 --> 01:05:41,240
They then stored information about that function in a file called standard I.O.h.

1406
01:05:41,240 --> 01:05:44,680
If I had not included that seemingly cryptic line of code

1407
01:05:44,680 --> 01:05:48,720
at the very top of my previous program, even that hello world program would not

1408
01:05:48,720 --> 01:05:51,520
have worked, because clang, the compiler, wouldn't

1409
01:05:51,520 --> 01:05:52,880
have known what I'm talking about.

1410
01:05:52,880 --> 01:05:53,640
What is printf?

1411
01:05:53,640 --> 01:05:57,840
I don't know what that is, unless you tell it to also include this file

1412
01:05:57,840 --> 01:06:01,640
that humans wrote years ago in which printf has been created.

1413
01:06:01,640 --> 01:06:06,040
And now, if I want to use getString as well as the new keyword string,

1414
01:06:06,040 --> 01:06:10,440
I need to tell clang, the compiler, also go ahead and look in cs50.h

1415
01:06:10,440 --> 01:06:14,040
for more functionality, such as string and getString.

1416
01:06:14,080 --> 01:06:17,360
So let me go ahead now and try this again.

1417
01:06:17,360 --> 01:06:21,160
I'm going to clear my terminal here and just try that same command again.

1418
01:06:21,160 --> 01:06:24,760
Make, hello, enter.

1419
01:06:24,760 --> 01:06:25,760
Damn it.

1420
01:06:25,760 --> 01:06:28,920
Now I've got another error, but, but, but, progress.

1421
01:06:28,920 --> 01:06:30,000
Well, no, well, no.

1422
01:06:30,000 --> 01:06:32,320
Just as many errors as before somehow.

1423
01:06:32,320 --> 01:06:33,720
But different ones.

1424
01:06:33,720 --> 01:06:37,360
Notice now, well, wait, that was before.

1425
01:06:37,360 --> 01:06:38,200
Oh, no, I'm sorry.

1426
01:06:38,200 --> 01:06:39,040
It is fewer errors.

1427
01:06:39,040 --> 01:06:41,160
Here's where I ran the command a moment ago.

1428
01:06:41,160 --> 01:06:43,640
And now I'm getting this error instead.

1429
01:06:43,640 --> 01:06:45,000
OK, so progress.

1430
01:06:45,000 --> 01:06:46,480
Now my error is not on line five.

1431
01:06:46,480 --> 01:06:50,400
It's on line six, though fun fact, line six used to be line five.

1432
01:06:50,400 --> 01:06:53,160
So it's apparently still involved in the problem.

1433
01:06:53,160 --> 01:06:54,880
So let's read the error message.

1434
01:06:54,880 --> 01:06:58,840
The problem is on line six, which not surprising is that one there.

1435
01:06:58,840 --> 01:06:59,880
But this time it's different.

1436
01:06:59,880 --> 01:07:02,960
Error, unused variable name.

1437
01:07:02,960 --> 01:07:07,200
OK, that one I kind of understand even without being a programmer.

1438
01:07:07,200 --> 01:07:10,040
What does the, what does it mean?

1439
01:07:10,040 --> 01:07:11,040
Yeah?

1440
01:07:12,040 --> 01:07:14,960
Uh, maybe declare prior to using.

1441
01:07:14,960 --> 01:07:17,080
But turns out this is how you declare it.

1442
01:07:17,080 --> 01:07:23,520
But I'm actually, yeah, yeah, I'm just kind of wasting the computer's time.

1443
01:07:23,520 --> 01:07:24,600
I'm creating it.

1444
01:07:24,600 --> 01:07:26,240
So line six on the left is correct.

1445
01:07:26,240 --> 01:07:30,680
Hey, computer, give me a string variable and call it name and put a value in it.

1446
01:07:30,680 --> 01:07:33,520
But what's the point of that exercise if you're never, as you say,

1447
01:07:33,520 --> 01:07:34,920
doing anything with it?

1448
01:07:34,920 --> 01:07:38,840
And in fact, recall from the slide a moment ago, how do I do something with it?

1449
01:07:38,840 --> 01:07:40,960
Well, this is not how you do something with it.

1450
01:07:40,960 --> 01:07:43,480
If I go ahead and run this program now successfully,

1451
01:07:43,480 --> 01:07:46,280
what would I actually see on the screen?

1452
01:07:46,280 --> 01:07:47,800
Like literally, hello name.

1453
01:07:47,800 --> 01:07:51,680
H-E-L-L-O comma space N-A-M-E, obviously not correct.

1454
01:07:51,680 --> 01:07:53,040
So how do I plug in the variable?

1455
01:07:53,040 --> 01:07:55,000
What was the trick?

1456
01:07:55,000 --> 01:07:59,960
Yeah, percent s for string, a format code, so to speak, hence the name print f.

1457
01:07:59,960 --> 01:08:03,200
And then I need to pass a second argument to print f.

1458
01:08:03,200 --> 01:08:06,840
And I do that with a comma and then the name of the variable I want to plug in.

1459
01:08:06,840 --> 01:08:09,120
Now notice there are two commas in this line here.

1460
01:08:09,120 --> 01:08:11,640
If I zoom in, notice there's two commas.

1461
01:08:11,640 --> 01:08:14,840
But there's only two arguments or inputs to print f.

1462
01:08:14,840 --> 01:08:18,000
The input to a function is just typically called an argument

1463
01:08:18,000 --> 01:08:19,800
or also called a parameter.

1464
01:08:19,800 --> 01:08:23,600
So there are two commas, but this one is an English comma,

1465
01:08:23,600 --> 01:08:26,440
just separating hello from the person's name.

1466
01:08:26,440 --> 01:08:30,560
This white comma here, color coded because the sandbox is doing that for me,

1467
01:08:30,560 --> 01:08:35,360
is actually separating, excuse me, the first argument from the second argument.

1468
01:08:35,400 --> 01:08:39,600
So now for a third time, make hello, enter.

1469
01:08:39,600 --> 01:08:40,800
Oh my god, thank you.

1470
01:08:40,800 --> 01:08:41,800
Now it worked.

1471
01:08:41,800 --> 01:08:45,560
It still spit out this pretty long cryptic command in white, but that's OK.

1472
01:08:45,560 --> 01:08:49,640
That is, again, the automated command that make is making possible for us.

1473
01:08:49,640 --> 01:08:53,080
But the fact that I see no red, no errors, just another blinking prompt

1474
01:08:53,080 --> 01:08:55,040
means that my program has been made.

1475
01:08:55,040 --> 01:09:00,480
So let me go ahead and do, how do I run a program if it's called hello?

1476
01:09:00,480 --> 01:09:01,920
Yeah, dot slash hello.

1477
01:09:01,920 --> 01:09:04,200
And we'll see why you have the stupid dot at the beginning.

1478
01:09:04,200 --> 01:09:07,560
It essentially means run the program called hello that's right here

1479
01:09:07,560 --> 01:09:11,080
in your current folder on the server, dot slash hello.

1480
01:09:11,080 --> 01:09:11,800
What is your name?

1481
01:09:11,800 --> 01:09:13,120
Very nice.

1482
01:09:13,120 --> 01:09:15,040
David, enter.

1483
01:09:15,040 --> 01:09:16,200
Hello, David.

1484
01:09:16,200 --> 01:09:17,160
Interesting.

1485
01:09:17,160 --> 01:09:20,600
Let's make one tweak because I did this by accident earlier, as you noted.

1486
01:09:20,600 --> 01:09:23,720
What if I left off, for instance, one of these backslash ends?

1487
01:09:23,720 --> 01:09:26,440
That's literally now not telling the computer

1488
01:09:26,440 --> 01:09:28,320
to move the cursor to another line.

1489
01:09:28,320 --> 01:09:31,560
So let me go ahead and rerun the program.

1490
01:09:31,560 --> 01:09:32,120
Wait a minute.

1491
01:09:32,120 --> 01:09:34,200
That looks the same.

1492
01:09:34,200 --> 01:09:38,000
I just changed the code, but it's still behaving exactly the same.

1493
01:09:38,000 --> 01:09:40,880
Where's my confusion?

1494
01:09:40,880 --> 01:09:42,080
I didn't recompile it.

1495
01:09:42,080 --> 01:09:44,400
Unlike Scratch, which is amazing because you just hit the green flag

1496
01:09:44,400 --> 01:09:47,600
and it runs the code again, we have a second intermediate step.

1497
01:09:47,600 --> 01:09:49,360
I have to rerun the code.

1498
01:09:49,360 --> 01:09:50,800
Now, how do you get out of a program?

1499
01:09:50,800 --> 01:09:51,560
I could just hit Enter.

1500
01:09:51,560 --> 01:09:54,680
You can also hit Control C for cancel, and that will just get you out

1501
01:09:54,680 --> 01:09:56,320
of whatever confusion you're in.

1502
01:09:56,320 --> 01:09:57,400
Let me go ahead and rerun.

1503
01:09:57,400 --> 01:09:58,760
Make hello.

1504
01:09:58,760 --> 01:10:00,080
Seems to be OK.

1505
01:10:00,080 --> 01:10:02,720
Dot slash hello, Enter.

1506
01:10:02,720 --> 01:10:05,720
OK, this is why I've had all those backslash ends.

1507
01:10:05,720 --> 01:10:07,920
Let me zoom in on what's happening.

1508
01:10:07,920 --> 01:10:12,160
I mean, it doesn't look horrible, but frankly, it kind of rubs me the wrong

1509
01:10:12,160 --> 01:10:15,320
way if this is what my program looks like when I'm typing in user input.

1510
01:10:15,320 --> 01:10:16,560
I mean, this just looks stupid.

1511
01:10:16,560 --> 01:10:18,560
Minimally, I should add a space.

1512
01:10:18,560 --> 01:10:20,560
Maybe I could put backslash end to move the character.

1513
01:10:20,560 --> 01:10:21,880
This is just user interface now.

1514
01:10:21,880 --> 01:10:23,080
This isn't really logic.

1515
01:10:23,080 --> 01:10:25,400
It's just aesthetics, but I think this looks stupid.

1516
01:10:25,400 --> 01:10:28,040
So that's why I've had the backslash ends there all the time,

1517
01:10:28,040 --> 01:10:31,640
but that's why they need to be there to tell the computer to actually put

1518
01:10:31,640 --> 01:10:32,800
things where you want them.

1519
01:10:32,800 --> 01:10:34,160
Alternatively, you know what?

1520
01:10:34,160 --> 01:10:35,040
OK, I don't like that.

1521
01:10:35,040 --> 01:10:36,440
Control C for cancel.

1522
01:10:36,440 --> 01:10:37,760
Let me put this one back.

1523
01:10:37,760 --> 01:10:39,880
What happens if I get rid of this one?

1524
01:10:39,880 --> 01:10:43,840
And let me go ahead and recompile the code first, as you note.

1525
01:10:43,840 --> 01:10:46,040
Dot slash hello, Enter.

1526
01:10:46,040 --> 01:10:49,080
OK, I've cleaned up that aesthetic headache.

1527
01:10:49,080 --> 01:10:50,400
Enter.

1528
01:10:50,400 --> 01:10:55,280
OK, I mean, it's not quite the same problem, but this looks stupid too,

1529
01:10:55,280 --> 01:10:57,320
because the dollar sign just represents my prompt,

1530
01:10:57,320 --> 01:11:00,640
where I'm supposed to type commands, and yet hello comma David prompt.

1531
01:11:00,640 --> 01:11:01,280
This is messy.

1532
01:11:01,280 --> 01:11:03,560
So this is why we've had all of these new lines.

1533
01:11:03,560 --> 01:11:06,480
Now, you asked earlier, what if you put the new line elsewhere in the string?

1534
01:11:06,480 --> 01:11:07,600
Well, suppose I do that.

1535
01:11:07,600 --> 01:11:09,080
Suppose I put a couple of them.

1536
01:11:09,080 --> 01:11:10,000
Let me do this.

1537
01:11:10,000 --> 01:11:11,680
And no space is whatsoever.

1538
01:11:11,680 --> 01:11:14,600
Now, this is looking a little weird, but the computer is just

1539
01:11:14,600 --> 01:11:15,880
going to interpret this literally.

1540
01:11:15,880 --> 01:11:18,720
Print H-E-L-L-L comma new line.

1541
01:11:18,720 --> 01:11:22,000
Substitute in the string for percent s, then another new line.

1542
01:11:22,000 --> 01:11:26,280
So how many lines of output is this going to display?

1543
01:11:26,320 --> 01:11:27,040
I heard four.

1544
01:11:30,280 --> 01:11:30,920
Other values?

1545
01:11:30,920 --> 01:11:31,640
Let's see.

1546
01:11:31,640 --> 01:11:36,000
Let's go ahead and make hello, and then run dot slash hello.

1547
01:11:36,000 --> 01:11:38,080
What is your name as before?

1548
01:11:38,080 --> 01:11:40,360
Enter hello comma new line David.

1549
01:11:40,360 --> 01:11:45,160
So four total lines, certainly, or just two lines from the computer itself.

1550
01:11:45,160 --> 01:11:48,640
So just to recap then, with code like this,

1551
01:11:48,640 --> 01:11:55,280
how many functions have I used in this particular program?

1552
01:11:55,280 --> 01:11:56,120
How many functions?

1553
01:11:59,720 --> 01:12:00,320
So it's two.

1554
01:12:00,320 --> 01:12:02,920
Print F, which we've been using, and get string, which is the new one.

1555
01:12:02,920 --> 01:12:06,120
Where is get string declared?

1556
01:12:06,120 --> 01:12:11,280
CS50.H, print F, meanwhile, is declared in standard IO.H, standard input output.

1557
01:12:11,280 --> 01:12:15,480
Meanwhile, string, this data type, also comes from CS50 itself.

1558
01:12:15,480 --> 01:12:18,120
And then we've used the format codes, and we've used variables

1559
01:12:18,120 --> 01:12:19,480
to achieve the same result.

1560
01:12:19,480 --> 01:12:20,800
And let's just hammer this one.

1561
01:12:20,800 --> 01:12:23,880
Brian and Karim, do you mind popping up for just a second?

1562
01:12:23,880 --> 01:12:25,040
Or who's that?

1563
01:12:25,040 --> 01:12:26,680
Aaron, come on up.

1564
01:12:26,680 --> 01:12:30,200
So just to make this clear, because there's now some terminology

1565
01:12:30,200 --> 01:12:31,600
that we want to use.

1566
01:12:31,600 --> 01:12:34,240
Let's see, do you want to be get string?

1567
01:12:34,240 --> 01:12:37,920
OK, so we have some name tags here, like you get it, events.

1568
01:12:37,920 --> 01:12:42,760
So Aaron shall be get underscore string.

1569
01:12:42,760 --> 01:12:45,680
If you want to go ahead and put this on.

1570
01:12:45,680 --> 01:12:49,440
OK, and Brian, you want to be print F.

1571
01:12:49,440 --> 01:12:51,760
So we won't act out all of our actual programs,

1572
01:12:51,760 --> 01:12:53,480
because this will quickly become obvious.

1573
01:12:53,480 --> 01:12:57,240
So Brian is print F. So this point, though, remains,

1574
01:12:57,240 --> 01:13:00,280
in that this is nice that I have some colleagues with whom I work here,

1575
01:13:00,280 --> 01:13:04,760
because I don't really want to do all of the hard work of making things happen.

1576
01:13:04,760 --> 01:13:08,000
And so if I'm instead the programmer, or the orchestrator of a whole bunch

1577
01:13:08,000 --> 01:13:11,920
of things happening, I can actually implement this code now more physically.

1578
01:13:11,920 --> 01:13:15,640
And let's focus, though, for just a moment on what the key takeaways are.

1579
01:13:15,640 --> 01:13:18,640
One, functions can take inputs.

1580
01:13:18,640 --> 01:13:21,840
Those inputs are called arguments or parameters.

1581
01:13:21,840 --> 01:13:23,840
And functions can return things.

1582
01:13:23,840 --> 01:13:25,560
They can have return values.

1583
01:13:25,560 --> 01:13:26,880
Print F, for instance.

1584
01:13:26,880 --> 01:13:27,760
Does it take inputs?

1585
01:13:30,360 --> 01:13:31,960
What's the input to print F, for instance?

1586
01:13:34,600 --> 01:13:35,680
Yeah, like hello world.

1587
01:13:35,680 --> 01:13:39,880
Whatever it is you want to print is, by definition, the input to print F.

1588
01:13:39,880 --> 01:13:44,040
Does print F return a value thus far?

1589
01:13:44,040 --> 01:13:46,040
It does do something on the screen, certainly.

1590
01:13:46,040 --> 01:13:47,320
Like it prints stuff on the screen.

1591
01:13:47,320 --> 01:13:49,320
But we haven't seen it return something,

1592
01:13:49,320 --> 01:13:52,560
because we haven't seen it with an equal sign to the left.

1593
01:13:52,560 --> 01:13:54,400
Now, it turns out print F does return things.

1594
01:13:54,400 --> 01:13:56,480
It's just not often that useful to use.

1595
01:13:56,480 --> 01:13:59,000
But we've only seen print F for the moment as taking inputs.

1596
01:13:59,000 --> 01:14:00,360
More on that another time.

1597
01:14:00,360 --> 01:14:01,320
Get string, meanwhile.

1598
01:14:01,320 --> 01:14:04,400
Does get string take inputs?

1599
01:14:04,400 --> 01:14:06,560
How many inputs?

1600
01:14:06,560 --> 01:14:09,680
Just one, the prompt that you want the human to see.

1601
01:14:09,680 --> 01:14:11,640
The first prompt I used was, what is your name?

1602
01:14:11,640 --> 01:14:14,560
I could make the prompt anything, but that's the question that get string is asking.

1603
01:14:14,560 --> 01:14:16,920
Does get string return a value?

1604
01:14:16,920 --> 01:14:17,520
It does.

1605
01:14:17,520 --> 01:14:21,040
That's, of course, in Scratch called answer, hard coded as answer.

1606
01:14:21,040 --> 01:14:22,880
We can store it in any variable we want.

1607
01:14:22,880 --> 01:14:24,800
So let me just go ahead and implement this program.

1608
01:14:24,800 --> 01:14:30,080
Aaron, go get me a string and ask the person, what is their name?

1609
01:14:30,080 --> 01:14:41,200
So she's writing down Elizabeth now.

1610
01:14:41,200 --> 01:14:42,640
But Aaron has taken input from me.

1611
01:14:42,640 --> 01:14:44,880
Aaron, go get someone's name and ask them, what is their name?

1612
01:14:44,880 --> 01:14:46,960
Now you've produced output for me.

1613
01:14:46,960 --> 01:14:47,960
Thank you.

1614
01:14:47,960 --> 01:14:50,200
This is the return value, storing the value, Elizabeth.

1615
01:14:50,200 --> 01:14:52,600
And I'm going to go ahead and tuck it away in a variable called name,

1616
01:14:52,600 --> 01:14:53,760
like this piece of paper here.

1617
01:14:53,760 --> 01:14:56,320
OK, Brian, could you go ahead and say hello, Elizabeth?

1618
01:15:09,480 --> 01:15:11,960
OK, so what's going on here?

1619
01:15:11,960 --> 01:15:13,720
I'm just doing less work.

1620
01:15:13,720 --> 01:15:15,440
Like, I kind of am writing this program.

1621
01:15:15,440 --> 01:15:16,520
Aaron, go get someone's name.

1622
01:15:16,520 --> 01:15:17,920
Brian, could you print this out?

1623
01:15:17,920 --> 01:15:19,880
Like, that's what I've been doing is programming,

1624
01:15:19,880 --> 01:15:22,920
just delegating functionality to other functions, or in this case,

1625
01:15:22,920 --> 01:15:24,600
other humans who know how to do that.

1626
01:15:24,600 --> 01:15:27,360
And honestly, I don't have to know how Aaron got that name.

1627
01:15:27,360 --> 01:15:28,280
She just got it.

1628
01:15:28,280 --> 01:15:31,320
I don't have to know how Brian wrote in that particular kind

1629
01:15:31,320 --> 01:15:33,320
of style of English on the screen.

1630
01:15:33,320 --> 01:15:35,000
I just know that he can do it.

1631
01:15:35,000 --> 01:15:37,240
And now my program is complete.

1632
01:15:37,240 --> 01:15:39,280
Thank you very much to both of these two here.

1633
01:15:39,280 --> 01:15:42,520
We'll continue in just a moment as follows.

1634
01:15:42,520 --> 01:15:44,960
So all this time, we've been taking for granted

1635
01:15:44,960 --> 01:15:48,640
that we have an actual computer on which we can execute code.

1636
01:15:48,640 --> 01:15:50,320
And I keep saying Intel inside, because that's

1637
01:15:50,320 --> 01:15:54,280
a sort of silly slogan that you see inside of most Macs and PCs

1638
01:15:54,280 --> 01:15:55,480
with the hardware they have.

1639
01:15:55,480 --> 01:15:58,080
But the CPU is just the brains of the computer.

1640
01:15:58,080 --> 01:16:00,520
And at the end of the day, recall that the goal

1641
01:16:00,520 --> 01:16:04,120
is to actually have the computer turn something like this, source code,

1642
01:16:04,120 --> 01:16:07,320
into actual machine code, 0s and 1s.

1643
01:16:07,320 --> 01:16:10,520
And that's all Clang was actually doing for us.

1644
01:16:10,520 --> 01:16:13,320
Of course, we've only just scratched the surface now of what we can do.

1645
01:16:13,320 --> 01:16:16,240
It turns out there's going to be not just these commands that we can run,

1646
01:16:16,240 --> 01:16:20,400
but other features of C. And in particular, the CS50 library.

1647
01:16:20,400 --> 01:16:22,320
We've only seen thus far how to get a string,

1648
01:16:22,320 --> 01:16:25,040
but you can get integers and characters and funky things like floats

1649
01:16:25,040 --> 01:16:28,120
and doubles, which actually open a can of worms as two problems that

1650
01:16:28,120 --> 01:16:29,440
can happen in a computer.

1651
01:16:29,440 --> 01:16:32,440
And it turns out you can store different types of variables,

1652
01:16:32,440 --> 01:16:36,360
not just integers and strings, but bool for Boolean and chars

1653
01:16:36,360 --> 01:16:37,080
for characters.

1654
01:16:37,080 --> 01:16:39,040
And you can format those things in printf.

1655
01:16:39,040 --> 01:16:41,240
We've only seen %i, %s.

1656
01:16:41,240 --> 01:16:44,640
I alluded to %i earlier, but there's a few others still.

1657
01:16:44,640 --> 01:16:46,760
But we've got a lot of possibilities here.

1658
01:16:46,760 --> 01:16:48,720
But let's go ahead and take, say, a five minute break

1659
01:16:48,720 --> 01:16:51,720
to give everyone a bit of a respite, turn on some music and come back in five,

1660
01:16:51,720 --> 01:16:55,240
and dive in deeper to more sophisticated programs in C.

1661
01:16:55,240 --> 01:16:57,160
All right.

1662
01:16:57,160 --> 01:17:01,040
So recall we began by comparing some scratch blocks

1663
01:17:01,040 --> 01:17:02,440
against the corresponding C code.

1664
01:17:02,440 --> 01:17:05,960
But we didn't actually use most of those blocks in C just yet.

1665
01:17:05,960 --> 01:17:08,240
So let's try out a number of examples, some of which

1666
01:17:08,240 --> 01:17:12,280
I'll write on the fly in typing code out on my own keyboard, some of which

1667
01:17:12,280 --> 01:17:15,560
we already have on the course's website, so we can just open them to save some time.

1668
01:17:15,560 --> 01:17:18,120
But let me just draw your attention to what CS50 Sandbox is,

1669
01:17:18,120 --> 01:17:20,360
because this was the step that I skipped over earlier.

1670
01:17:20,360 --> 01:17:23,880
CS50 Sandbox can be used to program in bunches of languages.

1671
01:17:23,880 --> 01:17:26,120
Will initially in the semester use it for C.

1672
01:17:26,120 --> 01:17:30,440
But if you've written Java before or Python or any number of languages,

1673
01:17:30,440 --> 01:17:33,720
when you go to sandbox.cs50.io, you can simply

1674
01:17:33,720 --> 01:17:35,440
choose the language you want to write in.

1675
01:17:35,440 --> 01:17:38,640
And then at the bottom, you'll see you can specify the name of the file

1676
01:17:38,640 --> 01:17:39,880
you want to pre-create.

1677
01:17:39,880 --> 01:17:44,320
So for instance, what I did earlier was I selected C at top.

1678
01:17:44,320 --> 01:17:46,720
And then at the bottom, I typed in hello.c,

1679
01:17:46,720 --> 01:17:49,560
because that was the name of the file I wanted, and then I clicked Start.

1680
01:17:49,560 --> 01:17:54,600
And what that led me to was precisely the interface in which we wrote hello.c

1681
01:17:54,600 --> 01:17:57,920
just a moment ago, where my code editor appears on the top here,

1682
01:17:57,920 --> 01:18:00,080
my terminal window appears at the bottom,

1683
01:18:00,080 --> 01:18:02,400
and then I'm allowed to just start writing code.

1684
01:18:02,400 --> 01:18:04,200
So that's how we got to where we were.

1685
01:18:04,240 --> 01:18:07,280
And if you want to follow along now with some of these examples,

1686
01:18:07,280 --> 01:18:10,000
note that on the course's website, we have all of them pre-made.

1687
01:18:10,000 --> 01:18:13,560
And you can actually click the links on the course's website

1688
01:18:13,560 --> 01:18:16,240
and open up your own copy of a sandbox with that code.

1689
01:18:16,240 --> 01:18:19,000
So if the Wi-Fi cooperates, you're welcome to tinker and play and run

1690
01:18:19,000 --> 01:18:22,400
the same commands, but everything is also on the course's website after.

1691
01:18:22,400 --> 01:18:24,320
So you need to type everything out.

1692
01:18:24,320 --> 01:18:26,200
So let's go ahead and do just a quick example.

1693
01:18:26,200 --> 01:18:31,040
I'm going to call this int.c just so that we can reinforce some of what we did

1694
01:18:31,040 --> 01:18:32,160
just a moment ago.

1695
01:18:32,200 --> 01:18:35,440
Rather than get a string, like we did with our hello example,

1696
01:18:35,440 --> 01:18:40,360
let me go ahead and just get, say, an integer, and then print it out,

1697
01:18:40,360 --> 01:18:41,920
just as we did print a name.

1698
01:18:41,920 --> 01:18:44,600
So I'm going to have to go ahead and just through muscle memory,

1699
01:18:44,600 --> 01:18:47,840
I kind of remember that I need standard io.h at the top,

1700
01:18:47,840 --> 01:18:51,440
and then int main void, and then curly braces,

1701
01:18:51,440 --> 01:18:55,360
and then I can do the act of actually getting the input.

1702
01:18:55,360 --> 01:18:57,680
So there was a function before called get string.

1703
01:18:57,680 --> 01:18:59,840
Turns out there's another function called get int,

1704
01:18:59,840 --> 01:19:01,160
if you want to get an integer.

1705
01:19:01,160 --> 01:19:04,480
So I can actually call get int, and I can say something like integer

1706
01:19:04,480 --> 01:19:07,440
is the prompt, like, hey, human, please give me an integer.

1707
01:19:07,440 --> 01:19:09,840
I need a semicolon at the end of this line.

1708
01:19:09,840 --> 01:19:15,280
And then how do I actually store the return value of get int in a variable?

1709
01:19:15,280 --> 01:19:17,960
Just as Aaron handed me a sheet of paper with a string,

1710
01:19:17,960 --> 01:19:20,680
how do if I'm handed a sheet of paper with a number,

1711
01:19:20,680 --> 01:19:23,240
how do I store it somewhere?

1712
01:19:23,240 --> 01:19:27,160
What should I literally type on line five here?

1713
01:19:27,160 --> 01:19:29,120
Int, space, and then number or something.

1714
01:19:29,120 --> 01:19:31,000
So I'm going to call it i just because it's an integer,

1715
01:19:31,000 --> 01:19:33,160
but I could call it number or anything else.

1716
01:19:33,160 --> 01:19:35,160
And then I'm going to go ahead and print this out.

1717
01:19:35,160 --> 01:19:42,360
So printf, let's say something like hello, i, backslash, n, semicolon.

1718
01:19:42,360 --> 01:19:43,800
OK, not quite correct, right?

1719
01:19:43,800 --> 01:19:46,080
This is going to literally print hello, comma, i.

1720
01:19:46,080 --> 01:19:47,760
How do I actually substitute something in?

1721
01:19:47,760 --> 01:19:50,040
Well, we've only seen how to substitute in a string,

1722
01:19:50,040 --> 01:19:52,080
but I think I spoiled earlier the answer.

1723
01:19:52,080 --> 01:19:56,040
Fuse, percent, i, that says, hey, computer, put an integer here.

1724
01:19:56,040 --> 01:20:00,840
Then I need a second argument to printf, just as we handed Brian

1725
01:20:00,840 --> 01:20:02,480
an argument as well.

1726
01:20:02,480 --> 01:20:04,640
And I said i.

1727
01:20:04,640 --> 01:20:06,200
I want to say i here.

1728
01:20:06,200 --> 01:20:08,360
But this program isn't quite correct yet.

1729
01:20:08,360 --> 01:20:09,800
It's in a file called int.c.

1730
01:20:09,800 --> 01:20:11,680
I've included standard io.h.

1731
01:20:11,680 --> 01:20:13,880
It's in main, and so what is main?

1732
01:20:13,880 --> 01:20:16,520
Well, today, we're largely going to wave our hands at that.

1733
01:20:16,520 --> 01:20:20,000
But int main void is perhaps the most cryptic way

1734
01:20:20,000 --> 01:20:22,680
you can say the equivalent of when green flag clicked.

1735
01:20:22,680 --> 01:20:23,800
Like, that's all that does.

1736
01:20:23,800 --> 01:20:27,080
And we'll come back in the weeks to come as to why it's int, why it's main,

1737
01:20:27,080 --> 01:20:27,880
why it's void.

1738
01:20:27,880 --> 01:20:30,000
But for now, humans years ago just decided

1739
01:20:30,040 --> 01:20:33,560
that when you're writing a program in C and you want to start the program off,

1740
01:20:33,560 --> 01:20:36,800
you literally have to type int main void with those parentheses,

1741
01:20:36,800 --> 01:20:39,800
with those curly braces, and it's the equivalent to scratches when green

1742
01:20:39,800 --> 01:20:40,760
flag clicked.

1743
01:20:40,760 --> 01:20:42,720
But this program will not compile.

1744
01:20:42,720 --> 01:20:45,320
And I don't even want to induce the stress of seeing those errors.

1745
01:20:45,320 --> 01:20:47,280
How do I void it?

1746
01:20:47,280 --> 01:20:51,040
Yeah, I need to teach the computer that get int exists.

1747
01:20:51,040 --> 01:20:55,600
And I know how to do that from before by including the so-called CS50 library.

1748
01:20:55,600 --> 01:20:58,320
Technically, CS50.h is a header file.

1749
01:20:58,320 --> 01:21:00,000
.h means header.

1750
01:21:00,000 --> 01:21:03,640
And it's just a file containing C code in which the functions are created.

1751
01:21:03,640 --> 01:21:05,080
More on that another time.

1752
01:21:05,080 --> 01:21:07,320
But that just gives us access to printf.

1753
01:21:07,320 --> 01:21:10,440
So if I've made no typos, I should be able to compile this program

1754
01:21:10,440 --> 01:21:13,640
by running what command?

1755
01:21:13,640 --> 01:21:14,360
Make int.

1756
01:21:14,360 --> 01:21:15,520
I could do clang.

1757
01:21:15,520 --> 01:21:17,200
I could do clang-o.

1758
01:21:17,200 --> 01:21:20,360
But for now, I'm going to do it simpler, would just make int

1759
01:21:20,360 --> 01:21:24,080
and let make automate the process of compiling this program.

1760
01:21:24,080 --> 01:21:25,800
No error messages is good.

1761
01:21:25,800 --> 01:21:27,600
Let me go ahead and zoom in.

1762
01:21:27,600 --> 01:21:30,320
.int, I think, would run the program.

1763
01:21:30,320 --> 01:21:32,680
Integer, how about 42?

1764
01:21:32,680 --> 01:21:34,080
Hello, 42.

1765
01:21:34,080 --> 01:21:35,440
Notice I can save time now.

1766
01:21:35,440 --> 01:21:38,600
If I want to run it again, I don't have to do .int all the time.

1767
01:21:38,600 --> 01:21:41,280
It turns out that in this kind of Linux environment,

1768
01:21:41,280 --> 01:21:44,560
this operating system called Linux, you can actually go up and down

1769
01:21:44,560 --> 01:21:47,520
and see previous commands you've typed and some others that

1770
01:21:47,520 --> 01:21:49,000
happen to be system specific.

1771
01:21:49,000 --> 01:21:51,440
And if you just hit up and enter, you can run it again.

1772
01:21:51,440 --> 01:21:54,880
Type in 50 this time and see another output as well.

1773
01:21:54,880 --> 01:21:56,440
All right, so any questions then?

1774
01:21:56,440 --> 01:21:59,840
On just an example like that?

1775
01:21:59,840 --> 01:22:00,160
No?

1776
01:22:00,160 --> 01:22:02,760
Well, let me go ahead and I'm going to save time in this environment.

1777
01:22:02,760 --> 01:22:07,280
I can actually create files in here if I want by clicking the folder icon,

1778
01:22:07,280 --> 01:22:11,000
clicking the plus, and then I can actually say, give me a file called float.c.

1779
01:22:11,000 --> 01:22:13,120
So this is equivalent to going back to the main menu

1780
01:22:13,120 --> 01:22:14,280
and typing in the name of the file.

1781
01:22:14,280 --> 01:22:15,880
I'm just going to do it a little more quickly now

1782
01:22:15,880 --> 01:22:17,160
in this graphical environment.

1783
01:22:17,160 --> 01:22:18,920
And I want to call it float.c.

1784
01:22:18,920 --> 01:22:21,520
It's a bit of a weird name, because at least growing up,

1785
01:22:21,520 --> 01:22:24,160
you probably learned maybe about integers.

1786
01:22:24,160 --> 01:22:27,480
You probably learned about real numbers, numbers that can have decimal points,

1787
01:22:27,480 --> 01:22:29,520
and then things after the decimal point in a computer.

1788
01:22:29,520 --> 01:22:33,680
Those things with decimal points are called floating point values, or floats.

1789
01:22:33,680 --> 01:22:36,720
And you can think of it as the decimal point can kind of float to the left

1790
01:22:36,720 --> 01:22:38,960
or the right, depending on how big or small the number is,

1791
01:22:38,960 --> 01:22:41,680
or how precise the numbers after the decimal point are.

1792
01:22:41,680 --> 01:22:42,720
That's a float.

1793
01:22:42,720 --> 01:22:45,120
So let me go ahead and implement a very similar program.

1794
01:22:45,160 --> 01:22:51,320
Include cs50.h, include standardio.h int main void.

1795
01:22:51,320 --> 01:22:54,520
And this is after 20 years of doing this, that you can do it so quickly.

1796
01:22:54,520 --> 01:22:58,840
Now, let me instead get a float from the user, so a real number that

1797
01:22:58,840 --> 01:23:00,920
may very well have a decimal point in it.

1798
01:23:00,920 --> 01:23:02,960
I'm going to do that a little differently.

1799
01:23:02,960 --> 01:23:06,200
I'll zoom in, and I'm going to say, hey, computer, give me a float,

1800
01:23:06,200 --> 01:23:10,120
as is the data type called, not int, not string, but float.

1801
01:23:10,120 --> 01:23:12,360
I'll call it f, just because that sounds like float,

1802
01:23:12,360 --> 01:23:13,840
and it's nice and succinct.

1803
01:23:13,840 --> 01:23:18,080
Equals get float, and then I'm just going to say float.

1804
01:23:18,080 --> 01:23:18,840
That's the prompt.

1805
01:23:18,840 --> 01:23:21,160
I could make the prompt in green anything I want.

1806
01:23:21,160 --> 01:23:22,440
And now I'm going to print it.

1807
01:23:22,440 --> 01:23:26,360
Print f, hello, f, but I don't want f.

1808
01:23:26,360 --> 01:23:28,480
I want to actually print out a placeholder,

1809
01:23:28,480 --> 01:23:31,560
and you can probably guess by now what the pattern is,

1810
01:23:31,560 --> 01:23:37,760
percent f for a float, new line, comma, f, semicolon.

1811
01:23:37,760 --> 01:23:41,080
So this is like the same program three times now with a string,

1812
01:23:41,120 --> 01:23:43,760
with an int and a float, but again, just for some muscle memory

1813
01:23:43,760 --> 01:23:44,880
and going through the pattern.

1814
01:23:44,880 --> 01:23:46,600
But let's see what happens differently here.

1815
01:23:46,600 --> 01:23:49,400
Let me go ahead and type make float, enter.

1816
01:23:49,400 --> 01:23:50,560
OK, good, no errors.

1817
01:23:50,560 --> 01:23:59,120
Let me zoom in and run this now as dot slash float.

1818
01:23:59,120 --> 01:24:00,520
And let me go ahead and type in a number.

1819
01:24:00,520 --> 01:24:02,280
I'm going to just say 42.

1820
01:24:02,280 --> 01:24:05,920
But the computer now has the capability of storing more precision.

1821
01:24:05,920 --> 01:24:08,440
Before, it was just an integer by definition of int.

1822
01:24:08,440 --> 01:24:13,160
Now it's a float, so even though it's pretty precise as 42.000,

1823
01:24:13,160 --> 01:24:17,720
that's indeed a real number now storing some amount of precision there.

1824
01:24:17,720 --> 01:24:21,920
So it turns out, though, that we can do more interesting math.

1825
01:24:21,920 --> 01:24:25,440
Let me go ahead and just open this example in advance.

1826
01:24:25,440 --> 01:24:27,720
This one's going to be called ints.c, so they

1827
01:24:27,720 --> 01:24:29,840
don't have to type everything out.

1828
01:24:29,840 --> 01:24:33,800
And in ints.c, we're going to see some math written in code

1829
01:24:33,800 --> 01:24:36,600
that I pre-created just to reinforce that you can actually

1830
01:24:36,600 --> 01:24:38,560
do some basic arithmetic in a program.

1831
01:24:38,560 --> 01:24:41,800
I can see more of the code here by just scrolling down.

1832
01:24:41,800 --> 01:24:44,200
And let me scroll this up so we can focus on main.

1833
01:24:44,200 --> 01:24:46,760
And let me zoom in on the first few lines.

1834
01:24:46,760 --> 01:24:50,160
On this first line, I'm just getting an int, and I'm calling it x.

1835
01:24:50,160 --> 01:24:52,000
We've not used a variable called x recently,

1836
01:24:52,000 --> 01:24:52,600
but now we are.

1837
01:24:52,600 --> 01:24:55,200
It's no different logically than before.

1838
01:24:55,200 --> 01:24:57,280
Here, give me another variable so we can see now

1839
01:24:57,280 --> 01:25:00,240
that you can get multiple variables from the user, just like in Scratch.

1840
01:25:00,240 --> 01:25:05,360
And now, in these lines, in green, are just some format strings.

1841
01:25:05,520 --> 01:25:07,560
What do I want printf to display?

1842
01:25:07,560 --> 01:25:10,000
I literally, in this highlighted line here,

1843
01:25:10,000 --> 01:25:14,640
want printf to display x plus y equals something.

1844
01:25:14,640 --> 01:25:15,600
What is that something?

1845
01:25:15,600 --> 01:25:21,240
Well, notice what's cool about printf is that before it is passed an input,

1846
01:25:21,240 --> 01:25:23,200
you can perform simple arithmetic operations.

1847
01:25:23,200 --> 01:25:26,360
So if you want to add x and y together, literally do x plus y,

1848
01:25:26,360 --> 01:25:30,760
then the sum of those numbers will get handed to printf as its input.

1849
01:25:30,760 --> 01:25:33,640
Just like I handed Aaron's piece of paper to Brian as input,

1850
01:25:33,640 --> 01:25:39,160
I'm handing not x and y to Brian in this case, but x plus y or some value,

1851
01:25:39,160 --> 01:25:40,120
the actual sum.

1852
01:25:40,120 --> 01:25:43,880
Similarly, subtraction is the hyphen on your keyboard.

1853
01:25:43,880 --> 01:25:45,760
For multiplication, it's not an x.

1854
01:25:45,760 --> 01:25:47,080
That would be weird, x, x, y.

1855
01:25:47,080 --> 01:25:49,840
It's instead star or an asterisk on your keyboard.

1856
01:25:49,840 --> 01:25:51,520
Division is a single slash.

1857
01:25:51,520 --> 01:25:54,400
And then this one's a little funky, but we'll come up with some uses for this.

1858
01:25:54,400 --> 01:25:59,040
You can actually do modular arithmetic or just more simply, remainders.

1859
01:25:59,080 --> 01:26:06,280
If you do x percent y, you'll get back the remainder of dividing x by y.

1860
01:26:06,280 --> 01:26:07,160
And what's the remainder?

1861
01:26:07,160 --> 01:26:14,800
So if x is 20 and y is 10, well, 20 divided by 10 goes in twice perfectly.

1862
01:26:14,800 --> 01:26:17,320
So remainder is 0, for instance, if it's been a while.

1863
01:26:17,320 --> 01:26:19,400
So notice what's curious here.

1864
01:26:19,400 --> 01:26:22,160
In this context, percent is not a placeholder.

1865
01:26:22,160 --> 01:26:22,800
It's not percent s.

1866
01:26:22,800 --> 01:26:23,520
It's not percent i.

1867
01:26:23,520 --> 01:26:24,400
It's not percent f.

1868
01:26:24,400 --> 01:26:27,600
Notice it's not inside of printf's format string.

1869
01:26:27,600 --> 01:26:30,640
This is just literally math, a math operator,

1870
01:26:30,640 --> 01:26:32,960
as is implied by the different color blue there.

1871
01:26:32,960 --> 01:26:36,320
So if I actually run this, let's go ahead and run this program.

1872
01:26:36,320 --> 01:26:39,960
I'm going to go ahead and make ints plural, because that's the name of the file.

1873
01:26:39,960 --> 01:26:42,240
Enter dot slash int.

1874
01:26:42,240 --> 01:26:45,120
And let me zoom in and clear the screen.

1875
01:26:45,120 --> 01:26:46,160
Enter.

1876
01:26:46,160 --> 01:26:48,000
Give me a number.

1877
01:26:48,000 --> 01:26:48,880
2, I heard.

1878
01:26:48,880 --> 01:26:50,960
And another.

1879
01:26:50,960 --> 01:26:52,360
10, I heard.

1880
01:26:52,360 --> 01:26:56,760
So fyi, 2 plus 10 is 12.

1881
01:26:56,760 --> 01:26:58,480
2 minus 10 is negative 8.

1882
01:26:58,480 --> 01:26:59,960
2 times 10 is 20.

1883
01:26:59,960 --> 01:27:08,240
2 divided by 10, 2 mod y, or 2, and then take the remainder when dividing by y

1884
01:27:08,240 --> 01:27:10,960
is what mod means, is 2.

1885
01:27:10,960 --> 01:27:14,800
So I get like 4 out of 5 for correctness.

1886
01:27:14,800 --> 01:27:16,400
What's a little funky here?

1887
01:27:17,400 --> 01:27:26,320
Yeah, like 2 divided by 10, I'm pretty sure that's like 2 tenths, or maybe 1

1888
01:27:26,320 --> 01:27:28,000
fifth, or 0.2.

1889
01:27:28,000 --> 01:27:30,520
I mean, I'll take any number of answers, but not 0.

1890
01:27:30,520 --> 01:27:31,680
So what's going on?

1891
01:27:31,680 --> 01:27:33,360
Well, this is a matter of representation.

1892
01:27:33,360 --> 01:27:38,000
It turns out in a computer program, we decided in advance, I'm going to store ints.

1893
01:27:38,000 --> 01:27:40,720
OK, an int is something that does not have a decimal point.

1894
01:27:40,720 --> 01:27:43,320
And yet here I am, rather presumptuously,

1895
01:27:43,320 --> 01:27:46,880
trying to do 2, an integer, divided by 10, an integer,

1896
01:27:46,880 --> 01:27:49,080
and expecting something other than an integer.

1897
01:27:49,080 --> 01:27:53,240
No, like I literally am doing integer arithmetic.

1898
01:27:53,240 --> 01:27:56,240
So what's the computer apparently doing, just intuitively?

1899
01:27:56,240 --> 01:28:01,160
Why when dividing x by y, as I did in this line here,

1900
01:28:01,160 --> 01:28:04,560
or specifically in this example you proposed, 2 divided by 10,

1901
01:28:04,560 --> 01:28:08,680
where is my 2 tenths going?

1902
01:28:08,680 --> 01:28:10,600
Yeah, it's as though it's technically what?

1903
01:28:10,600 --> 01:28:13,240
It's supposed to be 0.2, or 0.2.

1904
01:28:13,240 --> 01:28:15,040
OK, that's actually the solution, right?

1905
01:28:15,040 --> 01:28:18,880
Because if it's 0.2, but integers can't store decimal points or anything

1906
01:28:18,880 --> 01:28:20,640
after them, what do you have left?

1907
01:28:20,640 --> 01:28:22,560
Just the 0 at the beginning.

1908
01:28:22,560 --> 01:28:25,520
So integer arithmetic is fine if you're working with integers,

1909
01:28:25,520 --> 01:28:27,800
but if you want floating point arithmetic,

1910
01:28:27,800 --> 01:28:29,760
you're going to need to make some changes.

1911
01:28:29,760 --> 01:28:31,280
And so I can fix this.

1912
01:28:31,280 --> 01:28:34,480
In fact, let me go ahead and write a different program here.

1913
01:28:34,480 --> 01:28:39,920
Let me go ahead and open up from the course's website, floats.c.

1914
01:28:39,920 --> 01:28:43,520
And that's going to give me this example, which

1915
01:28:43,520 --> 01:28:47,000
is implemented using floating point values instead.

1916
01:28:47,000 --> 01:28:49,720
So once this loads, I'm going to see a program I wrote in advance.

1917
01:28:49,720 --> 01:28:53,560
It's a little shorter, because now I only care about looking at one problem.

1918
01:28:53,560 --> 01:28:56,720
And notice now, x and y are now floats and not ints.

1919
01:28:56,720 --> 01:28:59,440
Another data type that exists, and I'm using get float, which also comes

1920
01:28:59,440 --> 01:29:00,920
from CS50's library.

1921
01:29:00,920 --> 01:29:05,040
And then this line is almost the same, but let me tweak this.

1922
01:29:05,040 --> 01:29:06,840
Let me just make it exactly the same.

1923
01:29:06,840 --> 01:29:10,920
This line now that I've highlighted is exactly the same as before.

1924
01:29:10,920 --> 01:29:14,760
So if I do type in the same number, so let's go ahead and zoom in and do

1925
01:29:14,760 --> 01:29:21,040
make floats plural and dot slash floats, I'll give it 2 and 10.

1926
01:29:21,040 --> 01:29:24,240
And I should hopefully see what now?

1927
01:29:24,240 --> 01:29:25,320
0.2.

1928
01:29:25,320 --> 01:29:28,000
Yeah, OK, that's pretty good, pretty precise.

1929
01:29:28,000 --> 01:29:30,320
But you know what?

1930
01:29:30,320 --> 01:29:35,560
I hate to tell you, but let's look a little farther.

1931
01:29:35,560 --> 01:29:38,000
It turns out, by default, when you do percent F,

1932
01:29:38,000 --> 01:29:41,880
you only see a few decimal places, like five or so it looks, by default.

1933
01:29:41,880 --> 01:29:43,440
Let me see a few more.

1934
01:29:43,440 --> 01:29:49,920
So this was 1, 2, 3, 4, 5, 6 points after the decimal point.

1935
01:29:49,920 --> 01:29:50,640
So you know what?

1936
01:29:50,640 --> 01:29:53,280
I'm going to say, hey, computer, give me seven decimal points.

1937
01:29:53,280 --> 01:29:55,200
This looks completely cryptic, and you just

1938
01:29:55,200 --> 01:29:57,720
have to kind of remember this or look it up if you forget.

1939
01:29:57,720 --> 01:30:01,480
If you put a dot and a number in between the percent and the F,

1940
01:30:01,480 --> 01:30:04,680
that's the cryptic way of telling the computer, show me a float,

1941
01:30:04,720 --> 01:30:06,600
but with this many decimal places, please.

1942
01:30:06,600 --> 01:30:10,280
So that just gives me seven decimal places, weird as the expression looks.

1943
01:30:10,280 --> 01:30:13,080
All right, hopefully, I'm just going to see some more zeros.

1944
01:30:13,080 --> 01:30:15,440
So let me go ahead and make floats.

1945
01:30:15,440 --> 01:30:20,880
And let me go ahead and zoom in and do dot slash floats, 2, 10, enter.

1946
01:30:20,880 --> 01:30:23,600
OK, still correct.

1947
01:30:23,600 --> 01:30:26,080
Let me get a little curious.

1948
01:30:26,080 --> 01:30:29,000
Let's see a lot of zeros, like 50 of them.

1949
01:30:29,000 --> 01:30:33,440
Let me go down here and do make floats, because I changed the code,

1950
01:30:33,480 --> 01:30:37,760
dot slash floats, 2, 10.

1951
01:30:37,760 --> 01:30:39,480
Ha!

1952
01:30:39,480 --> 01:30:42,000
Your grade school teachers lied to you.

1953
01:30:42,000 --> 01:30:50,400
2 divided by 10 is apparently not 0.2000000 infinitely.

1954
01:30:50,400 --> 01:31:01,160
It's apparently 0.2000000298023223876953125, and then all of those zeros.

1955
01:31:01,200 --> 01:31:03,800
What the hell is going on?

1956
01:31:03,800 --> 01:31:05,000
Where's the bug?

1957
01:31:05,000 --> 01:31:06,080
Where's my mistake?

1958
01:31:06,080 --> 01:31:07,280
Where's my misunderstanding?

1959
01:31:10,280 --> 01:31:13,920
What's the explanation for this?

1960
01:31:13,920 --> 01:31:19,040
Well, what if I told you that inside of your computer is stuff like this?

1961
01:31:19,040 --> 01:31:20,560
This is RAM or memory.

1962
01:31:20,560 --> 01:31:22,280
And you've probably generally known this idea, right?

1963
01:31:22,280 --> 01:31:25,960
They store files to store music and videos, like you need memory,

1964
01:31:25,960 --> 01:31:28,640
some kind of space, hard disk space is permanent storage.

1965
01:31:28,640 --> 01:31:31,960
RAM or random access memory is temporary storage.

1966
01:31:31,960 --> 01:31:35,880
So when your laptop is open or your desktop computer is on or your phone is powered,

1967
01:31:35,880 --> 01:31:38,400
you're using RAM for all of the programs you're running at once.

1968
01:31:38,400 --> 01:31:41,120
So if you open a file, that file is stored in RAM,

1969
01:31:41,120 --> 01:31:42,840
but it's permanently stored on your hard drive.

1970
01:31:42,840 --> 01:31:44,320
So there's different types of memory.

1971
01:31:44,320 --> 01:31:45,960
But notice this is zoomed in.

1972
01:31:45,960 --> 01:31:50,000
In reality, this is like a couple of inches wide and maybe an inch tall.

1973
01:31:50,000 --> 01:31:53,080
So it's pretty small, but it doesn't really matter how big it is.

1974
01:31:53,080 --> 01:31:55,680
It just matters that it's finite in size.

1975
01:31:55,680 --> 01:31:59,080
You have physical hardware on your laps or in your pockets or at home

1976
01:31:59,080 --> 01:32:02,640
that only are so big and therefore only have so many parts

1977
01:32:02,640 --> 01:32:07,000
and therefore only have so many transistors and other pieces of hardware

1978
01:32:07,000 --> 01:32:09,520
that's actually doing the work of storing information.

1979
01:32:09,520 --> 01:32:12,920
And so if you only have a finite amount of memory,

1980
01:32:12,920 --> 01:32:18,960
how in the world are we going to represent an infinite number of numbers?

1981
01:32:18,960 --> 01:32:20,800
Because I do recall from grade school I was taught

1982
01:32:20,800 --> 01:32:23,360
there's an infinite number of numbers, certainly real numbers,

1983
01:32:23,360 --> 01:32:25,680
where the decimal point can go on forever.

1984
01:32:25,680 --> 01:32:29,360
That is a problem if you want to represent all possible numbers

1985
01:32:29,360 --> 01:32:35,400
in the universe, which is infinitely many, with a finite amount of hardware.

1986
01:32:35,400 --> 01:32:39,880
So at some point, the computers got to start cutting some corners.

1987
01:32:39,880 --> 01:32:43,600
And so what you're really seeing here is as close as the computer

1988
01:32:43,600 --> 01:32:47,480
can get to storing that fraction for you precisely.

1989
01:32:47,480 --> 01:32:48,480
And I got a little greedy.

1990
01:32:48,480 --> 01:32:50,680
I looked a little too far to the right.

1991
01:32:50,680 --> 01:32:53,720
And granted, these are infinitesimally small values.

1992
01:32:53,720 --> 01:32:55,760
It's not hugely, hugely off.

1993
01:32:55,760 --> 01:32:58,200
But it is off, because I can't expect the computer

1994
01:32:58,200 --> 01:33:02,120
to represent an infinite number of values using a finite amount of memory.

1995
01:33:02,120 --> 01:33:07,680
It's got to kind of round off here or there and be imprecise, so to speak.

1996
01:33:07,680 --> 01:33:08,680
So is this a problem?

1997
01:33:11,840 --> 01:33:14,400
I mean, we would never have known this if I hadn't gotten greedy

1998
01:33:14,400 --> 01:33:19,400
and looked at 50 decimal places instead of 7, which was already pretty precise.

1999
01:33:19,440 --> 01:33:20,200
Is this a problem?

2000
01:33:22,680 --> 01:33:23,180
Yeah?

2001
01:33:23,180 --> 01:33:24,480
Like why?

2002
01:33:24,480 --> 01:33:24,980
Why?

2003
01:33:28,820 --> 01:33:29,320
Yeah.

2004
01:33:29,320 --> 01:33:30,020
That's a good one.

2005
01:33:30,020 --> 01:33:34,160
Logically, if I start using equals equals to compare things for equality,

2006
01:33:34,160 --> 01:33:37,680
it's going to be really hard for me to ever compare something for too tense

2007
01:33:37,680 --> 01:33:40,760
as its value, because I'm going to literally have to remember or write

2008
01:33:40,760 --> 01:33:43,840
down or figure out this value and compare against that and not just

2009
01:33:43,840 --> 01:33:45,880
compare more loosely against point two.

2010
01:33:45,880 --> 01:33:46,640
And that's true.

2011
01:33:46,640 --> 01:33:50,960
You should actually never compare floating point values in code for equality.

2012
01:33:50,960 --> 01:33:53,960
I could probably get away with less than or greater than,

2013
01:33:53,960 --> 01:33:58,080
but even then, it's going to be a little off from what I expect.

2014
01:33:58,080 --> 01:34:00,160
Why else might this imprecision be worrisome?

2015
01:34:03,520 --> 01:34:06,560
When might you not want your computer being imprecise?

2016
01:34:06,560 --> 01:34:07,360
What domains?

2017
01:34:07,360 --> 01:34:09,080
What worlds outside of a classroom?

2018
01:34:09,080 --> 01:34:10,080
Yeah?

2019
01:34:10,080 --> 01:34:12,240
What's that?

2020
01:34:12,240 --> 01:34:14,160
Yeah, so rockets, right?

2021
01:34:14,160 --> 01:34:17,960
Are there anything involving math and physics and danger?

2022
01:34:17,960 --> 01:34:21,560
Like, you don't want numbers to be ever so slightly off.

2023
01:34:21,560 --> 01:34:23,720
And if you think about it, rockets is a good example,

2024
01:34:23,720 --> 01:34:27,040
because I don't know much about rockets, but I know they go pretty fast.

2025
01:34:27,040 --> 01:34:28,940
And there's probably angles involved, because you're

2026
01:34:28,940 --> 01:34:30,600
trying to keep them on a trajectory.

2027
01:34:30,600 --> 01:34:31,440
And that's fine.

2028
01:34:31,440 --> 01:34:33,440
But if your trajectory is ever so slightly off

2029
01:34:33,440 --> 01:34:36,000
and something's going really fast and really far,

2030
01:34:36,000 --> 01:34:40,840
I'm pretty sure that eventually, those small imprecisions start to add up.

2031
01:34:40,840 --> 01:34:43,560
And indeed, there's been historical incidents

2032
01:34:43,560 --> 01:34:45,960
where that kind of imprecision does, in fact,

2033
01:34:45,960 --> 01:34:49,880
add up in the realm of militaristic operations or in financial operations.

2034
01:34:49,880 --> 01:34:52,280
In fact, if you've ever seen Office Space or way back when,

2035
01:34:52,280 --> 01:34:55,040
like Superman 3, this is how some people made some money,

2036
01:34:55,040 --> 01:34:59,280
because they just kind of kept all of the fractions of pennies

2037
01:34:59,280 --> 01:35:03,160
that computer systems were just ignoring, and eventually, they start to add up.

2038
01:35:03,160 --> 01:35:06,920
So long story short, any time you have scientific or financial

2039
01:35:06,920 --> 01:35:11,040
or any sort of large data sets that involve big numbers and lots of them

2040
01:35:11,040 --> 01:35:13,360
and lots of time, this is a problem.

2041
01:35:13,360 --> 01:35:17,000
And it almost suggests you shouldn't use C or let alone computers

2042
01:35:17,000 --> 01:35:18,440
unless we actually address this.

2043
01:35:18,440 --> 01:35:21,440
Now, as a spoiler, humans have chipped away at this problem.

2044
01:35:21,440 --> 01:35:26,160
And you can use more and more bits, but not infinitely many bits.

2045
01:35:26,160 --> 01:35:27,920
At some point, you have to draw a line.

2046
01:35:27,920 --> 01:35:30,920
But this is why, for instance, the stock exchange might only represent

2047
01:35:30,920 --> 01:35:33,840
two decimal points of precision for dollars or maybe four decimal points

2048
01:35:33,840 --> 01:35:36,280
to the thousands place for dollars and cents.

2049
01:35:36,280 --> 01:35:39,000
And they just have to decide, that's all the precision we can actually

2050
01:35:39,000 --> 01:35:39,840
store precisely.

2051
01:35:39,840 --> 01:35:43,600
But you've got to decide how to handle it and not just ignore the problem.

2052
01:35:43,600 --> 01:35:44,960
But we can do a little better.

2053
01:35:44,960 --> 01:35:45,720
You know what?

2054
01:35:45,720 --> 01:35:48,480
It turns out that in most computers, a float,

2055
01:35:48,480 --> 01:35:51,360
it takes up, yes, a finite amount of space, but very specifically,

2056
01:35:51,360 --> 01:35:54,240
32 bits of space or four bytes.

2057
01:35:54,240 --> 01:35:55,680
A byte, recall, is eight bits.

2058
01:35:55,680 --> 01:35:57,480
So four bytes is 32 bits.

2059
01:35:57,480 --> 01:35:59,800
And that's just a very common unit of measure.

2060
01:35:59,800 --> 01:36:00,880
But there's another one.

2061
01:36:00,880 --> 01:36:03,680
Turns out, if you want twice as many bits,

2062
01:36:03,680 --> 01:36:07,240
you can literally use a data type called double.

2063
01:36:07,240 --> 01:36:11,800
And in the CS50 library, there is a function called get double.

2064
01:36:11,800 --> 01:36:18,080
And if I go ahead and do it here, I can now recompile this code, make floats,

2065
01:36:18,080 --> 01:36:21,080
even though they're not technically float types anymore.

2066
01:36:21,080 --> 01:36:24,440
And let me go ahead and do dot slash floats, enter.

2067
01:36:24,440 --> 01:36:26,960
And let me type in 2 and 10.

2068
01:36:26,960 --> 01:36:29,720
And now it's still imprecise.

2069
01:36:29,720 --> 01:36:33,040
But notice, instead of seven zeros, which I think I had before,

2070
01:36:33,040 --> 01:36:39,240
now I've got 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 zeros.

2071
01:36:39,240 --> 01:36:42,320
So I've kind of pushed the problem further out, so to speak.

2072
01:36:42,320 --> 01:36:44,440
So it's more precise, but it's not perfect.

2073
01:36:44,440 --> 01:36:46,760
Can't get certain values perfect if you want

2074
01:36:46,760 --> 01:36:50,000
to be able to represent an infinite range.

2075
01:36:50,000 --> 01:36:53,760
Any questions, then, about this?

2076
01:36:53,760 --> 01:36:55,440
We'll come back as to some implications.

2077
01:36:55,440 --> 01:36:55,940
Yeah?

2078
01:36:55,940 --> 01:36:56,480
Yeah, here.

2079
01:36:56,480 --> 01:37:00,920
So would it be better to double the size?

2080
01:37:00,920 --> 01:37:01,440
Good question.

2081
01:37:01,440 --> 01:37:04,120
Would it always be better to use doubles because they're more precise?

2082
01:37:04,120 --> 01:37:05,240
Short answer, yes.

2083
01:37:05,240 --> 01:37:07,720
But we're going to see thematically in this course in computer science

2084
01:37:07,720 --> 01:37:09,640
more generally, there's always a trade-off.

2085
01:37:09,640 --> 01:37:13,920
And yes, if you use a double, you will avoid this problem a bit more.

2086
01:37:13,920 --> 01:37:16,760
But what price will you pay, so to speak?

2087
01:37:16,760 --> 01:37:19,600
Maybe processing power, because it's got to deal with more bits at once.

2088
01:37:19,600 --> 01:37:22,920
And even more, literally, more space.

2089
01:37:22,920 --> 01:37:24,840
I mean, sure, we can take your solution, but I'm

2090
01:37:24,840 --> 01:37:26,400
going to charge you twice as many bits.

2091
01:37:26,400 --> 01:37:29,520
And back in the day, decades ago, when C was first being invented

2092
01:37:29,560 --> 01:37:33,400
and computers were really coming into play, spending twice as many bits,

2093
01:37:33,400 --> 01:37:36,080
even if it's only 32 more tiny zeros and ones,

2094
01:37:36,080 --> 01:37:38,360
that was actually expensive, literally, financially.

2095
01:37:38,360 --> 01:37:39,120
And it adds up.

2096
01:37:39,120 --> 01:37:41,840
And even today, if you want to spend more space, that's fine.

2097
01:37:41,840 --> 01:37:44,280
But you're going to spend more space, therefore more money,

2098
01:37:44,280 --> 01:37:46,520
and therefore have less space available for other things.

2099
01:37:46,520 --> 01:37:47,560
So it's just a trade-off.

2100
01:37:47,560 --> 01:37:51,760
And you have to decide as an intelligent human

2101
01:37:51,760 --> 01:37:55,360
where the right inflection point is between what's more important.

2102
01:37:55,360 --> 01:37:58,800
Let me open up a very different example now called parity.

2103
01:37:58,800 --> 01:38:01,360
Just as an example, and let me ask this question,

2104
01:38:01,360 --> 01:38:06,480
how do you know if a number is even or odd?

2105
01:38:06,480 --> 01:38:08,880
What's the trick?

2106
01:38:08,880 --> 01:38:13,200
If it's divided by 2, so 0, and 2, and 4, and 6 are even,

2107
01:38:13,200 --> 01:38:15,920
because if you divide by 2, you don't get a remainder.

2108
01:38:15,920 --> 01:38:18,360
So actually, if you just want to see a quick example of why

2109
01:38:18,360 --> 01:38:20,880
you might use a remainder, even though it's out of context,

2110
01:38:20,880 --> 01:38:22,200
here's an example for parity.

2111
01:38:22,200 --> 01:38:26,000
Parity is just a term referring to even or odd in this context.

2112
01:38:26,000 --> 01:38:27,120
How might we use this?

2113
01:38:27,120 --> 01:38:30,320
Well, notice I can get an in from the user up at the top.

2114
01:38:30,320 --> 01:38:32,240
I can then check the parity of the integer.

2115
01:38:32,240 --> 01:38:34,160
Is it even or odd with syntax like this?

2116
01:38:34,160 --> 01:38:36,640
Now I'm kind of combining some of these operators

2117
01:38:36,640 --> 01:38:38,360
as you might be inclined intuitively.

2118
01:38:38,360 --> 01:38:43,680
If n, the number the user typed in, mod 2, or divided by and then

2119
01:38:43,680 --> 01:38:47,240
check the remainder of, but that's a mouthful, equals equals 0,

2120
01:38:47,240 --> 01:38:51,600
you just said it's an even number, so print even, else print odd.

2121
01:38:51,600 --> 01:38:53,280
Because what's the possible other remainder?

2122
01:38:53,280 --> 01:38:55,800
If you do n or any value divided by 2, you

2123
01:38:55,800 --> 01:38:59,040
might get a remainder of 0 or 1.

2124
01:38:59,040 --> 01:39:02,120
I only have to check for one of those, 0, because the else

2125
01:39:02,120 --> 01:39:03,640
implies the other thing.

2126
01:39:03,640 --> 01:39:05,400
So again, very simple example.

2127
01:39:05,400 --> 01:39:07,920
But honestly, all of us probably have an intuitive understanding

2128
01:39:07,920 --> 01:39:09,080
of what's even and odd.

2129
01:39:09,080 --> 01:39:11,440
A computer needs to be taught that, and so there's

2130
01:39:11,440 --> 01:39:13,680
a program that does exactly that.

2131
01:39:13,680 --> 01:39:17,000
Let me open up a larger program called Conditions.

2132
01:39:17,000 --> 01:39:19,840
And rather than type this one out because it's a few lines of code,

2133
01:39:19,840 --> 01:39:23,240
let me just open it up because it concludes exactly the code we

2134
01:39:23,240 --> 01:39:27,840
saw a little bit ago on the slide when we compared it to a similar C block.

2135
01:39:27,840 --> 01:39:30,480
In this program, in my main function, let

2136
01:39:30,480 --> 01:39:32,560
me focus on the first few lines there.

2137
01:39:32,560 --> 01:39:36,560
I have an int called x that I'm getting via get int.

2138
01:39:36,560 --> 01:39:39,240
Another int called y that I'm getting via get int.

2139
01:39:39,240 --> 01:39:41,680
And then I'm just doing some simple comparisons.

2140
01:39:41,680 --> 01:39:43,840
We saw this again when we compared it to scratch.

2141
01:39:43,840 --> 01:39:47,560
But this is quite simply that same code in context

2142
01:39:47,560 --> 01:39:50,600
rather than just seeing it statically on a slide.

2143
01:39:50,600 --> 01:39:52,040
So let me go ahead and compile this.

2144
01:39:52,040 --> 01:39:53,640
Make conditions.

2145
01:39:53,640 --> 01:39:54,140
Enter.

2146
01:39:54,140 --> 01:39:55,240
Seems to compile.

2147
01:39:55,240 --> 01:39:58,600
Let me zoom in and do dot slash conditions.

2148
01:39:58,600 --> 01:39:59,440
Enter.

2149
01:39:59,440 --> 01:40:01,400
x will be, say, 2 again.

2150
01:40:01,400 --> 01:40:03,040
y will be 10.

2151
01:40:03,040 --> 01:40:04,480
x is indeed less than y.

2152
01:40:04,480 --> 01:40:08,080
If I run it again and I can save time by hitting up through my history

2153
01:40:08,080 --> 01:40:11,600
and just hitting Enter, let's do 2 and 2.

2154
01:40:11,600 --> 01:40:13,600
And indeed, x is equal to y and so forth.

2155
01:40:13,600 --> 01:40:16,280
So again, just the exact same kind of code as before,

2156
01:40:16,280 --> 01:40:18,560
but now in the context of a working program.

2157
01:40:18,560 --> 01:40:22,160
What if I actually wanted to get user input kind of like our past student

2158
01:40:22,160 --> 01:40:26,360
did with getting yes or no answers to the Apple and the cupcake question?

2159
01:40:26,360 --> 01:40:30,760
Well, in answer.c, it turns out you can actually get textual input

2160
01:40:30,760 --> 01:40:36,160
from the user, perhaps a simple yes or no, or just y or n, for succinctness.

2161
01:40:36,160 --> 01:40:38,760
And in this case, if I just get back a single character,

2162
01:40:38,760 --> 01:40:40,800
turns out there's a separate data type for character.

2163
01:40:40,800 --> 01:40:43,880
If you don't want a whole string, like a whole word, or a paragraph,

2164
01:40:43,880 --> 01:40:46,040
or sentence, or whatever, you just want one character,

2165
01:40:46,040 --> 01:40:48,960
you can actually use what's called a char, or character.

2166
01:40:48,960 --> 01:40:54,760
And so here, I'm using one other function, appropriately named, called get char.

2167
01:40:54,760 --> 01:40:58,760
I'm storing it in a variable called c, because it's nice and succinct,

2168
01:40:58,760 --> 01:41:00,200
of type char.

2169
01:41:00,200 --> 01:41:02,280
And then notice this.

2170
01:41:02,280 --> 01:41:05,160
You might not have seen this syntax before, especially

2171
01:41:05,160 --> 01:41:07,680
if you've never programmed before, even in Scratch,

2172
01:41:07,680 --> 01:41:10,800
but you might have seen this block similar to this in Scratch.

2173
01:41:10,800 --> 01:41:14,920
What does the vertical double bar probably imply here?

2174
01:41:14,920 --> 01:41:15,760
Or that's it.

2175
01:41:15,760 --> 01:41:17,480
So in Scratch, it's nice and user-friendly.

2176
01:41:17,480 --> 01:41:18,760
They literally just say, or.

2177
01:41:18,760 --> 01:41:20,640
In programming, it's often the case that you

2178
01:41:20,640 --> 01:41:23,080
use just more cryptic sequences of characters,

2179
01:41:23,080 --> 01:41:26,880
and two vertical bars, which are typically above the Enter key on a US

2180
01:41:26,880 --> 01:41:32,280
keyboard, if c equals equals capital Y or c equals equals lowercase y,

2181
01:41:32,280 --> 01:41:36,160
let's assume that the user wanted to say yes, and go ahead and say yes.

2182
01:41:36,160 --> 01:41:39,960
Else, if the user typed in n in capitals or n in lowercase,

2183
01:41:39,960 --> 01:41:43,080
let's assume he or she meant no, and say no accordingly.

2184
01:41:43,080 --> 01:41:45,840
And what are we going to do otherwise?

2185
01:41:45,840 --> 01:41:46,800
Apparently, nothing.

2186
01:41:46,800 --> 01:41:47,640
And that's fine.

2187
01:41:47,640 --> 01:41:50,840
You don't need to have a default case if you want the program to do nothing.

2188
01:41:50,840 --> 01:41:55,000
Might be a little confusing, because the user is going to type in some random word

2189
01:41:55,000 --> 01:41:57,360
and get no output, but that's a design decision.

2190
01:41:57,360 --> 01:42:00,520
Logically, this is just how we might express this.

2191
01:42:00,520 --> 01:42:06,920
What about actually building our own blocks?

2192
01:42:06,920 --> 01:42:11,640
Any questions, though, before we start to create?

2193
01:42:12,000 --> 01:42:15,640
So recall that in Scratch, we had that cough example.

2194
01:42:15,640 --> 01:42:20,960
Let me go ahead and create a file here real quickly called cough0.c,

2195
01:42:20,960 --> 01:42:23,360
and just kind of recreate what we did last week,

2196
01:42:23,360 --> 01:42:28,600
include standard.io.h int main void, again, just muscle memory now,

2197
01:42:28,600 --> 01:42:33,680
and then printf quote unquote cough backslash n semicolon.

2198
01:42:33,680 --> 01:42:34,200
And you know what?

2199
01:42:34,200 --> 01:42:38,440
Let me go ahead and cough not once, but twice, three times.

2200
01:42:38,440 --> 01:42:43,200
The moment you start copying and pasting, you're probably not writing good code, right?

2201
01:42:43,200 --> 01:42:44,280
It's not very maintainable.

2202
01:42:44,280 --> 01:42:46,800
Now if I want to change the word or translate it to another language,

2203
01:42:46,800 --> 01:42:48,160
I have to change it in three places.

2204
01:42:48,160 --> 01:42:50,600
We already decided last week that was bad.

2205
01:42:50,600 --> 01:42:56,560
So what would be better in C or in Scratch or in general than this approach?

2206
01:42:56,560 --> 01:42:57,840
Yeah, so like a for loop.

2207
01:42:57,840 --> 01:42:58,480
So let me do that.

2208
01:42:58,480 --> 01:43:00,000
Let me create another file.

2209
01:43:00,000 --> 01:43:03,640
I'm going to call this one cough1.c is my second version.

2210
01:43:03,640 --> 01:43:07,320
Let me go ahead now and just copy and paste the original code.

2211
01:43:07,320 --> 01:43:08,320
And let's just improve it.

2212
01:43:08,360 --> 01:43:10,120
Let's get rid of two of these.

2213
01:43:10,120 --> 01:43:12,000
And let's see if we can't express the four.

2214
01:43:12,000 --> 01:43:13,880
So it was four.

2215
01:43:13,880 --> 01:43:15,240
Let me zoom in.

2216
01:43:15,240 --> 01:43:17,400
int i gets 0.

2217
01:43:17,400 --> 01:43:19,000
i is less than some number.

2218
01:43:19,000 --> 01:43:19,920
Before it was 50.

2219
01:43:19,920 --> 01:43:21,640
Now I'm going to have it be 3.

2220
01:43:21,640 --> 01:43:25,040
i plus plus curly braces.

2221
01:43:25,040 --> 01:43:29,840
And now let me move the cough block inside of there and indent it just to be pretty.

2222
01:43:29,840 --> 01:43:34,360
And notice stylistically, I've been doing this sort of instinctively for some time.

2223
01:43:34,360 --> 01:43:37,520
Everything's nicely indented just to make it more readable,

2224
01:43:37,520 --> 01:43:40,480
quite like the Scratch blocks, even though, again, a lot of that white space

2225
01:43:40,480 --> 01:43:42,440
doesn't matter to the computer.

2226
01:43:42,440 --> 01:43:46,880
So if I go ahead and run this, let me pull up the terminal window so I can see it.

2227
01:43:46,880 --> 01:43:53,680
Make cough1 enter, looks good, dot slash cough1, cough, cough, cough.

2228
01:43:53,680 --> 01:43:55,000
OK, that's good.

2229
01:43:55,000 --> 01:43:59,280
But recall that we actually improved this design further by abstracting it away.

2230
01:43:59,280 --> 01:44:01,560
Let me go ahead and make my own function now.

2231
01:44:01,560 --> 01:44:07,800
Let me go ahead and open up a new file, cough2, cough2.c,

2232
01:44:07,800 --> 01:44:10,800
just like I had another Scratch program.

2233
01:44:10,800 --> 01:44:16,000
Again, include standard io.h int main void.

2234
01:44:16,000 --> 01:44:22,400
And then in here, let me go ahead and do what?

2235
01:44:22,400 --> 01:44:30,720
Well, for int i gets 0, i less than 3, i plus plus plus curly braces.

2236
01:44:30,720 --> 01:44:33,360
Then let me go ahead and just call cough.

2237
01:44:33,360 --> 01:44:35,000
It would be nice if cough existed.

2238
01:44:35,000 --> 01:44:36,600
But unfortunately, cough does not exist.

2239
01:44:36,600 --> 01:44:39,560
It's not in the CS50 library even, so that's not going to help us.

2240
01:44:39,560 --> 01:44:41,680
I have to make my own function.

2241
01:44:41,680 --> 01:44:44,600
So in Scratch, you went to the blocks thing, and you make your own block,

2242
01:44:44,600 --> 01:44:47,160
and the big prompt comes up, and you make your new puzzle piece.

2243
01:44:47,160 --> 01:44:49,160
Here, we're going to have to be a little more deliberate.

2244
01:44:49,160 --> 01:44:52,680
And it turns out you can do it like this.

2245
01:44:52,680 --> 01:44:55,080
Some of these details will be non-obvious at first.

2246
01:44:55,080 --> 01:44:57,760
But I'm going to go ahead and call the function cough.

2247
01:44:57,760 --> 01:45:00,640
And cough, at the moment, does not need to take any input.

2248
01:45:00,640 --> 01:45:03,720
So the keyword there is void, and we've actually seen that before.

2249
01:45:03,720 --> 01:45:05,560
Main also has not been taking any inputs.

2250
01:45:05,560 --> 01:45:08,600
That's why we had the word void, but more on that another time.

2251
01:45:08,600 --> 01:45:10,640
And cough is not going to return anything either.

2252
01:45:10,640 --> 01:45:12,920
It's going to print on the screen, just like Brian did.

2253
01:45:12,920 --> 01:45:15,560
But Brian recall didn't hand me anything back physically,

2254
01:45:15,560 --> 01:45:17,160
so there's no return value.

2255
01:45:17,160 --> 01:45:20,400
So I'm going to say void to the left of cough.

2256
01:45:20,400 --> 01:45:24,480
So for today's purposes, this just means that cough neither takes input

2257
01:45:24,480 --> 01:45:26,560
nor returns a value as output.

2258
01:45:26,560 --> 01:45:27,480
That's it.

2259
01:45:27,480 --> 01:45:28,640
Void void.

2260
01:45:28,640 --> 01:45:31,520
Now, as the body of that function, so to speak,

2261
01:45:31,520 --> 01:45:36,320
I'm just going to go ahead and say, quite simply, cough backslash n semicolon.

2262
01:45:36,320 --> 01:45:37,000
That's it.

2263
01:45:37,000 --> 01:45:39,600
So now I have a puzzle piece, if you will, whose purpose in life

2264
01:45:39,600 --> 01:45:43,720
is to cough, which means now I can magically just call it by its name

2265
01:45:43,720 --> 01:45:46,560
up here as many times as I want.

2266
01:45:46,560 --> 01:45:48,480
So let's go ahead and compile this.

2267
01:45:48,480 --> 01:45:49,600
I'm really on a good roll.

2268
01:45:49,600 --> 01:45:51,360
Everything's been working out great so far.

2269
01:45:51,360 --> 01:45:52,720
Make cough to enter.

2270
01:45:52,720 --> 01:45:56,040
Ugh, ugh, red errors.

2271
01:45:56,040 --> 01:45:59,640
So this is interesting, and this kind of reminds me of the previous error.

2272
01:45:59,640 --> 01:46:03,120
So first of all, what line is my error on?

2273
01:46:03,120 --> 01:46:05,240
OK, 7 in character 9, if you care.

2274
01:46:05,240 --> 01:46:07,280
But it's 7 on line 7.

2275
01:46:07,280 --> 01:46:10,880
Implicit declaration of function cough is invalid in C99.

2276
01:46:10,880 --> 01:46:15,320
C99 is referring to, literally, 1999 when this version of C was invented.

2277
01:46:15,320 --> 01:46:21,000
And so implicit declaration of function cough, but it's right here.

2278
01:46:21,000 --> 01:46:25,320
OK, wait a minute, let me, uh, instinct, let me just move this, right?

2279
01:46:26,120 --> 01:46:27,440
Let me just put it up top.

2280
01:46:27,440 --> 01:46:28,800
Let's see what happens.

2281
01:46:28,800 --> 01:46:33,280
Make cough to, oh my god, that fixed it.

2282
01:46:33,280 --> 01:46:35,040
Why?

2283
01:46:35,040 --> 01:46:36,840
Like, even if you've never programmed before,

2284
01:46:36,840 --> 01:46:39,680
just kind of reason through intuitively why this solves something.

2285
01:46:44,680 --> 01:46:45,160
Exactly.

2286
01:46:48,720 --> 01:46:49,720
Exactly.

2287
01:46:49,720 --> 01:46:54,400
Because I previously was trying to use cough early on on line 7,

2288
01:46:54,440 --> 01:46:58,320
but I was only teaching the computer what cough was farther down in the file.

2289
01:46:58,320 --> 01:46:59,560
Frankly, C is kind of dumb.

2290
01:46:59,560 --> 01:47:02,040
It literally reads your code top to bottom, left to right.

2291
01:47:02,040 --> 01:47:05,200
And if you try to do something before you've taught the computer how to do that,

2292
01:47:05,200 --> 01:47:07,840
you're going to get that kind of undeclared identifier,

2293
01:47:07,840 --> 01:47:10,280
because it just doesn't know what the word is yet.

2294
01:47:10,280 --> 01:47:11,720
Now in Scratch, this isn't a big deal.

2295
01:47:11,720 --> 01:47:13,640
You just move the puzzle pieces anywhere you want.

2296
01:47:13,640 --> 01:47:16,560
Order of blocks physically on the screen does not matter.

2297
01:47:16,560 --> 01:47:17,800
But in C, it does.

2298
01:47:17,800 --> 01:47:22,560
But frankly, this seems a little annoying that now the main program here

2299
01:47:22,600 --> 01:47:24,840
kind of keeps getting pushed farther and farther down.

2300
01:47:24,840 --> 01:47:27,520
The more kind of complexity I want to add to my program.

2301
01:47:27,520 --> 01:47:29,160
So there's another solution.

2302
01:47:29,160 --> 01:47:31,480
Let me actually go ahead and put this back where it is,

2303
01:47:31,480 --> 01:47:33,600
because I'm a little sort of particular.

2304
01:47:33,600 --> 01:47:36,080
I just like, by convention, main to be at the top.

2305
01:47:36,080 --> 01:47:38,120
And frankly, that's kind of good style.

2306
01:47:38,120 --> 01:47:40,840
If main is the most important function in your program by default,

2307
01:47:40,840 --> 01:47:45,000
because it is the main function, and it's what gets called, per earlier,

2308
01:47:45,000 --> 01:47:48,760
by default by the computer, why am I going to push it all the way down

2309
01:47:48,760 --> 01:47:51,680
just to work around this stupid detail?

2310
01:47:51,680 --> 01:47:56,280
Well, I just need to teach the computer what the function is.

2311
01:47:56,280 --> 01:48:01,840
And I can do that a little redundantly by just saying this.

2312
01:48:01,840 --> 01:48:05,320
This is what we're going to call the prototype for a function.

2313
01:48:05,320 --> 01:48:10,000
If you literally just copy the very first line of it that has its name,

2314
01:48:10,000 --> 01:48:14,640
its inputs, if any, and its output, if any, that's a prototype, semicolon.

2315
01:48:14,640 --> 01:48:16,920
It's literally copy-paste from the function itself.

2316
01:48:16,920 --> 01:48:21,840
But this is now enough of a hint to say, hey, computer, this shall exist.

2317
01:48:21,840 --> 01:48:24,480
This is enough information for you to then call it,

2318
01:48:24,480 --> 01:48:28,840
because the computer, so long as it has seen the function's name before,

2319
01:48:28,840 --> 01:48:34,680
it's OK if the 0s and 1s, so to speak, that implement it come a little later.

2320
01:48:34,680 --> 01:48:38,040
And so that's the more conventional way to solve that problem.

2321
01:48:38,040 --> 01:48:44,960
So just intuitively then, take a guess if it's not too much of an indirect leap,

2322
01:48:45,000 --> 01:48:47,680
what is in standard.io.h?

2323
01:48:47,680 --> 01:48:49,520
What is in CS50.h?

2324
01:48:53,480 --> 01:48:54,800
We'll call them declarations.

2325
01:48:54,800 --> 01:48:59,640
So literally, in standard.io.h is a line of code

2326
01:48:59,640 --> 01:49:03,160
that teaches the computer what printf's inputs are

2327
01:49:03,160 --> 01:49:05,320
and what printf's output is, if any.

2328
01:49:05,320 --> 01:49:07,680
In CS50.h, there's literally an line of code

2329
01:49:07,680 --> 01:49:11,800
that tells the computer what getString's input is and what its output is.

2330
01:49:11,800 --> 01:49:15,720
And the same for getInt and getFloat and getChar and others.

2331
01:49:15,720 --> 01:49:17,720
That's all that's in those header files.

2332
01:49:17,720 --> 01:49:20,480
The 0s and 1s, so to speak, are actually in files literally called

2333
01:49:20,480 --> 01:49:25,600
standard.io.c and CS50.c, although that's technically source code.

2334
01:49:25,600 --> 01:49:28,880
The 0s and 1s are in a compiled file elsewhere on the system.

2335
01:49:28,880 --> 01:49:31,400
But all of these things we've kind of been taking for granted,

2336
01:49:31,400 --> 01:49:33,120
now hopefully it makes a little more sense,

2337
01:49:33,120 --> 01:49:35,720
because the fact that I'm doing the sharp include at the top,

2338
01:49:35,720 --> 01:49:37,360
that's just a solution to a problem.

2339
01:49:37,360 --> 01:49:41,400
In that file is enough information to teach the computer what printf

2340
01:49:41,400 --> 01:49:45,000
or what getString and other things are so that I

2341
01:49:45,000 --> 01:49:49,840
don't need to bother moving things around myself or copying and pasting

2342
01:49:49,840 --> 01:49:53,200
whoever wrote printf his or her code into my program.

2343
01:49:53,200 --> 01:49:55,680
Now let's do one final example with coughing.

2344
01:49:55,680 --> 01:49:58,600
And go ahead and call this cough3.c.

2345
01:49:58,600 --> 01:50:01,840
And go ahead and paste my same code as a moment ago just to get us started.

2346
01:50:01,840 --> 01:50:05,120
And recall that the last step of our cough example last week

2347
01:50:05,120 --> 01:50:06,920
was to actually give cough an input.

2348
01:50:06,920 --> 01:50:11,520
I'd kind of like to whittle this code down to literally cough3,

2349
01:50:11,520 --> 01:50:13,760
because this is a really nice abstraction.

2350
01:50:13,760 --> 01:50:17,680
I don't want main to have to think about how many times to just cough three times.

2351
01:50:17,680 --> 01:50:20,120
That's a nice, useful human abstraction.

2352
01:50:20,120 --> 01:50:22,680
Now let's put the functionality down here.

2353
01:50:22,680 --> 01:50:27,160
So if I want cough to be able to tolerate an input like three,

2354
01:50:27,160 --> 01:50:30,040
which mentions avoid presumably needs to change?

2355
01:50:30,040 --> 01:50:32,160
The one on the left or the right?

2356
01:50:32,160 --> 01:50:34,120
The right, the one inside the parentheses.

2357
01:50:34,120 --> 01:50:38,600
And it turns out, just like you can declare variables inside of a function,

2358
01:50:38,600 --> 01:50:43,560
as we've done, so can you declare arguments to a function like this.

2359
01:50:43,560 --> 01:50:46,520
So you can call it anything you want, though the data type matters.

2360
01:50:46,520 --> 01:50:50,720
But this is now saying, hey, computer, cough does not return a value,

2361
01:50:50,720 --> 01:50:53,160
like Aaron did return a piece of paper.

2362
01:50:53,160 --> 01:50:56,160
Hey, computer, cough does take one input.

2363
01:50:56,160 --> 01:50:58,400
It's an integer, and just call it n.

2364
01:50:58,400 --> 01:51:01,960
And now that you've done this, now you can have a line of code in here like this.

2365
01:51:01,960 --> 01:51:10,720
For int i gets 0, i is less than n, i plus plus plus plus plus.

2366
01:51:10,720 --> 01:51:14,120
And then, OK, off by keystrokes here.

2367
01:51:14,120 --> 01:51:17,080
Then I can move this inside here, indent it nicely.

2368
01:51:17,080 --> 01:51:19,960
And now notice all of the complexity of coughing

2369
01:51:19,960 --> 01:51:23,320
has been factored out into a function, my own puzzle piece, if you will,

2370
01:51:23,320 --> 01:51:27,240
that even takes an argument so that now you can literally,

2371
01:51:27,240 --> 01:51:29,280
if I move this far away and out of mind,

2372
01:51:29,280 --> 01:51:32,040
now your program is getting pretty interesting,

2373
01:51:32,040 --> 01:51:34,360
because it really just does what it says.

2374
01:51:34,360 --> 01:51:37,840
And this is a nice functional abstraction, if you will,

2375
01:51:37,840 --> 01:51:43,000
so that now I have a new verb, a new action, a new function called cough.

2376
01:51:43,000 --> 01:51:44,920
Any questions on that one?

2377
01:51:44,920 --> 01:51:47,400
Yeah?

2378
01:51:47,400 --> 01:51:48,120
Sorry, say again?

2379
01:51:48,120 --> 01:51:50,000
What integer with main return?

2380
01:51:50,000 --> 01:51:51,240
What integer with main return?

2381
01:51:51,240 --> 01:51:52,840
It turns out, and we'll come back to this,

2382
01:51:52,840 --> 01:51:55,080
it's going to return 0 almost always by default.

2383
01:51:55,080 --> 01:51:58,040
But that leaves you with almost an infinite number of non-zero values,

2384
01:51:58,040 --> 01:52:00,640
which represent all of the many things that can go wrong.

2385
01:52:00,640 --> 01:52:03,680
So more on that when we start creating more mistakes.

2386
01:52:03,680 --> 01:52:05,080
Let's look at one other.

2387
01:52:05,080 --> 01:52:10,440
Let me go ahead and open this file in advance myself called positive.c.

2388
01:52:10,440 --> 01:52:14,200
Suppose that I'm not content to just have access to get int.

2389
01:52:14,200 --> 01:52:16,400
I want a function called get positive int,

2390
01:52:16,400 --> 01:52:19,400
because for whatever reason, my program, my game, my whatever,

2391
01:52:19,400 --> 01:52:20,720
needs to know a positive value.

2392
01:52:20,720 --> 01:52:23,040
Maybe I'm asking the user how many players are there.

2393
01:52:23,040 --> 01:52:24,320
And that shouldn't be negative.

2394
01:52:24,320 --> 01:52:26,960
It should be a positive integer, like one or two or more.

2395
01:52:27,000 --> 01:52:31,840
So it turns out, I could write a program, if I want, that looks like this.

2396
01:52:31,840 --> 01:52:37,600
Call on this line here a function called get positive int, pass it in a prompt,

2397
01:52:37,600 --> 01:52:41,080
and then store the value still in an integer on the left hand side.

2398
01:52:41,080 --> 01:52:43,600
And then just go ahead and print it out.

2399
01:52:43,600 --> 01:52:48,000
Get positive int has this prototype at the top of the file.

2400
01:52:48,000 --> 01:52:51,880
Notice this is not a function that comes with CS50's library, CS50.h.

2401
01:52:51,880 --> 01:52:54,040
The function is called get positive int, as you would hope.

2402
01:52:54,040 --> 01:52:55,160
It returns an int.

2403
01:52:55,160 --> 01:52:59,880
And it takes a string as its prompt, whatever words you want the human to see.

2404
01:52:59,880 --> 01:53:01,560
Let's scroll down now.

2405
01:53:01,560 --> 01:53:03,800
And this one looks a little more involved.

2406
01:53:03,800 --> 01:53:07,880
And this is not a feature that Scratch has, but let's take a look.

2407
01:53:07,880 --> 01:53:10,800
The first line is identical to the prototype,

2408
01:53:10,800 --> 01:53:12,640
because I literally copied and pasted it.

2409
01:53:12,640 --> 01:53:16,320
Everything between these brackets is the function itself.

2410
01:53:16,320 --> 01:53:18,880
And here, to answer someone's question from earlier on,

2411
01:53:18,880 --> 01:53:22,400
do you have to declare a variable and then use it right away?

2412
01:53:22,400 --> 01:53:23,040
No.

2413
01:53:23,040 --> 01:53:26,600
And that's actually a helpful solution to a problem that we'll see in a moment.

2414
01:53:26,600 --> 01:53:29,440
Notice here, this new keyword, didn't see it before,

2415
01:53:29,440 --> 01:53:33,840
do the following while n is less than 1.

2416
01:53:33,840 --> 01:53:36,160
Previously, we saw a while loop.

2417
01:53:36,160 --> 01:53:37,600
And we saw a for loop.

2418
01:53:37,600 --> 01:53:39,320
We did not see a do while loop.

2419
01:53:39,320 --> 01:53:43,160
And a do while loop, well, it sounds obviously similar to a while loop,

2420
01:53:43,160 --> 01:53:44,920
what seems a little different?

2421
01:53:44,920 --> 01:53:49,640
When I had that forever block earlier translated to while true,

2422
01:53:49,640 --> 01:53:52,440
what was the order of operations?

2423
01:53:52,440 --> 01:53:56,000
Did we check the condition, the true, and then print hello world?

2424
01:53:56,000 --> 01:54:00,520
Or did we just print hello world and then check the condition?

2425
01:54:00,520 --> 01:54:03,080
Yeah, you might not recall precisely, but I did actually.

2426
01:54:03,080 --> 01:54:04,920
I checked is true, true.

2427
01:54:04,920 --> 01:54:06,560
And we all said yes, obviously.

2428
01:54:06,560 --> 01:54:09,680
Printf is a true, printf is a true, printf.

2429
01:54:09,680 --> 01:54:11,840
So check the condition first.

2430
01:54:11,840 --> 01:54:14,880
You might infer then this loop is a little different.

2431
01:54:14,880 --> 01:54:16,680
It has another word, do.

2432
01:54:16,680 --> 01:54:21,720
This is literally going to do this first, and then check the condition,

2433
01:54:21,720 --> 01:54:23,960
and only do it again if the condition is true.

2434
01:54:23,960 --> 01:54:27,240
So it's a nice way of just flipping things around in terms of order

2435
01:54:27,240 --> 01:54:31,960
to do something at least once, rather than potentially never at all,

2436
01:54:31,960 --> 01:54:33,360
like was the case earlier.

2437
01:54:33,360 --> 01:54:34,800
So what are we doing?

2438
01:54:34,800 --> 01:54:37,800
Get an int, passing in this prompt, stored an n.

2439
01:54:37,800 --> 01:54:41,080
And if the user types in a value that's less than 1,

2440
01:54:41,080 --> 01:54:45,120
is this going to be true or false if n is less than 1?

2441
01:54:45,120 --> 01:54:49,960
So if n is like if the human type's in 0, is 0 less than 1?

2442
01:54:49,960 --> 01:54:50,600
True, yes.

2443
01:54:50,600 --> 01:54:51,560
So what happens?

2444
01:54:51,560 --> 01:54:54,240
You go back to the do, and you do it again.

2445
01:54:54,240 --> 01:54:57,560
If the user types in negative 1, is negative 1 less than 1?

2446
01:54:57,560 --> 01:54:58,680
Yes, or true.

2447
01:54:58,680 --> 01:54:59,680
So you do it again.

2448
01:54:59,680 --> 01:55:04,240
If he or she types in negative 2, again, what if he or she types in 50?

2449
01:55:04,240 --> 01:55:06,440
Well, 50 is not less than 1.

2450
01:55:06,440 --> 01:55:08,120
So this is false.

2451
01:55:08,120 --> 01:55:11,440
And so then you proceed to the next line of code altogether.

2452
01:55:11,440 --> 01:55:13,480
But what's interesting about the next line of code

2453
01:55:13,480 --> 01:55:18,520
is that unlike the cough example, which had void as its return type,

2454
01:55:18,520 --> 01:55:21,200
get positive int by default is supposed to return an int.

2455
01:55:21,200 --> 01:55:24,920
Just like, again, Aaron handed me a piece of paper with a string on it.

2456
01:55:24,920 --> 01:55:28,880
And so here, if I want my own custom function called get positive int

2457
01:55:28,880 --> 01:55:30,880
to return a value, there's another word in C.

2458
01:55:30,880 --> 01:55:35,320
You literally write return, and then the name of the variable, or the value,

2459
01:55:35,320 --> 01:55:39,200
that you want to hand back on a metaphorical piece of paper,

2460
01:55:39,200 --> 01:55:42,160
to whatever code is using this.

2461
01:55:42,160 --> 01:55:44,120
So what's this oddity?

2462
01:55:44,120 --> 01:55:47,560
Why can I not do this?

2463
01:55:47,600 --> 01:55:52,480
If I were to mimic the code we wrote earlier, like this,

2464
01:55:52,480 --> 01:55:56,200
why does this line of code not work just logically,

2465
01:55:56,200 --> 01:56:00,720
using some of the sort of mental model that we've had thus far?

2466
01:56:00,720 --> 01:56:02,720
Say again?

2467
01:56:02,720 --> 01:56:03,720
Say again?

2468
01:56:03,720 --> 01:56:05,440
Yeah.

2469
01:56:05,440 --> 01:56:08,640
So declaring just means creating is the fancy way in programming of saying creating.

2470
01:56:08,640 --> 01:56:10,840
So this says, hey, computer, give me an integer.

2471
01:56:10,840 --> 01:56:13,880
Call it n and set it equal to the return value of get in.

2472
01:56:13,880 --> 01:56:17,760
So whatever the function, or Aaron, hands me back, put it over here.

2473
01:56:17,760 --> 01:56:21,560
But the problem is that in C, variables have scope.

2474
01:56:21,560 --> 01:56:27,120
Scope is a fancy way of saying they only exist in between the curly braces

2475
01:56:27,120 --> 01:56:29,000
between which they were declared.

2476
01:56:29,000 --> 01:56:33,440
So that means that this line, this variable, n, literally only exists

2477
01:56:33,440 --> 01:56:36,760
between here and here, and then it just kind of goes away.

2478
01:56:36,760 --> 01:56:38,680
The computer doesn't know about it anymore.

2479
01:56:38,680 --> 01:56:41,520
But that's a problem, because on what line number do we actually

2480
01:56:41,520 --> 01:56:44,880
need to know n?

2481
01:56:44,880 --> 01:56:48,080
Looks like 21, and that's outside the curly braces.

2482
01:56:48,080 --> 01:56:50,560
So just based on that basic definition, scope

2483
01:56:50,560 --> 01:56:53,200
is the two curly braces between which a variable is declared.

2484
01:56:53,200 --> 01:56:54,520
It doesn't exist outside of them.

2485
01:56:54,520 --> 01:56:56,600
This code just won't work, and I'll fix it later

2486
01:56:56,600 --> 01:56:58,320
so that you see the correct error message.

2487
01:56:58,320 --> 01:56:59,640
Why does this not work?

2488
01:56:59,640 --> 01:57:02,480
Well, you're declaring n inside of those curly braces.

2489
01:57:02,480 --> 01:57:03,760
So how do you avoid this?

2490
01:57:03,760 --> 01:57:06,200
Well, it turns out, as someone deposited earlier,

2491
01:57:06,200 --> 01:57:09,760
just declare it by itself without even giving it a value.

2492
01:57:09,800 --> 01:57:13,360
And indeed, the syntax for that is just to do half of a thought.

2493
01:57:13,360 --> 01:57:14,840
Int n semicolon.

2494
01:57:14,840 --> 01:57:16,760
It has no value that we know yet.

2495
01:57:16,760 --> 01:57:19,360
It has a garbage value, but more on that another time.

2496
01:57:19,360 --> 01:57:20,360
But it does now exist.

2497
01:57:20,360 --> 01:57:24,840
And now notice which curly braces does it exist within this one

2498
01:57:24,840 --> 01:57:27,920
and this one, which means now it's accessible everywhere.

2499
01:57:27,920 --> 01:57:30,520
And if you and your Scratch programs actually used variables,

2500
01:57:30,520 --> 01:57:32,160
you might have noticed that you had to choose.

2501
01:57:32,160 --> 01:57:36,040
You had to make a decision for this sprite or for all sprites.

2502
01:57:36,040 --> 01:57:41,680
That was an illusion to what's called in programming a local or a global variable.

2503
01:57:41,680 --> 01:57:44,280
These are still local, and we'll come back to this term earlier.

2504
01:57:44,280 --> 01:57:46,320
But it has to do with scope, because if you

2505
01:57:46,320 --> 01:57:48,920
had specified for this sprite only, MIT

2506
01:57:48,920 --> 01:57:52,360
would have only let you use that variable for that specific sprite,

2507
01:57:52,360 --> 01:57:55,760
that cat, or sheep, or whatever it was you were programming.

2508
01:57:55,760 --> 01:58:00,920
Just as in C, this now means n can be used here and here, but not elsewhere,

2509
01:58:00,920 --> 01:58:03,240
like higher up in my program.

2510
01:58:03,240 --> 01:58:06,200
That's the matter of scope.

2511
01:58:06,200 --> 01:58:09,800
So let's now see what can go wrong beyond that.

2512
01:58:09,800 --> 01:58:14,240
Let me go ahead and open up this, because it turns out, when programming,

2513
01:58:14,240 --> 01:58:17,840
there's other issues that can happen, not just floating point in precision,

2514
01:58:17,840 --> 01:58:19,520
as I described it as earlier.

2515
01:58:19,520 --> 01:58:22,920
It turns out that there's other problems that can go wrong,

2516
01:58:22,920 --> 01:58:25,880
even with integers, that we kind of avoid it all together.

2517
01:58:25,880 --> 01:58:28,160
So recall that we started talking about 1, 2, and 3,

2518
01:58:28,160 --> 01:58:30,560
and why it's 123 last week.

2519
01:58:30,560 --> 01:58:34,400
Well, what happens in decimal if you add 1 to 123?

2520
01:58:34,400 --> 01:58:35,840
What number do you get?

2521
01:58:35,840 --> 01:58:37,000
Obviously, 124.

2522
01:58:37,000 --> 01:58:40,520
If we do it again, 125, 26, 27, 28, 29.

2523
01:58:40,520 --> 01:58:45,160
What happens in decimal if I add 1 to a 9?

2524
01:58:45,160 --> 01:58:48,520
Well, I should get 10, but that's not how we would write this.

2525
01:58:48,520 --> 01:58:51,680
You put down the 0 instead, and you carry the 1.

2526
01:58:51,680 --> 01:58:54,040
Remember those kind of mental heuristics?

2527
01:58:54,040 --> 01:58:55,200
So that's all we did there.

2528
01:58:55,200 --> 01:59:00,400
And then it's 2 plus 1, so that's why 129 plus 1

2529
01:59:00,400 --> 01:59:03,840
is 130, because you put the 0, you carry the 1, and so forth.

2530
01:59:03,840 --> 01:59:05,720
So we just all do that intuitively now.

2531
01:59:05,720 --> 01:59:08,440
But this has implications for what computers do, too.

2532
01:59:08,440 --> 01:59:12,160
Because suppose that we consider a bigger number, like 999.

2533
01:59:12,160 --> 01:59:15,920
And so what do you get when you add 1 to 999?

2534
01:59:15,920 --> 01:59:20,280
Well, you carry the 1, you carry the 1, and you get, hopefully, 1,000.

2535
01:59:20,280 --> 01:59:25,000
But what if your computer only has space for three digits?

2536
01:59:25,000 --> 01:59:28,120
Or what if your phone, or what if your alarm clock, or whatever the device is,

2537
01:59:28,120 --> 01:59:31,680
literally only has room for three digits?

2538
01:59:31,680 --> 01:59:37,840
What is 999 plus 1 if your hardware only has three digits?

2539
01:59:37,840 --> 01:59:39,320
Well, it's apparently 0.

2540
01:59:39,320 --> 01:59:44,720
So you get this kind of overflow, where 998, 999, 0.

2541
01:59:44,720 --> 01:59:46,320
It overflows, so to speak.

2542
01:59:46,320 --> 01:59:50,360
The 1 kind of falls off conceptually, and you roll over to the next value,

2543
01:59:50,360 --> 01:59:52,560
which is 0, 0, 0.

2544
01:59:52,560 --> 01:59:54,560
So what about in binary?

2545
01:59:54,560 --> 01:59:58,160
What number is this in binary if you translate it to decimal in your head?

2546
01:59:58,160 --> 02:00:02,720
And remember, it's the 1's column, the 2's column, and the 4's column.

2547
02:00:02,720 --> 02:00:04,600
So this was 7 in binary, 1.

2548
02:00:04,600 --> 02:00:06,440
So it's 4 plus 2 plus 1.

2549
02:00:06,440 --> 02:00:08,000
So 7 in binary.

2550
02:00:08,000 --> 02:00:10,080
So how do you do arithmetic with binary?

2551
02:00:10,080 --> 02:00:11,200
It's actually the same thing.

2552
02:00:11,200 --> 02:00:15,280
It's just you don't have 2's, or 3's, or 9's, or anything in between.

2553
02:00:15,280 --> 02:00:16,480
You just have 1's and 0's.

2554
02:00:16,480 --> 02:00:20,120
So what do you get when you add 1 to 111?

2555
02:00:20,120 --> 02:00:21,360
Well, it's the same idea.

2556
02:00:21,360 --> 02:00:23,320
You put down a 0, and you carry the 1.

2557
02:00:23,360 --> 02:00:26,680
Because 1 plus 1, you want to say 2 in decimal, but there is no 2.

2558
02:00:26,680 --> 02:00:29,040
So it rolls over to 0, but you carry the 1.

2559
02:00:29,040 --> 02:00:31,840
1 plus 1 is 2, but OK, that's 0.

2560
02:00:31,840 --> 02:00:32,760
Carry the 1.

2561
02:00:32,760 --> 02:00:35,600
1 plus 1, that's 2, but I don't have a 2, so I go back to 0.

2562
02:00:35,600 --> 02:00:36,320
Carry the 1.

2563
02:00:36,320 --> 02:00:42,520
So in binary, if you only have 3 bytes, or bits rather,

2564
02:00:42,520 --> 02:00:47,880
if you only have 3 bits, what do you get when you add 1 to 7 in binary?

2565
02:00:47,880 --> 02:00:49,360
You apparently get 0.

2566
02:00:49,360 --> 02:00:50,880
And now it's getting more real.

2567
02:00:50,920 --> 02:00:53,240
In my computer, in my phone, in all of your hardware,

2568
02:00:53,240 --> 02:00:55,680
it's just a finite amount of memory, RAM, that little chip

2569
02:00:55,680 --> 02:00:58,120
that I showed on the screen with all the little circuits.

2570
02:00:58,120 --> 02:01:01,400
And that has more than 3 bits of memory, certainly.

2571
02:01:01,400 --> 02:01:02,520
But it is finite.

2572
02:01:02,520 --> 02:01:06,040
And if we're only using, as a matter of convention, 32 bits to represent things,

2573
02:01:06,040 --> 02:01:09,320
or 64 bits, maybe if we use doubles, or something else called along.

2574
02:01:09,320 --> 02:01:14,520
Along is a 64-bit integer, whereas an integer is typically 32 bits.

2575
02:01:14,520 --> 02:01:17,920
It seems that at some point, numbers might overflow,

2576
02:01:17,920 --> 02:01:21,360
and we're going to actually have some, so to speak, imprecision.

2577
02:01:21,360 --> 02:01:23,280
Ergo, integer overflow.

2578
02:01:23,280 --> 02:01:26,560
So you can actually see this or defenses against this in the real world.

2579
02:01:26,560 --> 02:01:29,120
So this is a screenshot from a game that is

2580
02:01:29,120 --> 02:01:30,800
common on a few different platforms.

2581
02:01:30,800 --> 02:01:34,680
And it's a game that allows you to accumulate coins or points, really,

2582
02:01:34,680 --> 02:01:36,080
or little Lego pieces.

2583
02:01:36,080 --> 02:01:37,800
And if you accumulate these points, you'll

2584
02:01:37,800 --> 02:01:40,880
notice that eventually, if you have way too much free time,

2585
02:01:40,880 --> 02:01:43,800
you can only score so high in this game.

2586
02:01:43,800 --> 02:01:46,520
What's the highest score, apparently, according to the screenshot

2587
02:01:46,560 --> 02:01:49,240
from whoever took this after playing for too many hours?

2588
02:01:49,240 --> 02:01:51,320
Wasn't me.

2589
02:01:51,320 --> 02:01:52,440
Four million.

2590
02:01:52,440 --> 02:01:53,480
No, four billion.

2591
02:01:53,480 --> 02:01:54,640
Four billion.

2592
02:01:54,640 --> 02:01:56,000
Why is that?

2593
02:01:56,000 --> 02:01:59,520
Well, it turns out that if numbers and computers, as I've proposed,

2594
02:01:59,520 --> 02:02:03,080
are generally stored using 32 bits, that kind of invites the question,

2595
02:02:03,080 --> 02:02:05,000
well, how high can you count with 32 bits?

2596
02:02:05,000 --> 02:02:08,480
Well, 32 bits means you have 32 zeros and ones.

2597
02:02:08,480 --> 02:02:11,640
The biggest they could be is like 1, 1, 1, 1, 1, 32 ones.

2598
02:02:11,640 --> 02:02:15,360
And if you actually do the math using our little columns and so forth,

2599
02:02:15,360 --> 02:02:18,680
it's roughly four billion, a little bigger than four billion.

2600
02:02:18,680 --> 02:02:21,520
So the authors of this Lego game just decided, you know what,

2601
02:02:21,520 --> 02:02:24,240
let's just say that the maximum number of points or coins

2602
02:02:24,240 --> 02:02:26,880
you can accumulate in this Lego game is four billion even.

2603
02:02:26,880 --> 02:02:27,160
Why?

2604
02:02:27,160 --> 02:02:31,200
It just looks even cleaner than whatever the actual value is.

2605
02:02:31,200 --> 02:02:32,080
But why?

2606
02:02:32,080 --> 02:02:36,760
How many bits are they using to store your score in this game?

2607
02:02:36,760 --> 02:02:40,240
Presumably, 32 bits or four bytes.

2608
02:02:40,240 --> 02:02:41,200
And that's just convention.

2609
02:02:41,200 --> 02:02:43,400
Whatever language they program this game is,

2610
02:02:43,400 --> 02:02:45,560
it probably has a data type called an int.

2611
02:02:45,560 --> 02:02:48,440
And that int, by convention, uses 32 bits.

2612
02:02:48,440 --> 02:02:51,840
So at some point, they decide we can either use more memory,

2613
02:02:51,840 --> 02:02:53,280
as you proposed earlier, for doubles.

2614
02:02:53,280 --> 02:02:54,320
Let's use 64 bits.

2615
02:02:54,320 --> 02:02:56,600
Then you can have crazy numbers of hours playing the game

2616
02:02:56,600 --> 02:02:57,840
and getting more and more points.

2617
02:02:57,840 --> 02:03:01,120
Or we can just say, that's enough points to accumulate in the game.

2618
02:03:01,120 --> 02:03:02,920
Now, that's when you actually anticipate this.

2619
02:03:02,920 --> 02:03:04,880
This doesn't always actually happen.

2620
02:03:04,880 --> 02:03:08,800
If we go ahead and take a look at some example code,

2621
02:03:08,800 --> 02:03:12,840
let me go ahead and open up overflow.c.

2622
02:03:12,840 --> 02:03:17,720
In this program here, you'll see on line eight this slash slash syntax.

2623
02:03:17,720 --> 02:03:20,880
And I've had a bunch of these so far, but I haven't actually mentioned them.

2624
02:03:20,880 --> 02:03:23,120
Turns out in C, just like in Scratch, though odds are you

2625
02:03:23,120 --> 02:03:25,040
didn't notice this little feature of Scratch,

2626
02:03:25,040 --> 02:03:26,600
you can have what are called comments.

2627
02:03:26,600 --> 02:03:29,880
A comment is just a note to yourself, to your TF, to your friend,

2628
02:03:29,880 --> 02:03:32,600
to your colleague, whatever whom you're writing code with.

2629
02:03:32,600 --> 02:03:36,240
And it's just a note to self, like to remind yourself of what the code does.

2630
02:03:36,240 --> 02:03:39,480
Without this line, I could, once I'm comfortable enough programming,

2631
02:03:39,480 --> 02:03:41,560
kind of figure out what these lines of code are doing.

2632
02:03:41,560 --> 02:03:43,040
But frankly, that's a waste of time.

2633
02:03:43,040 --> 02:03:44,000
I wrote the code once.

2634
02:03:44,000 --> 02:03:46,640
And if I look at it weeks or months later or someone else wrote it,

2635
02:03:46,640 --> 02:03:47,880
just tell me what it does.

2636
02:03:47,880 --> 02:03:52,600
So a comment in a program is just like a nice summary of like a few lines

2637
02:03:52,600 --> 02:03:56,200
of code, or it's a summary in English or whatever spoken language that

2638
02:03:56,200 --> 02:03:59,960
kind of describes what otherwise a cryptic looking code might actually

2639
02:03:59,960 --> 02:04:03,360
be doing, so you don't have to think too hard about it to understand a program.

2640
02:04:03,360 --> 02:04:05,160
So iteratively, double I.

2641
02:04:05,160 --> 02:04:08,640
Iteratively, it just means loopingly, again and again and again.

2642
02:04:08,640 --> 02:04:09,440
This is funky.

2643
02:04:09,480 --> 02:04:12,640
We didn't see this before, but you might guess what it does.

2644
02:04:12,640 --> 02:04:15,560
What does star equals do?

2645
02:04:15,560 --> 02:04:16,280
It does double.

2646
02:04:16,280 --> 02:04:20,680
It's like plus equals adds 1, star equals doubles if the value on the right

2647
02:04:20,680 --> 02:04:21,400
is 2.

2648
02:04:21,400 --> 02:04:26,880
So this is going to start printing 1, then 2, then 4, then 8, and so forth.

2649
02:04:26,880 --> 02:04:29,360
And notice this function, it's called sleep.

2650
02:04:29,360 --> 02:04:31,440
It literally is going to sleep for a second.

2651
02:04:31,440 --> 02:04:34,240
And that sleep function has a prototype that someone else

2652
02:04:34,240 --> 02:04:37,520
wrote in a file called unistandard.h.

2653
02:04:37,520 --> 02:04:39,800
I only know that by looking it up in the documentation,

2654
02:04:39,800 --> 02:04:42,200
but that's a new file just for sleeping.

2655
02:04:42,200 --> 02:04:45,520
Make overflow, which is kind of apt here.

2656
02:04:45,520 --> 02:04:48,800
And let me go ahead and make the terminal window even bigger for this one.

2657
02:04:48,800 --> 02:04:51,960
Dot slash overflow.

2658
02:04:51,960 --> 02:04:54,720
OK, it's going.

2659
02:04:54,720 --> 02:04:55,280
It's going.

2660
02:04:55,280 --> 02:04:57,200
It's going to go faster and faster, so to speak,

2661
02:04:57,200 --> 02:05:02,480
because we're adding more and more each time by doubling.

2662
02:05:02,480 --> 02:05:07,560
All right, 2,000, 4,000, 8,000, 16,000.

2663
02:05:07,560 --> 02:05:10,920
Still going, 64,000, 65,000.

2664
02:05:10,920 --> 02:05:12,680
Now we're into the millions.

2665
02:05:12,680 --> 02:05:16,120
Two millions, four, eight, 16 million.

2666
02:05:16,120 --> 02:05:18,240
It's getting bigger and bigger.

2667
02:05:18,240 --> 02:05:22,120
All of these big numbers.

2668
02:05:22,120 --> 02:05:24,080
Ooh, interesting.

2669
02:05:24,080 --> 02:05:26,720
What just happened?

2670
02:05:26,720 --> 02:05:29,680
So it turns out if you double numbers big enough, you get zero eventually.

2671
02:05:29,680 --> 02:05:31,880
Also, something you probably weren't taught.

2672
02:05:31,880 --> 02:05:32,760
So what actually happened?

2673
02:05:32,760 --> 02:05:34,560
Control C will cancel this.

2674
02:05:34,560 --> 02:05:35,200
What happened?

2675
02:05:35,200 --> 02:05:39,120
I mean, the program's trying to tell me, even though it's a little cryptic,

2676
02:05:39,120 --> 02:05:40,440
signed integer overflow.

2677
02:05:40,440 --> 02:05:43,040
Sign just means it went from positive to negative, essentially.

2678
02:05:43,040 --> 02:05:45,800
So what happened?

2679
02:05:45,800 --> 02:05:46,800
What's that?

2680
02:05:46,800 --> 02:05:47,920
Yeah, I ran out of bits.

2681
02:05:47,920 --> 02:05:50,000
I'm doubling the number again and again and again.

2682
02:05:50,000 --> 02:05:54,360
And at some point, we carried the one, so to speak, and it was a 33rd one,

2683
02:05:54,360 --> 02:05:56,720
therefore past the boundaries of a 32-bit value.

2684
02:05:56,720 --> 02:05:58,680
And it just rolled over to apparently a negative,

2685
02:05:58,680 --> 02:06:00,760
because at some point, and we haven't talked about it,

2686
02:06:00,760 --> 02:06:04,400
we can use the leftmost bit, in some sense, to say positive or negative.

2687
02:06:04,400 --> 02:06:06,160
We've just talked about positive so far.

2688
02:06:06,160 --> 02:06:08,920
And then at that point, frankly, the computer just gave up, not really

2689
02:06:08,920 --> 02:06:10,960
knowing what you intended beyond that.

2690
02:06:10,960 --> 02:06:14,440
So if you don't write code to handle this situation

2691
02:06:14,440 --> 02:06:18,720
and make sure that your numbers are less than 4 billion before you roll over,

2692
02:06:18,720 --> 02:06:20,200
just bugs will happen.

2693
02:06:20,200 --> 02:06:24,680
And this might seem contrived here, but this happened not too long ago.

2694
02:06:24,680 --> 02:06:28,600
So 1999 was just before a lot of people thought the world was going to end,

2695
02:06:28,600 --> 02:06:31,240
because of the so-called Y2K bug.

2696
02:06:31,240 --> 02:06:36,040
And it really wasn't so much a bug, as it was lack of forethought or lack of features.

2697
02:06:36,040 --> 02:06:38,240
What was the Y2K problem in a nutshell?

2698
02:06:42,200 --> 02:06:43,400
Someone want to propose?

2699
02:06:43,400 --> 02:06:44,840
Even in a non-technical sense, yeah?

2700
02:06:44,840 --> 02:06:45,340
Yeah.

2701
02:06:45,340 --> 02:06:48,480
You're just going to display in the number 2000 a year.

2702
02:06:48,480 --> 02:06:49,320
Yeah.

2703
02:06:49,320 --> 02:06:51,680
Yeah, so let me summarize here.

2704
02:06:51,680 --> 02:06:55,160
So if they are only using two digits to display values,

2705
02:06:55,160 --> 02:07:00,080
you could confuse the year 2000 with actually the year 1900.

2706
02:07:00,080 --> 02:07:04,280
Because long story short, what humans did kind of reasonably decades ago was,

2707
02:07:04,280 --> 02:07:06,000
you know, space was expensive.

2708
02:07:06,000 --> 02:07:07,440
Computers were expensive.

2709
02:07:07,440 --> 02:07:11,400
Memory was not sort of as abundant as it is now with all the cloud storage

2710
02:07:11,400 --> 02:07:12,040
and the like.

2711
02:07:12,040 --> 02:07:12,920
So you know what?

2712
02:07:12,920 --> 02:07:19,000
If it was like 1970, do we really care about 1969, 1968, let alone 1900?

2713
02:07:19,000 --> 02:07:19,680
Not really.

2714
02:07:19,680 --> 02:07:25,080
Let's just assume we're all in the 1900s and never show or store 19.

2715
02:07:25,080 --> 02:07:27,200
Let's just store two digits for every year.

2716
02:07:27,200 --> 02:07:28,720
So 70 is 70.

2717
02:07:28,720 --> 02:07:30,840
99 is 1999.

2718
02:07:30,840 --> 02:07:34,320
But the problem is the humans ended up running code

2719
02:07:34,320 --> 02:07:39,400
that they wrote years ago, decades ago, way longer than humans thought they might.

2720
02:07:39,400 --> 02:07:39,760
Why?

2721
02:07:39,760 --> 02:07:40,560
Well, it's expensive.

2722
02:07:40,560 --> 02:07:42,080
It's time consuming to change code.

2723
02:07:42,080 --> 02:07:42,840
The code's working.

2724
02:07:42,840 --> 02:07:44,120
Why try to break it?

2725
02:07:44,120 --> 02:07:48,680
Problem is too, as people aged and passed away, there's fewer and fewer people.

2726
02:07:48,680 --> 02:07:51,600
They'd even knew the languages in which those programs were written.

2727
02:07:51,600 --> 02:07:53,760
And so now who's going to even update the software?

2728
02:07:53,760 --> 02:07:56,680
So lots of problems were feared.

2729
02:07:56,680 --> 02:08:03,560
And this really just boils down to because 1999 might have overflowed to not zero per se,

2730
02:08:03,560 --> 02:08:06,200
but an implicit 1900.

2731
02:08:06,200 --> 02:08:08,680
And indeed, this definitely happened, though not nearly on the scale,

2732
02:08:08,680 --> 02:08:09,680
as people thought.

2733
02:08:09,680 --> 02:08:12,440
But it does happen in even more real terms just a few years ago.

2734
02:08:12,440 --> 02:08:16,160
This is a Boeing 787, an actual airplane that

2735
02:08:16,160 --> 02:08:21,560
had to be grounded for some amount of time because it had a programming error.

2736
02:08:21,560 --> 02:08:24,760
And it summarized here in an online article.

2737
02:08:24,760 --> 02:08:30,720
A 787 airplane that has been powered continuously for 248 days, it turns out,

2738
02:08:30,720 --> 02:08:36,240
was the warning, can lose all of its electrical power due to the generator

2739
02:08:36,240 --> 02:08:38,320
going into failsafe mode.

2740
02:08:38,320 --> 02:08:38,960
Why is that?

2741
02:08:38,960 --> 02:08:44,080
This condition is caused by a software counter-internal to the generator

2742
02:08:44,080 --> 02:08:49,040
that will overflow after 248 days of continuous power.

2743
02:08:49,040 --> 02:08:50,600
So translate that.

2744
02:08:50,640 --> 02:08:54,560
That just means there's software running in the Boeing's actual 787s.

2745
02:08:54,560 --> 02:08:56,440
They were using 32-bit integers.

2746
02:08:56,440 --> 02:08:59,920
They were using those integers to store hundreds of seconds.

2747
02:08:59,920 --> 02:09:05,200
And at some point, if you leave your plane on for 248 days,

2748
02:09:05,200 --> 02:09:10,240
each of which has 24 hours, 60 minutes in an hour, 60 seconds in a minute,

2749
02:09:10,240 --> 02:09:15,120
and 100 tenths of a second, or 100 one hundredths of a second,

2750
02:09:15,120 --> 02:09:20,200
in every second, that product of multiplying things out gets big pretty fast.

2751
02:09:20,200 --> 02:09:25,080
And on day 249, planes, theoretically, would shut down even

2752
02:09:25,080 --> 02:09:27,520
in the middle of flight for very real reasons,

2753
02:09:27,520 --> 02:09:31,240
because a really big number rolls over to zero and that confused the generator.

2754
02:09:31,240 --> 02:09:36,720
These are actual smart airplane engineers making these kinds of mistakes

2755
02:09:36,720 --> 02:09:40,120
because of software, not anticipating one line of code or some number of lines

2756
02:09:40,120 --> 02:09:43,320
of code, or as you proposed, why didn't they just use more bits?

2757
02:09:43,320 --> 02:09:45,360
And again, these are very real concerns.

2758
02:09:45,360 --> 02:09:48,400
So this was, thankfully, addressed and solved, but not before.

2759
02:09:48,400 --> 02:09:50,760
Of course, there was quite the scare there.

2760
02:09:50,760 --> 02:09:55,040
So it turns out in an older game, this was the game of civilization,

2761
02:09:55,040 --> 02:09:58,480
turns out that one of the characters, as whom you can play, Gandhi,

2762
02:09:58,480 --> 02:10:02,560
is actually not as peaceful a character in the game as you might think.

2763
02:10:02,560 --> 02:10:05,320
And let's, for context, just take a look here for a second.

2764
02:10:05,320 --> 02:10:10,040
If we actually take a look at some more binary,

2765
02:10:10,040 --> 02:10:13,680
this in binary is what number in decimal?

2766
02:10:13,680 --> 02:10:14,480
OK, one.

2767
02:10:14,480 --> 02:10:15,720
And this is 8 bits.

2768
02:10:15,720 --> 02:10:16,840
So it's a full byte.

2769
02:10:16,840 --> 02:10:17,640
8 bits is a byte.

2770
02:10:17,640 --> 02:10:20,000
1, 2, 3, 4, 5, 6, 7, 8.

2771
02:10:20,000 --> 02:10:26,760
So what do you get if you subtract 1 from this?

2772
02:10:26,760 --> 02:10:28,440
You obviously get what?

2773
02:10:28,440 --> 02:10:29,160
OK, all 0.

2774
02:10:29,160 --> 02:10:30,920
So 1 minus 1 is just 0.

2775
02:10:30,920 --> 02:10:35,280
What if you subtract 2 from this value?

2776
02:10:35,280 --> 02:10:37,360
What happens?

2777
02:10:37,360 --> 02:10:40,440
This is actually called integer underflow, which is just the opposite.

2778
02:10:40,440 --> 02:10:42,600
But there's really not too many options to think about this.

2779
02:10:42,600 --> 02:10:44,440
If you only have 0s and 1s, you can probably

2780
02:10:44,440 --> 02:10:45,920
imagine what the bad scenario is.

2781
02:10:45,960 --> 02:10:50,640
If 0, 0, 0, 0, 0, 0, 0, 1, if you subtract 1 goes to 0s,

2782
02:10:50,640 --> 02:10:54,360
and then you do it again, you now underflow, which just brings you

2783
02:10:54,360 --> 02:10:55,680
around to the opposite.

2784
02:10:55,680 --> 02:10:58,160
1, 1, 1, 1, 1, 1, 1.

2785
02:10:58,160 --> 02:11:01,840
So if you have 8 1s, what value is that?

2786
02:11:01,840 --> 02:11:06,720
If you do the math 1s, 2s, 4s, 8, 16s, it turns out it's 255

2787
02:11:06,720 --> 02:11:08,360
if you actually do out all the math.

2788
02:11:08,360 --> 02:11:10,960
So it turns out that this game's civilization

2789
02:11:10,960 --> 02:11:15,200
was using a single byte to represent every character's level of aggressiveness

2790
02:11:15,200 --> 02:11:15,880
in the game.

2791
02:11:15,880 --> 02:11:19,360
And Gandhi's was, as you would expect, by default initialized to 1,

2792
02:11:19,360 --> 02:11:21,320
like very non-aggressive.

2793
02:11:21,320 --> 02:11:24,440
Unfortunately, in this game of civilization,

2794
02:11:24,440 --> 02:11:28,600
when a player adopts democracy in his or her civilization,

2795
02:11:28,600 --> 02:11:32,920
their aggression would be automatically reduced by 2.

2796
02:11:32,920 --> 02:11:37,280
And so if Gandhi went democratic, his aggression wouldn't go to negative 1.

2797
02:11:37,280 --> 02:11:40,840
It looped back around to the ludicrously high figure of 255,

2798
02:11:40,840 --> 02:11:45,080
making him as aggressive as a civilization could possibly be.

2799
02:11:45,120 --> 02:11:49,000
So less impactful, to be sure, than something like the airplane example.

2800
02:11:49,000 --> 02:11:51,000
But these problems are omnipresent.

2801
02:11:51,000 --> 02:11:53,240
And if you start to keep an eye out in the popular media,

2802
02:11:53,240 --> 02:11:55,320
or when there are bugs, or hacks, or exploits,

2803
02:11:55,320 --> 02:12:01,680
it's so often because a programmer has made a mistake in his or her code.

2804
02:12:01,680 --> 02:12:03,000
They didn't anticipate a scenario.

2805
02:12:03,000 --> 02:12:06,120
Or they made maybe reasonable decisions years ago,

2806
02:12:06,120 --> 02:12:09,280
but that eventually proved to be naive, and that we're still running the same code.

2807
02:12:09,280 --> 02:12:10,760
Numbers are getting too big.

2808
02:12:10,760 --> 02:12:11,840
Their math is wrong.

2809
02:12:11,840 --> 02:12:13,280
And so very real things happen.

2810
02:12:13,280 --> 02:12:17,240
But what's most important for us is just understanding how and why those things

2811
02:12:17,240 --> 02:12:17,880
happen.

2812
02:12:17,880 --> 02:12:19,720
And so what will we do in the days ahead?

2813
02:12:19,720 --> 02:12:21,480
So the next homework assignment, as with Scratch,

2814
02:12:21,480 --> 02:12:22,520
will be to program something.

2815
02:12:22,520 --> 02:12:25,880
But this time in C, you'll use an environment called CS50 Lab, which

2816
02:12:25,880 --> 02:12:28,920
essentially is CS50 Sandbox, with which we've been tinkering today.

2817
02:12:28,920 --> 02:12:32,160
But it adds to it the instructions and the specification of the problems

2818
02:12:32,160 --> 02:12:33,080
that you'll want to solve.

2819
02:12:33,080 --> 02:12:35,520
And it will hold your hands initially through some of these steps.

2820
02:12:35,520 --> 02:12:38,640
You don't need to have written everything down and memorized everything I typed today,

2821
02:12:38,640 --> 02:12:41,600
but do feel free in the meantime to go to the course's website and play

2822
02:12:41,600 --> 02:12:42,920
with any of those examples.

2823
02:12:42,960 --> 02:12:46,960
Among the challenges ahead will be to recreate some snippets of games

2824
02:12:46,960 --> 02:12:49,800
from yesteryear, thinking about how things you might have seen growing up

2825
02:12:49,800 --> 02:12:51,560
can be translated to actual code.

2826
02:12:51,560 --> 02:12:54,880
And undoubtedly, among the first things you'll experience is frustration.

2827
02:12:54,880 --> 02:12:57,760
You'll forget the stupid semicolon, or where does the parenthesis go,

2828
02:12:57,760 --> 02:12:59,120
and you'll have to look back at code.

2829
02:12:59,120 --> 02:13:01,080
But keep in mind, none of that stuff matters.

2830
02:13:01,080 --> 02:13:02,880
It's absolutely frustrating initially.

2831
02:13:02,880 --> 02:13:06,400
But what's most important is the idea is, and honestly, the sense of gratification

2832
02:13:06,400 --> 02:13:08,760
that you, like all of CS50 staff before you,

2833
02:13:08,760 --> 02:13:12,000
ultimately feel when actually building and creating something of your own.

2834
02:13:12,000 --> 02:13:14,040
So let's call it a day there, and we'll see you next time.

