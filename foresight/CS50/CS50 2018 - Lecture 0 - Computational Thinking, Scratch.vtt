WEBVTT

00:00.000 --> 00:13.420
Thank You for wearing T-shirt.

00:30.000 --> 00:55.360
This is CS50, Harvard University's introduction to the intellectual enterprises of computer

00:55.360 --> 00:57.520
science and the arts of programming.

00:57.520 --> 01:02.200
My name is David Malan, and if you are among those in the room who are thinking, why am

01:02.200 --> 01:06.200
I in a class of computer science, realize that I, too, felt that exact same way.

01:06.200 --> 01:10.200
In fact, my freshman year, I didn't quite get up the nerve to take this class, or computer

01:10.200 --> 01:11.560
science, more generally.

01:11.560 --> 01:14.080
And that was largely because I was intimidated by it.

01:14.080 --> 01:15.320
I was a little nervous.

01:15.320 --> 01:19.440
It felt well out of my comfort zone, and I really didn't know at the end of the day what

01:19.440 --> 01:20.440
it actually was.

01:20.440 --> 01:23.880
But realize if you, too, are feeling a little bit of that, or even if you're among those

01:23.880 --> 01:27.440
more comfortable who have dabbled in computer science or programming, realize that they're

01:27.440 --> 01:30.720
so many blanks that we can fill in along the way so that, ultimately, at the end of

01:30.720 --> 01:35.040
the semester, everyone will feel themselves on the same page.

01:35.040 --> 01:40.000
And until then, rest assured that 68% of the people sitting to your left and to your right

01:40.000 --> 01:46.080
and behind and in front have never taken a CS course before, which may very well be the

01:46.080 --> 01:47.760
demographic into which you fit.

01:47.760 --> 01:52.480
But realize, too, that with such an amazing support structure, with so many office hours

01:52.480 --> 01:56.680
and sections and materials and beyond, realize that what's ultimately important in this course

01:56.720 --> 02:01.720
is not so much where you end up relative to your classmates in week 10, our final week,

02:01.720 --> 02:05.040
but where you end up relative to yourself in week zero.

02:05.040 --> 02:06.680
And indeed, that is where we now are.

02:06.680 --> 02:09.400
And as it turns out, computer scientists start counting at zero.

02:09.400 --> 02:14.240
And so over the next 11 weeks, will we take you from being among those less comfortable

02:14.240 --> 02:17.680
or perhaps somewhere in between less comfortable and more to feeling much more

02:17.680 --> 02:21.120
comfortable and confident and capable than that?

02:21.120 --> 02:24.720
But to get there, we need to understand what computer science really is.

02:24.760 --> 02:28.200
And this was something I didn't understand until I set foot in a room like this.

02:28.200 --> 02:31.840
And I dare say we can distill computer science into just this picture.

02:31.840 --> 02:33.960
Computer science is about problem solving.

02:33.960 --> 02:36.120
And I know that high school courses typically

02:36.120 --> 02:38.960
do kind of paint a misleading picture that it's only about.

02:38.960 --> 02:41.920
And it's entirely about programming and people with their heads down

02:41.920 --> 02:44.920
in the computer lab working fairly anti-socially on code.

02:44.920 --> 02:48.680
But the reality is it's all about solving problems and very often solving problems

02:48.680 --> 02:52.680
collaboratively, either in person or by leveraging code programs that others

02:52.680 --> 02:53.880
have written in the past.

02:53.880 --> 02:55.640
And what does it mean to solve a problem?

02:55.640 --> 02:57.280
Well, you need inputs.

02:57.280 --> 02:58.920
So there's a problem you're trying to solve.

02:58.920 --> 02:59.920
That is the input.

02:59.920 --> 03:00.680
And you want output.

03:00.680 --> 03:02.360
You want the solution to that problem.

03:02.360 --> 03:04.480
And the sort of secret sauce of computer science

03:04.480 --> 03:07.840
is going to be everything in this proverbial black box in the middle

03:07.840 --> 03:12.640
that over the next several weeks, we begin to understand exactly what you can do with that.

03:12.640 --> 03:15.720
But in order to start solving problems, we kind of just

03:15.720 --> 03:18.920
need to decide as a group how we're going to represent these problems.

03:18.920 --> 03:20.280
And what might a problem be?

03:20.280 --> 03:22.000
Well, in this room, there's a whole bunch of people.

03:22.000 --> 03:25.240
If we wanted to take attendance or count the number of people in this room,

03:25.240 --> 03:28.640
I might need to start keeping track of how many people I see.

03:28.640 --> 03:31.320
But how do I represent the number of people I see?

03:31.320 --> 03:32.880
Well, I can do it sort of old school.

03:32.880 --> 03:35.640
And I can just take out a piece of chalk or whatnot and say, all right,

03:35.640 --> 03:39.040
I see one, two, three, four, five.

03:39.040 --> 03:41.480
I can do little stylistic conventions like that to save space

03:41.480 --> 03:46.360
or remind myself six, seven, eight, nine, 10, and so forth.

03:46.360 --> 03:49.520
Or I can, of course, just do that on my own hand.

03:49.520 --> 03:53.400
So one, two, three, four, five, and so forth.

03:53.400 --> 03:58.000
But obviously, how high can I count on just one hand?

03:58.000 --> 03:59.520
So five, you would think.

03:59.520 --> 04:02.400
But that's just because we haven't really thought hard enough about this problem.

04:02.400 --> 04:05.480
It turns out that with just these five fingers, let alone these five more,

04:05.480 --> 04:07.720
I can actually count rather higher.

04:07.720 --> 04:10.680
Because after all, the system I'm using of hash marks on the board

04:10.680 --> 04:13.840
or just now with my fingers is just kind of keeping my fingers down.

04:13.840 --> 04:16.840
We're putting them up to represent ones, really.

04:16.840 --> 04:19.840
But what if I actually took into account the order of my fingers

04:19.840 --> 04:23.200
and sort of permuted them, so to speak, so that it's really patterns

04:23.200 --> 04:25.520
of fingers that represent the number of people in the room

04:25.520 --> 04:28.200
and not just the mere presence of a finger going up or down?

04:28.200 --> 04:30.120
In other words, this can remain zero.

04:30.120 --> 04:31.760
This could still be one.

04:31.760 --> 04:36.800
But what if two is not just this, the obvious, but what if it's just this?

04:36.800 --> 04:39.280
So raising just one, my second finger.

04:39.280 --> 04:41.840
What if then three is this?

04:41.840 --> 04:45.080
So we have zero, one, two, three.

04:45.080 --> 04:47.800
That's going to lead us to four, somewhat offensively.

04:47.800 --> 04:52.640
But if we can jump ahead to five, five I might now permute this finger

04:52.640 --> 04:53.480
and this finger up.

04:53.480 --> 04:56.800
And if I want to now represent six, I could do this.

04:56.800 --> 04:57.640
And now seven.

04:57.640 --> 05:00.560
In other words, I've expressed so many more patterns on my hand already.

05:00.560 --> 05:03.200
And if we keep doing this, I think I can actually represent,

05:03.200 --> 05:07.000
painfully perhaps, like 32 different patterns.

05:07.000 --> 05:10.800
And therefore, 32 different people on my hands alone or 31 people

05:10.800 --> 05:12.320
if I start counting at zero.

05:12.320 --> 05:13.600
So what is that?

05:13.600 --> 05:14.600
What's the relationship?

05:14.600 --> 05:15.600
And how did we even get here?

05:15.600 --> 05:19.760
Well, it turns out that computers are kind of simplistic, much like our hands here.

05:19.760 --> 05:21.960
At the end of the day, your computer is plugged into the wall

05:21.960 --> 05:25.640
where it's got a battery, so it either has or it does not have electricity.

05:25.640 --> 05:28.320
At the end of the day, that is the physical resource that drive these things

05:28.320 --> 05:30.600
in our phones and all of technology today.

05:30.600 --> 05:35.560
So if there's either electricity or not, that kind of maps nicely to no finger

05:35.560 --> 05:36.480
or yes finger.

05:36.480 --> 05:40.000
And indeed, computers, as you probably know, only speak what language,

05:40.000 --> 05:41.920
what alphabet, so to speak?

05:41.920 --> 05:43.560
Yeah, binary, by meaning two.

05:43.560 --> 05:46.840
And indeed, that refers to the fact that in binary and computers,

05:46.840 --> 05:49.840
you only have two digits, zero and one.

05:49.840 --> 05:53.200
We humans, of course, have zero, one, two, three, four, five, six, seven,

05:53.200 --> 05:54.000
eight, nine.

05:54.000 --> 05:56.160
And then we can combine those to count even higher.

05:56.160 --> 05:58.240
But computers only have zero, one.

05:58.240 --> 05:59.240
And then that's it.

05:59.240 --> 06:01.000
Because at the end of the day, there's actually

06:01.000 --> 06:03.960
a direct mapping between power being off and it being a zero,

06:03.960 --> 06:06.680
or power being on and it being one, or some electrons,

06:06.680 --> 06:09.600
or whatever flowing from your battery or from the wall.

06:09.600 --> 06:13.440
So this is why computers tend to speak only binary because at the end

06:13.440 --> 06:15.880
of the day, it just maps really cleanly to what

06:15.880 --> 06:18.960
it is that's powering them in the first place.

06:18.960 --> 06:20.560
But how is this actually useful?

06:20.560 --> 06:23.920
If computers only have zeros and ones, how can they do anything useful?

06:23.920 --> 06:28.600
Well, think about our human world where you might have this pattern of symbols.

06:28.600 --> 06:31.680
This is decimal, deck meaning 10, because you have zero through nine.

06:31.680 --> 06:33.880
And this is, of course, 123.

06:33.880 --> 06:34.600
But why?

06:34.600 --> 06:36.960
If you haven't thought about this in quite some time,

06:36.960 --> 06:40.360
this is really just a pattern of three symbols, one and two and three,

06:40.360 --> 06:42.160
shapes or glyphs on the screen.

06:42.160 --> 06:44.280
But we humans, ever since grade school, have

06:44.280 --> 06:46.920
started describing meaning to each of these numbers, right?

06:46.920 --> 06:50.320
If you think back, this is the ones column, this is the tens column,

06:50.320 --> 06:52.800
this is the hundreds column, and so forth.

06:52.800 --> 06:53.920
And we could keep going.

06:53.920 --> 06:58.080
And so why does this pattern one, two, three mean 123?

06:58.080 --> 07:00.840
Well, it's because all of us, sort of intuitively nowadays,

07:00.840 --> 07:07.320
are just quickly in our head doing 100 times 1 plus 10 times 2 plus 1

07:07.320 --> 07:12.040
times 3, which of course gives us 100 plus 20 plus 3.

07:12.040 --> 07:15.760
And then the number we know mathematically as 123.

07:15.760 --> 07:17.960
But we're all doing this so quickly, you don't really

07:17.960 --> 07:19.120
think about this anymore.

07:19.120 --> 07:21.520
Well, computers work fundamentally the same way.

07:21.520 --> 07:24.640
They don't have as many digits, zero through nine as we do.

07:24.640 --> 07:26.560
They only have zeros and ones.

07:26.560 --> 07:28.800
And so if they were to store values, you're

07:28.800 --> 07:30.400
only going to see zeros and ones on the screen.

07:30.400 --> 07:32.560
But those zeros and ones just mean different things.

07:32.560 --> 07:35.120
Instead of having a ones place, tens, hundreds,

07:35.120 --> 07:39.800
they're going to have a ones place, a twos place, a fours place,

07:39.800 --> 07:41.880
and then eights and 16 and beyond.

07:41.880 --> 07:42.680
Now why?

07:42.680 --> 07:46.920
Well, one and 10 and 100 turns out those are powers of 10.

07:46.920 --> 07:49.400
10 to the zero is technically one.

07:49.400 --> 07:51.000
10 to the one is just 10.

07:51.000 --> 07:52.400
10 to the two is 100.

07:52.400 --> 07:55.760
And that's why you have ones, tens, hundreds, thousands, and so forth.

07:55.760 --> 08:00.200
Computers are apparently using powers of two, not surprising, binary two.

08:00.200 --> 08:05.040
So if you only have ones, twos, and fours as your placeholders,

08:05.040 --> 08:10.360
if a computer were storing these digits, zero, zero, zero,

08:10.360 --> 08:13.960
that computer is presumably storing what number so far as we humans

08:13.960 --> 08:15.480
understand it.

08:15.480 --> 08:17.240
Well, that's how a computer would store zero.

08:17.240 --> 08:20.200
If a computer is storing literally zero, zero, zero,

08:20.200 --> 08:22.400
just like in our human world, that also is zero.

08:22.400 --> 08:25.680
But that's technically because it's four times zero, plus two times zero,

08:25.680 --> 08:28.240
plus one times zero, which is obviously zero.

08:28.240 --> 08:33.680
Meanwhile, if a computer is actually storing not just say zero, zero, zero,

08:33.680 --> 08:38.840
but instead is storing this value in binary, what is that map to in decimal?

08:38.840 --> 08:39.760
So that's one.

08:39.760 --> 08:46.440
And now why, if we change this zero and one to this value here,

08:46.440 --> 08:49.560
is this two both mathematically for the exact same reasons.

08:49.560 --> 08:51.160
And so earlier, I had five fingers.

08:51.160 --> 08:55.000
But if you consider just my first three, when I did this holding up one finger,

08:55.000 --> 08:56.960
I was representing two.

08:56.960 --> 09:00.200
And if I want to represent three, recall that I put up the second finger.

09:00.200 --> 09:03.400
And so the reason that could nicely represent three

09:03.400 --> 09:08.000
is because all I was doing with my human hand was counting in binary.

09:08.000 --> 09:09.720
And I could keep counting more and more and more.

09:09.720 --> 09:14.880
And so if I have five fingers or five bits, bit meaning binary digits,

09:14.880 --> 09:15.720
I could count up.

09:15.720 --> 09:19.880
It turns out if we do the math, as high as 31 by starting to zero.

09:19.880 --> 09:23.200
It's going to be hard to physically do that, but we could.

09:23.200 --> 09:25.000
So why is this useful?

09:25.000 --> 09:26.840
What the end of the day, a computer, therefore,

09:26.840 --> 09:30.200
can represent any number of values from zero to one to two to three

09:30.200 --> 09:32.600
to some number much, much, much higher than that.

09:32.600 --> 09:35.400
All it needs is enough bits, enough zeros and ones.

09:35.400 --> 09:36.600
Well, what are those bits?

09:36.600 --> 09:40.720
Well, all of us have these days in our phone's sources of light, for instance.

09:40.720 --> 09:43.680
So I could actually say that this physical device right now

09:43.680 --> 09:45.120
might be a little hard to tell.

09:45.120 --> 09:48.000
It does have a flashlight, and it's technically off at the moment.

09:48.000 --> 09:51.640
But if I turn this flashlight on, thereby using some of the electricity,

09:51.640 --> 09:53.520
then now I'm storing a one.

09:53.520 --> 09:54.600
And so the phone is on.

09:54.600 --> 09:55.520
Now it's off.

09:55.520 --> 09:56.280
Now it's on.

09:56.280 --> 09:59.880
And if I see, can I borrow someone's phone real quick, is may I?

09:59.880 --> 10:01.840
OK, and flashlight.

10:01.840 --> 10:03.600
How do I turn on the flashlight?

10:03.600 --> 10:05.000
Oh, shake it.

10:06.000 --> 10:07.520
I'm working.

10:07.520 --> 10:08.200
That's OK.

10:08.200 --> 10:10.280
OK, thank you.

10:10.280 --> 10:10.920
Oh, thank you.

10:10.920 --> 10:11.960
OK, so this is great.

10:11.960 --> 10:12.800
Now I can count higher.

10:12.800 --> 10:16.320
So now this represents the number of what?

10:16.320 --> 10:20.000
If I have two light bulbs or two switches on at the moment?

10:20.000 --> 10:21.800
Yeah, three, because I have a one.

10:21.800 --> 10:24.840
I have a one, and I have a two, which of course is going to end up equaling three.

10:24.840 --> 10:27.760
And if I pick up a third phone somehow, I could count even higher.

10:27.760 --> 10:31.360
Technically, if I had three light bulbs on, one, one, one,

10:31.360 --> 10:33.120
what would that value be?

10:33.120 --> 10:36.560
Seven, because it's a four plus a two plus a one, and so forth.

10:36.560 --> 10:38.560
Thank you so much for the spontaneity.

10:38.560 --> 10:43.440
So why does this not lead to limitations for us?

10:43.440 --> 10:45.800
I can count in a decimal as high as I want.

10:45.800 --> 10:49.200
I can now count in binary as high as I want, so long as I have enough bits.

10:49.200 --> 10:52.880
But how do I actually represent other information?

10:52.880 --> 10:57.880
Well, if I want to represent something like a letter, how do I get there?

10:57.880 --> 11:02.200
If computers only have electricity in them, and they use binary to count,

11:02.200 --> 11:04.960
and yet somehow they're much more useful than just doing math.

11:04.960 --> 11:08.720
They can have text messages, and emails, and websites, and videos, and more.

11:08.720 --> 11:11.800
How do we get from 0s and 1s to letters?

11:11.800 --> 11:12.640
Well, we should, yeah.

11:16.000 --> 11:18.800
Sorry, a little louder?

11:18.800 --> 11:21.320
Yeah, we just need to kind of relate the numbers to letters.

11:21.320 --> 11:22.760
In other words, all the people in this room

11:22.760 --> 11:25.080
just need to decide at some point that, you know what,

11:25.080 --> 11:27.840
if we want to represent something like the capital letter A,

11:27.840 --> 11:31.120
we just need to decide on a pattern of bits, a pattern of fingers

11:31.120 --> 11:34.720
that's going to represent A. And it turns out, humans years ago just

11:34.720 --> 11:40.520
unilaterally decided 65 shall be the decimal number that represents capital letter A.

11:40.520 --> 11:44.400
And you might guess capital B is represented by what decimal number?

11:44.400 --> 11:47.040
66, and then C is 67, and so forth.

11:47.040 --> 11:51.560
And there's a mapping of like 128 or even 256 possible values for all

11:51.560 --> 11:55.360
the keys you might see on a typical keyboard in order to represent letters.

11:55.360 --> 11:58.880
Now, how does a computer distinguish, though, numbers from letters?

11:58.880 --> 12:00.360
Well, it just depends on the context.

12:00.400 --> 12:03.600
If you're using like a calculator program on your Mac or PC or iPhone

12:03.600 --> 12:06.320
or Android, well, the computer, the device,

12:06.320 --> 12:08.480
is just going to know contextually, let me

12:08.480 --> 12:12.040
interpret this pattern of zeros and ones as actual numbers to do math.

12:12.040 --> 12:15.520
But if you're using the SMS app or the Messages app on your phone,

12:15.520 --> 12:17.760
you're going to actually be in the context of text.

12:17.760 --> 12:20.600
And so your phone is going to interpret that same pattern of zeros

12:20.600 --> 12:24.480
and ones, or light bulbs being off, or at the end of the day, transistors,

12:24.480 --> 12:28.080
tiny pieces of hardware and computers that are either on or off.

12:28.080 --> 12:31.120
It's going to interpret those patterns as just representing a letter.

12:31.120 --> 12:33.840
If you're in the context of a text messaging application,

12:33.840 --> 12:36.320
or Microsoft Word, or Google Docs, or the like,

12:36.320 --> 12:38.800
it completely depends on context.

12:38.800 --> 12:41.360
The system we humans came up with just called ASCII,

12:41.360 --> 12:43.720
American Standard Code for Information Interchange.

12:43.720 --> 12:47.360
The name isn't interesting, but the fact that we all agreed years ago

12:47.360 --> 12:50.840
that 65 is A, and so forth, is what's important.

12:50.840 --> 12:53.440
And so for instance, if we look at this mapping here

12:53.440 --> 12:56.880
of just the first few letters, what does this mean?

12:56.880 --> 13:01.520
If I were to now get a text message, and I had the ability somehow

13:01.520 --> 13:04.320
to look underneath the hood, so to speak, at the pattern of zeros

13:04.320 --> 13:07.480
and ones that someone had just texted me, and that pattern,

13:07.480 --> 13:12.840
if I convert it to decimal, technically said, let's say, 72 and 73.

13:12.840 --> 13:14.600
So I get a whole bunch of zeros and ones.

13:14.600 --> 13:18.120
I do some math, and I realize, OK, I just received 72 and 73,

13:18.120 --> 13:21.200
but this is texting, and so it's not just numbers my friend is sending me.

13:21.200 --> 13:22.200
It's a message.

13:22.200 --> 13:26.560
What message did my friend likely send me if he or she sent 72,

13:26.560 --> 13:28.720
and then 73?

13:28.720 --> 13:31.880
Yeah, hi, HI, because if you skim ahead at the right there,

13:31.880 --> 13:37.320
that just happens to be in ASCII, the mapping between 72 and 73 to H and I.

13:37.320 --> 13:41.320
If technically the message had a third byte, if you will, a byte,

13:41.320 --> 13:43.720
if you've ever wondered, it's just eight bits.

13:43.720 --> 13:45.880
It's convenient to talk, not in terms of single bits,

13:45.880 --> 13:49.080
where you can't count very high, but with a byte or eight bits,

13:49.080 --> 13:50.320
you can count higher.

13:50.320 --> 13:54.640
And so it turns out if I received a third byte, another sequence of eight zeros

13:54.640 --> 14:00.360
and ones together, 33, how would we know what this message now is?

14:00.360 --> 14:03.400
Yeah, so it turns out you would not know this other than by guessing or googling

14:03.400 --> 14:04.880
or just coming in with this knowledge.

14:04.880 --> 14:08.800
This is now high with an exclamation point, because 33 just so happens

14:08.800 --> 14:12.760
if you look it up to map to an exclamation point as well.

14:12.760 --> 14:15.080
Now, if we actually looked at the binary of this,

14:15.080 --> 14:17.280
you would actually see this pattern of zeros and ones.

14:17.280 --> 14:19.560
This is how you represent 72 in binary.

14:19.560 --> 14:23.480
This is how you represent 73, and this is how you represent 33.

14:23.480 --> 14:27.440
And notice, I've only used one, two, three, four, five, six bits,

14:27.440 --> 14:30.880
even though I technically tend to receive things in units of eight,

14:30.880 --> 14:31.880
units of bytes.

14:31.880 --> 14:38.440
But why did I not bother writing another zero, zero here and another zero here?

14:38.440 --> 14:41.560
Does it matter when you write these things out?

14:41.560 --> 14:42.320
No, not really.

14:42.320 --> 14:46.680
Like in English, in our human world, if you were to write one, two, three,

14:46.680 --> 14:51.520
that's 123, if you were to write zero, one, two, three, that's still 123.

14:51.560 --> 14:54.320
So even though we tend to get them in clusters of eight,

14:54.320 --> 14:57.280
we don't necessarily need to write those when just talking about them.

14:57.280 --> 14:58.200
So what have we done?

14:58.200 --> 15:00.680
Well, let me introduce a fancy word now known as abstraction.

15:00.680 --> 15:03.720
Abstraction is just a term generally used in computer science,

15:03.720 --> 15:06.760
and we'll soon see in programming for taking some low level,

15:06.760 --> 15:10.640
like literally low level implementation details, like minutia

15:10.640 --> 15:12.920
even, and understanding them at some point,

15:12.920 --> 15:16.120
but then deciding this is not a useful level conceptually

15:16.120 --> 15:17.360
to think about problems.

15:17.360 --> 15:20.960
I really don't want to solve problems in this world thinking in zeros and ones.

15:20.960 --> 15:24.160
I'd much rather think about things minimally in decimal or better

15:24.160 --> 15:27.040
yet in the context of letters if I'm actually receiving text

15:27.040 --> 15:28.760
or even some other representation.

15:28.760 --> 15:32.680
So abstraction is about taking fairly low level details

15:32.680 --> 15:36.680
and just simplifying them so that we can have a more useful conversation

15:36.680 --> 15:39.960
and never again worry about where the electricity is coming from.

15:39.960 --> 15:43.280
We can just stipulate, my computer can represent zeros and ones.

15:43.280 --> 15:44.800
Therefore, it can represent numbers.

15:44.800 --> 15:47.680
Therefore, it can also represent ASCII or letters.

15:47.680 --> 15:51.520
And we can kind of move on and start solving more interesting problems.

15:51.520 --> 15:55.400
But it would seem that we can't solve all problems

15:55.400 --> 15:59.880
because on my keyboard here, this American keyboard here,

15:59.880 --> 16:02.720
there's a whole bunch of symbols, like 100 or two maybe in total

16:02.720 --> 16:05.200
if we actually hit Shift and Option and all that.

16:05.200 --> 16:07.880
But what you don't see are some pretty common characters,

16:07.880 --> 16:09.680
especially in a very international audience.

16:09.680 --> 16:13.240
What can I apparently not even type on this keyboard?

16:13.240 --> 16:14.080
What kinds of symbols?

16:14.080 --> 16:15.680
Yeah?

16:15.680 --> 16:16.920
Anything with an accent?

16:16.920 --> 16:20.400
If you have accents over vowels or other letters, what else?

16:20.400 --> 16:21.600
I'm sorry?

16:21.600 --> 16:23.240
Umlats or other characters above letters?

16:23.240 --> 16:24.440
Yeah?

16:24.440 --> 16:25.760
Pound?

16:25.760 --> 16:27.000
Like pound symbol?

16:27.000 --> 16:28.520
Oh, like the UK pound symbol?

16:28.520 --> 16:28.840
Sure.

16:28.840 --> 16:30.000
In other countries too.

16:30.000 --> 16:32.640
Any number of Asian languages, there's so many symbols that are not

16:32.640 --> 16:33.720
depicted on this keyboard.

16:33.720 --> 16:37.280
And yet somehow, all of us with international keyboards or phones

16:37.280 --> 16:38.960
can surely express themselves.

16:38.960 --> 16:42.840
But that's because phones and computers these days don't just use ASCII.

16:42.840 --> 16:46.440
ASCII literally use just eight bits total, technically seven,

16:46.440 --> 16:48.240
but then ultimately really eight.

16:48.240 --> 16:51.360
And with eight bits, if you actually do the math, if you have eight bits or eight

16:51.360 --> 16:56.800
fingers, you can only permute them in 256 total possible ways, which

16:56.800 --> 17:00.240
is to say that you can only represent 256 characters using

17:00.240 --> 17:03.160
ASCII with numbers underneath the hood.

17:03.160 --> 17:05.720
And that's not enough to represent so many different symbols

17:05.720 --> 17:07.280
like those enumerated here.

17:07.280 --> 17:09.840
You can't represent any of the accents that you can nonetheless type

17:09.840 --> 17:11.040
on your Macs and PCs.

17:11.040 --> 17:14.400
And you certainly can't type these things, which are very much in vogue,

17:14.400 --> 17:18.200
which even though they're pictures, they're actually just characters.

17:18.200 --> 17:22.680
Because it turns out some years ago, the world decided eight bits is not enough.

17:22.680 --> 17:25.480
Let's start using something called Unicode, where you actually

17:25.480 --> 17:28.840
use one or two or three or even four bytes.

17:28.840 --> 17:34.120
So eight bits or 16 bits, 24 bits, or even 32 bits to represent characters.

17:34.120 --> 17:38.120
And now we have the ability to represent thousands or even millions of characters.

17:38.120 --> 17:43.200
And frankly, dare say, the result of that huge amount of availability

17:43.200 --> 17:45.880
is partly why there are so many of these things these days.

17:45.880 --> 17:48.520
And they just keep making more because there's just so many different numbers

17:48.520 --> 17:50.000
available to us.

17:50.000 --> 17:53.600
So Unicode is often a specific version of it called 8UTF-8,

17:53.600 --> 17:54.880
which we'll see before long.

17:54.880 --> 17:56.720
But let me ask this question here.

17:56.720 --> 18:02.360
This is a crying face with joy, I think this is called.

18:02.360 --> 18:04.480
So it turns out, according to Apple or iOS,

18:04.480 --> 18:07.080
this is the most popular emoji that at least iPhone people

18:07.120 --> 18:08.440
are sending to each other.

18:08.440 --> 18:12.040
So when you're receiving this, though, if we can really take the fun out of this,

18:12.040 --> 18:15.560
what pattern of bits are you actually receiving from your friend?

18:15.560 --> 18:18.240
He or she is clearly trying to express some emotion.

18:18.240 --> 18:24.760
But really, what your friend is sending you, the decimal number, 128,514.

18:24.760 --> 18:28.320
Or really, if you looked at the 0s and 1s coming to you over the internet

18:28.320 --> 18:31.800
or airwaves, you're getting this pattern of 0s and 1s,

18:31.800 --> 18:35.120
which is hardly joyful or hardly descriptive.

18:35.120 --> 18:37.280
But all your phone or computer are doing is

18:37.280 --> 18:40.360
seeing this pattern of bits, looking it up in like a little cheat sheet

18:40.360 --> 18:43.880
and saying, oh, whenever I see this pattern of bits in the context of text,

18:43.880 --> 18:48.160
like texting, I should actually display it as that picture.

18:48.160 --> 18:51.760
Now, that picture has a lot of yellow and other colors in it.

18:51.760 --> 18:53.600
But how do we even get there?

18:53.600 --> 18:57.960
Well, it turns out that this same pattern of numbers, 72, 73, 33,

18:57.960 --> 19:00.840
which just to be sure, a moment ago meant what?

19:00.840 --> 19:04.720
Hi, in the context of a textual program like Microsoft Word, Google Docs

19:04.720 --> 19:06.640
texting, this means high.

19:06.640 --> 19:10.560
But what if you saw this same pattern of bytes?

19:10.560 --> 19:13.920
And again, we could draw the 0s and 1s, but it's not interesting anymore.

19:13.920 --> 19:16.200
So we're going to abstract away at the decimal level.

19:16.200 --> 19:19.680
If you've got this same pattern of 0s and 1s or numbers in the context

19:19.680 --> 19:23.840
of like Photoshop or a browser or some kind of photo program,

19:23.840 --> 19:27.600
well, it might make more sense to interpret it not as text, but as

19:27.600 --> 19:29.400
imagery, some kind of colors.

19:29.400 --> 19:31.760
Well, it turns out there's this other system in the world.

19:31.760 --> 19:36.120
You might have seen this acronym before called RGB, red, green, blue.

19:36.120 --> 19:40.600
And this is just a way of humans having standardized years ago that, you know what,

19:40.600 --> 19:43.600
if we want to represent a dot on someone's screen, otherwise known

19:43.600 --> 19:46.800
as a pixel, tiny little square on the screen of your phone, your laptop,

19:46.800 --> 19:50.560
or even TV these days, we're going to use three bytes.

19:50.560 --> 19:54.720
One byte to specify how much red should be in that specific pixel.

19:54.720 --> 19:58.600
One more byte to specify how much green should be combined with red to form

19:58.600 --> 19:59.280
that pixel.

19:59.280 --> 20:02.560
And then one more byte, a third, to represent how much blue

20:02.560 --> 20:06.280
to combine with those other two colors to make a new color altogether.

20:06.280 --> 20:09.800
So it's kind of like combining paints, except in this case,

20:09.800 --> 20:14.480
it's more really waves of light in order to get a specific color using just

20:14.480 --> 20:17.160
red, green, and blue as your palette.

20:17.160 --> 20:21.440
And so if we were to see this red, green, blue pattern and say, you know what,

20:21.440 --> 20:26.440
give me 72 red, 73 of green, and 33 of blue,

20:26.440 --> 20:28.920
if the total possible range, as I alluded to earlier,

20:28.920 --> 20:33.800
is like 0 to 256, or technically 0 to 255,

20:33.800 --> 20:36.480
if you start counting in computer science light from 0,

20:36.480 --> 20:39.280
this is like a medium amount of red, medium amount of green,

20:39.280 --> 20:42.720
and just a little bit of blue if the range goes from 0 to 255.

20:42.720 --> 20:44.840
So if you combine these three things together,

20:44.840 --> 20:48.160
anyone know what color you get?

20:48.160 --> 20:51.360
Yeah, so it's kind of a light yellow that looks like this.

20:51.360 --> 20:55.080
So if a computer is storing a single dot on the screen that

20:55.120 --> 20:58.400
happens to be in yellow, what the computer is actually storing

20:58.400 --> 21:01.920
is not this dot physically, but a pattern of three bytes.

21:01.920 --> 21:03.760
How much red, how much green, how much blue

21:03.760 --> 21:06.200
should the computer display at this particular point?

21:06.200 --> 21:11.320
So if we look at this crying face of joy, and we kind of enhance or zoom in on it

21:11.320 --> 21:15.080
here, you can actually see it start to pixelate, so to speak,

21:15.080 --> 21:16.400
where you start to see the dots.

21:16.400 --> 21:18.720
If I punch in a little more, now you can really

21:18.720 --> 21:20.800
start to see the dots on the screen.

21:20.800 --> 21:22.960
And if I go in even farther, you can actually

21:22.960 --> 21:26.880
see the tiny little squares that compose this image, most of which

21:26.880 --> 21:30.080
at the zoom level are yellow, but a bunch of which are black,

21:30.080 --> 21:33.840
a bunch of which are like light black or dark yellow.

21:33.840 --> 21:36.440
And that's what composes this image ultimately.

21:36.440 --> 21:40.640
So this is to say, if you count up all of the pixels on the screen

21:40.640 --> 21:43.920
and then multiply it by 1, 2, 3 bytes, that's

21:43.920 --> 21:47.600
how many bytes or kilobytes or megabytes, if you've heard those terms,

21:47.600 --> 21:52.320
are going to be stored on your computer just to represent that image.

21:52.320 --> 21:56.800
So we've gone from electricity to down here, so to speak, to 0s and 1s

21:56.800 --> 21:58.680
to decimal, now to colors.

21:58.680 --> 22:00.920
Well, with colors, you can get images.

22:00.920 --> 22:02.200
What comes after images?

22:02.200 --> 22:05.920
Well, if we've all watched videos or movies, certainly digitally these days,

22:05.920 --> 22:08.200
well, what is a movie or a video file?

22:08.200 --> 22:09.480
How might that be implemented?

22:12.480 --> 22:14.320
Say a little louder?

22:14.320 --> 22:15.720
Yeah, it's a collection of images.

22:15.720 --> 22:19.160
If you've ever heard of frames per second, like movies tend to be 24 frames

22:19.160 --> 22:21.840
per second or 30 frames per second, that just

22:21.840 --> 22:26.760
means that a typical movie every second is showing you 24 or 30 images

22:26.760 --> 22:30.120
per second, and they're just flying by so quickly that you actually don't

22:30.120 --> 22:32.600
notice you're just watching a sequence of static images.

22:32.600 --> 22:35.520
It's like as a kid, if you ever had one of those paper flip books,

22:35.520 --> 22:38.800
where there's tons of drawings in them, and as you flip through the pages,

22:38.800 --> 22:41.680
you see things moving, but that's just because your eyes are just seeing

22:41.680 --> 22:45.880
little snapshots ever so quickly of something moving on the paper.

22:45.880 --> 22:47.880
That's all a video file actually is.

22:47.880 --> 22:50.520
So if you have an iPhone and you've ever played with these an emojis,

22:50.520 --> 22:55.080
so to speak, well, all those are our little video files composed of lots

22:55.080 --> 22:59.360
and lots and lots of images that you have saved on your phone or texted

22:59.360 --> 23:00.560
to someone else.

23:00.560 --> 23:03.800
And if we just think now, OK, now we're at the point of video, but that's OK.

23:03.800 --> 23:05.360
Videos are just bunches of images.

23:05.360 --> 23:07.000
Images are just bunches of colors.

23:07.000 --> 23:08.760
Colors are just patterns of bits.

23:08.760 --> 23:11.440
And bits, at the end of the day, are just the result of electricity

23:11.440 --> 23:15.240
coming into my machine or transistors turning switches on and off.

23:15.240 --> 23:18.240
Like we've all of a sudden told this entire story,

23:18.240 --> 23:20.880
but none of us ever is going to need to really think about binary

23:20.880 --> 23:25.120
in the context of videos because a video is just an abstraction on top

23:25.120 --> 23:26.040
of bunches of images.

23:26.040 --> 23:29.960
And images are just an abstraction of top bunches of pixels and so forth.

23:29.960 --> 23:33.640
So we can keep painting this hierarchy that just allows us to talk about things

23:33.640 --> 23:34.560
at a more useful level.

23:34.560 --> 23:36.800
And the reason we had this conversation is just

23:36.800 --> 23:42.120
because we needed a way to represent inputs and outputs to problems.

23:42.120 --> 23:47.040
So let me pause there for just a second to see if there's any questions.

23:47.040 --> 23:50.200
Anything at all?

23:50.200 --> 23:53.120
All right, so what's inside this black box?

23:53.120 --> 23:56.720
Well, it turns out this is where the really interesting work starts

23:56.720 --> 23:58.640
to happen and the thought starts to come in.

23:58.640 --> 24:02.400
This is the proverbial algorithms, step by step instructions

24:02.400 --> 24:03.920
for solving some problem.

24:03.920 --> 24:06.040
And some of you might have solved this problem before,

24:06.040 --> 24:07.640
either digitally or textually.

24:07.640 --> 24:10.640
But of course, if you have contacts in your phone these days

24:10.640 --> 24:13.520
and you've got bunches of friends and family, odds are they're alphabetized

24:13.520 --> 24:14.760
by first name or last name.

24:14.760 --> 24:16.480
And you have autocomplete these days.

24:16.480 --> 24:19.040
But it really is just a long list of names and numbers.

24:19.040 --> 24:21.520
That's not all that different from yesterday's implementation

24:21.520 --> 24:25.240
of the same problem, which was this device here, a phone book.

24:25.240 --> 24:28.920
Now, this phone book might have a friend of ours, and it's a Mike Smith, whose

24:28.920 --> 24:30.280
last name starts with s.

24:30.280 --> 24:32.560
And I could, of course, if trying to find Mike Smith,

24:32.560 --> 24:37.080
start by looking at the first page, the second page, the third page,

24:37.080 --> 24:40.400
the fourth page, and eventually just hopefully find Mike Smith.

24:40.400 --> 24:44.600
Indeed, is this algorithm, this step by step process, correct for finding

24:44.600 --> 24:46.560
someone like Mike Smith?

24:46.560 --> 24:47.440
Yeah, it's correct.

24:47.440 --> 24:50.600
It's stupid and slow, perhaps, because it's going to take forever

24:50.600 --> 24:52.040
in a phone book of this size.

24:52.040 --> 24:55.240
But it is correct, because if Mike's in here, I will, in fact, find him.

24:55.240 --> 24:56.160
But I could do this better.

24:56.160 --> 25:00.960
I could do it sort of two at a time, so two, four, six, eight, 10,

25:00.960 --> 25:03.200
imperfectly, 10, 12, 14.

25:03.200 --> 25:05.080
Is that faster?

25:05.080 --> 25:07.240
Obviously, it's going twice as fast.

25:07.240 --> 25:09.440
Is it correct?

25:09.440 --> 25:11.760
No, why is it not correct?

25:11.760 --> 25:12.880
I might miss him, right?

25:12.880 --> 25:16.200
Mike just accidentally might eventually get sandwiched between two pages,

25:16.200 --> 25:19.000
and I have the unlucky experience of just missing him.

25:19.000 --> 25:20.040
Now, is this fixable?

25:20.040 --> 25:20.640
Yeah.

25:20.640 --> 25:24.840
I can probably, once I hit, like, SN or the T section, for instance,

25:24.840 --> 25:27.320
I can just say, all right, obviously I've gone too far for Mike.

25:27.320 --> 25:30.560
Let me just double back one or just a few pages, so it is fixable.

25:30.560 --> 25:34.000
And so long as I've saved time by flying through this twice as fast,

25:34.000 --> 25:37.960
can I at least afford to spend a few more steps at the very end just

25:37.960 --> 25:39.320
to find Mike Smith?

25:39.320 --> 25:40.560
But none of us are going to do that.

25:40.560 --> 25:43.080
And our Apple devices and Android devices certainly

25:43.080 --> 25:44.920
don't do that for efficiency today.

25:44.920 --> 25:49.120
Odds are most of us are going to do what to find someone in any book like this?

25:49.120 --> 25:52.360
Yeah, open to roughly the middle, or maybe bias ourselves toward the end,

25:52.360 --> 25:53.760
because S is after the middle.

25:53.760 --> 25:55.960
But I'm in the middle of the phone book here.

25:55.960 --> 25:59.320
And now, if I know that Mike is in the S's, and therefore over here,

25:59.320 --> 26:01.920
where do I know he's not?

26:01.920 --> 26:03.760
He's not in the beginning, and I can literally

26:03.760 --> 26:08.280
tear a problem like this in half, throw figuratively and literally half

26:08.320 --> 26:12.160
of the problem away, and be left with fundamentally the same problem,

26:12.160 --> 26:13.120
but it's half as big.

26:13.120 --> 26:16.200
I went from, like, whatever, 1,000 pages to 500 pages,

26:16.200 --> 26:17.960
and I can now repeat this algorithm.

26:17.960 --> 26:19.680
I look down, and a little too far.

26:19.680 --> 26:21.120
I'm in the T section now.

26:21.120 --> 26:25.680
OK, I can again tear the problem in half, throw that half away,

26:25.680 --> 26:29.000
taking a 500 page byte out, a 250 page byte out,

26:29.000 --> 26:31.680
now leaving myself with just 250 pages more,

26:31.680 --> 26:33.360
and notice just how quickly I got here.

26:33.360 --> 26:37.880
The first two algorithms got me from 1,000 to 999 to 998,

26:37.920 --> 26:41.600
or 1,000 to 998 to 996.

26:41.600 --> 26:44.440
But here, I went from 1,000 to 500 to 250.

26:44.440 --> 26:46.400
Feels like we're making up time here.

26:46.400 --> 26:48.240
And indeed, if I keep repeating this process,

26:48.240 --> 26:51.080
hopefully, I'll be left with just one page of the book

26:51.080 --> 26:55.760
that Mike is either on or not, at which point I will call him.

26:55.760 --> 26:58.840
And so that's an algorithm that honestly leverages probably all

26:58.840 --> 27:01.800
the intuition we have, and a lot of what programming is going to be.

27:01.800 --> 27:05.400
It's thinking about a problem like this, figuring out how to divide and conquer

27:05.400 --> 27:07.160
it, and then expressing yourself in a way

27:07.160 --> 27:09.600
that the computer can then solve that problem for you.

27:09.600 --> 27:13.240
And just to paint a picture of how much better this algorithm is,

27:13.240 --> 27:15.560
well, if this is just a very abstract chart where

27:15.560 --> 27:19.200
we have on the vertical or y-axis how much time it takes to solve a problem,

27:19.200 --> 27:21.960
and on the horizontal axis how big the problem is,

27:21.960 --> 27:25.080
so the farther out you go this way, the more pages in the problem,

27:25.080 --> 27:27.520
the more pages in the phone book, and the higher you go up here,

27:27.520 --> 27:29.960
the more seconds or page turns it's going to take.

27:29.960 --> 27:34.320
That first algorithm is just like a linear slope, so to speak.

27:34.320 --> 27:36.360
Because for every additional page in the book,

27:36.400 --> 27:39.320
it might take me one more second, right up, right up.

27:39.320 --> 27:42.240
It's just a one-for-one relationship with pages.

27:42.240 --> 27:45.960
The second algorithm, if I plot it where I'm flying through twice as fast,

27:45.960 --> 27:47.720
what is that line going to look like instead?

27:52.160 --> 27:54.400
Yeah, it's going to look lower than this one.

27:54.400 --> 27:57.760
It's still going to be a straight line, because now there's a two-to-one relationship.

27:57.760 --> 28:00.240
But if you've got a phone book that's got this many pages,

28:00.240 --> 28:03.560
and in the first algorithm it took this long here,

28:03.560 --> 28:07.320
well, in the second algorithm it's going to take about half as many steps,

28:07.320 --> 28:10.440
plus or minus one or two, if you need to actually double back a little bit.

28:10.440 --> 28:13.280
But that third algorithm is what we'll call logarithmic.

28:13.280 --> 28:15.640
If n is the number of pages in the phone book,

28:15.640 --> 28:17.520
the first algorithm in the very worst case

28:17.520 --> 28:19.600
might take all n pages to find Mike Smith.

28:19.600 --> 28:21.800
The second algorithm is going to take half as many steps,

28:21.800 --> 28:23.640
because I'm flying through it two at a time.

28:23.640 --> 28:26.880
But the third algorithm is going to look and feel like this.

28:26.880 --> 28:31.320
It's going to be curved and ever so slowly rising and rising and rising.

28:31.320 --> 28:35.040
The implication of which is if Verizon or the phone company doubles

28:35.040 --> 28:36.840
the number of pages in the phone book next year,

28:36.840 --> 28:40.200
because Cambridge and Somerville merge together in the phone book,

28:40.200 --> 28:41.840
and we now have 2,000 pages.

28:41.840 --> 28:45.760
Well, how many more steps does my third algorithm take?

28:45.760 --> 28:47.880
Just one, because I can take a thousand page

28:47.880 --> 28:50.880
bite out of the problem with that clever algorithm,

28:50.880 --> 28:54.760
whereas my first two algorithms would take it one or just two pages at a time.

28:54.760 --> 28:59.360
So that is to say, we have to hugely increase the size of this problem

28:59.400 --> 29:04.120
just for the number of seconds or page turns to appreciably actually increase.

29:04.120 --> 29:06.160
And so as we start to learn about programming,

29:06.160 --> 29:11.720
it's again going to be leveraging of this intuition in order to actually solve

29:11.720 --> 29:18.480
problems in code more effectively than we might without that intuition alone.

29:18.480 --> 29:20.200
So let's formalize this now.

29:20.200 --> 29:23.600
So that was kind of a very intuitive way of dividing and conquering a problem.

29:23.600 --> 29:26.040
Just kind of made sense to go in the middle, tear it,

29:26.040 --> 29:29.720
and go to the other half, or the other half, and tear it again, and so forth.

29:29.720 --> 29:34.240
But a computer, even as cool as Alexa and Google Home and all this,

29:34.240 --> 29:36.800
are, you can't really just talk to them as another human

29:36.800 --> 29:38.480
and have them execute things correctly.

29:38.480 --> 29:42.040
I struggle just to get Siri to set a timer on my phone.

29:42.040 --> 29:43.880
So we're not quite there yet, so we're still

29:43.880 --> 29:47.880
at the age where we have to be ever so precise with computers, voice

29:47.880 --> 29:51.120
activated or otherwise, and so thus enter pseudocode for now.

29:51.120 --> 29:53.200
Pseudocode has no formal definition.

29:53.200 --> 29:57.640
This is just a way of saying, use English-like syntax or any spoken language

29:57.640 --> 30:00.880
and just express yourself succinctly and correctly

30:00.880 --> 30:03.760
so that a computer or a robot or even another person

30:03.760 --> 30:06.320
can understand what it is you're trying to say.

30:06.320 --> 30:09.880
So here, I propose as an algorithm written in pseudocode,

30:09.880 --> 30:12.440
English-like syntax, that just gets my point across.

30:12.440 --> 30:14.200
And I could write this in any number of ways.

30:14.200 --> 30:17.320
I've numbered the steps from 0 on up just for the sake of discussion,

30:17.320 --> 30:19.560
but this would seem to capture what I did there.

30:19.560 --> 30:22.520
Pick up the phone book, open to the middle of the phone book,

30:22.520 --> 30:25.920
look at the names, if Smith is among the names, call Mike.

30:25.920 --> 30:29.920
Else, if Smith is earlier in the book, go to the left, specifically

30:29.920 --> 30:33.560
the middle of the left half of the book, and then go back to step two.

30:33.560 --> 30:36.200
Because indeed, I was just doing the same thing again and again.

30:36.200 --> 30:38.960
And the reason I wasn't doing it forever was because every time I

30:38.960 --> 30:42.720
repeated myself by opening and tearing, I was shrinking the problem.

30:42.720 --> 30:46.160
And I can only shrink a problem of some fixed finite size so many times

30:46.160 --> 30:47.600
until I get just one page.

30:47.600 --> 30:50.720
And so if I can continue this logic looking to the right or to the left

30:50.720 --> 30:54.120
or just quitting, if I don't find Mike at all on the last page,

30:54.120 --> 30:57.400
this would seem to capture more precisely that code.

30:57.400 --> 30:59.840
Well, let's actually excerpt from this now a few concepts

30:59.840 --> 31:02.640
and then start to apply them to actual code.

31:02.640 --> 31:03.840
Highlight it in yellow here.

31:03.840 --> 31:06.400
I daresay are all of the verbs or actions.

31:06.400 --> 31:08.680
These are the functions, as we're going to start

31:08.680 --> 31:10.000
calling them in this algorithm.

31:10.000 --> 31:13.160
A function is just a specific step, a specific action

31:13.160 --> 31:16.280
you take in order to do something.

31:16.280 --> 31:20.480
And so in yellow here, pick up, open to, look at, call, open, quit,

31:20.480 --> 31:24.040
or all actions or verbs, or henceforth, we'll call them functions.

31:24.040 --> 31:28.120
Meanwhile, highlighted in yellow here, if, else, if, else, if, else,

31:28.120 --> 31:30.200
these are kind of starting to ask questions.

31:30.200 --> 31:33.240
What might these be called if you have some familiarity?

31:33.240 --> 31:36.160
Yeah, it turns out many programming languages, if you've seen any before,

31:36.160 --> 31:37.200
would call these conditions.

31:37.200 --> 31:39.720
They're branches or proverbial forks in the road.

31:39.720 --> 31:41.400
If this is true, go this way.

31:41.400 --> 31:44.840
Else maybe go this other way, or perhaps a third or fourth direction

31:44.840 --> 31:45.680
altogether.

31:45.680 --> 31:49.280
Meanwhile, if we actually look at these highlighted phrases,

31:49.280 --> 31:52.080
if Smith is among names, or if Smith is earlier in book,

31:52.080 --> 31:55.400
or Smith is later in book, these are the specific questions we're

31:55.400 --> 31:57.000
asking in order to make that decision.

31:57.000 --> 31:59.760
These are known as Boolean expressions, named after a gentleman

31:59.760 --> 32:01.800
by the last name of Boole some years ago.

32:01.800 --> 32:05.360
And so a Boolean expression is just a question that has a yes or no answer,

32:05.360 --> 32:09.440
a true false answer, a 1-0 answer, if you will.

32:09.440 --> 32:12.000
And that's a nice mapping to what computers are really good at.

32:12.000 --> 32:14.040
So within conditions, you have Boolean expressions

32:14.040 --> 32:17.320
to decide which fork in the road you want to go down.

32:17.320 --> 32:19.320
And then lastly, highlighted in yellow here,

32:19.320 --> 32:21.880
are you go back to step two in a couple of places.

32:21.880 --> 32:24.560
This is inducing some kind of cycle or loop

32:24.560 --> 32:28.400
that's telling the computer to do something again, and again, and again.

32:28.400 --> 32:32.280
So in short, we have these building blocks already, conceptually.

32:32.280 --> 32:36.600
And it turns out we can now start to translate these to an actual programming

32:36.600 --> 32:37.240
language.

32:37.240 --> 32:39.240
The first of the languages we'll introduce in CS50

32:39.240 --> 32:40.520
is something called Scratch.

32:40.520 --> 32:42.360
Turns out this is not a text-based language,

32:42.360 --> 32:44.800
like in my English pseudocode there, but it's graphical.

32:44.800 --> 32:47.300
And things look like puzzle pieces that you can drag and drop,

32:47.300 --> 32:49.500
and they interconnect if it makes logical sense to do so.

32:49.500 --> 32:51.820
And in fact, some of you might have played with this back in the day

32:51.820 --> 32:53.660
as kids or even more recently, because it's actually

32:53.660 --> 32:56.660
targeted typically at students in after-school programs who just

32:56.660 --> 33:00.780
want to learn more methodical, more algorithmic, or computational thinking.

33:00.780 --> 33:04.180
And we're going to use it to explore not only these building blocks,

33:04.180 --> 33:05.540
but a few others as well.

33:05.540 --> 33:09.900
It turns out in the other languages we'll explore in CS50 and beyond are languages

33:09.900 --> 33:13.140
like C that we'll actually transition to as quickly as next week

33:13.140 --> 33:17.180
to then translate what we do this week in Scratch to next week in C.

33:17.220 --> 33:19.740
And in languages like Python and JavaScript and SQL,

33:19.740 --> 33:22.660
which we'll also explore, do we have other capabilities, the ability

33:22.660 --> 33:25.940
to store data in variables, so to speak, to use threads, which

33:25.940 --> 33:28.460
means get the computer to do multiple things at once,

33:28.460 --> 33:31.020
events to mean listen for things happening,

33:31.020 --> 33:34.900
like a click on the page, or a human typing, or even saying something.

33:34.900 --> 33:38.820
We'll be able to do all of the things that you take for granted in your very own phones.

33:38.820 --> 33:41.580
And we'll do this first by way of this guy.

33:41.580 --> 33:45.100
So this is Scratch, the default cat that comes with this programming language

33:45.100 --> 33:46.540
from MIT's Media Lab.

33:46.540 --> 33:49.980
And via Scratch, can we start programming him to move up, down,

33:49.980 --> 33:54.180
left, right, say something, utter something, and other commands all together?

33:54.180 --> 33:57.420
In fact, let me go ahead and switch contexts here

33:57.420 --> 34:00.020
to show you the very first thing I ever wrote in Scratch.

34:00.020 --> 34:02.060
It was back in the day when I was in graduate school.

34:02.060 --> 34:04.300
And Scratch had just been invented by MIT.

34:04.300 --> 34:06.220
Let me go ahead and open this.

34:06.220 --> 34:09.460
And I called it Oscar time.

34:09.460 --> 34:12.300
And if we could perhaps have a volunteer come on up for just a moment,

34:12.300 --> 34:14.860
you have to be comfortable being on stage and on the internet.

34:14.860 --> 34:16.020
I have it here in the white shirt.

34:16.020 --> 34:17.200
Saw your hand first.

34:17.200 --> 34:18.700
Come on down.

34:18.700 --> 34:20.140
So this is Oscar time.

34:20.140 --> 34:22.420
It's implemented in a language called Scratch.

34:22.420 --> 34:26.500
And at the end of the day, all that is underneath the hood of this program

34:26.500 --> 34:30.140
is functions, and loops, and conditions, and a few other of these concepts.

34:30.140 --> 34:30.980
Hi, what's your name?

34:30.980 --> 34:31.480
Aviva?

34:31.480 --> 34:32.260
Aviva, David.

34:32.260 --> 34:33.020
Nice to meet you.

34:33.020 --> 34:35.100
Come on over here.

34:35.100 --> 34:38.620
And in just a moment, I'm going to go ahead and click the green flag

34:38.620 --> 34:41.220
at the top left hand corner, which is going to play this game.

34:41.220 --> 34:43.220
And we'll see on the screen the instructions.

34:43.980 --> 34:50.980
Oh, I love trash.

34:50.980 --> 34:55.180
Anything dirty or dingy or dusty.

34:55.180 --> 34:59.540
Anything ragged or rotten or rusty.

34:59.540 --> 35:03.420
Yes, I love trash.

35:03.420 --> 35:05.980
If you really want to see something trashy, look at this.

35:05.980 --> 35:10.100
I have here a sneaker that's tattered and worn.

35:10.100 --> 35:14.260
It's all full of holes and the laces are torn.

35:14.260 --> 35:18.380
A gift from my mother the day I was born.

35:18.380 --> 35:22.340
I love it because it's trash.

35:22.340 --> 35:26.260
Oh, I love trash.

35:26.260 --> 35:30.460
Anything dirty or dingy or dusty.

35:30.460 --> 35:34.940
Anything ragged or rotten or rusty.

35:34.940 --> 35:38.540
Yes, I love trash.

35:38.540 --> 35:41.260
Yes, I'm more rotten stuff.

35:41.260 --> 35:44.780
I have here some newspaper, 13 months old.

35:44.780 --> 35:46.540
All right, we're going to round of applause for Aviva

35:46.540 --> 35:47.380
for coming on up.

35:47.380 --> 35:48.620
Thank you.

35:48.620 --> 35:49.420
Here, up, Aviva.

35:52.420 --> 35:53.860
A little CS50 stress ball.

35:53.860 --> 35:56.820
So suffice it to say, if you're tired of this song,

35:56.820 --> 36:00.020
consider how tired I was eight hours later while debugging

36:00.020 --> 36:01.300
and building this program.

36:01.300 --> 36:02.740
But consider what it is we just saw.

36:02.740 --> 36:05.100
It's this interactive game, and stuff is animated,

36:05.100 --> 36:06.180
and music is playing.

36:06.180 --> 36:09.860
But if you focus on decomposing, so to speak, this program,

36:09.860 --> 36:13.020
into just basic building blocks, this is just kind of a big abstraction

36:13.020 --> 36:16.060
over some lower level pieces of functionality.

36:16.060 --> 36:17.260
Like this trash can here.

36:17.260 --> 36:18.780
At the moment, it's just a picture.

36:18.780 --> 36:21.340
And on occasion, as soon as Aviva dropped something into the trash,

36:21.340 --> 36:23.140
the lid came up, and Oscar came out.

36:23.140 --> 36:25.340
He said something, and then he went back down.

36:25.340 --> 36:27.380
But that animation is super simplistic.

36:27.380 --> 36:31.820
It was just a sequence of one, two, three, or so images displaying,

36:31.820 --> 36:34.580
and then going back down to create the illusion of animation.

36:34.580 --> 36:36.940
Meanwhile, every time Oscar said something,

36:36.940 --> 36:39.980
that was keeping track of her score in what's called a variable.

36:39.980 --> 36:41.900
In algebra, you have x, and y, and z.

36:41.900 --> 36:43.620
But in programming, you have the same idea,

36:43.620 --> 36:46.220
but it's generally more useful to call them more descriptively,

36:46.220 --> 36:47.100
like your score.

36:47.100 --> 36:49.780
And so there's probably a variable in this game called score

36:49.780 --> 36:52.220
that was just keeping track of how many times Aviva

36:52.220 --> 36:53.900
had dropped something into the trash.

36:53.900 --> 36:57.740
Meanwhile, the trash itself, and the shoe, and the newspaper,

36:57.740 --> 36:59.860
and even more things happened eventually,

36:59.860 --> 37:02.820
were falling from the sky at random locations.

37:02.820 --> 37:05.820
And that's because I programmed the game to sort of start the trash here

37:05.820 --> 37:09.700
or over here, just to make it a little more challenging as the game picked up.

37:09.700 --> 37:12.180
And in fact, things start falling faster and faster over time,

37:12.180 --> 37:15.180
like a typical game, getting more and more difficult.

37:15.180 --> 37:17.380
So how do we get to something like that?

37:17.380 --> 37:20.620
Well, let me go ahead and open up Scratch itself and introduce

37:20.620 --> 37:21.780
the environment.

37:21.780 --> 37:24.860
So in Scratch, you essentially have three general areas.

37:24.860 --> 37:27.340
And it's web-based, and so you can do this on any computer.

37:27.340 --> 37:30.180
And in the left-hand side here, you have those puzzle pieces,

37:30.180 --> 37:31.580
to which I referred earlier.

37:31.580 --> 37:36.780
These puzzle pieces are all mapping to functions, or loops, or conditions,

37:36.780 --> 37:38.660
or variables, things that we saw before.

37:38.660 --> 37:41.860
And I'm going to be able to drag and drop them into the middle in order

37:41.860 --> 37:44.980
to interconnect them and write my program, which we'll do in just a moment.

37:44.980 --> 37:48.340
Meanwhile, Scratch lives in this stage, this world, where

37:48.340 --> 37:49.900
you can move up, down, left, right.

37:49.900 --> 37:51.420
You can change what Scratch looks like.

37:51.420 --> 37:53.980
You can add other characters, otherwise known as sprites,

37:53.980 --> 37:55.860
in order to have multiple things happening at once.

37:55.860 --> 37:57.260
And of course, you can full screen it.

37:57.260 --> 38:01.100
And so the Oscar time game a moment ago was actually a whole bunch of sprites.

38:01.100 --> 38:03.020
Oscar's trash can was one.

38:03.020 --> 38:05.340
Each piece of trash was another sprite.

38:05.340 --> 38:07.660
The newspaper was a sprite, and so forth.

38:07.660 --> 38:11.820
So each of them were separate programs running in parallel at the same time.

38:11.820 --> 38:13.700
So let's actually make him do something.

38:13.700 --> 38:17.540
It turns out that if I jump down to, say, events,

38:17.540 --> 38:20.540
I'm going to see one of the most powerful blocks from the gecko, which

38:20.540 --> 38:22.820
is this, when green flag clicked.

38:22.820 --> 38:24.700
That's indeed how I started the game with Aviva

38:24.700 --> 38:27.900
by clicking just above Scratch's world, this green flag.

38:27.900 --> 38:30.820
And if I wanted to stop it as I did, you can click the red stop sign

38:30.820 --> 38:31.780
to say stop.

38:31.780 --> 38:36.140
Meanwhile, the green flag I can constantly listen for.

38:36.140 --> 38:39.260
By dragging and dropping this puzzle piece, when the green flag is clicked,

38:39.260 --> 38:40.380
what do I want to do?

38:40.380 --> 38:41.980
Well, let me go up to looks.

38:41.980 --> 38:43.740
And these are just different categories.

38:43.740 --> 38:45.900
And we can scroll through all the different colorful blocks,

38:45.900 --> 38:47.900
but they pretty much just do what they say.

38:47.900 --> 38:51.740
I'm going to go under looks, where I know there to be a block that's called say.

38:51.740 --> 38:54.660
And I'm going to go ahead and type the most canonical computer science

38:54.660 --> 38:56.740
thing, hello world, in this box.

38:56.740 --> 39:00.500
So notice that functions themselves can actually take inputs.

39:00.500 --> 39:03.740
And the input to this function, say, is going to be hello world.

39:03.740 --> 39:08.380
If I now go over to the green flag and click it, hello world.

39:08.380 --> 39:11.660
All right, so not all that difficult, not all that interesting,

39:11.660 --> 39:13.100
but it actually got the job done.

39:13.100 --> 39:15.460
And so my program is indeed just this.

39:15.460 --> 39:17.700
Well, how might I make this a little more interesting?

39:17.700 --> 39:20.380
Just saying hello world all the time isn't all that compelling.

39:20.380 --> 39:21.380
Well, you know what?

39:21.380 --> 39:21.880
Let me think.

39:21.880 --> 39:23.220
Let me undo this.

39:23.220 --> 39:25.060
Let me scroll down to sensing.

39:25.060 --> 39:29.140
And notice this, functions can also take input from the human.

39:29.140 --> 39:32.900
And functions can hand you back a value, a so-called return value.

39:32.900 --> 39:36.340
So this block here, ask something by default that says, what's your name

39:36.340 --> 39:40.020
and weight, is another function built into Scratch that allows me to do this.

39:40.020 --> 39:42.100
I'm going to go ahead and drag this here.

39:42.100 --> 39:44.500
And I'm going to let it say, what's your name?

39:44.500 --> 39:47.500
Notice now that below this block is a special block,

39:47.500 --> 39:49.340
that whatever it is, the block returns.

39:49.340 --> 39:52.220
So answer is whatever the human is going to type in.

39:52.220 --> 39:56.700
And if I want to now save what the human typed in, let me go again to looks,

39:56.700 --> 39:59.780
go to say, and notice that these blocks are kind of magnetic.

39:59.780 --> 40:00.900
They want to snap together.

40:00.900 --> 40:02.740
So I'm going to go ahead and let go there.

40:02.740 --> 40:05.900
And if I go back to sensing and grab answer,

40:05.900 --> 40:08.420
notice that even though it's not quite the same size,

40:08.420 --> 40:09.860
it's going to grow to fill.

40:09.860 --> 40:13.260
And now I can have my program ask the user what his or her name is,

40:13.260 --> 40:15.580
and then say whatever that answer is.

40:15.580 --> 40:18.900
So let me go ahead and stop and click Play again.

40:18.900 --> 40:20.300
Notice it's asking me for my name.

40:20.300 --> 40:22.900
So let me go ahead and type in David, enter.

40:22.900 --> 40:26.460
OK, it's a little weird way to greet someone, David.

40:26.460 --> 40:29.180
So it'd be nice to clean that up a bit.

40:29.180 --> 40:30.020
So you know what?

40:30.020 --> 40:32.060
I know this only from having poked around before.

40:32.060 --> 40:33.900
Not all of this is obvious at first glance,

40:33.900 --> 40:37.860
but it turns out that under operators, the category, there's this thing here.

40:37.860 --> 40:40.900
Join, apple, and banana, which are just default values.

40:40.900 --> 40:42.140
You can change them.

40:42.140 --> 40:43.380
Because what do I want to do?

40:43.380 --> 40:45.700
I want to say hello, David, or whoever.

40:45.700 --> 40:50.380
So I kind of want to say hello, comma, and then David, whatever the human typed in.

40:50.380 --> 40:51.700
And that's what join lets you do.

40:51.700 --> 40:55.100
It lets you join or concatenate two phrases that

40:55.100 --> 40:56.820
are somehow provided by you or the user.

40:56.820 --> 40:59.380
So let me pull this out, the answer.

40:59.380 --> 41:01.340
Let me go ahead and grab the join block.

41:01.340 --> 41:03.340
Notice it too is going to grow to fill.

41:03.340 --> 41:09.700
Let me go ahead and say hello, comma, space, and now drag answer into there.

41:09.700 --> 41:15.060
And notice this nesting, just like in math, this nesting of functions.

41:15.060 --> 41:19.420
I can first join, hello, and answer by taking those two things as input,

41:19.420 --> 41:21.420
and then pass them to say as another input,

41:21.420 --> 41:23.100
because these things are layered on top.

41:23.100 --> 41:27.900
And so now if I stop this and play it again and say, David, hello, David,

41:27.900 --> 41:31.500
now we have the makings of a more interesting interactive program that

41:31.500 --> 41:32.940
isn't just hard coded.

41:32.940 --> 41:38.940
Of course, it's not nearly as audible as something like Oscar time a moment ago.

41:38.940 --> 41:39.940
So let me go ahead and do this.

41:39.940 --> 41:44.300
Let me start over all together and treat scratch like the cat he is,

41:44.300 --> 41:46.220
and just start the sound called meow.

41:46.220 --> 41:48.780
So it turns out there's a category of blocks called sound.

41:48.780 --> 41:51.380
And within sound, there's play some defaults down.

41:51.380 --> 41:54.660
So start sound meow, and now things will get a little cuter.

41:57.660 --> 42:03.860
And now if I, again, and I can kind of simulate a cat by standing here for a while

42:03.860 --> 42:05.540
and keep clicking this button.

42:05.540 --> 42:08.420
But let me make a meow a few times, because that's more realistic.

42:08.420 --> 42:10.220
So let me grab a second one and a third one

42:10.220 --> 42:12.180
and you can get this infinite supply of blocks.

42:12.180 --> 42:12.860
Let me hit play.

42:17.140 --> 42:18.100
Seems like a bug.

42:18.100 --> 42:19.020
Let's try again, play.

42:21.620 --> 42:24.140
This is my first bug or mistake.

42:24.140 --> 42:25.340
This looks correct.

42:25.340 --> 42:29.300
It says when green flag clicked, start sound meow, start sound meow,

42:29.300 --> 42:30.580
start sound meow.

42:30.580 --> 42:34.060
Why am I only hearing one meow?

42:34.060 --> 42:39.020
Yeah, they're kind of at the same time or so close to the same time

42:39.020 --> 42:42.140
that the sounds are kind of tripping over each other and just overlapping.

42:42.140 --> 42:44.300
The block literally says start sound meow.

42:44.300 --> 42:45.700
But computers are really fast.

42:45.700 --> 42:48.340
If you've heard of the expression like gigahertz, that's a unit of measure.

42:48.420 --> 42:51.180
And if your computer has a 1 gigahertz CPU,

42:51.180 --> 42:54.820
central processing unit or brain, that means it can literally do like a billion

42:54.820 --> 42:56.340
things per second.

42:56.340 --> 42:59.860
It can certainly start three sounds super fast.

42:59.860 --> 43:02.860
And if they're effectively all happening one after the other

43:02.860 --> 43:05.940
before the sound even finishes, you're just hearing one net effect.

43:05.940 --> 43:07.220
So how can we fix this?

43:07.220 --> 43:10.540
Well, I can actually go and fix this with this block here.

43:10.540 --> 43:12.860
Play sound meow until done.

43:12.860 --> 43:14.500
Play sound meow until done.

43:14.500 --> 43:16.220
Play sound meow until done.

43:16.220 --> 43:21.660
And now, OK, it's a little unhappy, this particular cap.

43:21.660 --> 43:23.300
But at least it's now more correct.

43:23.300 --> 43:27.620
And as it turns out, if I go to Control, there's this block here.

43:27.620 --> 43:29.420
Wait some number of seconds.

43:29.420 --> 43:31.580
I can go ahead and insert this here.

43:31.580 --> 43:33.220
Let me do another one here.

43:33.220 --> 43:34.180
And now hit Play.

43:34.180 --> 43:36.180
Play sound meow.

43:36.180 --> 43:38.660
Play sound meow.

43:38.660 --> 43:40.820
Yeah, it's not bad.

43:40.820 --> 43:43.860
It now sounds a little more realistic.

43:43.860 --> 43:47.820
But honestly, if I keep doing this, you can actually right-click or control-click

43:47.820 --> 43:51.660
on blocks, duplicate them, and just copy and paste even more if you want them.

43:51.660 --> 43:56.020
So if I were to do this, now it's just going to go six times.

43:56.020 --> 43:58.180
And then I could copy it again and go 12 times.

43:58.180 --> 43:59.660
But there's got to be a better way.

43:59.660 --> 44:01.140
This is now bad programming.

44:01.140 --> 44:04.180
This is bad design because I'm literally copying and pasting,

44:04.180 --> 44:05.300
albeit graphically.

44:05.300 --> 44:10.020
But we've already seen a building block with which we can design this program better.

44:10.020 --> 44:11.860
It's correct, but it's not well designed.

44:11.860 --> 44:16.420
What would the building block be that I need to make this a little cleaner?

44:16.420 --> 44:20.420
Oh, OK, a for loop don't quite exist in Scratch, but a loop fundamentally.

44:20.420 --> 44:21.940
Do something cyclically.

44:21.940 --> 44:24.540
And indeed, if I go under Control and start poking around,

44:24.540 --> 44:27.540
you'll notice that there's a few blocks that might apply here.

44:27.540 --> 44:30.620
There's the repeat block, some number of times, or the forever block,

44:30.620 --> 44:33.060
both of which sound like loops or cycles.

44:33.060 --> 44:34.860
So sure enough, let me go ahead here.

44:34.860 --> 44:37.780
And I can throw away blocks by just dragging them to the left.

44:37.780 --> 44:43.660
Let me pull this out for a second, and then just say forever, play this sound,

44:43.660 --> 44:45.140
and then wait one second.

44:45.140 --> 44:47.700
So now my program looks like this.

44:47.700 --> 44:56.980
Yeah, we'll never know if it's technically correct

44:56.980 --> 44:59.020
because it's just going to go, we think, forever.

44:59.020 --> 45:00.820
But it looks like this is correct.

45:00.820 --> 45:02.220
And it was a lot less code.

45:02.220 --> 45:05.940
And it's a lot easier to maintain because if I want him to kind of get sleepy,

45:05.940 --> 45:14.380
I can then maybe say two seconds instead, and we can adjust this on the fly as we go.

45:14.380 --> 45:16.980
But let's start to combine some of these ideas now

45:16.980 --> 45:20.140
and change what it is the ultimate effect is.

45:20.140 --> 45:22.980
Let me go ahead and open an example I made in advance.

45:22.980 --> 45:24.940
This one's called count zero.

45:24.940 --> 45:28.060
And we'll put this on the website later so that you can play with it if you like.

45:28.060 --> 45:29.900
And this is kind of the opposite of counting sheep.

45:29.900 --> 45:32.820
Rather than me or this person sleeping counting sheep,

45:32.820 --> 45:35.020
this sheep will count itself.

45:35.020 --> 45:37.740
So let me go ahead and just play.

45:37.740 --> 45:42.340
And adorably, he seems to just be counting 1, 2, 3.

45:42.340 --> 45:43.460
But why is that?

45:43.460 --> 45:45.060
He's just going to count forever.

45:45.060 --> 45:47.940
But let's look at the blocks with which he's counting forever.

45:47.940 --> 45:51.220
When green flag clicked, set counter, turns out this orange block

45:51.220 --> 45:52.420
is what we call the variable.

45:52.420 --> 45:54.220
So an algebra would be like x or y or z.

45:54.220 --> 45:55.300
Those are not descriptive.

45:55.300 --> 45:59.100
I called this one counter instead, but I could have called it x or y or z.

45:59.100 --> 46:03.740
And then I forever say the counter for one second, then wait one second,

46:03.740 --> 46:07.060
and then change the counter by one, which technically means just increment it.

46:07.060 --> 46:08.060
Add one to it.

46:08.060 --> 46:10.980
And the sheep is just going to, therefore, count up and up and up.

46:10.980 --> 46:12.580
Now, this is a little tedious, but that's

46:12.580 --> 46:15.660
kind of the point of counting sheep, of course, to fall asleep.

46:15.660 --> 46:19.500
But what if this sheep actually kind of liked counting a little faster?

46:19.500 --> 46:22.180
Well, let me go into operators here.

46:22.180 --> 46:25.500
Multiplication sounds like it could get us places quicker.

46:25.500 --> 46:27.900
And let me go ahead and go to variables.

46:27.900 --> 46:30.620
And instead of changing the counter by one,

46:30.620 --> 46:32.940
let me go ahead and just keep setting it to something else.

46:32.980 --> 46:34.180
So let me drag and drop this.

46:34.180 --> 46:37.900
Set the counter equal to something times something.

46:37.900 --> 46:43.140
Specifically, the counter times 2.

46:43.140 --> 46:45.460
Thereby, doubling, doubling, doubling, doubling.

46:45.460 --> 46:47.820
That would seem to grow, so to speak, a lot faster.

46:47.820 --> 46:50.060
Let's see.

46:50.060 --> 46:55.060
1, 2, 4, 8.

46:55.060 --> 46:57.420
So he's counting faster, but it's still kind of tedious.

46:57.420 --> 46:59.300
What if we instead do this?

46:59.300 --> 47:00.900
Let's stop waiting.

47:00.900 --> 47:05.020
And let's go ahead and, with the looks, not say counter for one second,

47:05.020 --> 47:07.700
but let's just quickly say counter.

47:07.700 --> 47:09.100
So I'm going to say the counter.

47:09.100 --> 47:09.940
Whoops.

47:09.940 --> 47:11.620
I'm going to say the counter.

47:11.620 --> 47:14.100
And then I'm going to set it to itself times 2.

47:14.100 --> 47:15.180
So here's where we're at.

47:15.180 --> 47:17.620
Initialize or set the counter to 1 initially.

47:17.620 --> 47:19.620
Say it, then double it.

47:19.620 --> 47:20.580
Then double it.

47:20.580 --> 47:22.500
Then double it, saying it along the way.

47:22.500 --> 47:24.340
So here we go.

47:24.340 --> 47:27.260
That's impressive.

47:27.260 --> 47:30.580
So now the sheep has counted up to 10 to the 60th.

47:30.620 --> 47:34.940
So far, 10 to the 100th.

47:34.940 --> 47:40.020
OK, now it doesn't even fit in the speech bubble, but he's still going.

47:40.020 --> 47:42.060
How high can he go?

47:42.060 --> 47:46.620
What's the biggest number you can count to in a computer?

47:46.620 --> 47:50.100
Anyone want to guess?

47:50.100 --> 47:52.060
Could be here a while.

47:52.060 --> 47:54.780
10 to the 270th now.

47:54.780 --> 47:55.740
How high can you count?

47:55.740 --> 48:00.380
Or rather, OK, so we gave up.

48:00.380 --> 48:01.620
And just call to infinity.

48:01.620 --> 48:04.020
So it turns out infinity does have a precise value.

48:04.020 --> 48:06.340
10 times to the 250th or so.

48:06.340 --> 48:07.820
But what happens here?

48:07.820 --> 48:10.140
Well, because computers at the end of the day

48:10.140 --> 48:13.220
are just storing information digitally, but that information digitally

48:13.220 --> 48:15.460
has to be physically stored using electricity,

48:15.460 --> 48:17.620
using these lower level switches called transistors.

48:17.620 --> 48:20.860
At the end of the day, my phone, my laptop, whatever device in question,

48:20.860 --> 48:23.180
only has a finite amount of those things.

48:23.180 --> 48:24.940
I only have a finite number of fingers.

48:24.940 --> 48:27.460
Using unary, my old school hash mark approach,

48:27.460 --> 48:29.020
I can count to five on this hand.

48:29.060 --> 48:33.060
Using binary, I claimed I could count to 31 on this hand.

48:33.060 --> 48:34.300
But it's still finite.

48:34.300 --> 48:37.940
I cannot count to infinity on this hand because I only have five fingers.

48:37.940 --> 48:40.940
Similarly, does a computer only have so many transistors

48:40.940 --> 48:43.100
or so many bytes or bits of memory?

48:43.100 --> 48:45.940
And at some point, the programmer has to think about,

48:45.940 --> 48:49.020
what is he or she going to do when the user wants to count so high

48:49.020 --> 48:51.660
that you can't physically fit it anymore?

48:51.660 --> 48:54.980
You have to give up like this and say something semi-accurately.

48:54.980 --> 48:58.540
Or you have to handle the issue in some other way.

48:58.540 --> 49:01.860
And we'll see when we get to see that how you handle this problem is not

49:01.860 --> 49:03.260
necessarily straightforward.

49:03.260 --> 49:06.540
And indeed, a lot of software out there does not handle this problem.

49:06.540 --> 49:09.460
And odds are, all of us have programs that if you type big enough words

49:09.460 --> 49:13.620
or big enough numbers into them, they might very well break or crash or freeze

49:13.620 --> 49:16.420
because the humans, unlike MIT, did not anticipate

49:16.420 --> 49:18.580
that that might actually happen and handle it.

49:18.580 --> 49:19.860
Well, let me go ahead and do this.

49:19.860 --> 49:23.420
Let me open up this program and see if we can't read the code now.

49:23.420 --> 49:25.980
This is called pet zero.

49:25.980 --> 49:28.940
And this is a program that simulates petting.

49:28.940 --> 49:33.900
So if I click play and don't touch the keyboard, nothing seems to be happening.

49:33.900 --> 49:39.900
But if I now move my cursor over to the cat, oh, it's kind of cute.

49:39.900 --> 49:43.420
Right now, it's more only meowing on demand when you pet the cat.

49:43.420 --> 49:44.100
Why?

49:44.100 --> 49:46.260
Well, notice I've added some other building blocks.

49:46.260 --> 49:49.060
We haven't used this one before, but it intuitively probably

49:49.060 --> 49:51.660
makes pretty clear sense when the green flag is clicked,

49:51.660 --> 49:53.300
forever do the following.

49:53.300 --> 49:56.740
If the cat is touching the mouse pointer, this thing in blue

49:56.740 --> 49:58.660
is what we called earlier a Boolean expression.

49:58.660 --> 50:01.820
It has a yes, no, a true, false, a one, zero answer.

50:01.820 --> 50:04.740
And touching mouse pointer is one of the options in the little drop down here

50:04.740 --> 50:05.780
if you tinker with it.

50:05.780 --> 50:08.900
So if the cat is touching the mouse pointer, then and only then,

50:08.900 --> 50:11.060
play, sound, meow, until done.

50:11.060 --> 50:14.820
So we've combined now functions with loops with a condition.

50:14.820 --> 50:16.940
But why the loop?

50:16.940 --> 50:19.980
The cat's only meowing once when I pet him.

50:19.980 --> 50:22.260
Why am I doing anything forever here?

50:29.260 --> 50:33.540
Yeah, I might want to pet it again, so I want the program to anticipate that.

50:33.540 --> 50:37.580
And honestly, if I omitted this forever block and my program instead

50:37.580 --> 50:41.500
looked just like this, so let me get rid of that and this,

50:41.500 --> 50:46.380
and then I clicked play, and now I hover over him,

50:46.380 --> 50:48.300
why is it not working even once?

50:50.980 --> 50:51.980
Say again?

50:56.980 --> 50:59.980
Yeah, so I mean, at this point, if I can summarize,

50:59.980 --> 51:03.660
it's that happened, the computer's so damn fast that this already happened

51:03.660 --> 51:06.660
by the time I move my cursor over to the cat.

51:06.660 --> 51:10.260
And at the moment I clicked play, I was not touching the cat.

51:10.260 --> 51:12.700
Those blocks executed, so to speak, top to bottom.

51:12.700 --> 51:14.060
That's it for the program.

51:14.060 --> 51:17.020
So by the time I move the cursor over to the cat, the program is over.

51:17.020 --> 51:17.740
It's not listening.

51:17.740 --> 51:21.460
And so forever, this way, I can actually listen in perpetuity

51:21.460 --> 51:23.340
for something to actually happen.

51:23.340 --> 51:26.060
What if I want to do something not just if something is true,

51:26.060 --> 51:28.380
but handle two cases, if or else?

51:28.380 --> 51:31.180
Well, let me go ahead and open up pet one.

51:31.180 --> 51:32.980
And this is another example.

51:32.980 --> 51:37.140
And could someone perhaps describe, after reading this code,

51:37.140 --> 51:39.300
what this program is going to do instead?

51:42.380 --> 51:42.880
Yeah?

51:48.220 --> 51:48.700
Exactly.

51:48.700 --> 51:50.060
And let me summarize more verbally.

51:50.060 --> 51:54.060
So if this time you're touching the cat, it's going to roar instead.

51:54.060 --> 51:56.660
Else, it's just going to meow sweetly.

51:56.660 --> 52:00.220
So this time it is meowing perpetually once every second.

52:00.220 --> 52:03.500
But if you touch this particular cat, he doesn't like it.

52:03.500 --> 52:15.740
So play meow, meow, and now don't touch the cat.

52:16.740 --> 52:18.260
Don't touch the cat.

52:18.260 --> 52:20.780
So now we might interact in two different ways

52:20.780 --> 52:23.740
by having two different roads that you can go down.

52:23.740 --> 52:26.180
Well, let's actually make something a little more interactive.

52:26.180 --> 52:28.220
Let me go ahead and open another example.

52:28.220 --> 52:30.500
This one called bounce zero, because now we

52:30.500 --> 52:34.300
can start to see some design elements from what Oscar time was.

52:34.300 --> 52:36.980
Like this now is getting a little interesting.

52:36.980 --> 52:38.900
What is actually going on here?

52:38.900 --> 52:41.100
So let me zoom in on the blocks here.

52:41.100 --> 52:43.460
This block is just saying forever.

52:43.460 --> 52:45.700
Move 10 steps, which is another block we haven't

52:45.700 --> 52:47.580
seen, but 10 steps is like 10 pixels.

52:47.580 --> 52:49.580
So move 10 pixels on the screen.

52:49.580 --> 52:52.900
But if you're touching the edge, then turn around 180 degrees.

52:52.900 --> 52:54.860
And you can see exactly that happening.

52:54.860 --> 52:58.060
Scratch is turning around 180 degrees, and this rotation style

52:58.060 --> 52:58.980
just means double back.

52:58.980 --> 53:01.460
Don't like loop around 180 degrees.

53:01.460 --> 53:05.740
So that's kind of cool, but this is not how humans or cats walk.

53:05.740 --> 53:08.740
Like what is obviously unnatural about this?

53:11.220 --> 53:12.900
Yeah, I mean, I can't even simulate it, right?

53:12.900 --> 53:17.140
Like his feet are in static position, yet sliding back and forth on the screen.

53:17.140 --> 53:18.820
And yet that is not what walking is.

53:18.820 --> 53:21.060
Like walking, presumably, has some kind of movement.

53:21.060 --> 53:21.660
And what?

53:21.660 --> 53:24.820
Well, we could just kind of simulate it like, OK, I could just walk.

53:24.820 --> 53:29.060
Walking, and you can imagine taking really quick photographs of my legs

53:29.060 --> 53:31.500
or the cat's leg moving, and then just deciding,

53:31.500 --> 53:34.020
this photo will be representative of one step,

53:34.020 --> 53:36.140
this photo will be representative of another.

53:36.140 --> 53:39.100
And with just two of those steps, I'd wager

53:39.100 --> 53:41.940
we could actually do a pretty good job of simulating

53:41.980 --> 53:43.180
what walking looks like.

53:43.180 --> 53:46.860
In fact, if I go back to where we began, this picture of Scratch,

53:46.860 --> 53:50.180
what if I just move his legs ever so slightly?

53:50.180 --> 53:52.820
Then go back, then go forward.

53:52.820 --> 53:55.820
And even just in my PDF, I can simulate animation

53:55.820 --> 53:58.780
by hitting up arrow, down arrow, up arrow, down arrow,

53:58.780 --> 54:01.940
because it kind of looks like he's walking now when really your human eyes

54:01.940 --> 54:04.820
are just seeing two different pictures again and again.

54:04.820 --> 54:05.940
So how can I do this?

54:05.940 --> 54:09.020
Well, if I go back to Scratch, he's still walking.

54:09.020 --> 54:15.300
Let me go ahead and open up Bounce 1, the second version of this.

54:15.300 --> 54:19.300
And now do this, OK.

54:19.300 --> 54:20.500
So how did I add this?

54:20.500 --> 54:22.580
There's a little purple block that we haven't seen yet.

54:22.580 --> 54:24.380
But if you poke around the categories, you'll

54:24.380 --> 54:27.460
see other blocks like this, next costume that just keeps changing,

54:27.460 --> 54:28.900
the costume that he's wearing.

54:28.900 --> 54:31.580
It turns out Scratch exists as a picture.

54:31.580 --> 54:33.380
And his default picture is him not moving.

54:33.380 --> 54:36.420
But if I go up here to top left and click Costumes,

54:36.420 --> 54:38.900
you can actually see that here's his one costume.

54:38.900 --> 54:40.620
Here's his second costume.

54:40.620 --> 54:43.300
And so that purple block that says next costume,

54:43.300 --> 54:47.180
because it's in the forever loop, it just keeps doing next, next, next,

54:47.180 --> 54:49.900
next, next, just showing one costume or the other,

54:49.900 --> 54:52.860
they're clearly mimicking walking.

54:52.860 --> 54:54.300
Now, this is not very natural.

54:54.300 --> 54:57.900
Why don't we slow him down to, say, five steps at a time

54:57.900 --> 54:59.700
and have him go again?

54:59.700 --> 55:01.340
Now, this is still going pretty fast.

55:01.340 --> 55:05.660
Let me go ahead and say we could have control.

55:05.660 --> 55:11.740
We could have him wait a second after moving very dramatically.

55:11.740 --> 55:13.220
Weeks should probably speed this up.

55:13.220 --> 55:16.220
So let's wait 1 tenth of a second, 0.1.

55:16.220 --> 55:19.420
Or maybe that's even, let's do 0.01, 1 hundredth of a second.

55:19.420 --> 55:21.100
Now it's getting a little more realistic.

55:21.100 --> 55:22.500
But this is what animation is.

55:22.500 --> 55:26.100
If you've ever watched a cartoon or a movie based on pictures like this,

55:26.100 --> 55:29.220
you're just tinkering with some of these parameters, these inputs,

55:29.220 --> 55:31.420
in order to produce this output by understanding

55:31.420 --> 55:34.140
what the fundamental representation of these things

55:34.140 --> 55:37.540
is, which in this case are just pictures, again and again and again,

55:37.540 --> 55:39.380
in order to create that animation.

55:39.380 --> 55:41.060
But what about interactivity?

55:41.060 --> 55:42.140
Let me do this one myself.

55:42.140 --> 55:46.620
Let me go ahead and get rid of this, go back to events and say,

55:46.620 --> 55:50.900
when green flag clicked, then let me go ahead and grab a forever block

55:50.900 --> 55:52.900
so that this keeps going again and again.

55:52.900 --> 55:54.820
And then let me go ahead to go to motion.

55:54.820 --> 55:57.900
It turns out that under motion, there's this block we haven't seen,

55:57.900 --> 56:00.020
point towards the mouse pointer.

56:00.020 --> 56:02.300
And let me go ahead and pull this in here.

56:02.300 --> 56:07.140
And then let me have it move just like one step at a time instead of 10.

56:07.140 --> 56:10.220
What is this going to do?

56:10.220 --> 56:13.380
What's this program do?

56:13.380 --> 56:15.060
Yeah, say again?

56:15.060 --> 56:15.940
Follow the mouse.

56:15.940 --> 56:21.220
Yeah, this is kind of like a way of taking your cat for a walk.

56:21.220 --> 56:25.620
Perhaps not quite the animal we intended, but he'll follow the cursor.

56:25.620 --> 56:27.820
And I can actually speed this up a little bit.

56:27.820 --> 56:29.700
So let's have him move 10 steps.

56:29.700 --> 56:32.620
OK, now there we go.

56:32.620 --> 56:34.180
So now he's moving up and down.

56:34.180 --> 56:35.540
And so now it's interactive.

56:35.540 --> 56:39.580
So you might recall that when we were playing Oscar time earlier and picking up

56:39.580 --> 56:41.660
the, OK, don't do that.

56:41.660 --> 56:43.540
See, that's a bug.

56:43.540 --> 56:44.380
He's just confused.

56:44.380 --> 56:47.620
He's constantly moving toward it, but you're already, OK, so we're going to stop.

56:47.620 --> 56:50.900
OK, so now he's following, but that's how we might now

56:50.900 --> 56:53.980
create, for instance, the ability to move those pieces of trash around

56:53.980 --> 56:56.740
and have them follow the mouse cursor if you think back to Oscar time.

56:56.740 --> 56:58.580
Every time you picked up a piece of trash,

56:58.580 --> 57:02.020
you'd follow the cursor because there was a forever loop and a block like this

57:02.020 --> 57:03.860
pointing toward the mouse pointer.

57:03.860 --> 57:08.220
Well, now let's integrate multiple ideas and actually have multiple scripts.

57:08.220 --> 57:12.900
I proposed earlier that programs can actually have multiple threads.

57:12.900 --> 57:16.420
A thread is just a fancy way of saying, in our context, multiple scripts.

57:16.420 --> 57:21.820
Multiple scripts in one program that are happening essentially in parallel.

57:21.820 --> 57:25.260
Computer can effectively do multiple things at a time thanks to threading,

57:25.260 --> 57:26.740
and more on that down the road.

57:26.740 --> 57:30.780
So these are more involved, but let's understand first what this program does.

57:30.780 --> 57:33.700
Let me go ahead and hit Play, and this one tends to be a little loud.

57:38.700 --> 57:43.420
So the C line is just barking endlessly, annoyingly.

57:43.420 --> 57:49.260
So by reading the code, how can I stop him from barking?

57:49.260 --> 57:50.620
Hit the spacebar.

57:50.620 --> 57:53.700
All right, so hit the spacebar.

57:53.700 --> 57:56.340
OK, I could just stop the program, obviously,

57:56.340 --> 57:58.420
but this program is still running technically.

57:58.420 --> 57:59.900
But why did that work?

57:59.900 --> 58:02.900
Well, notice this on the left-hand side is the first script.

58:02.900 --> 58:07.180
When the green flag is clicked, set this variable that I called muted to false.

58:07.180 --> 58:10.140
Could have called it x or y or z or counter, but none of those really makes sense.

58:10.140 --> 58:11.140
So I called it muted.

58:11.140 --> 58:15.180
And I set it equal to false, which is, again, a Boolean value, true or false.

58:15.180 --> 58:16.780
Just mean yes or no.

58:16.780 --> 58:20.420
Forever, if the key space is pressed, then do this.

58:20.420 --> 58:24.820
If muted is currently false, then change muted to true.

58:24.820 --> 58:27.180
Else, change muted to false.

58:27.180 --> 58:30.100
So if muted is false, change it to true.

58:30.100 --> 58:32.460
If muted is true, change it to false.

58:32.460 --> 58:36.420
Any time the human hits the spacebar, update that variable.

58:36.420 --> 58:40.100
Now, if we look at the other script, which is also driving the C line,

58:40.100 --> 58:41.180
what is he doing?

58:41.180 --> 58:45.340
Forever, if muted is false, so if he's not muted.

58:45.340 --> 58:48.660
If muted is false means not muted, start the sound C line,

58:48.660 --> 58:52.780
and then think, hi, hi, hi, for two seconds, and then wait for one more second.

58:52.780 --> 58:54.500
And then just repeat, repeat, repeat.

58:54.500 --> 58:57.340
But if I change with the spacebar, muted to true,

58:57.340 --> 59:00.820
he's going to say, if muted equals false, that's not so.

59:00.820 --> 59:02.420
I'm not going to play a sound this time.

59:02.420 --> 59:05.980
And so now we have the ability to integrate multiple scripts together

59:05.980 --> 59:08.980
in order to achieve a more interactive result.

59:08.980 --> 59:10.300
And what about this?

59:10.300 --> 59:16.180
Back in when I was a kid, might have played over in the summer's like Marco Polo.

59:16.180 --> 59:19.100
Super simple game where we played it in the pool for some reason,

59:19.100 --> 59:21.460
where one person in the pool very safely is blindfolded.

59:21.500 --> 59:23.180
And then he or she yells Marco.

59:23.180 --> 59:26.220
And then everyone around him or her is supposed to yell Polo.

59:26.220 --> 59:28.100
And then the person who's blindfolded is supposed

59:28.100 --> 59:30.180
to go chase the other kids in the pool and tag them,

59:30.180 --> 59:31.300
and then they become it.

59:31.300 --> 59:33.660
But in other words, it's this signaling mechanism.

59:33.660 --> 59:36.380
Someone yells Marco, and everyone else responds

59:36.380 --> 59:38.820
to that broadcast of the word Marco.

59:38.820 --> 59:41.540
Well, it turns out we can simulate this with these two puppets.

59:41.540 --> 59:44.500
This guy here, notice that I've highlighted the orange puppet,

59:44.500 --> 59:46.860
because there's a second blue puppet there, separate sprites.

59:46.860 --> 59:49.900
And these are just photographs we uploaded to the game.

59:49.900 --> 59:52.980
Forever, if the key space is pressed.

59:52.980 --> 59:56.100
So if the space bar is pressed, say Marco for two seconds,

59:56.100 --> 59:57.940
and then broadcast an event.

59:57.940 --> 01:00:03.020
Meanwhile, the blue puppet here has a super simple block,

01:00:03.020 --> 01:00:05.340
but it's fundamentally different from the ones we've seen.

01:00:05.340 --> 01:00:08.180
He's not starting when the green flag is clicked.

01:00:08.180 --> 01:00:11.340
He is starting only when he receives an event.

01:00:11.340 --> 01:00:14.260
So it turns out that sprites and scratch can't hear or see what

01:00:14.260 --> 01:00:16.300
the other one is saying in those speech bubbles.

01:00:16.300 --> 01:00:19.880
You have to use a fancier technique, which is this special block called broadcast.

01:00:19.920 --> 01:00:24.060
Which is like passing a note digitally from one sprite to another

01:00:24.060 --> 01:00:26.880
that the other one can read or receive, so to speak.

01:00:26.880 --> 01:00:29.120
So only when he receives this event, so to speak,

01:00:29.120 --> 01:00:31.480
does he say polo for two seconds.

01:00:31.480 --> 01:00:35.200
And again, the orange puppet sends that secret message

01:00:35.200 --> 01:00:38.000
just using this other puzzle piece, broadcast an event,

01:00:38.000 --> 01:00:41.080
like passing a note that the human doesn't actually see.

01:00:41.080 --> 01:00:44.760
So if I now hit the green flag and hit the space bar,

01:00:44.760 --> 01:00:49.040
orange yells Marco, blue guy yells polo in response.

01:00:49.040 --> 01:00:50.920
But those aren't timed together.

01:00:50.920 --> 01:00:54.320
Rather, the blue guy is hearing what the orange one has said,

01:00:54.320 --> 01:00:59.280
thereby allowing multiple sprites to actually intercommunicate.

01:00:59.280 --> 01:01:00.440
So how did we get here?

01:01:00.440 --> 01:01:03.720
Well, recall that we had all of these building blocks a moment ago.

01:01:03.720 --> 01:01:05.920
First, we started out with just functions and conditions

01:01:05.920 --> 01:01:07.360
and Boolean expressions and loops.

01:01:07.360 --> 01:01:10.680
We've now added to that the ability to store information and variables

01:01:10.680 --> 01:01:12.560
and threads to do multiple things at once.

01:01:12.560 --> 01:01:14.640
And then if you do have multiple things happening,

01:01:14.640 --> 01:01:17.840
events where they can intercommunicate somehow,

01:01:17.840 --> 01:01:19.200
yet another building block.

01:01:19.200 --> 01:01:22.280
So if we now take a step back and consider

01:01:22.280 --> 01:01:25.920
how we can make functions of our own, we

01:01:25.920 --> 01:01:28.560
have the final piece of the puzzle, so to speak.

01:01:28.560 --> 01:01:29.760
Let me go ahead and do this.

01:01:29.760 --> 01:01:34.160
Let me go ahead and create a simple program with when green flag clicked

01:01:34.160 --> 01:01:36.240
that simply simulates coughing for a cat.

01:01:36.240 --> 01:01:41.440
So this cat is going to say, not hello, but cough for one second.

01:01:41.440 --> 01:01:45.200
And then he's going to go ahead and wait for one second.

01:01:45.200 --> 01:01:48.880
And then I'm going to go ahead and copy paste as I did before.

01:01:48.880 --> 01:01:51.120
This is one of those do as I say, not as I do,

01:01:51.120 --> 01:01:54.800
to implement this program here where he coughs three times.

01:01:54.800 --> 01:01:57.720
We already know, though, from earlier, that this is not good design.

01:01:57.720 --> 01:02:00.240
Why?

01:02:00.240 --> 01:02:01.200
You're repeating yourself.

01:02:01.200 --> 01:02:02.760
Don't repeat yourself.

01:02:02.760 --> 01:02:04.240
DRY is an acronym, actually.

01:02:04.240 --> 01:02:08.040
Don't repeat yourself because you're doing three times as many times,

01:02:08.040 --> 01:02:10.000
something that you only really need to do once.

01:02:10.000 --> 01:02:13.240
The solution before, of course, was just use a loop of some sort.

01:02:13.240 --> 01:02:14.880
So let me actually take that out.

01:02:14.880 --> 01:02:18.760
Let me use a repeat block, change 10 to 3,

01:02:18.760 --> 01:02:20.480
and then just use two of these blocks.

01:02:20.480 --> 01:02:22.920
And notice already, the program is so much more compact.

01:02:22.920 --> 01:02:27.680
And now, if I want to change the 3 to a 30 or to a 10 or any number,

01:02:27.680 --> 01:02:29.200
I just change one simple value.

01:02:29.200 --> 01:02:32.480
I don't have to rewrite or copy paste or delete things.

01:02:32.480 --> 01:02:34.480
I can update the program much more readily.

01:02:34.480 --> 01:02:40.000
And now, the same thing is going to happen with just cough, cough, cough.

01:02:40.000 --> 01:02:44.160
But it turns out that it would be nice to henceforth abstract away from this.

01:02:44.160 --> 01:02:47.600
I just want any program I write to know how to cough.

01:02:47.600 --> 01:02:51.080
And coughing is really just saying something, perhaps some number of times.

01:02:51.080 --> 01:02:53.760
But it turns out we can abstract this away in code.

01:02:53.760 --> 01:02:56.000
Let me go down to my blocks here.

01:02:56.000 --> 01:02:58.400
And this allows me to click this button, make a block.

01:02:58.400 --> 01:03:00.080
It allows me to make my own function.

01:03:00.080 --> 01:03:04.520
I get this dialog window here, and I'm just going to call this block cough.

01:03:04.520 --> 01:03:06.400
I'm going to go ahead and click OK.

01:03:06.400 --> 01:03:10.400
And now, I have this new pink block that itself can have blocks underneath it.

01:03:10.400 --> 01:03:11.480
And you know what I'm going to do?

01:03:11.480 --> 01:03:12.960
I'm going to go ahead and do this.

01:03:12.960 --> 01:03:17.160
I'm going to go ahead and say cough under there.

01:03:17.160 --> 01:03:20.880
And now, notice on the left, I now have access to this new pink piece.

01:03:20.880 --> 01:03:22.720
I can now put this in here.

01:03:22.720 --> 01:03:27.080
So now, notice, even though, yes, this is how coughing is implemented

01:03:27.080 --> 01:03:30.840
on the left-hand side here, next time when I write a program,

01:03:30.840 --> 01:03:32.720
I just want to call cough.

01:03:32.720 --> 01:03:35.240
And I don't care about those lower-level implementation details.

01:03:35.240 --> 01:03:36.960
I don't care about the binary or any of that.

01:03:36.960 --> 01:03:38.880
I just want this to be an abstraction.

01:03:38.880 --> 01:03:40.800
But I could do better than this.

01:03:40.800 --> 01:03:42.940
Wouldn't it be nice if instead of just repeating

01:03:42.940 --> 01:03:46.300
cough three times, what if I made that a feature of cough?

01:03:46.300 --> 01:03:47.300
So let me do this.

01:03:47.300 --> 01:03:51.620
I can go ahead and right-click on this pink piece, and I can edit it.

01:03:51.620 --> 01:03:53.620
That brings up that same window from before.

01:03:53.620 --> 01:03:55.700
And notice this, add an input.

01:03:55.700 --> 01:03:58.860
So when I make a custom block, I can actually make pretty fancy blocks

01:03:58.860 --> 01:04:02.220
just like the ones MIT gives us with the software.

01:04:02.220 --> 01:04:04.340
And now, I can type in something like n.

01:04:04.340 --> 01:04:07.660
And if I add a label just to make it more descriptive, I can just say times.

01:04:07.660 --> 01:04:12.420
So now, I've made a special custom puzzle piece that says cough some number of times

01:04:12.420 --> 01:04:16.900
where n for number is just the go-to variable that programmers tend to use.

01:04:16.900 --> 01:04:24.780
So now, I can actually move this repeat block into cough itself.

01:04:24.780 --> 01:04:26.940
But rather than hard code three, notice this.

01:04:26.940 --> 01:04:30.860
I can steal that variable and now say cough this many times

01:04:30.860 --> 01:04:35.260
by repeating, saying, this, again, and again, and again.

01:04:35.260 --> 01:04:40.620
And now, when I cough in my actual program, I just type in three here.

01:04:40.620 --> 01:04:42.900
So I have this beautiful abstraction now, so to speak.

01:04:42.900 --> 01:04:46.100
Cough this many times, and I, and no one else in the world,

01:04:46.100 --> 01:04:48.540
never again needs to care about what it means to cough,

01:04:48.540 --> 01:04:50.860
because we've already implemented that before.

01:04:50.860 --> 01:04:53.460
And so just as MIT has given us so much functionality

01:04:53.460 --> 01:04:55.180
that we ourselves don't have to think about,

01:04:55.180 --> 01:04:58.060
so can I now make functionality that I don't have to think about?

01:04:58.060 --> 01:05:01.060
And as we progress to higher level languages like C and JavaScript

01:05:01.060 --> 01:05:02.940
and Python, we're going to continue this process,

01:05:02.940 --> 01:05:07.060
sometimes solving problems ourselves by making our own custom puzzle pieces,

01:05:07.060 --> 01:05:09.260
but very often using things called libraries,

01:05:09.300 --> 01:05:11.940
code that other humans wrote before us that's just

01:05:11.940 --> 01:05:17.660
useful to get the job done just as Scratch has done here in part for us.

01:05:17.660 --> 01:05:21.220
Let me go ahead, then, and bring all of this together

01:05:21.220 --> 01:05:24.300
by opening this other example here.

01:05:24.300 --> 01:05:28.020
Let me go ahead and open up this one, which isn't something we've seen,

01:05:28.020 --> 01:05:31.940
but it's kind of an interactive game like this, made by a former student.

01:05:32.540 --> 01:05:33.700
Should we have an apple?

01:05:33.700 --> 01:05:34.180
Yes.

01:05:36.700 --> 01:05:37.540
Little animation.

01:05:41.700 --> 01:05:43.700
OK, that didn't end well.

01:05:43.700 --> 01:05:49.540
Let's try again, play again, and notice the say block is happening.

01:05:49.540 --> 01:05:51.500
There's some kind of ask block.

01:05:51.500 --> 01:05:54.060
The student was checking if the human typed in yes or no.

01:05:54.060 --> 01:05:56.140
Let's type no this time, no apple.

01:05:56.140 --> 01:05:57.300
Ooh, cupcake.

01:05:57.300 --> 01:05:58.620
OK, yes.

01:05:58.620 --> 01:05:59.100
Enter.

01:05:59.980 --> 01:06:02.860
OK, don't do that.

01:06:02.860 --> 01:06:03.860
One more life.

01:06:03.860 --> 01:06:04.340
Here we go.

01:06:06.860 --> 01:06:20.820
OK, no apple, no cupcake, a little variable, counting it.

01:06:20.820 --> 01:06:33.220
OK, so I won the game.

01:06:33.220 --> 01:06:38.420
In our final moments here, let me go ahead and open one final example.

01:06:38.420 --> 01:06:42.580
As you know, CS50 is offered not only at Harvard, but at Yale as well.

01:06:42.580 --> 01:06:45.660
So it seems fitting to perhaps end on a note that pits one campus,

01:06:45.660 --> 01:06:48.740
perhaps, against the other by way of another game that a former student

01:06:48.740 --> 01:06:50.700
wrote called Ivy's Hardest Game.

01:06:50.700 --> 01:06:54.260
But for this, I think we need one final volunteer who's coming up.

01:06:54.260 --> 01:06:55.700
OK, first hand, right there.

01:06:55.700 --> 01:06:57.540
Come on down.

01:06:57.540 --> 01:07:01.180
So in Ivy's Hardest Game, it's a game played with the keyboard.

01:07:01.180 --> 01:07:03.620
And even though it might look a little overwhelming at first glance,

01:07:03.620 --> 01:07:06.460
just like Oscar Time did, and heck, just like the gingerbread animation

01:07:06.460 --> 01:07:09.740
might, realize that if you decompose it in just your mind's eye,

01:07:09.740 --> 01:07:11.820
thinking about what those individual building blocks are,

01:07:11.820 --> 01:07:13.820
you can probably guess what the puzzle pieces are.

01:07:13.820 --> 01:07:14.460
Hi, what's your name?

01:07:14.460 --> 01:07:15.180
Hi, I'm Andrea.

01:07:15.180 --> 01:07:16.860
Andrea, David, nice to meet you.

01:07:16.900 --> 01:07:20.580
Here is Ivy's Hardest Game.

01:07:20.580 --> 01:07:23.180
We'll pitch you against all of the IVs here.

01:07:23.180 --> 01:07:27.340
And then right after this, we'll be adjourned for cupcakes in the trans set.

01:07:27.340 --> 01:07:29.340
Ready?

01:07:30.340 --> 01:07:34.340
You can't touch this.

01:07:34.340 --> 01:07:37.340
You can't touch this.

01:07:37.340 --> 01:07:41.340
You can't touch this.

01:07:41.340 --> 01:07:44.340
You can't touch this.

01:07:44.340 --> 01:07:45.340
Nice.

01:07:45.340 --> 01:07:47.340
You can't touch this.

01:07:47.340 --> 01:07:53.340
My, my, my, my music hit me so hard, makes me say, oh, my lord, thank you,

01:07:53.340 --> 01:07:57.340
for blessing me when my too running, too high, that you're good,

01:07:57.340 --> 01:07:58.340
that you know you're down.

01:07:58.340 --> 01:08:01.340
I'm super dope all the way from the old town, and I know it's such,

01:08:01.340 --> 01:08:04.340
and this is beautiful, you can't touch this.

01:08:04.340 --> 01:08:08.340
I told you, homeboy, you can't touch this.

01:08:08.340 --> 01:08:12.340
Yeah, that's how you live it, and you know you can't touch this.

01:08:12.340 --> 01:08:15.340
Look at my eyes, man, you can't touch this.

01:08:15.340 --> 01:08:18.340
You can't touch this.

01:08:18.340 --> 01:08:20.340
Fresh through juice and bandage, you got it like that,

01:08:20.340 --> 01:08:23.340
that you know you want to make it so blue, out of your suit,

01:08:23.340 --> 01:08:26.340
and get it by your attention while it's rolling.

01:08:26.340 --> 01:08:29.340
Hold on, pull a little bit and it'll go on like that.

01:08:29.340 --> 01:08:30.340
Like that.

01:08:30.340 --> 01:08:32.340
Pull a little bit and it'll go on like that, I know.

01:08:32.340 --> 01:08:36.340
You can't touch this.

01:08:36.340 --> 01:08:40.340
Come on, come on, come on, come on, come on.

01:08:40.340 --> 01:08:43.340
While you standing there, man, you can't touch this.

01:08:43.340 --> 01:08:46.340
Yo, Santa, be all smooth and subtle and you can't touch this.

01:08:46.340 --> 01:08:48.340
Yeah, that's how you live it.

01:08:48.340 --> 01:08:51.340
You know you're down, make knows, and that's what I'm getting down.

01:08:51.340 --> 01:08:53.340
They know you're talking about the hammer,

01:08:53.340 --> 01:08:56.140
We're talking about show that's hot and tight.

01:08:56.140 --> 01:08:59.100
Singers are slow, so fast, so high for a tape.

01:08:59.100 --> 01:09:00.940
Two hundred, what's gonna get you nice,

01:09:00.940 --> 01:09:02.380
two hundred times.

01:09:02.380 --> 01:09:03.740
Second to last level.

01:09:03.740 --> 01:09:05.580
You might as well quit.

01:09:05.580 --> 01:09:08.100
That's word, cause you know what,

01:09:08.100 --> 01:09:09.420
you can't touch this.

01:09:09.420 --> 01:09:14.940
Oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh,

01:09:14.940 --> 01:09:20.780
oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh,

01:09:20.780 --> 01:09:29.220
oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh, oh,

01:09:29.220 --> 01:09:31.420
stop and have time go with the flow

01:09:31.420 --> 01:09:32.380
and stay in the game.

01:09:32.380 --> 01:09:33.180
You do it.

01:09:33.180 --> 01:09:36.060
Just put your hands in the air, bust your ears,

01:09:36.060 --> 01:09:37.380
put your fingers in your head.

01:09:37.380 --> 01:09:40.140
Sit for awhile, now dance with air,

01:09:40.140 --> 01:09:41.740
thinking want to get in the mood.

01:09:41.740 --> 01:09:44.260
Slide your arm just for a minute that's all.

01:09:44.260 --> 01:09:47.180
The bump, bump, bump, bump, bump, bump, bump, bump, bump, bump,

01:09:47.180 --> 01:09:48.600
you can't touch this.

01:09:48.600 --> 01:09:52.600
Look, man, you can't test me.

01:09:52.600 --> 01:09:54.600
You better get a high five.

01:09:54.600 --> 01:09:56.600
Oh!

01:09:56.600 --> 01:09:58.600
Please, man.

01:09:58.600 --> 01:10:00.600
Break it down.

01:10:00.600 --> 01:10:02.600
One, two, two. I swore.

01:10:05.600 --> 01:10:07.600
No, it's okay.

01:10:10.600 --> 01:10:12.600
One more left.

01:10:12.600 --> 01:10:14.600
Stop. Have a time.

01:10:19.600 --> 01:10:22.600
Alright, a round of applause for Andrea if we could.

01:10:26.600 --> 01:10:29.600
That's it for CS50. See the website for details.

01:10:29.600 --> 01:10:31.600
We'll see you for cake and like a transept.

01:10:31.600 --> 01:10:33.600
Welcome aboard.

