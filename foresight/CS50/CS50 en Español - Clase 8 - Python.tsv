start	end	text
0	15680	All right, so this is CS50, and this is the day before our test, of course.
15680	17680	But this is lecture 8, in which we're actually
17680	20720	going to finally transition from C, this lower level language that we've
20720	22440	been spending quite some time to.
22440	25440	And the goal today isn't so much to focus on Python, per se,
25440	28160	but honestly, to do what we hope will be one of the most empowering
28160	31720	aspects of the class, which is to emphasize that this is not
31720	34840	in a semester learning C. This has been a semester learning programming,
34840	37760	a certain type of programming called procedural or imperative programming,
37760	40080	but more on that in another higher level class, perhaps.
40080	43320	But really, that this class is about ultimately teaching yourself
43320	45320	to learn new languages.
45320	48520	And indeed, what you'll find is that as we explore some of the features
48520	52600	and the syntax of Python, odds are today it might look as cryptic as C did
52600	55760	just a few weeks ago, but you'll find that once you start recognizing
55760	59200	patterns as you have with C, it'll be all the more accessible
59200	63240	and all the more useful when solving some problems.
63240	66520	So unrelated, just earlier this week, I happened
66520	68760	to be in Mountain View with some of the team.
68760	71760	And you might recall from last lecture at Harvard,
71760	75200	we offered this glimpse of one of the earliest racks of servers
75200	76720	that Google itself had.
76720	78680	Well, it turns out they changed buildings,
78680	81800	but we happened to stumble upon the actual display.
81800	85240	So pictured here is a photo from my own phone, which was actually really
85240	86000	cool to see.
86000	89760	So inside of this, you'll see all of the old hard drives they've used.
89760	91280	We actually looked at some of the labels.
91280	94160	And indeed, hard drives manufactured in 1999, which
94160	96360	was when Google started getting some of its momentum.
96360	98280	I mean, you can see the green circuit boards here,
98280	101240	on which would be CPUs and other things potentially.
101240	103200	So if you'd like to stroll down memory lane,
103200	106920	feel free to read up on this on Wikipedia or even on the excerpts here.
106920	110520	And then, strangely enough, at the conference, some of us were at,
110520	113680	did we discover this, perhaps the biggest duck debugger
113680	118400	made up of smaller duck debuggers, one of whom was our own.
118400	120760	So that, too, was how we spent this past week.
120760	123600	All right, so how are we going to spend this week and the weeks to come?
123600	126680	So you'll recall that when we transitioned from scratch to C,
126680	129440	we drew a couple of comparisons between syntax and features.
129440	132120	And I thought it'd be useful to take that same approach here really
132120	134880	to emphasize that most of the ideas we're going to explore today
134880	135960	are themselves not new.
135960	139520	It's just how you express them and how you write the syntax in the language,
139520	143720	known as Python, that's indeed going to be different from scratch, from C.
143720	145280	And now here we are with Python.
145280	150200	So back in the day, in week 0, when you wanted to say something in scratch,
150200	152880	you would literally use this purple puzzle piece, say hello.
152880	155240	And we called that a function or a statement.
155240	156760	It was some kind of verb action.
156760	159200	And in C, of course, it looked a little something like this.
159200	163080	Henceforth, starting today in Python, it's going to look like this.
163080	167000	So before, after, before, after.
167000	169280	So it's pretty easy to visually diff these two things.
169280	171360	But what are just a couple of the differences that jump out at you
171360	172320	immediately?
172320	173960	See?
173960	174440	Python.
177380	179720	So there's no more backslash N, it would seem, in this context.
179720	182080	So that's kind of a nice relief to not have to type anymore.
182080	184400	What else seems to be different?
184400	186080	No semicolon, thank god, right?
186080	187720	Perhaps the stupidest source of frustration
187720	191920	that you might have experienced by just omitting one of those and someone over here?
191920	195840	Yeah, so printf is now just print, which is pretty reasonable unto itself.
195840	198160	So these are terribly minor differences.
198160	200800	But it's sort of testament to the kinds of mental adjustments
200800	202120	you're going to have to start to make.
202120	204720	Fortunately, thus far, we've seen that you can start leaving things off,
204720	206520	which is actually a guiding principle of Python
206520	209440	and that one of its goals is meant to be easier to write than some
209440	211400	of its predecessors among them C.
211400	215960	So in C, we might have implemented this Hello World program that actually
215960	218760	ran when you click the green flag using code like that at the right.
218760	222520	And this was, if those of you had no programming experience coming in to CS50,
222520	226240	what probably looked like the proverbial grief to you just a few weeks ago.
226240	228480	And we teased apart what those various lines meant.
228480	229920	But in Python, guess what?
229920	233200	If you want to write a program whose purpose in life is to say Hello,
233200	236440	we'll just write def main print Hello World.
236440	239040	So it's a little similar, structurally structured.
239040	244560	And in fact, it does not lack for some of the more arcane syntax here,
244560	247040	but we'll see soon what this actually means.
247040	249560	But it's a little simpler than the one before.
249560	250600	And let's tease this apart.
250600	253200	So def here simply means define me a function.
253200	257120	So whereas in C, we've historically seen that you specify the type
257120	258400	that the function should return.
258400	260600	We're not going to do that in Python anymore.
260600	262000	Python still has data types.
262000	265160	But we're not going to explicitly mention what data types we're using.
265160	266920	Meanwhile, here is the name of the function.
266920	268120	And main would be a convention.
268120	271400	But it's not built into the language in the same way as it is in C,
271400	272880	as we shall see.
272880	276040	Meanwhile, this silly incantation is just a way
276040	279680	of ensuring that the default function to be executed in a Python program
279680	281320	is indeed going to be called main.
281320	283680	But more on that when we actually start creating.
283680	286760	But this is perhaps the most subtle but most important difference,
286760	287960	at least early on.
287960	289520	And it's even hard to see at this scale.
289520	293560	But notice the colons, both here and here, that I've highlighted now
293560	295720	in yellow, and these dots, which are not to be typed,
295720	298760	but are just meant to draw your attention to the fact that I hit the space bar four
298760	300800	times in those locations.
300800	304840	So if you have ever sort of gotten some feedback from your TA or TF,
304840	308280	that your style could be better, closer to five out of five,
308280	310920	because of lack of indentation or pretty formatting.
310960	313000	Python's actually going to help us out with this.
313000	317920	So Python code will not run if you have not indented things properly.
317920	322400	So gone are the curly braces that encapsulate related lines of code
322400	325160	within some block of functionality, and instead they're
325160	327720	replaced generally with this general structure.
327720	330320	You have a colon, and then below that and indented
330320	334000	are all of the lines that are somehow related to that earlier line of code.
334000	336000	And the indentation must be consistent.
336000	340680	So even though your own eye might not quite distinguish four spaces from three,
340680	343080	the Python environment will.
343080	346720	And so this will actually help implicitly enforce better style,
346720	350760	perhaps, than might have been easily done from the get go.
350760	353120	So then, of course, in Scratch, we had a forever block, which
353120	354360	says, hello world forever.
354360	356520	Much like in C, we could implement it like this.
356520	358560	Now there's actually pretty clean mapping in Python.
358560	361480	We already know we can get rid of the semicolon.
361480	363960	We already know we can get rid of the curly braces.
363960	366480	We're going to have to add in a colon, but it turns out
366480	368360	we can get rid of a little more too.
368360	374440	So what more is absent from this translation of hello world to Python?
374440	377040	This one's more subtle.
377040	378920	So we definitely got rid of the curly braces,
378920	380400	relying now just on indentation.
384280	386320	OK, so there's no parentheses around while.
386320	389440	And so this, too, is actually meant to be a feature of Python.
389440	392240	If you don't logically need parentheses to enforce
392240	396160	order of operations, like in arithmetic or the like, then don't use them,
396160	397520	because they're just an distraction.
397520	398560	They're just more to type.
398560	401920	And the code now is just visually cleaner and easier to read.
401920	403200	There's a minor difference, too.
403200	405520	True and false are going to be capitalized in Python,
405520	407520	but that's a fairly incidental detail.
407520	409960	But notice this kind of captures already the spirit of Python.
409960	412440	It's not a huge leap to go from one to the other,
412440	414920	but we've just kind of started to get rid of some of the clutter
414920	417040	and the stuff that never really intellectually added much.
417040	419840	And if anything was annoying, to have to remember early on.
419840	421400	So true here is Arbolian.
421400	423840	And now we have a finite number of iterations.
423840	426080	We might want to say hello world exactly 50 times.
426080	427960	In C, this was a crazy mess.
427960	430920	If you wanted to do this, you'd have to initialize a variable with which
430920	435120	to count up to, but not including 50 plus plusing along the way and so forth.
435120	437040	In Python, it's going to be a little cleaner.
437040	439640	And we'll come back to what this means exactly.
439640	441680	But if you kind of read it from left to right,
441680	444360	it kind of says what you mean, right?
444360	446840	For i in the range of 50.
446840	449120	So i is probably going to be a variable.
449120	450920	And notice we're not mentioning its type.
450920	454160	It's going to be implied by whatever the context is, which in this case
454160	456720	has to do apparently with numbers per the 50.
456720	459320	Range is actually going to be a data type unto itself.
459320	460600	It's a little funky in that sense.
460600	461760	It's called a class.
461760	465080	But this essentially is a special feature of Python
465080	469160	that unlike in C, where if you want to iterate over an array of values
469160	472800	or 50 such values, you would literally have an array of 50 values.
472800	475360	Range is kind of cool in that it kind of stands there.
475360	478760	And every time you iterate through a loop, it hands you the next number,
478760	480480	but just one at a time.
480520	484080	Thereby using maybe as little as 150th the amount of memory,
484080	486760	because it only has to keep one number around at a time.
486760	488440	And there's a bit more overhead than that.
488440	490760	It's not a perfect savings quite so.
490760	496240	But this just says for i in range 50, and that's going to implicitly
496240	499240	count from 0 up through 49.
499240	503000	And meanwhile, what's below it is what's going to get printed this time.
503000	506640	So meanwhile, here is one of our bigger scratch blocks early on.
506640	510080	And it translates pretty literally to code in C.
510080	514360	And you can perhaps guess, if you've never seen Python before today,
514360	516880	what the Python code might now look like.
516880	519120	If this here on the right is the C code, what
519120	521800	are some of the features syntactically that we're about to throw away?
521800	522300	Yeah?
522300	524600	You can throw it at curly braces and the parentheses.
524600	526880	Curly braces and parentheses are going to go away.
526880	529120	What else might go away?
529120	532440	The semicolons are going to go away?
532440	534840	The backslash n inside of the print statements?
534840	536480	Great.
536480	539800	One more thing, I think?
540800	541440	The if?
541440	543460	So well, we don't strictly need the parentheses
543460	546760	because it's not like I'm combining things logically like this or that
546760	548000	or this and that.
548000	550040	So it should suffice to get rid of those two.
550040	552280	And there's a couple of other tweaks we're going to have to make here.
552280	554920	But indeed, the code is going to be a lot tighter, so to speak.
554920	556960	Now you're just going to say what you mean here.
556960	559920	And there is one weird thing, and it's not a typo.
559920	563240	What apparently are you ever going to have to start knowing now?
563240	564440	L if or whatever.
564440	566400	So L if is not a typo.
566400	569080	It's indeed how you express the notion of else if,
569080	571000	but otherwise everything is exactly the same.
571000	573960	And notice the colons, frankly, ironically, whereas previously it
573960	576920	might have been annoying to occasionally forget a semicolon.
576920	580000	Now the colons might take on that role, but at least everything below them
580000	581920	is meant to be indented.
581920	585840	So here's a fundamental difference beyond the sort of silly syntactic
585840	587920	differences of this in, say, other languages.
587920	591200	The flow of work that we've been using thus far
591200	594000	has been essentially this in C. You write source code in a file,
594000	596080	generally ending in .c.
596080	600600	You run a compiler, which is a quick check, is called Clang.
600600	601840	So it's not technically make.
601840	604000	Make is just this helpful build utility that
604000	605680	automates the process of calling Clang.
605680	607920	So Clang is, strictly speaking, the compiler.
607920	611440	And Clang outputs zeros and ones, otherwise known as machine code.
611440	614600	And your computer, Mac, PC, whatever, has a CPU,
614600	618080	central processing unit inside, made by Intel or some other company.
618080	622160	And that CPU is hardwired to understand certain patterns of bits,
622160	625280	zeros and ones, otherwise known as machine code.
625320	629440	So that's been our world in C with Python.
629440	631600	So the code that you might compile in C, for instance,
631600	634720	might have been this, which we said you run Clang on like this.
634720	637480	And if you don't specify a default file name as output,
637480	640640	you'll instead just get in your file all of these zeros and ones, which
640640	645200	can then be executed by way of .slash a.out, the default name
645200	647120	for the assembler's output here.
647120	653280	So in Python, though, the world gets here, too, a little simpler as well.
653280	656720	So we just now have source code and an interpreter.
656720	659120	So there's no machine code it would seem.
659120	660720	There's no compiler it would seem.
660720	662800	And frankly, there's one fewer arrow, which
662800	665720	suggests to me that the process of running Python code itself
665720	667120	is actually going to be a little easier.
667120	669360	Running C code has typically been two steps.
669360	672480	You rerun Clang, or via Mac, you run Clang.
672480	673640	Then you run the program.
673640	674200	And it's fine.
674200	675840	It's not all that hard, but it's two steps.
675840	678880	Why not reduce to two steps what you could instead do in one?
678880	680480	And we'll see exactly what this means.
680480	682920	Now, technically, that's a bit of an oversimplification.
682920	687400	Technically, underneath the hood, if you wanted to run a program like this
687400	693360	that simply prints out hello world, you would simply run Python hello.py.
693360	696760	And the result of that would be to see hello world on the screen,
696760	697880	as we'll soon see.
697880	701120	But technically, underneath the hood, there is some other stuff going on.
701120	702960	So there actually kind of is a compiler.
702960	704760	But there's not something called machine code per se.
704760	705680	It's called byte code.
705680	708080	There's even something called a Python virtual machine.
708080	711160	But all of this is abstracted away for us.
711160	713440	Certainly for the sake of today's conversation,
713440	715680	but also in the real world more generally.
715680	719160	Humans have gotten better over the decades at writing software and writing
719160	721440	tools via which we can write software.
721440	724960	And so a lot of the more manual processes and a lot of the lower level
724960	729120	details that we've been focusing on, if not struggling on in C, start to go away.
729120	732800	Because much like in week zero, where we started layering on idea after idea,
732800	737440	zeros and ones, ASCII, colors and whatnot, similarly with our actual tools,
737440	738960	are we going to start to do the same.
739000	742200	So whereas in the past, or whereas in actuality,
742200	746560	what's going on underneath the hood is this process here,
746560	750040	we can start to think about it really as something quite simpler.
750040	754440	Now, if you're curious, and if you take some higher level class like CS61
754440	757960	or another, you'll actually talk about things like byte code and assembly
757960	758640	code and the like.
758640	760720	And we saw a glimpse of the latter a bit ago.
760720	762680	This happens to be an intermediate language
762680	766880	that Python source code is converted into before it's run by the computer.
766880	770920	But again, we're going to turn a blind eye to those lower level details.
770920	773520	So here are some of the tools now in our toolkit.
773520	775280	In Python, there are data types.
775280	777920	Though as of now, we've not seen any examples whereby
777920	781120	I specify what types of values are going to be in my variables
781120	783600	or what types of values a function is going to return.
783600	785280	But they are there.
785280	787800	Everything is sort of loosely typed in that whatever
787800	791280	you want a variable to be, it will just take on that data type,
791280	793520	whether it's an int or string or the like.
793520	795400	It's not going to be the full word string.
795400	797560	In Python, it's literally called str.
797560	802240	But there are some familiar types here, bool and float and int and others.
802240	806280	And in fact, among the others, as we'll soon see, are features like range.
806280	810400	But before that, no two that will provide for at least our first foray
810400	813040	into Python a few familiar functions.
813040	816600	So Python has different mechanisms than C for getting input from the user.
816600	821480	We've abstracted some of those details away in a new CS50 library for Python
821480	824920	that you'll really just use one or few times before we transition away
824920	825840	from even that.
825840	828920	But we'll give you functions like get char, get float, get int, get string
828920	832800	that handle all the requisite error checking so that at least for your first few programs,
832800	836200	you can just start to get some real work done without diving
836200	838800	into underneath the hood there.
838800	841360	And then lastly, here's some other tools in our toolkit.
841360	843800	And we'll just scratch the surface of some of these today.
843800	848120	But what's nice about Python and what's nice about higher level languages
848120	850200	more generally, like more modern languages that
850200	852600	learned lessons from older languages like C
852600	856920	is that you get so much more for free, so much more out of the box.
856920	858480	There's so much more of a kitchen sink.
858480	860840	There's so many metaphors we can use here, all of which
860840	864640	speak to the fact that Python has more features than C.
864640	869040	Much like Java, if you took a PCS or something else, had than C,
869040	873280	so does Python have a whole toolkit for representing complex numbers,
873280	876640	for representing dictionaries otherwise implemented as hash tables,
876640	877600	as you now know.
877600	879880	Lists, which is kind of synonymous with an array,
879880	883760	but in a list is an array that can sort of automatically grow and shrink.
883760	885880	We don't have to jump through hoops as we did in C.
885880	887880	Range we've seen briefly, which just hands you back,
887880	891240	one number after another in some range, ideally for iteration.
891240	892880	Set is the notion from mathematics, where
892880	895400	if you want to put bunches of things into a data structure
895400	898440	and you want to make sure you have only one of each such thing without
898440	900200	duplicates, you can use a set.
900200	902920	And a tuple is also a mathematical notion, typically,
902920	906680	where you can combine related things without complicating things
906680	908000	with actual structs.
908040	911040	Like x comma y is a common paradigm in lots of programs,
911040	914600	graphics or videos or certainly math and graphing itself.
914600	916920	You don't really need a whole full-fledged data structure.
916920	919880	You might just want to say x comma y.
919880	922520	And so Python gives us that kind of expressiveness.
922520	926640	So let's actually now dive in with that quick mapping from one world
926640	930000	to the other and focus on what you can actually do with Python.
930000	933840	So here I am in the familiar CS50 IDE, much like we have pre-installed for you,
933840	935480	Clang and Make and other tools.
935480	938240	We've also installed for you a program.
938240	941760	That program is called Python, which is a little confusing at first glance,
941760	944520	because Python is apparently the name of the language,
944520	946240	but it's also the name of the program.
946240	947920	And here's where Python is different.
947920	951200	Whereas C is, again, compiled, and you use something like Clang
951200	954360	to convert it to machine code, Python is both the name of the language
954360	958160	and the name of the program you use to interpret the language.
958160	961040	So pre-installed in CS50 IDE, and frankly, these days,
961040	964200	probably on your own Macs or PCs, even if you don't know it,
964200	968200	it is a program called Python that, if fed Python source code as input,
968200	970080	will do what that code says.
970080	972640	So let's go ahead and try something just like that.
972640	976280	Let me go ahead and save a file preemptively as hello.py.
976280	979760	So .py will be the convention now instead of .c.
979760	982440	And I'm going to go ahead and actually keep this pretty simple.
982440	983960	I'm just going to print the first thing.
983960	986320	It's muscle memory, so it's not printf anymore.
986320	990360	It's just hello, world, save, done.
990360	992720	That's going to be my first program in Python.
992720	993220	Why?
993220	994480	It's one line of code.
994480	998760	It's consistent with the features I've claimed Python has.
998760	1000360	So how do I run it?
1000360	1003960	Well, in C, we would have done like make hello,
1003960	1007440	but make knows nothing about this because make is typically used with C,
1007440	1009680	at least in this context here.
1009680	1014000	So maybe it's like dot slash hello.py.
1014000	1016440	No, it seems I don't have permission there.
1016440	1020880	But there's a step that I teased us with earlier on just the slide alone.
1020880	1025560	How do I go about running a program, did I say?
1025560	1027440	Yeah, I have to be a little more explicit.
1027440	1030760	So Python, which is the name of the interpreter that understands Python,
1030760	1032360	and now I need to feed it some input.
1032360	1035880	And we know from our time in C that programs can take command line arguments.
1035880	1037280	And indeed, this program itself does.
1037280	1040240	Python, you just give it the name of a program to run.
1040240	1043320	And there it is, our very first program.
1043320	1044800	So that's all fine and good.
1044800	1047400	But what if I wanted to do something a little more interesting,
1047400	1049240	like getting a string from the user?
1049240	1052800	Well, it turns out in Python, in CS50 ID especially,
1052800	1054120	I can do something like this.
1054120	1058280	s gets get underscore string.
1058280	1061840	And I can ask someone, for instance, for their name, like this.
1061840	1066840	Now, CS50 ID is already yelling at me, undefined variable get string.
1066840	1070360	And let's actually see if maybe it's just buggy.
1070360	1073680	No, so this is a little more arcane than usual.
1073680	1076600	But trace back, most recent call last.
1076800	1079520	Hello.py line 2 in module, whatever that is.
1079520	1081160	So I see a line of code from line 2.
1081160	1083520	Name, error, name, get string is not defined.
1083520	1086080	This is not the same language we've seen before.
1086080	1087760	But what does this feel reminiscent of?
1089760	1093080	Yeah, when the past, when you've forgotten CS50.h,
1093080	1096760	you've gotten something about an undeclared identifier, something like that.
1096760	1100160	It just didn't understand something related to the CS50 library.
1100160	1103800	So in C, we would have done include CS50.h.
1103800	1106360	That's no longer germane, because now we're in Python.
1106360	1108080	But it's somewhat similar in spirit.
1108080	1113160	Now I'm going to say, instead, from CS50, import get string.
1113160	1115120	And now save that.
1115120	1118560	And hopefully, momentarily, the errors will go away as the IDE realizes,
1118560	1122400	oh, you've now imported the CS50 library, specifically a method,
1122400	1125080	or function, rather, inside of it, called get string.
1125080	1126680	So there, too, it's different syntax.
1126680	1128520	But it kind of says what it means, from CS50, which
1128520	1131640	is apparently the name of the library, import a function called get string.
1131640	1134800	Now, if I go ahead and rerun Python, hello.py,
1134800	1137080	I can go ahead and type in, say, Maria's name,
1137080	1141560	and ignore her altogether, because I need to make a fix here.
1141560	1146160	What's the obvious bug, obvious now, to me, in the program?
1146160	1148480	You need to include the variable, or s?
1148480	1152640	Yeah, so I need to include s, which I got on line three,
1152640	1155000	but then thereafter, use in any way.
1155000	1158440	So this is going to be wrong, of course, because that's
1158440	1160280	going to say, literally, hello, s.
1160280	1164080	This is kind of how we used to do it, and then we would put in s.
1164080	1165280	But this is not print f.
1165280	1167600	This is print, so the world is a little different.
1167600	1170280	And it turns out we can do this in a couple of different ways.
1170280	1174120	Perhaps the easiest, if at least obvious, would
1174120	1181120	be something like this, where I could simply say, hello.
1181120	1184040	Open curly brace, close curly brace.
1184040	1187240	And then inside of there, simply specify the name of the variable
1187240	1188400	that I want to plug in.
1188400	1190160	And that's not quite all the way there.
1190160	1192400	Let me go ahead and run this once more.
1192400	1195960	Now, if I type in Maria's name, still not quite right,
1195960	1199560	I need to actually tell Python that this is a special type of string.
1199560	1203280	It's a formatted string, similar in spirit to what print f expected.
1203280	1206440	And the way you do this, even though it's a little different from c,
1206440	1207960	is you just say f.
1207960	1208800	This is an f string.
1208800	1211720	So literally before the quotes, you write the letter f.
1211720	1214120	And then if I now run this program here,
1214120	1218120	I'm going to actually see Maria's name as hello Maria.
1218120	1220040	And I'll take care of that red x later.
1220040	1220880	So that's a format string.
1220880	1221800	And there's one other way.
1221800	1226040	And this is not very obvious, I would say.
1226040	1229320	You might also see an online documentation, something like this.
1229320	1231640	And let's just tease this apart for just a second.
1231640	1235080	It turns out in Python that what I've highlighted in green here
1235080	1237560	is known as a string, otherwise known as a stir.
1237560	1240040	S-T-R is the name of this data type.
1240040	1243720	Well, unlike in C, where string was kind of a white lie,
1243720	1245960	where it was just a pointer at the end of the day,
1245960	1249760	a string is actually a first class object in Python,
1249760	1252400	which means it's not just a sequence of characters.
1252400	1256160	It has built-in functionality, built-in features.
1256160	1260200	So much like a struct in C had multiple things inside of it,
1260200	1264280	so does a string in Python have multiple things inside of it,
1264280	1267760	not just the sequence of characters, but functions
1267760	1269280	that can actually do things.
1269280	1271560	And it turns out you access those functions
1271560	1273760	by way of the same dot operator as in C.
1273760	1276400	And then you would only know from the documentation or examples
1276400	1279800	in class what functions are inside of the string object.
1279800	1282880	But one of them is format, and that's just a function that takes an argument.
1282880	1286240	What do you want to plug into the string to the left of the dot?
1286240	1292800	And so simply by specifying, hey, Python, here's a string with a placeholder.
1292800	1295360	Inside of this string is a built-in function,
1295360	1298560	otherwise known as a method, when a function is inside some object
1298560	1301040	or structure, pass in the value s.
1301040	1305600	So if I now go ahead and rerun this after saving my changes,
1305600	1309480	I should now see that Maria's name is still plugged in.
1309480	1312480	So that's it, but a simple idea that now even strings
1312480	1315200	have things inside of them, besides the characters alone,
1315200	1317280	and you can access that via the dots.
1317280	1321040	So let's go ahead now and ramp things up to a more familiar example
1321040	1321920	from a while back.
1321920	1325120	Let me go ahead and open up two side-by-side windows
1325120	1327280	and see if we can't translate one to the other.
1327280	1332720	I'm going to go ahead and open up, for instance, int dot c from some time ago.
1332720	1335080	So you might recall from int dot c, we had
1335080	1338720	this program here whose purpose in life was to get an integer from the user
1338720	1342040	and actually now plug it into printf and then print it out.
1342040	1344720	So what's going to be different now in Python?
1344720	1348920	Well, in Python, if I go ahead and implement this as, say, int dot pi,
1348920	1351120	I'm going to go ahead and do the following.
1351120	1353800	Let me scroll down to kind of line things up roughly.
1353800	1359480	I can go ahead and say def, oops, def main, as I saw in the slides before.
1359480	1364760	And then over here, I can say, I get int, quote unquote, integer.
1364760	1368940	And then down here, I'm going to say not printf, but print, quote unquote,
1368940	1372400	hello, and then the placeholder.
1372400	1376040	What's the simplest way to do this now, per our past example?
1376040	1378240	Curly brace?
1378240	1380560	I. And then I just need to be super clear.
1380560	1384440	This is a special f string or format string into which you can plug values.
1384440	1386480	And now I'm going to go ahead and save that.
1386480	1391200	And I've got most of the pieces together now, ignoring for now the red x.
1391200	1393840	So what more remains to be done?
1393840	1397480	I've made one same mistake as before.
1397480	1398720	Yeah, so the get int.
1398720	1401240	So up here, really, the equivalent of line 3
1401240	1406440	would be from CS50 import get int this time.
1406440	1407160	Saving that.
1407160	1415720	And now, if in my terminal window, I go ahead and run Python of int dot pi,
1415720	1418960	that seems strange.
1418960	1422200	It's not an error in terms of, like, erroneous output.
1422200	1423560	Just nothing happened.
1423760	1427080	So why might this be?
1427080	1430120	How might you go about troubleshooting this, even with very little Python
1430120	1432280	under your belt?
1432280	1432880	Is that a hand?
1432880	1433840	I don't know.
1433840	1434120	No?
1434120	1435280	OK.
1435280	1437440	Yeah?
1437440	1438720	Is there a line break?
1438720	1439400	That's OK.
1439400	1442240	I was just doing that to kind of make everything line up, but it's no big deal.
1442240	1446240	Everything's indented properly, which is the important aesthetic.
1446240	1448440	Yeah?
1448440	1449560	We didn't call the function.
1449560	1451720	And this is where Python's a little different from C.
1451720	1454480	In C, recall, main just gets called automatically for you.
1454480	1457600	Humans years ago decided that shall be the default name of a function.
1457600	1461360	In Python, line 6 here, calling something main is just a convention.
1461360	1464200	I could have called it foo or bar or any other word.
1464200	1465720	It has no special meaning.
1465720	1468200	And so in Python, if you want to actually call main,
1468200	1470360	you need to do something, frankly, that's, I think,
1470360	1472680	one of the stupider distractions early on.
1472680	1477280	But you have to literally say this, if the name of this file
1477280	1483600	happens to equal something that's specially called main, then call main.
1483600	1487720	So long story short, when you run the Python interpreter on a file,
1487720	1492520	as we've been doing with Python space int.py or hello.py,
1492520	1497280	there is a special global variable that your program has access to called
1497280	1500240	underscore underscore name, underscore underscore.
1500240	1503400	And if that default name happens to be underscore underscore main,
1503400	1509880	underscore underscore, then you know that you have the ability to call
1509880	1511560	any function you want by default.
1511560	1513960	So for now, much like we did in week one, where
1513960	1517240	we glossed over certain details that just weren't all that interesting,
1517240	1520440	lines 11 and 12 for now, let's consider not all that interesting,
1520440	1522920	but it's how we're going to kickstart these programs.
1522920	1527760	Because now, if I run Python space int.py, type in a great number,
1527760	1532840	hello, 42, the meaning of life, the universe, and everything.
1532880	1536200	So let's now actually do something more powerful than just getting
1536200	1537360	a single int from the user.
1537360	1540640	Let me go ahead and close off this one and close off this one
1540640	1547440	and open up, say, ints.c after splitting my window again into two windows here.
1547440	1548960	And let's open ints.c.
1548960	1553680	So this one was a little different in that we did some arithmetic.
1553680	1557200	And so here's going to be another difference in Python.
1557200	1561880	Here's what we did in C. And what was curious or worth noting about math
1561880	1563760	in C?
1563760	1566960	Which of these did not quite behave as you might expect in the real world?
1569960	1570880	Division?
1570880	1571280	Yeah, why?
1571280	1572200	What did division do?
1574640	1576560	Yeah, it chopped off or rounded down.
1576560	1579800	It floored the value by throwing away everything after the decimal point.
1579800	1582320	So this line here, 18, where it's such and such,
1582320	1584560	divided by such and such, is such and such.
1584560	1587040	And we literally just said x divided by y.
1587040	1590800	If you divided, for instance, 1 divided by 2 in grade school,
1590800	1593960	hopefully you would get the value 1 half or 0.5.
1593960	1596360	But in C, what did we get instead?
1596360	1596800	Zero.
1596800	1602080	So it gets truncated to an int, the closest int without a decimal point being zero,
1602080	1604000	because 0.5 is really 0.5.
1604000	1605760	And thus, we had that effect.
1605760	1608840	So in Python, things are going to be similar in spirit,
1608840	1613800	but this is kind of a feature that was fixed or a bug that was fixed.
1613800	1618920	In Python, let me go ahead here and open up an example I wrote in advance called
1618920	1622720	ints.py, which is actually now going to look like this.
1622720	1627360	So the Python equivalent now, which I'll roughly line up,
1627360	1628920	looks a little different.
1628920	1631760	And there's a few distractions, because we have all these f strings now
1631760	1632640	in the way.
1632640	1635120	But notice I'm just plugging in x's and y's.
1635120	1639600	But what's a new feature, apparently, in Python, arithmetically?
1639600	1640880	So floor division.
1640880	1644520	So this was the more proper term for what C has been doing all this time.
1644520	1647880	In C, when you use the slash, and you divide one number by another,
1648880	1651840	it divides and then floors it to the nearest int.
1651840	1654480	In Python, if you want that same old school feature,
1654480	1657760	you're going to now use slash slash, not to be confused with the C comment.
1657760	1661440	And if you want division to work the way you always knew it did in grade
1661440	1664120	school, you continue using just the slash.
1664120	1667040	So a minor point, but one of the differences to keep in mind.
1667040	1669760	So if we actually run this here in Python,
1669760	1674680	if I go into source 8 today, and our week's directory for week 1,
1675040	1680200	and I run python ints.py, here now we're going to see 1 and 2.
1680200	1685280	And there's all of the values that we would expect to see.
1685280	1688840	All right, so without dwelling too much on this,
1688840	1692480	let's fast forward to something more powerful, like conditions.
1692480	1695920	So in Python, if we want to do something only conditionally,
1695920	1699600	laying out my browser like this, let me go ahead and open up,
1699600	1707360	let's say conditions.py, sorry, conditions.c, which once upon a time,
1707360	1708800	looked like this.
1708800	1714600	So in this example here, notice that we have a program that gets two ints
1714600	1718280	from the user and then just compares x and y and x and y
1718280	1721840	and prints out whether they're greater than, less than, or equal to, ultimately.
1721840	1724480	So let's actually do this one from scratch over here on the right.
1724480	1727480	So let me go ahead and save this as conditions.py.
1727480	1729400	And then at the top, what's the very first thing
1729400	1732760	I'm going to apparently now need?
1732760	1734080	Yeah, so the CS50 library.
1734080	1738400	So from CS50 import, it looks like get int is the one we want this time.
1738400	1741720	Now, how do I go about getting an int?
1741720	1744680	Or what's the translation of line nine on the left
1744680	1747880	to the right-hand side of the screen?
1747880	1757000	x equals get int of the same prompt.
1757000	1758280	OK, what comes next?
1758280	1763040	If I line it up roughly here, y gets get int of, quote unquote, y.
1763040	1766120	And what's down here?
1766120	1771480	The condition, so if x less than y, no parentheses are necessary.
1771480	1773520	It's not wrong to put them, but it's unnecessary.
1773520	1776720	And now enters a word into our terminology.
1776720	1778640	It's not pythonic, so to speak.
1778640	1780120	If you don't need them, don't put them.
1780120	1782720	So if x is indeed less than y, what do we want to do?
1782720	1788080	We want to print x is less than y, yes?
1789040	1789640	All right, good.
1789640	1794680	So else if x, OK, good.
1794680	1802920	So kind of goofily, l if, then go ahead and print out x is greater than y.
1802920	1805080	And as an aside, I actually did that accidentally.
1805080	1809800	But it turns out in Python, too, you can use double quotes or single quotes.
1809800	1811200	Either is fine.
1811200	1815200	Whereas in C, single quotes had a very specific meaning, which went what?
1815200	1816960	Char, so single characters.
1816960	1820880	And double quotes meant strings, sequence of characters, which meant zero
1820880	1823280	or more characters followed by backslash zero.
1823280	1825080	In Python, all of that is gone.
1825080	1827000	Single quotes and double quotes are equivalent.
1827000	1829400	I'll almost always use double quotes just for consistency,
1829400	1832800	as should you for consistency within your own files.
1832800	1836040	But sometimes it's useful to drop into one or the other if you nest,
1836040	1839440	for instance, quote marks, as you might have once in a while in C.
1839440	1845120	OK, so finally, else print out x is equal to y.
1845120	1848840	So it's cleaner, and frankly, I don't need all this white space.
1848840	1851400	So let's go ahead and just make this a little tighter still.
1851400	1856320	You can see that in 11 lines, we've now done what took 27 or so last time.
1856320	1859160	But I have omitted something, to be fair.
1859160	1861240	What did I omit?
1861240	1863440	Yeah, I didn't do that whole calling a function thing.
1863440	1864520	There's no mention of main.
1864520	1867760	And it actually turns out that's not strictly necessary in Python.
1867760	1871200	If you're going to be interpreting a file that contains Python code,
1871200	1873400	and it's a simple enough program that you don't really
1873400	1878440	need to factor code out and organize it into separate functions, then don't.
1878440	1881280	If this is what would now be called a command line script,
1881280	1885240	a program that just has lines of code, that you can execute literally
1885240	1885920	at the prompt.
1885920	1890320	So if I go into this directory and run Python of conditions.py enter,
1890320	1893560	x will be 1, y will be 2, x is indeed less than y.
1893560	1894320	And that's it.
1894320	1900040	I don't need to bother doing all of this as I proposed earlier, def main.
1900040	1902680	And then I could go in here, and if you've never known this,
1902680	1904520	and now it's useful, especially for Python,
1904520	1906880	you can highlight lines or just tab them all at once.
1906880	1909760	I could do this, but then I would need this thing, which I probably
1909760	1914000	have to go look up how to remember it if you're doing it for the first time.
1914000	1917200	There's just no value in this case to doing that.
1917200	1920760	But at least it can be there as needed.
1920760	1925080	So let me go ahead and undo that, and we're back to a porting of one to the other.
1925080	1927120	All right, so that might then be conditions.
1927120	1930720	And let's see if we can't no switch there.
1930720	1932000	Let's take a look at this one.
1932000	1935040	Let me open up, rather than comparing all of them side by side,
1935040	1938880	let me just open up this one now called noSwitch.py, which
1938880	1943960	is reminiscent of a program we ran some time ago called noSwitch.c.
1943960	1948480	And you can perhaps infer what this does from the comments alone.
1948480	1951160	What does this program do in English?
1951160	1953840	Because logical operators is not all that explicit at top.
1956960	1957960	What's that?
1958920	1964760	Yeah, so if you've ever interacted with a program that asks you for a prompt,
1964760	1967520	yes or no, here's some code with which you might implement it.
1967520	1970520	And we could do this in C. We're just comparing characters here.
1970520	1971680	But there's a few differences.
1971680	1974640	If you kind of now think back to how you might implement this in C,
1974640	1976680	even if you don't recall the specific program.
1976680	1979440	I'm importing my library right up here.
1979440	1984120	I'm then calling getchar this time, which is also in CS50's library for Python.
1984120	1987800	And then notice there's just a couple of things different down here syntactically.
1987800	1991560	Besides the colons and the indentation and such, what else is noteworthy?
1991560	1992060	Yeah.
1992060	1994160	You can use more instead of more.
1994160	1995320	Yeah, thank god.
1995320	1997240	You can just say more what you mean now.
1997240	2000640	If you want to do something or something, you literally say or.
2000640	2003840	And if we were instead, albeit nonsensically here,
2003840	2008200	trying to do the conjunction of two things, this and that, you could literally say and.
2008200	2010760	So instead of the two vertical bars or the two ampersands,
2010760	2013360	here's another slight difference in Python.
2013360	2017160	Let's now take a look at another example, reminiscent of one's past.
2017200	2019920	This one called return.py.
2019920	2024640	So here is an example where it's actually more compelling to have a main function,
2024640	2027880	because now I'm going to start organizing my code into different functions still.
2027880	2032840	So up here, we are importing the getint function from CS50 library.
2032840	2038360	Here I have my main function just saying x gets getint and then print out the square of x.
2038360	2042280	So how do you go about defining your own custom function in Python that's not just main?
2042280	2047080	Well, here on line 11 is how I would define a function called square
2047080	2050840	that takes apparently an argument called n, though I could call this anything I want,
2050840	2055000	colon return n star star 2.
2055000	2057840	So a few new features here, but again, it's no big deal.
2057840	2061480	Once you just kind of look these features up in a manual or in a class,
2061480	2063440	what is star star probably doing?
2063440	2067440	Not square root, the power of, yeah.
2067440	2070360	So n star star 2 is just n raised to the power of 2.
2070360	2074440	That was not a feature we had in C. So now we get this in Python.
2074440	2077000	And what's this line 12 in green?
2077040	2080520	With the weird use of double quotes.
2080520	2083440	It's a comment, and it's a different type of comment than we've seen before.
2083440	2086440	Because in my previous example, I did have a few comments.
2086440	2089680	Recall that just a moment ago in conditions.py,
2089680	2092200	we had a whole bunch of comments.
2092200	2095440	Prompt the user for x, prompt the user for y, compare x and y.
2095440	2097720	So whereas in C, we were using slash slash,
2097720	2101080	Python unfortunately uses that for floor division, so to speak.
2101080	2106240	So we instead just use the hashtag or the pound sign to enumerate a line,
2106240	2109320	to specify a line that should be thought of as a comment.
2109320	2111040	But here is something a little different.
2111040	2112760	And we won't dwell too much on this for now,
2112760	2115560	but Python has different types of comments, one of which is this.
2115560	2118800	This is technically called a doc string or document string.
2118800	2123160	And what's nice about Python, as well as languages like Java and other still,
2123160	2128360	is that you can put comments in your code that special programs can read
2128360	2130880	and then generate documentation for you.
2130880	2134000	So if you ever took APCS and you ever saw Java doc,
2134040	2137400	this was a way of commenting your methods and your code in Java using
2137400	2140680	funky at signs and other syntax so that if you ran a special command,
2140680	2143440	it could generate a user's manual for all of your functions
2143440	2147480	until you or colleagues or friends or teachers exactly what all your functions
2147480	2150480	are, what their arguments are, what their return values are, and all of that.
2150480	2155880	Similarly, in Python, can you use these funky quote, quote, quote doc strings
2155880	2157400	to document your function?
2157400	2160840	So whereas in C, our style has been to put quotes above the functions.
2160840	2164360	In Python, it's going to be to put them as the first line inside
2164360	2167560	and indented within the function.
2167560	2172440	All right, so now let's actually try to port a program from code again,
2172440	2179560	thinking back on week one in C when we had this program here.
2179560	2185280	So there's quite a bit going, oh, spoiler, don't look at that.
2185280	2187240	Hopefully, that didn't sink in just yet.
2187240	2192240	So in week one, we had this program in C, get positive int.
2192240	2195520	And its purpose in life was to write a program that gets a positive integer
2195520	2197840	from the user, in and of itself not all that interesting,
2197840	2200240	but it was an opportunity to introduce a few things.
2200240	2204880	One, we introduced this line six several weeks ago, which is known as a prototype.
2204880	2208840	And what was the purpose of having that function prototype up there?
2208840	2210920	Yeah, you declare the function, but why?
2210920	2214680	Because it's already implemented down here on line 15.
2215680	2222400	Yeah, because of the way the programs run, and frankly, because of how naive or dumb
2222400	2228320	that Clang is by design, it does not know that a function exists until it actually sees it.
2228320	2232760	So the problem is that if in C you have main, inside of which is a call to function
2232760	2236440	like get positive int, but it's not implemented until a few lines later,
2236440	2239040	Clang is going to be dumb and just not know that it even exists,
2239040	2240640	and it's not going to compile your code.
2240640	2244320	So this prototype, as we call it, is kind of a teaser, a hint
2244360	2245880	that doesn't implement the whole function.
2245880	2251120	It just shows the compiler its return type and its types and order of parameters
2251120	2253840	so that that's enough information to then just trust
2253840	2256800	that if I just blindly compile main, eventually,
2256800	2259400	I'm going to see the actual implementation of the function
2259400	2261600	so I can compile its bits as well.
2261600	2265800	So in here, in C, we call get positive int, and then we pass it in a prompt.
2265800	2268880	We stored it in a variable called i, and then printed it out.
2268880	2271640	And then to implement this, we use kind of a familiar construct
2271640	2273080	that you've used in other programs.
2273080	2276320	Pretty much any time you want to prompt the user for inputs
2276320	2279440	and you want to keep pestering him or her until they cooperate with whatever
2279440	2283200	your conditions are, you would use the so-called do-while loop.
2283200	2286680	And because the do-while loop recall is distinct from the while loop, how?
2289120	2291480	It runs at least once, which just kind of makes intuitive sense
2291480	2293520	if you want to prompt the user for something,
2293520	2297320	and then if he or she doesn't cooperate, only then do you want to prompt them again.
2297320	2300400	By contrast, with a while loop, it's going to happen again and again
2301280	2302880	no matter what from the get go.
2302880	2306560	So let's see if we can't now convert this or port this,
2306560	2308440	as people would say, to Python.
2308440	2313440	So here, I'm going to go ahead and save a new file called positive.py.
2313440	2319440	And I'm going to go ahead and do everything here in main as before.
2319440	2324400	So I'm going to go ahead and do, let's say, from cs50 import get int,
2324400	2325840	because I do need that.
2325840	2328400	And then I'm going to go ahead and have my main method here.
2328400	2331880	And then inside of main, just like on the left-hand side,
2331880	2338280	I'm going to do i get get positive int, positive integer, please.
2338280	2339640	It's going to wrap a little bit now.
2339640	2340520	That's fine.
2340520	2343480	And then I'm going to go ahead and print this, which recall is just print,
2343480	2347400	an f string where the placeholder is i.
2347400	2350960	Although, frankly, this is kind of stupid to just create a string that
2350960	2353080	has nothing other than the value we want to print.
2353080	2355400	Nicely enough in Python, just print what you want.
2355400	2357240	And so that simplifies that argument.
2357280	2362800	So now it remains to implement get positive int, which
2362800	2365160	is going to take some kind of prompt as its input.
2365160	2369840	And notice I'm not specifying the data type of prompt, which is string.
2369840	2372240	I'm not specifying the return type of this function,
2372240	2374920	but both actually do exist underneath the hood.
2374920	2379800	So in the past, to get a variable, I would do something like this semicolon.
2379800	2381920	But I know I don't need the semicolon.
2381920	2383560	I know I don't need the data type.
2383560	2386800	And this just looks stupid to just put a variable there
2386800	2387480	to need it.
2387480	2389040	You don't need to do this in Python.
2389040	2392000	If you want to use a variable, just start using it.
2392000	2395480	And unfortunately, whereas almost every other feature we've seen in Python
2395480	2401200	thus far kind of maps directly back to a feature in C,
2401200	2404480	Python does not have a do while.
2404480	2407200	So it has the for in.
2407200	2410760	And it has while, and maybe it has other things we haven't told you about,
2410760	2412600	but it doesn't have do while.
2412600	2416000	So knowing that and knowing only what we've presented thus far,
2416000	2420200	how do we still go about getting an int from the user
2420200	2423960	and ensuring it's positive and re-prompting him or her if and only
2423960	2424640	if it's not?
2427560	2428200	Put another way.
2428200	2432560	How would you do this in C if we took away from you the do while construct?
2436720	2437880	Exclamation points?
2437880	2442200	OK, so we could invert something maybe using that logically.
2442200	2443400	We could just do a while loop.
2443400	2445280	We could just use a while loop, how?
2446000	2450960	So while prompt is less than 1.
2450960	2455280	So while prompt is OK, so the prompt is the string we're going to input.
2455280	2457040	We're going to pass display to the user.
2457040	2459520	So it's not prompt, I think.
2459520	2464200	So maybe i or n to be consistent with the other side.
2464200	2466440	So you know what, why don't I, what about this?
2466440	2468720	What if I just do, you know what, I know I need a loop.
2468720	2471640	This is by far the easiest way to just get a loop, right?
2471640	2473360	It's infinite, which is not good.
2473360	2475480	But I can't break out of loops, recall.
2475480	2477720	So what if I do something like this?
2477720	2482840	What if I do n get int passing in the same prompt?
2482840	2485200	And then what do I want to do next?
2485200	2487720	I'm inside of an infinite loop, so this is going to keep happening,
2487720	2495360	keep happening, keep happening until is positive.
2495360	2497160	So Python's not quite that user friendly.
2497160	2499080	We can't just say that.
2499080	2502280	But we can say what?
2502280	2505720	Greater than, close.
2505720	2506680	Well, OK, that's fine.
2506680	2508560	Greater than or equal to 1.
2508560	2510120	Then what do we want to do?
2510120	2510880	Great.
2510880	2514240	So it's not quite as cool as like a do while loop, which kind of gives us
2514240	2516800	all these features, though frankly, this was never that pretty, right?
2516800	2519080	Especially the fact that you had to deal with the issue of scope
2519080	2520560	by putting the variable outside.
2520560	2523600	So in Python, the right way to do this would be something like this.
2523600	2526200	Just induce an infinite loop, but make sure you break out of it
2526200	2529200	logically when it's appropriate to do so.
2529200	2533640	And so now, if I go ahead and add in that last thing that I keep needing,
2533640	2540040	so if name equals main, and it's always fine to copy, paste something like that,
2540040	2543800	a call main, let me go ahead now, and in my terminal window,
2543800	2547160	run Python of positive dot pi.
2547160	2549520	And let me go ahead and give it negative 5.
2549520	2551240	How about negative 1?
2551240	2552680	How about 0?
2552680	2553560	Whoops, how about that?
2553560	2555040	How about 0, 1?
2556040	2558560	Hm.
2558560	2560520	I screwed up.
2560520	2561560	None is interesting.
2561560	2563440	It's kind of our new null, so to speak.
2563440	2566720	But whereas in C, null can potentially, if used in the wrong way,
2566720	2570520	crash your program, Python might just print it, apparently.
2570520	2573280	Where did I screw up?
2573280	2575480	Yeah, so I didn't return an actual value.
2575480	2577520	And whereas Clang might have noticed something like this,
2577520	2580640	Python the interpreter is not going to be as sort of vigilant when
2580640	2582960	it comes to figuring out if your code is missing something.
2582960	2585640	Because after all, we never said we were going to return anything,
2585640	2587360	and so we don't strictly need to.
2587360	2592200	So what could I instead do here instead of break?
2592200	2597080	I could just return n here, or I could equivalently do this,
2597080	2599560	and then just make sure I return n here.
2599560	2602920	And another difference in Python, too, is that the issue of scope
2602920	2606760	isn't quite as difficult as it was in C.
2606760	2612000	As soon as I've declared n to exist up here, it now exists down below.
2612040	2615040	So even though it was declared inside of this indentation,
2615040	2618240	it is not scoped to that while loop alone.
2618240	2621880	So either way, could we actually make this work?
2621880	2624600	OK, so now let's try to run this again.
2624600	2627720	Positive integer, negative 1, 0, 1.
2627720	2629440	And now we're actually seeing the number 1.
2629440	2631160	All right, let me pause here for just a moment
2631160	2633880	and see if there's any questions.
2633880	2634560	No?
2634560	2635060	Yes?
2635060	2639200	Do you have to call the thing you can see at the library individually,
2639200	2641200	or can you just import the entire one?
2641400	2644080	You have to call things inside of the CS50 library individually,
2644080	2646080	or can you import the whole thing?
2646080	2648640	You can technically import the whole thing as follows.
2648640	2651200	If you want access to everything in the CS50 library,
2651200	2652520	you can literally say star.
2652520	2655880	And in star in programming, well, in many computer contexts,
2655880	2657840	star generally is a wild card character,
2657840	2661640	and it means anything that matches this string here.
2661640	2663520	This is generally considered bad practice, though,
2663520	2668120	because if CS50's staff happens to give you functionality or variables
2668120	2670640	that you don't want, you have now just imported
2670640	2674600	into your namespace, so to speak, all of those functions.
2674600	2678760	So for instance, if the CS50 library had public inside of it
2678760	2682880	a variable called x and y and z, in addition to functions
2682880	2686320	like getString and getInt and getChar, your program
2686320	2688840	is now seeing variables x and y and z.
2688840	2691200	And if you have your own variables called x and y and z,
2691200	2693800	you're going to shadow those variables inside ours,
2693800	2695480	and it just gets messy quickly.
2695480	2698560	So generally, you want to be a little more nitpicky
2698560	2702920	and just import what you want, or another convention in Python
2702920	2708840	is to not specify it like this, but instead to do import CS50.
2708840	2712840	This does not have the same effect of importing all of those keywords,
2712840	2716640	like getInt and getString into your program's namespace,
2716640	2719840	like the list of symbols you can actually type in.
2719840	2721920	But what you then have to do is this.
2721920	2726160	You have to now prefix any usages of the functions
2726160	2730600	in that library with the now familiar or more familiar dot operator.
2730600	2733000	So this is just a stylistic decision now.
2733000	2735320	I have consciously chosen the other approach
2735320	2737760	so that initially you can just call getInt, getString,
2737760	2741320	just like we did in C. But technically and probably more conventionally
2741320	2744200	would people do this to make super clear this isn't my getInt method,
2744200	2748280	it's CS50's getInt function.
2748280	2750640	OK, other questions?
2750640	2751240	Yeah?
2751240	2756760	Is it good coding practice to do the if underscore name or just because you
2756760	2759240	can run Hello World without the defining main?
2759240	2760480	Do you really need to do like that?
2760480	2761760	Oh, it's a good question.
2761760	2763120	Short answer, no.
2763120	2765720	So I'm showing you this way because you'll
2765720	2768680	see this in various examples online and in programs
2768680	2771360	that you might look at that are open source.
2771360	2773280	Strictly speaking, this is not necessary.
2773280	2777760	If you end up making your own library, this tends to be a useful feature.
2777760	2783600	But otherwise, I could equivalently do this, which is perfectly fine as well.
2783600	2785760	I can still define getPositiveInt.
2785760	2788120	I can get rid of main altogether.
2788120	2790280	And I can just now do this.
2790280	2794480	So this program is equivalent and just as fine for now.
2794480	2797680	OK, so with that said, let's do a couple of more examples here.
2797680	2799600	That kind of paints a picture of some of the things
2799600	2801360	that are similar and different.
2801360	2804200	And let's go ahead and open up, for instance,
2804240	2809560	overflow.c from some weeks ago, splitting our windows again.
2809560	2813200	And then on the right-hand side, let me open up something called overflow.pi,
2813200	2815440	which I put together in advance.
2815440	2821600	So here, we have on the left an example of integer overflow, whereby
2821600	2825480	if I start counting at 1 and then don't even have a condition,
2825480	2829240	and I just keep multiplying i by 2, by 2, by 2, doubling it, doubling it,
2829240	2832240	doubling it, doubling it, we know from c that bad things happen.
2832280	2836120	And if you just kind of keep incrementing something without any boundary in sight.
2836120	2838680	So this program is just going to print out each of those values.
2838680	2840800	And it's going to sleep one second in between.
2840800	2843000	Same program in Python looks pretty similar.
2843000	2847320	But notice I'm initializing i to 1, doing the following forever,
2847320	2852280	printing out i, multiplying i by 2, and then sleeping for one second.
2852280	2855600	But sleep is also not built into Python in the way that print is.
2855600	2857280	Notice what I had to include up here.
2857280	2858480	And I wasn't sure what that was.
2858480	2862160	And so honestly, just a few days ago, I Googled to sleep one second
2862160	2866080	in Python, saw that there's this time library inside of which is a sleep
2866080	2866680	function.
2866680	2870000	And that's how I knew which library to actually include.
2870000	2872160	And so just as there are man pages for c,
2872160	2875600	there's a whole documentation website for Python
2875600	2877560	that has all of this information as well.
2877560	2878800	So let me go ahead and do this.
2878800	2883560	And let me actually try to create two windows here.
2883560	2887320	What's the best way for me to do this?
2887320	2889440	Split 1 to 2.
2889440	2893640	OK, so let's do this just so I can run this in the same place.
2893640	2902640	So if I go into my source 8 directory, and I go into weeks and 1,
2902640	2911320	and I make overflow, nope, sorry, week 1.
2911320	2917040	OK, so if I go into source 1, and I do make overflow, which is kind of cute
2917040	2920880	semantically, I'm now going to be able to run a program called overflow.
2920880	2928640	Meanwhile, over here, let me go ahead and split this window 2.
2928640	2930360	Damn it, not there.
2930360	2934640	Let's put this over here.
2934640	2935320	Oh, no.
2940640	2942520	OK, one second, sorry.
2942520	2944000	Overflow.py.
2944000	2945680	OK, so now we're back.
2945680	2946560	No, I lost the other window.
2949760	2950480	Oh, that's cool.
2950480	2954080	OK, so let's do this.
2954080	2957640	OK, now I know how to use the ID.
2957640	2960840	All right, so on the left-hand side, I'm about to run overflow.
2960840	2963640	And then lastly, without generating that beep again,
2963640	2969800	I'm going to go in here, and I'm about to run Python of overflow.py.
2969800	2971680	And so the left will run the C version.
2971680	2973680	The right will run the Python version.
2973680	2982200	And we'll start to see, no pun intended, what happens with these programs.
2982200	2983120	Oh, damn it, I got to scroll.
2987680	2989440	OK, so I'll just keep scrolling for us.
2992240	2992880	This is fun.
2999400	3003120	OK, next time, Google how to sleep for half a second instead.
3003120	3005040	OK, so there we go.
3005040	3007080	Something bad has happened here.
3007080	3009320	And now C is just completely choking.
3009320	3011440	Things are in a funky state.
3011440	3015280	So what happened on the left before the answer scrolls away?
3015280	3016280	Integer overflow, right?
3016280	3019600	We had so many bits becoming ones that eventually it
3019600	3021760	was mistaken for a negative number temporarily,
3021760	3025280	and then the whole thing just kind of got confused and became permanently
3025280	3029480	zeroes, whereas on the right-hand side, like, yeah, Python, look at you go.
3029480	3032760	Like, still counting higher and higher and higher.
3032760	3035400	And even though we haven't talked about the underlying representation
3035400	3039200	of these types in Python, like, what can we infer from the apparent
3039200	3043600	better correctness of the version on the right in Python?
3043600	3045200	It's not an 8-bit representation.
3045200	3047680	And even C, to be fair, uses 32 bits for its ints.
3047680	3050960	And that's why we got as high as 2 billion or 4 billion in total.
3050960	3054320	But same idea, how many bits must Python be using?
3054320	3055320	64?
3055320	3056600	Yeah, maybe 64.
3056600	3059240	I don't know exactly, but I know it's not 32,
3059240	3061240	because it keeps counting up and up and up.
3061240	3063080	And so this is another feature of Python,
3063080	3066240	whereas int in C has typically been for us 32 bits,
3066240	3068760	although that is technically machine-specific.
3068760	3071600	Python integers are now going to be 64, which just
3071600	3074000	means we can do much bigger math, which is great for various data
3074000	3075680	science applications and stats and whatnot,
3075680	3079040	where you actually might have some large data sets to deal with.
3079040	3081920	Unfortunately, we still have some issues of imprecision.
3081920	3084480	Let me go ahead and close a whole bunch of these windows
3084480	3090320	and go ahead and open up, for instance, just this one here.
3091040	3094600	No, I'm going to skip this and do something slightly more fun, which
3094600	3095280	is this.
3095280	3098840	So in Python here, let's do a quick warm-up.
3098840	3101400	This is going to print for me what?
3101400	3102480	Four question marks, right?
3102480	3103440	And this is reminiscent.
3103440	3106560	This is a really cheap version of Super Mario Brothers.
3106560	3109600	And if you think back to week one, where we explored this,
3109600	3111920	there was a screenshot I had of Super Mario Brothers, one
3111920	3115440	of the worlds, where we just had four question marks, which Mario could
3115440	3117560	hit his head against to actually generate a coin.
3117600	3120520	So we stepped up from there in C to do this instead.
3120520	3122320	And this is going to give us another feature.
3122320	3125960	But let's see if we can't start to infer from context what these programs do.
3125960	3127320	Here's another one, Mario 1.
3127320	3127920	What's this do?
3132080	3133520	It's using a loop, for sure.
3133520	3135960	And it's using how many iterations, apparently?
3135960	3138920	Four, so from 0 to 1 to 2 to 3, total.
3138920	3142000	Each time, it's going to print out, apparently, a question mark.
3142000	3143800	But now, just infer from this.
3143800	3145520	I haven't answered this question already.
3145560	3147560	What else is going on on line four and why?
3150680	3152200	Not going to a new line, right?
3152200	3155400	So there's always this trade-off in programming and CS more generally,
3155400	3158840	like, yay, we took away the backslash n, which was annoying to type.
3158840	3162120	But now, if it's always there, how do you turn it off?
3162120	3164200	So this is one way to do that.
3164200	3168360	And it also reveals another fundamental feature of Python.
3168360	3172320	Notice that print apparently takes, in this case, more than one argument.
3172320	3175920	The first is a string, literally, quote, unquote, and a question mark.
3175920	3178520	The second is a little funkier.
3178520	3183920	It's like a word, and it's then an equal sign, and then it's a quote mark.
3183920	3185320	So what is this here?
3185320	3189560	So it turns out, Python supports what are called named parameters.
3189560	3192520	So in C, any parameters you pass through a function
3192520	3196080	are defined, ultimately, by way of their order.
3196080	3200200	Because even if a function takes arguments that have names, like x and y
3200200	3203680	or a and b or whatever, when you call the function,
3203680	3205840	you do not mention those names.
3205840	3208080	You know they exist, and that's how you think about them
3208080	3210800	in the documentation or in the original code.
3210800	3215160	But you don't name the arguments as you pass them in and call a function.
3215160	3218480	You instead pass them in in the appropriate order per the man page
3218480	3220480	or per the documentation.
3220480	3223600	So in Python, you can actually be a little more flexible.
3223600	3227640	If a function takes multiple arguments, all of which have names,
3227640	3231800	you can actually mention the names explicitly, thereby freeing you
3231800	3235200	from the minor inconvenience of having to remember and always get right
3235200	3237600	the actual order of arguments.
3237600	3241640	So in this case, print apparently takes at least two arguments in this case,
3241640	3243120	one of which is called end.
3243120	3246800	And if you want to use that one, which is clearly optional because I haven't
3246800	3250640	used it yet, you can literally mention it by name, set an equal sign,
3250640	3253040	and then specify the value that you want to pass in.
3253040	3257040	So if I actually now go into this and go into weeks and one
3257040	3265760	and do Python of mario1.py, whoops, I'll still get in week two.
3265760	3270520	If I get mario1.py, I still get four question marks.
3270520	3274920	But that's the result of printing this with a line ending of quote unquote.
3274920	3278080	If I do this, meanwhile, it's a little stupid because I'm
3278080	3280720	going to get that for free if I just omit it all together.
3280720	3282520	But now I get four question marks here.
3282520	3286200	And if you really want to be funky, you can do something
3286240	3292560	like this, which is just going to be taken literally to give you that instead.
3292560	3299320	Unclear utility of taking this approach, but that's all, sorry, that's going on.
3299320	3300880	Let's take a look at mario2.
3300880	3302640	This one works a little differently as well.
3302640	3305680	And how would you describe the feature offered by this version of mario?
3309360	3311280	Print any number of question marks perfectly.
3311280	3313800	So it's parameterized by first getting an int from the user,
3313800	3315680	using CS50's getInt function.
3315680	3319760	And now I'm iterating from i to the range of n, whatever that is,
3319760	3322680	and then actually printing out the question marks.
3322680	3326840	Meanwhile, in mario3.py, a little fancier still,
3326840	3328600	but what am I doing a little better now?
3336480	3338280	Yeah, I'm just making sure that the n is positive.
3338280	3341640	So I didn't bother implementing a whole function called getPositiveAnt.
3341640	3342200	I don't need that.
3342200	3343640	This is a super short program.
3343640	3345520	I'm just using the same logic up here.
3345520	3348080	Inducing deliberately an infinite loop, breaking out of it
3348080	3350240	only when I've gotten back a positive integer,
3350240	3354760	and then printing out that many of hashtags reminiscent of the bricks
3354760	3355600	in mario.
3355600	3359720	And then lastly, we have this slightly more sophisticated version that
3359720	3363160	actually prints out a different shape altogether.
3363160	3366000	You can infer from the comments, but focus more on why.
3366000	3377240	So this first line 12 iterates from i to n, whatever n is, that the user typed in.
3377240	3384160	Meanwhile, line 15, indented, iterates from j from 0 up to n as well.
3384160	3387840	So this is kind of like our canonical forint i gets 0, dot, dot, dot,
3387840	3391640	forint j gets 0, dot, dot, dot, where we've had nested loops in the past.
3391640	3394880	So notice, now that we have this building block, which is a line of code,
3394880	3396760	or kind of conceptually just a scratch piece,
3396760	3398640	we can embed one inside of the other.
3398640	3401600	Here, I can print out a hashtag, making sure not to put a new line
3401600	3406320	after every single hashtag I print out, only printing out a new line,
3406320	3410000	on line 17, on each iteration of the outer loop.
3410000	3414600	And now notice, whereas in C, we would have done this historically,
3414600	3415640	and that's fine.
3415640	3419680	In Python, we don't need the f, and we also don't need the backslash n.
3419680	3421680	So ergo, you can simply do print, and you'll
3421680	3425080	get, if nothing else, a backslash n automatically,
3425080	3427560	so that now, when I run this version of Mario,
3427560	3429280	we now get something more interesting.
3429280	3431640	And I'll increase the size of my terminal window for this,
3431640	3434440	so that I can enter a positive number like this, and print 10.
3434440	3435920	And now we've got a whole block.
3435920	3436800	So that was a lot.
3436800	3439320	Let's go ahead and take our five minute break here, and we'll come back.
3439320	3442040	We'll look at some more sophisticated examples still.
3442040	3442920	All right.
3442920	3448040	So let's begin to start to transition to actually solving problems with Python
3448040	3450360	after introducing just a couple of additional features that aren't
3450360	3454120	so much syntactic, but actual features of the language.
3454120	3458560	So here on the left was an old program we wrote in week three called argv0.c.
3458560	3461680	And its purpose in life was simply to allow you to run a command line
3461680	3463200	argument for the very first time.
3463200	3465240	And that was a nice tool to have in our toolkit.
3465240	3467000	So how might we go ahead and map this?
3467000	3470720	Well, we actually need to know how Python works a little bit differently
3470720	3471520	as follows.
3471520	3483920	If I go ahead and open a new file called, let's call it argv0.py,
3483920	3486880	I'm going to go ahead and translate this just as we did earlier.
3486880	3492360	So I'm going to go ahead and want to use the following.
3492360	3496400	So if argc, so there is no argc.
3497160	3501480	So def main, there was also no argc or argv.
3501480	3506320	And it's not actually correct to do this and this, as you might assume.
3506320	3509840	It turns out that the feature command line arguments are provided by a Python
3509840	3514040	package, so to speak, or a library, much like the CS50 library is a package
3514040	3516080	that you can import in Python speak.
3516080	3518440	So to do this, I actually need to do this.
3518440	3522240	Import sys, which gives me access to a whole bunch of system related stuff
3522240	3524560	like what the user has typed at the command prompt.
3524600	3528960	And if I want to check if the number of words that the human typed at the prompt
3528960	3531480	is 2, I actually am going to do this.
3531480	3537600	If the length of sys.argv equals 2, then I'm
3537600	3543880	going to go ahead and print out, quote unquote, hello, comma,
3543880	3545920	and then a placeholder here.
3545920	3548920	I know for placeholders I need to turn this into a formatted string,
3548920	3550560	so an f string there.
3550560	3553680	And now inside of the curly braces, it turns out
3553680	3558240	I can do sys.argv bracket 1.
3558240	3561600	So it's a little different from before, but notice I'm barring almost
3561600	3565440	all the same ideas as earlier, including how we're printing out strings.
3565440	3567320	And even though this is a little more verbose, what
3567320	3569160	is between these two curly braces?
3569160	3573160	Well, it's the result of looking in the system package, which has a variable
3573160	3574920	called argv for argument vector.
3574920	3579400	Just like in C, it is itself an array, aka a list in Python.
3579400	3584160	And here we have the result of indexing into element 1 of that list.
3584160	3589040	And the way that I have access to this is because I've imported that whole package.
3589040	3593160	So if on the right hand side here, I go ahead after saving that file,
3593160	3597880	and I do Python of argv0.py, I see nothing.
3597880	3601680	But if I actually say, like, my name here, I see hello.david.
3601680	3605760	So very similar program, but implemented a little differently.
3605760	3610360	And you'll notice, too, that the length of an array, henceforth known
3610360	3614700	as a list, is not something that you yourself have to remember or keep
3614700	3615200	around.
3615200	3620000	You can just ask a list how long it is by calling the lang, or len,
3620000	3623600	for length function, passing it in as an argument.
3623600	3625600	So that's one of the takeaways there.
3625600	3628000	And if we actually want to do something a little more clever,
3628000	3632720	like print out all of the strings in argv, well, back in the day in C,
3632720	3637360	you might recall this example, argv1.c, wherein I had this for loop,
3637360	3640940	and I iterated from 0 on up to argc, the argument count,
3640940	3644400	printing out each of the arguments in that vector.
3644400	3648120	Python actually makes even something like this even simpler.
3648120	3650400	Let me go ahead and create a new file here,
3650400	3653560	and I'll call this, say, argv1.py.
3653560	3658480	And it turns out in Python, I can similarly just import sys, and then
3658480	3666800	do, honestly, for s in sys.argv, print s, done.
3666800	3668840	So again, kind of just says what it means.
3668840	3671920	So I've imported the system library, sys.argv,
3671920	3674520	I know to be a list, apparently, of command line arguments,
3674520	3678200	for something in something is a new syntax we have for for loop.
3678200	3683520	So for some variable s inside of this list, go ahead and print it.
3683520	3686800	And so it's a much cleaner, much more succinct way of, honestly,
3686800	3689680	getting rid of all of the complexity of this
3689680	3692200	by just saying, instead, what we mean.
3692200	3694240	Meanwhile, if I wanted to print out every character,
3694240	3695960	I can take this one step further.
3695960	3698520	So back in the day, in C, if I wanted to print out
3698520	3702160	every command line argument and every character therein,
3702160	3703040	I could do this.
3703040	3706520	I just need a couple of nested loops wherein, via the outer loop,
3706520	3709960	I iterate over all of the arguments passed in.
3709960	3713400	And on the inner loop, I iterate over the current string length
3713400	3715320	of whatever argument I'm printing.
3715360	3718760	And this had the effect of printing out all of the command line arguments
3718760	3721040	letters one at a time.
3721040	3723480	I can do this in Python, honestly, so much easier.
3723480	3725000	So let me go over here.
3725000	3730160	Let me create a new file called argv2.py.
3730160	3731840	Let me import sys as I did.
3731840	3741440	So import sys and then for snsys.argv, for cns, print c, done.
3741440	3742720	So what is this doing?
3742720	3747760	Gone is all of the overhead of four int i and four int j and so forth.
3747760	3753480	For snsys.argv, iterates over all of the elements of that list, one string at a time.
3753480	3758480	For cns is a little different, because s is technically a string or a stir object,
3758480	3759720	as we're going to start calling it.
3759720	3762520	But at the end of the day, a string is just a sequence of characters,
3762520	3766120	and turns out Python supports out of the box the ability to use a for loop,
3766120	3768600	even to iterate over all of the characters in a string.
3768600	3770000	And so c, I just mean char.
3770000	3773360	So for cns, that gives me each of the characters.
3773360	3781240	So now with the end here, if I go ahead and run Python of argv2.py with nothing,
3781240	3784520	I get just the program's name, because that's, of course,
3784520	3786920	the very first thing in argv as in C.
3786920	3789920	And if I write, say, a word like Maria here,
3789920	3795720	I get argv2.py Maria all in one long column,
3795720	3798920	because of the additional prints that are happening in the implicit new lines.
3798920	3799640	So any questions?
3799680	3805960	Before we proceed on this use of a package called sys, using these libraries,
3805960	3808080	rather using these functions therein.
3808080	3813560	All right, so let me skip ahead then to something slightly familiar too.
3813560	3819520	Let me go ahead, and you might recall, initials.c from some time ago,
3819520	3824680	wherein we accepted as a command line argument a user rather as an input
3824680	3827400	to get string, a user's name, and then we printed out their initial.
3827400	3828520	So let's go ahead and do that.
3828520	3832000	So from cs50, let me go ahead and import, get string.
3832000	3834800	Then let me go ahead and say, get me a string,
3834800	3839880	and I want the user to be prompted for their name, as we might do here.
3839880	3842920	Then let me go ahead and say, all right, there are initials.
3842920	3846280	I don't know what they are yet, so let me just initialize an empty string,
3846280	3847320	but then do this.
3847320	3853080	For c in s, which is for each character in the person's name, if,
3853080	3857880	and I don't know how to say this yet, if c is an uppercase
3857880	3864920	letter, then go ahead and append c to initials,
3864920	3866720	and then down here, print initials.
3866720	3868040	So I've left a couple of blanks.
3868040	3869880	That's just pseudocode for the moment.
3869880	3873480	But this line five, just to be clear, is doing what for me?
3873480	3875560	What is being iterated over?
3875560	3876000	The string.
3876000	3879880	So for each character in the string, for c in s,
3879880	3881200	I'm going to ask two questions.
3881200	3884320	So in c, we did this in a couple of different ways.
3884320	3886280	We can actually do it with kind of arithmetic,
3886280	3889280	assuming rather with inequality checks and actually considering
3889280	3890960	what the underlying ASCII values are.
3890960	3895000	The c type library had that is upper function and is lower that we use.
3895000	3900720	Well, it turns out, because c is itself not a char,
3900720	3904080	there is no such thing technically as a char in Python.
3904080	3906400	You have only strings of length one.
3906400	3909480	And this is why single quotes no longer have any special meaning.
3909480	3913480	It turns out c is technically just a one character string.
3913480	3916160	Strings are what we've started calling objects,
3916200	3918240	which is a fancier name for struct.
3918240	3921880	So inside of an object, like a string, is functionality.
3921880	3926080	And we saw one piece of functionality earlier, which was what?
3926080	3933040	Not length, but though that is another one, it was format.
3933040	3934120	We saw it briefly.
3934120	3936920	But when I did the string.format, I proposed
3936920	3939200	that there's actually built-in functionality to a string called
3939200	3939960	format.
3939960	3940680	Well, you know what?
3940680	3945600	It turns out there is a method or a function inside of the string class,
3945640	3947400	also called isUpper.
3947400	3951800	And I can ask the very string I'm looking at that question by saying,
3951800	3957640	if c.isUpper is true, then go ahead and append c to initials.
3957640	3963720	So in c, if initials were technically a string,
3963720	3967400	how could you go about appending another character to a string in c?
3970400	3972160	C dot appends?
3972160	3974200	Not in c.
3974200	3977360	Oh, so in c, the language.
3977360	3978680	OK, so what's a string in c?
3978680	3981640	A string in c is a sequence of characters, the last one of which
3981640	3984000	is backslash 0.
3984000	3986640	All right, so it's an array of characters, last of which is backslash 0.
3986640	3989720	So if I, for instance, typed in my first name, David,
3989720	3992440	and now I want to append mail-in to the end of it,
3992440	3993480	how do I do that in c?
3996120	3997800	Exactly, it's like an utter pain in the neck.
3997800	4001240	You have to create a new array that's bigger, that can fit both words,
4001280	4004820	copy the David into the new array, then copy the last name in,
4004820	4006640	then put the null terminator at the new array,
4006640	4008600	then free, probably, the original memory.
4008600	4010840	I mean, it's a ridiculous number of hoops to jump through.
4010840	4013600	And you've done this on occasion, especially for things like, perhaps,
4013600	4014800	problem set five.
4014800	4016560	But my god, we're kind of past that.
4016560	4020880	Just go ahead and append to the array the character you care about.
4020880	4023560	So in this case, not an array, but a list.
4023560	4028000	Sorry, not an array, but a string object that's initially blank.
4028000	4031160	It turns out that Python supports this syntax plus equals
4031160	4034440	typically means arithmetic and add one number to another,
4034440	4036080	but it also means append.
4036080	4040960	So you can simply append two initials by doing plus equals c,
4040960	4042080	one additional character.
4042080	4044920	So even though the string starts like this in this big in memory,
4044920	4046560	it's then going to grow for one character,
4046560	4050600	grow, grow, grow, grow until it has all of the user's initials.
4050600	4053880	And as for where that memory is coming from, who cares?
4053880	4056120	This is the point that we're now past.
4056120	4057560	You leave it to the language.
4057560	4060520	You leave it to the computer to start to manage those details.
4060520	4062640	And yes, if it needs to call Malek, fine, do it.
4062640	4064280	Don't bother me with that detail.
4064280	4066880	We can now start thinking and writing code sort of conceptually
4066880	4069480	at this level instead of at this level.
4069480	4072360	So again, we're sort of abstracting away what a string even is
4072360	4074400	and leaving it to the language itself.
4074400	4078360	So if I now go ahead and run Python of initials.py and type in,
4078360	4085000	for instance, Maria Zlatkova here with a capital M and a capital Z,
4085000	4088000	I then see her names because I've plucked out the middle initials.
4088000	4092080	And if we do something else like David J. Malen, even with a period in there,
4092080	4095880	it infers from the capitalization what my initials should actually be.
4095880	4098440	So again, a much tighter way of doing things.
4098440	4100420	Let me go ahead and now open up another example.
4100420	4102600	We didn't see a few weeks ago, though it was included
4102600	4106160	in some of our distribution code, if you wanted to look.
4106160	4110040	Some weeks ago, we had this program among the distribution code,
4110040	4114800	where I declared an array of strings called book.
4114800	4118600	And I proposed that there were these several names in the phone book,
4118600	4123080	so to speak, all of the past instructors of CS50 sorted alphabetically.
4123080	4127160	And then down below in this C program, I used that global variable called
4127160	4131160	book to implement, it seems, linear search.
4131160	4134680	And to implement linear search in C, I'm going to need, of course,
4134680	4137080	a loop to iterate over all of the strings.
4137080	4139720	This line 26 does exactly that.
4139720	4143080	I then in C recall how to use stir compare because remember, we tripped over
4143080	4146040	this issue early on where you can't just compare two strings in C
4146040	4150320	because you'd be comparing accidentally their addresses, their pointers,
4150320	4151280	not the actual value.
4151280	4154680	So we use stir compare, and I can pass in the name that I'm looking for
4154680	4158200	and the ith book one at a time, checking for equals zero.
4158200	4161560	And then I can call Mike or David or whoever I'm trying to call,
4161560	4164200	or just quit if the user isn't found.
4164200	4165960	So what did this program actually do?
4165960	4171080	If I go into this example, which again was from week three,
4171080	4176840	and I do make linear, nope, not that make, oh, wrong directory again.
4176840	4180680	If I go into source three and make linear,
4180680	4183160	this program is supposed to behave as follows.
4183160	4187880	So if I go ahead and run dot slash linear, look for our old friend Smith.
4187880	4192600	If found Smith, if I go ahead and search for, say, Jones, who did not previously
4192600	4194280	teach CS50, it says quitting.
4194280	4198360	All right, so meanwhile, in Python, bless its heart,
4198360	4200680	we can get rid of all of that.
4200680	4205520	And in our source eight directory here and our sub directory three,
4205520	4208600	let me go ahead and open this instead.
4208600	4213000	In Python, I can declare an array, otherwise known as a list, almost
4213000	4216720	in the same way, but what's different just to be super clear?
4216720	4217920	Brackets?
4217920	4220600	So the brackets are now square brackets instead of curly braces.
4220600	4224200	And frankly, unless you statically initialized an array in C,
4224200	4226200	like hard coded the values for your array in C,
4226200	4228600	you might not even have known you could use curly braces.
4228600	4230080	So that's not a huge deal here.
4230080	4233240	But in Python, square brackets here and here
4233240	4236080	represent a list of elements, literally.
4236080	4239520	And what else is different?
4239520	4240800	Didn't declare the size of the array.
4240800	4242640	And I technically don't have to do that in C either
4242640	4245640	if you're hard coding all of the values all at once.
4245640	4248840	But there is something missing on line seven.
4248840	4251200	Sorry?
4251200	4251760	The type.
4251760	4252920	I didn't specify string.
4252920	4256280	But otherwise, this is pretty similar to what we've done in C.
4256280	4261200	But what's beautiful here, and let me go ahead and hide that for just a second,
4261200	4265160	let me go ahead and prompt the user for his or her name.
4265160	4267120	So let's ask for the name here.
4267120	4270680	And then if I want to search the book, which is just a list of names,
4270680	4272320	how do I implement linear search?
4272320	4280680	Well, I could just do if name in book, print, calling, name,
4280680	4282520	and let's make this an F string.
4282520	4285320	And then down here, that's it.
4285320	4287560	So that's how you implement linear search in Python.
4287560	4288600	You don't need a loop.
4288600	4290840	You can just ask the question yourself.
4290840	4295480	So if book is a list, and name is the string that you're looking for,
4295480	4297880	just ask the language to figure this out for you.
4297880	4303280	If name in book is the syntax you can use to ask literally that question.
4303280	4306880	And in Python, we'll use probably linear search over that list,
4306880	4308960	because it doesn't necessarily know it's sorted,
4308960	4310760	even though it happens to be alphabetically.
4310760	4314680	But it will find it for you, thereby saving us a lot of the complexity
4314680	4318200	and time of having had to implement that ourselves.
4318200	4323040	Meanwhile, if I want to compare two strings, let me propose this.
4323040	4324760	Let me write a quick program here.
4324760	4326520	Compare 1.py.
4326520	4331080	And let me go ahead and from CS50 import, get string as before.
4331080	4336220	And now let me go ahead and get one string that I'll call S.
4336220	4342500	And let me get another string that I shall call T, just as we did a few weeks ago.
4342500	4347140	And now in C, this was buggy.
4347140	4352380	If I print same, else I print different.
4352380	4356780	So in C, just to be super clear, why was this incorrect,
4356780	4359540	this general idea of using equals equals?
4362940	4364420	Yeah, they're comparing addresses.
4364420	4367060	This was like the day before we peeled back
4367060	4369340	the layer of what a string actually is.
4369340	4373100	And it turns out that S and T in C were char stars or addresses,
4373100	4375260	which means, certainly, if you get two different strings,
4375260	4376860	even if you've typed the same characters,
4376860	4378740	you're going to be comparing two different addresses.
4378740	4380020	They're not going to be the same.
4380020	4382820	Now you can perhaps infer from the theme of today,
4382820	4387220	what is Python going to do if asked if S and T are equal?
4387220	4391260	It's going to ask and answer that question as you would expect as the human.
4391260	4394900	Equals equals now in Python is going to compare S and T,
4394900	4397700	look at their actual values, because they are strings,
4397700	4401500	and return same if you literally type the same words.
4401500	4406660	So in here, if I go in here, and I do Python of compare 1.py,
4406660	4412380	and I type in, for instance, Maria, and then I type in Maria,
4412380	4413340	they're indeed the same.
4413340	4416780	If I type in Maria and say Stelios, they're different,
4416780	4419180	because it's actually now comparing the strings,
4419180	4421900	as we would have hoped some time ago.
4421900	4424000	So let's take a look at another that kind of led
4424000	4425580	to some interesting quandaries.
4425580	4430700	You might recall in week four, we had this example in C.
4430700	4434780	No swap, so named, because this just did not work.
4434780	4437420	It was logically, seemingly correct.
4437420	4442580	But swap did not actually swap x and y, but it did swap a and b.
4442580	4443080	Why?
4443840	4449840	The memory locations were different.
4449840	4452880	So x and y, recall, are variables in C that
4452880	4456080	exist in a certain slice of memory that we called a frame on the stack,
4456080	4458080	main's frame on the stack.
4458080	4462120	Meanwhile, a and b are from a slightly different location in memory.
4462120	4463840	We sort of kept drawing it slightly above,
4463840	4468080	like a tray at the dining hall on the so-called stack.
4468080	4472000	A and b had the same values of x and y, one and two,
4472000	4473360	but their own copies of them.
4473360	4477160	So even though we logically, as with Kate, I think with the Gatorade,
4477160	4481280	swap the two values, we ultimately swap the wrong two values
4481280	4485360	without actually permanently mutating the original x and y.
4485360	4488600	So unfortunately, and unfortunately in Python,
4488600	4490360	there is no such thing as a pointer.
4490360	4491760	So those are now gone.
4491760	4493880	So we no longer have the expressiveness with which
4493880	4495800	to solve this problem that way.
4495800	4501960	But let me propose that we do it in oh, so clever of another way.
4501960	4506000	Here, let me go ahead and declare x is 1, y is 2.
4506000	4507720	Let me go ahead and print out as much.
4507720	4513360	So with a format string, I'm going to go ahead and say x is x, y is y,
4513360	4515240	plugging in their respective values.
4515240	4516680	I'm going to do that twice.
4516680	4519520	But in between, I'm going to try to perform this swap.
4519520	4524920	And if your mind's ready to be blown, do that in Python.
4524960	4527440	Do the old switcheroo in Python.
4527440	4530440	And this actually does swap the two values as you would expect.
4530440	4531920	Now, this is not a very common case.
4531920	4534480	And to be fair, this is an incredibly contrived example.
4534480	4536760	Because if you needed them swapped, well, maybe you
4536760	4538560	should have just done this in the first place.
4538560	4540960	But it does speak to one of the features of Python
4540960	4544160	where you can actually do something like that.
4544160	4549760	Let me introduce now one additional feature that we only recently acquired in C.
4549760	4551320	And that's the notion of a struct.
4551320	4554200	And let me go ahead and do this in code from scratch.
4554240	4558400	So let me go ahead and save this file proactively as struct0.py,
4558400	4560640	reminiscent of one of our older programs.
4560640	4562080	And let me go ahead and do this.
4562080	4565720	From cs50, import getString.
4565720	4567840	And then let me give myself an empty list.
4567840	4569840	So that would be a conventional way of giving yourself
4569840	4571400	an empty list in Python.
4571400	4574880	And much like in C, you can declare an empty array.
4574880	4576760	But in C, you have to know the size of it.
4576760	4578320	Or if not, you have to use a pointer.
4578320	4579320	And then you have to mallet.
4579320	4581000	No, all of that is gone.
4581000	4582520	Now in Python, you want a list?
4582520	4585800	Just say you need a list, and it will grow and shrink as you need.
4585800	4590360	Now I'm going to go ahead and just three times arbitrarily for i in the range of three.
4590360	4594600	Let me go ahead and ask the user for a name using getString.
4594600	4596760	And I'll ask him or her if their name.
4596760	4599560	Dorm will use getString as well.
4599560	4600640	Dorm here.
4600640	4605200	And then I want to append to the array this student.
4605200	4608280	So I could do something like this.
4608280	4612240	Students.append name.
4612240	4614480	And it turns out, and we've not said this yet,
4614480	4619760	but there is inside of the list data type a method that is function built
4619760	4622520	into it called append that literally does that.
4622520	4625400	So if you've got an otherwise empty list,
4625400	4629200	and you call that list's name.append, you'll add something to the end of the list.
4629200	4630920	And if there's not enough memory for it, no big deal.
4630920	4634240	Python will find you the memory, allocate it, move everything in it,
4634240	4637160	and you move on your way without having to worry about that.
4637160	4639320	But I don't want to store just the name.
4639320	4641520	I want to store the name and the dorm.
4641520	4643080	So I could do this.
4643080	4645760	I could do, well, maybe this isn't really students.
4645760	4647720	Maybe this is now dorms.
4647720	4652920	And then here I could do dorms.append dorm.
4652920	4656760	But why is this devolving now into bad design
4656760	4660240	if my goal was to associate a student with his or her dorm
4660240	4662280	and then keep those values together?
4662280	4666320	Why is this not the best approach in Python or back in the day, even
4666320	4670280	in C, to have two separate arrays?
4670280	4671480	By struct.
4671480	4671980	What's that?
4671980	4673160	Struct.
4673160	4677400	So well, you have to, like, twice as many things to maintain, for sure.
4677400	4678400	And what else?
4678400	4679960	You can't map one to the other.
4679960	4681160	You can't map one to the other.
4681160	4683280	It's just, it's like, it's very arbitrary.
4683280	4686040	Like, it's sort of this social contract that I will just
4686040	4690040	assume that student zero lives in dorm zero.
4690040	4692560	And student one lives in dorm one.
4692560	4693200	And that's fine.
4693200	4694120	And that's true.
4694120	4696800	But one of the features of programming and computer science
4696800	4700240	is this idea of encapsulation, like, associate-related memory with each
4700240	4700800	other.
4700800	4702520	And so what did we do in C instead?
4702520	4705720	We did not have two arrays.
4705720	4707040	Yeah, we had a struct.
4707040	4710080	And so Python doesn't have structs per se.
4710080	4712000	It instead has what are called classes.
4712000	4714360	And it has a few other things like tuples and name tuples,
4714360	4716240	but more on those some other time.
4716240	4721040	So it turns out I could actually implement my own notion of a student.
4721040	4723000	And I could import it like this.
4723040	4726400	The convention in Python is if you create your own struct,
4726400	4730440	henceforth called a class, you capitalize the name of it by convention.
4730440	4732360	So a little different from C conventions.
4732360	4734360	So what is a student going to look like?
4734360	4737000	This is perhaps the most complex syntax that we'll have today,
4737000	4739040	but it just has a few lines.
4739040	4741920	If you want to implement the notion of a student, how
4741920	4742960	might you do this?
4742960	4748000	Well, in Python, you literally say class student, where class is similar in spirit
4748000	4751240	to, just to be clear, struct or type def struct.
4751240	4753600	But in Python, we're just saying class.
4753600	4755520	And then this is the funky part.
4755520	4759480	You can declare a function that by convention
4759480	4764360	must be called init for initialize, that takes as its first argument
4764360	4770160	a keyword called self, and then any number of other arguments like this.
4770160	4774600	And then, for reasons that will hopefully be clear momentarily,
4774600	4776880	I can write some code inside of this method.
4776880	4779080	So long story short, what am I doing?
4779080	4782800	I have declared a new type of data structure called student.
4782800	4785400	And implicitly inside of this data structure,
4785400	4789080	there are two things inside of itself, something called name and something
4789080	4790360	called dorm.
4790360	4793520	And this is how you would, in a C struct, typically do things
4793520	4796760	with the data types and semicolons inside of the curly braces.
4796760	4799240	Meanwhile, there's this method here.
4799240	4802800	And it's a method in so far as it is inside of a class.
4802800	4805520	Otherwise, it's a function just by a different name.
4805520	4809960	This method init takes whatever self is, more on that another time,
4809960	4813000	but it then takes zero more custom arguments that you can provide.
4813000	4814680	And I called it name and dorm.
4814680	4818160	So it turns out this special method init is a function that's
4818160	4821400	going to be called automatically for you any time you
4821400	4824120	create a student object.
4824120	4825960	So what does that actually mean?
4825960	4830120	That means in your code, what you can actually do is this.
4830120	4836840	I can create a student in memory by saying s gets capital student passing
4836840	4838080	in name and dorm.
4838080	4841680	And we don't have this feature in C. On the right hand side,
4841680	4844240	what I've highlighted is the name of the class
4844240	4846680	and its two arguments, name and dorm, which
4846680	4849880	are just what the user has typed in.
4849880	4853520	What this class does for me now is it allocates memory underneath the hood
4853520	4854080	for a student.
4854080	4856440	It's got to be big enough for their name and big enough for their dorm.
4856440	4858600	So it's like yay big in memory, so to speak.
4858600	4862240	It then puts in the name and the dorm strings into that object
4862240	4864560	and then returns the whole object.
4864560	4868720	So you can kind of think of this as a much fancier version of malloc.
4868720	4870920	So this is allocating all the memory you need,
4870920	4874680	but it's also installing inside of that memory the name and the dorm.
4874680	4878840	And it's bundling it up inside of not just an arbitrary chunk of memory,
4878840	4883920	but something you can call a student object.
4883920	4886760	And all that means that now for our students,
4886760	4890400	we can just go ahead and append that student to the list.
4890400	4896440	So now, if later, I want to iterate over for student in students,
4896440	4898480	I can go ahead and print out, for instance,
4898480	4907080	that student.name lives in student.dorm, close quote.
4907080	4912280	And if now over here, oops, close that, and now over here,
4912280	4916480	if I go ahead and run Python on struct0.py.
4916480	4919480	Oh, no.
4919480	4921880	Oh, thank you.
4921880	4923200	That goes there.
4923200	4924480	So now, damn it.
4927400	4928200	Missing curly.
4928200	4928760	Oh, thank you.
4931520	4935560	OK, so now if I want to go ahead and type Maria and Cabot and David and
4935560	4940800	Mather and Rob and say Kirkland, now we get all three of those names.
4940800	4945080	And there's other ways, too, if we want to actually store this thing on disk.
4945080	4947440	But I'll defer that to an example online.
4947440	4951720	Let's look at one final example that will hopefully either make you regret
4951720	4955640	the past several weeks or embrace the next several instead.
4955640	4960560	So you'll recall that, though the former I suppose could be true,
4960560	4965280	even without my help, so if I go into now, today's distribution code,
4965280	4966320	you will see this program.
4966320	4968200	And we won't walk through all of its lines,
4968240	4971400	but this is a program written in Python called Speller.
4971400	4974840	And what I did was literally sit down with Speller.c from problem set
4974840	4978840	5, and I just converted it from left to right from c to Python,
4978840	4983280	implementing it in Python in as close to an identical way as I could,
4983280	4985200	just using features of Python.
4985200	4988440	So just skimming this, you'll see that apparently my implementation
4988440	4992480	of Speller in Python has a class called dictionary, which is very similar in spirit
4992480	4994360	to dictionary.h and c.
4994360	4997400	Notice that I still have a constant here, or it's not technically a constant,
4997400	5001120	but a variable called length equals 45, like hardcoded in dictionary
5001120	5003520	slash large as Speller.c did too.
5003520	5006200	I'm using command line arguments as we saw earlier,
5006200	5008720	but this time in Python instead of c.
5008720	5011200	Notice you can do funky things like this, which
5011200	5013920	is reminiscent of our swap trick just a little bit ago.
5013920	5016960	If you want to declare multiple variables all on the same line
5016960	5020200	and initialize them, you can just enumerate them all with commas.
5020200	5022320	Then on the other side of the equal sign,
5022320	5026280	enumerate with commas the values that you want to assign to those variables.
5026280	5029400	And then down here, if I keep scrolling, you'll
5029400	5032960	see code that we won't get into the weeds of, but some familiar phrases.
5032960	5038360	So this is the program that actually runs a student's dictionary on some input,
5038360	5043760	and then prints out per all this stuff at the bottom all of the familiar phrases
5043760	5046040	that you might recall from problem set five.
5046040	5048760	So this took a lot of work, most likely, to implement in c.
5048760	5051360	And understandably, you might have used a linked list initially,
5051360	5053760	or ultimately, you might have used a hash table, or a try,
5053760	5055800	or struggled with something in between those two.
5055800	5058240	And that is a function of c.
5058240	5059280	C is difficult.
5059280	5061920	C is challenging, because you have to do everything yourself.
5061920	5063760	And upside, though, of it is that you end up
5063760	5066720	getting a lot of great performance, theoretically.
5066720	5068640	Like, once you have implemented the code,
5068640	5070760	you're kind of as close to the hardware as possible.
5070760	5073920	And so your code runs pretty darn well, and is dependent only then
5073920	5077440	on your algorithms, not on your choice of language.
5077440	5080960	So here, let me go ahead and implement a file called dictionary.py.
5081000	5088960	And let me propose that the words, the equivalent, sorry, of dictionary.h
5088960	5090400	would be this file here.
5090400	5094400	And it's going to have a key word, a function called check,
5094400	5097040	which takes an argument called word.
5097040	5101480	It's going to have a function called load, which takes in an argument called
5101480	5102480	dictionary.
5102480	5109600	It's going to have a method called size, which takes in no arguments other
5109600	5110680	than itself.
5110680	5113320	And then it's going to have a method called unload, which also takes
5113320	5114960	no arguments other than itself.
5114960	5118240	So if we were instead to have assigned problems at 5 in Python,
5118240	5121040	we essentially would have given you a file called dictionary.py
5121040	5122400	with these placeholders for you.
5122400	5125240	Because recall, in pset5, those were all to dos.
5125240	5127680	Strictly speaking, there would be one other here.
5127680	5131240	We would probably have a def init, because every class in Python
5131240	5134360	we'll see will typically have this init method, where we just
5134360	5138400	are able to do something to initialize the data structure.
5138400	5139720	So let me go ahead and do this.
5139720	5141760	We don't know that much Python yet, and we're
5141760	5144360	taking for granted that Speller, in fact, works.
5144360	5146840	But let me go ahead and load some words in a dictionary.
5146840	5149120	So here is my method called load.
5149120	5151360	Dictionary is going to be the name of the dictionary to load.
5151360	5155840	So you guys implemented this yourself by loading those files from disk.
5155840	5158120	In Python, I'm going to do this as follows.
5158120	5162080	Give me a file and open it in read mode.
5162080	5165800	I'll iterate over each line in the file.
5165800	5172000	Then go ahead and add to my set called words the result of that line
5172000	5176240	by stripping off the end of it, backslash 0.
5176240	5180960	Then go ahead and close the file, and then return true,
5180960	5183320	because I'm done implementing load.
5183320	5187800	So that is the load method in Python.
5187800	5188480	Happy, yes.
5188480	5189760	OK, so check.
5189760	5191160	Check was a struggle too, right?
5191160	5193560	Because once you had your hash table, or once you had your try,
5193560	5195840	now you had to actually navigate that structure in memory,
5195840	5198760	maybe recursively, maybe iteratively, following lots of pointers and the
5198760	5200240	like, following a linked list.
5200240	5211720	How about I just do, let's just say, if word lowercase in self.words,
5211720	5219320	return true, else return false, done.
5219320	5221200	So that one's done.
5221200	5224160	On size, we actually can kind of infer how to do this,
5224160	5226600	return the length of the words.
5226600	5227600	That's done.
5227600	5231400	Unload, don't have to worry about memory in Python, so that's done.
5231400	5234840	And there you have problem set five.
5234840	5236320	Thank you.
5236320	5238960	So what then are the takeaways?
5238960	5241400	Either great elation that you now have this power,
5241400	5244040	or great sadness that you had to implement this first and see,
5244040	5246440	but this was really ultimately meant to be thematic.
5246440	5249040	Like hopefully moving forward, even if you struggled with any number
5249080	5251720	of these topics, linked list, and hash tables, and pointers, and the like,
5251720	5254680	like hopefully you have a general understanding of some of these fundamentals
5254680	5256880	and what computers are doing underneath the hood.
5256880	5260760	And now with languages like Python, and soon with JavaScript and SQL,
5260760	5264080	with a little bit of HTML and CSS mixed in for our user interfaces,
5264080	5266840	do you have the ability to now solve problems taking for granted
5266840	5269040	both your understanding of those topics
5269040	5273080	and the reality that someone else has now implemented those concepts for you
5273080	5275880	so that when it comes to solving problems that's six and seven and eight,
5275880	5278640	and then leaving CS50 and solving problems in your own domain,
5278640	5280920	you have so many more tools in your toolkit.
5280920	5283200	And the goal really for you is going to be
5283200	5285720	to pick whichever one is most appropriate.
5285720	5286760	So let's adjourn here.
5286760	5289080	I'll stick around for questions, and we'll see you next time.
5289080	5291480	Best of luck on the test.
