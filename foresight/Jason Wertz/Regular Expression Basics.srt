1
00:00:00,000 --> 00:00:07,200
In this video lecture we're going to talk about regular expressions.

2
00:00:07,200 --> 00:00:11,360
We'll also take a look at the command line utilities grep and sed.

3
00:00:11,360 --> 00:00:13,080
So what are regular expressions?

4
00:00:13,080 --> 00:00:19,400
Well regular expressions are patterns that we can build to match against specific series

5
00:00:19,400 --> 00:00:25,020
of characters, you know, words, in a programming sense we can say strings.

6
00:00:25,020 --> 00:00:29,800
We can use these patterns to pull out specific pieces of information from a larger set of

7
00:00:29,800 --> 00:00:31,720
information that we're interested in.

8
00:00:31,720 --> 00:00:37,400
So if we're looking at something like a very large log file, we can use a regular expression

9
00:00:37,400 --> 00:00:41,560
to just isolate those aspects of the log file that we're interested in.

10
00:00:41,560 --> 00:00:47,400
This is really great when you've got a lot of data to pick through on the command line.

11
00:00:47,400 --> 00:00:51,920
We can also use regular expressions for finding data and then acting upon it and we'll take

12
00:00:51,920 --> 00:00:56,480
a brief look at sed which is the stream editor later on in this video lecture.

13
00:00:56,480 --> 00:01:02,040
So for now we're going to look at mostly a tool called grep which allows us to show

14
00:01:02,040 --> 00:01:09,080
or not show specific aspects of a file that conform to one of our regular expression patterns.

15
00:01:09,080 --> 00:01:16,600
So the command line grep utility is used to apply patterns to either standard input or

16
00:01:16,600 --> 00:01:18,800
to a specific file.

17
00:01:18,800 --> 00:01:23,000
And so we might have a very large file and what we're interested in doing is just taking

18
00:01:23,000 --> 00:01:25,360
a look at certain aspects of it.

19
00:01:25,360 --> 00:01:30,480
There's actually two forms of grep and grep stands for get regular expression and there's

20
00:01:30,480 --> 00:01:31,480
also grep and egrep.

21
00:01:31,480 --> 00:01:37,120
And what you're going to find is that because Unix is so old, it's had a lot of time to evolve

22
00:01:37,120 --> 00:01:42,120
and sometimes people have gone on and extended aspects of Unix and in their sense of making

23
00:01:42,120 --> 00:01:43,120
it better.

24
00:01:43,120 --> 00:01:47,920
So the idea of grep and egrep is that grep is the original grep and egrep is extended

25
00:01:47,920 --> 00:01:48,920
grep.

26
00:01:48,920 --> 00:01:52,120
And extended grep actually supports extended regular expressions.

27
00:01:52,120 --> 00:01:56,360
So anytime a language has been around for a long time, people try to start to add to

28
00:01:56,360 --> 00:02:00,200
it when they start to notice failings in that language.

29
00:02:00,200 --> 00:02:06,240
And what I'll mention is that we'll look at both extended and regular, regular expressions.

30
00:02:06,240 --> 00:02:08,880
There's also pearl regular expressions, which I'm most familiar with.

31
00:02:08,880 --> 00:02:12,380
So I also throw that out there when I'm talking about regular expressions.

32
00:02:12,380 --> 00:02:16,900
Anytime I make an error, I will probably be thinking in terms of pearl regular expressions.

33
00:02:16,900 --> 00:02:22,560
So enough about what regular expressions are, what utilities we're going to use, what

34
00:02:22,560 --> 00:02:28,140
does a regular expression do and look like?

35
00:02:28,140 --> 00:02:35,040
Let's think about a typical pattern that we might want to apply in this case.

36
00:02:35,040 --> 00:02:40,140
Let's say that I have asked someone to look through the phone book or a directory of employees

37
00:02:40,140 --> 00:02:44,860
and show me everybody whose last name starts with the letter s.

38
00:02:44,860 --> 00:02:46,020
So I've given you a pattern.

39
00:02:46,020 --> 00:02:48,300
I've given you a few bits of information.

40
00:02:48,300 --> 00:02:57,820
I've said, okay, I want you to look at last name, oops, and I want that last name to start

41
00:02:57,820 --> 00:02:59,580
with the letter s.

42
00:02:59,580 --> 00:03:10,420
So if I have somebody whose name is, right, like John Smith, this would match my pattern

43
00:03:10,420 --> 00:03:15,700
because I look at the last name and the first letter of that last name is an s.

44
00:03:15,700 --> 00:03:23,260
Their name was Steve, John, I guess we'll stick with people with two first names.

45
00:03:23,260 --> 00:03:28,860
Well, the first name starts with the letter s, but the last name doesn't, so it doesn't

46
00:03:28,860 --> 00:03:30,220
match my pattern.

47
00:03:30,220 --> 00:03:37,660
So we define patterns and we do so programmatically and we use those patterns to filter or match

48
00:03:37,660 --> 00:03:44,340
against information that we're most interested in.

49
00:03:45,060 --> 00:03:50,180
Let's look at some really basic ways that we can apply patterns on the command line.

50
00:03:50,180 --> 00:03:55,820
I'm currently in my home directory and there's a number of folders and at least two files

51
00:03:55,820 --> 00:03:57,420
in my home directory.

52
00:03:57,420 --> 00:04:03,980
So there's actually some basic pattern matching capabilities built into the Bash shell.

53
00:04:03,980 --> 00:04:07,020
So for example, if I want to see all of the folders that start with the capital letter

54
00:04:07,020 --> 00:04:12,820
d, notice that if I just put the letter d, I get an error because it's going to say,

55
00:04:12,820 --> 00:04:20,900
I can't find a folder or file named d, but if I add a star after the word d, I get a

56
00:04:20,900 --> 00:04:22,580
lot of information.

57
00:04:22,580 --> 00:04:27,460
In fact, I wanted to look just for folders, I would do dash d, which would give me information

58
00:04:27,460 --> 00:04:32,100
about the directories as opposed to items inside the directories.

59
00:04:32,100 --> 00:04:38,100
And this star character on the shell is called the file glob operator and basically you can

60
00:04:38,100 --> 00:04:40,460
think of it like a wild card match.

61
00:04:40,460 --> 00:04:45,140
And the pattern that I've essentially given the ls command here is that the ls command

62
00:04:45,140 --> 00:04:51,140
should display all folders that start with the capital d and then folders that have any

63
00:04:51,140 --> 00:04:53,580
number of characters following it.

64
00:04:53,580 --> 00:04:58,980
So when I mean wild card, I mean any number from zero to an infinite amount and I mean

65
00:04:58,980 --> 00:05:00,340
any type of character.

66
00:05:00,340 --> 00:05:05,580
So basically this would match any folder that starts with d and goes ahead and has a bunch

67
00:05:05,580 --> 00:05:07,340
of stuff in front of it.

68
00:05:07,340 --> 00:05:11,500
You can also use a wild card at the front of a string, so I'm going to see any folder

69
00:05:11,500 --> 00:05:16,900
that starts with the letter s and notice it shows me documents, downloads, pictures, templates

70
00:05:16,900 --> 00:05:19,660
and videos because all of those end with a lower case s.

71
00:05:19,660 --> 00:05:24,660
And remember that the command line is case sensitive, so if I do capital s, I get nothing.

72
00:05:24,660 --> 00:05:28,980
You can also do something along the lines of putting two stars on the command line.

73
00:05:28,980 --> 00:05:33,700
So I could say something like show me all directories that have any number of characters,

74
00:05:33,700 --> 00:05:38,380
the letter l in them and then any number of characters on the other side.

75
00:05:38,380 --> 00:05:42,820
And in this case it shows me downloads, examples.desktop, public and templates because all of these

76
00:05:42,820 --> 00:05:47,540
have a letter l in the middle that we can see in each one of these and on either side

77
00:05:47,540 --> 00:05:54,020
there is any given number of characters that match this wild card pattern.

78
00:05:54,020 --> 00:05:58,020
So this is built into the shell and this can be really useful if you wanted to show say

79
00:05:58,020 --> 00:06:01,460
all files in a directory and so if we look back up into the shell it will notice that

80
00:06:01,460 --> 00:06:05,140
in my desktop directory I have a couple .txt files.

81
00:06:05,140 --> 00:06:13,820
Let's clear this and let's say I wanted to do ls-l desktop star .txt and what this would

82
00:06:13,820 --> 00:06:19,220
do is say okay go into my desktop directory, show me files that have any name and then

83
00:06:19,220 --> 00:06:27,980
have a .txt extension and if I hit enter I see those two files sitting in my home directory.

84
00:06:27,980 --> 00:06:33,740
So pretty cool that those exist and that this capability exists.

85
00:06:33,740 --> 00:06:39,140
But what we want to do is we want to actually look at how we can utilize grep to get more

86
00:06:39,140 --> 00:06:46,260
detail information about things like file directory listings and actual files themselves.

87
00:06:46,260 --> 00:06:49,860
So ls is great when you're looking for just information about some listings and the wild

88
00:06:49,860 --> 00:06:54,180
card is helpful for getting some basic pattern matching going.

89
00:06:54,180 --> 00:06:56,860
But to learn regular expressions what we're going to do is we're going to look at a very

90
00:06:56,860 --> 00:07:05,020
specific file on the Unix system and that file is the American English dictionary used

91
00:07:05,020 --> 00:07:07,620
for spell checking and other things by the system.

92
00:07:07,620 --> 00:07:11,500
So I'm going to pass the American English dictionary file which is found in slash user

93
00:07:11,500 --> 00:07:15,940
slash share slash dict slash American English into the less command so we can see what's

94
00:07:15,940 --> 00:07:22,020
in there and what you'll notice is this is a very large file that goes on and on and

95
00:07:22,020 --> 00:07:26,060
on and on and keeps going and there's lots of words in it.

96
00:07:26,060 --> 00:07:32,820
So this is really useful for our pattern matching exercises so I'm going to hit Q and we're

97
00:07:32,820 --> 00:07:38,820
going to start to talk about some really basic regular expressions.

98
00:07:38,820 --> 00:07:42,740
And the way we're going to do this is we're going to actually use the command grep.

99
00:07:42,740 --> 00:07:45,640
Remember that I had mentioned there are actually grep and egrep.

100
00:07:45,640 --> 00:07:47,900
So what we'll do is we'll use grep until it breaks.

101
00:07:47,900 --> 00:07:51,140
In other words we'll use grep until we run into a feature that is an extended regular

102
00:07:51,140 --> 00:07:55,900
expression and then we will jump over to using the egrep command.

103
00:07:55,900 --> 00:08:00,100
Actually it's a better habit to just get into using egrep all the time and that way

104
00:08:00,100 --> 00:08:04,940
you don't have to worry about what is an extended and what isn't an extended regular expression.

105
00:08:04,940 --> 00:08:08,660
But I kind of want to mention, show you that at some point some of these features will

106
00:08:08,660 --> 00:08:09,660
not work.

107
00:08:09,660 --> 00:08:19,380
So I am going to actually set this up so that we can grep this file and the way greps work

108
00:08:19,380 --> 00:08:25,660
is that we give the grep command what we'll do is right in here we'll put a pattern and

109
00:08:25,660 --> 00:08:29,700
then we will actually go ahead and match it against a file.

110
00:08:29,700 --> 00:08:33,700
And so the easiest pattern that I can put in here is I want to look for say words that

111
00:08:33,700 --> 00:08:34,700
have cat in it.

112
00:08:34,700 --> 00:08:38,460
So let's use cat and see what we get.

113
00:08:38,460 --> 00:08:41,900
What you'll notice is a lot of words scroll by.

114
00:08:41,900 --> 00:08:46,420
I gave the pattern cat and maybe you were thinking well I'll only see the word cat but

115
00:08:46,420 --> 00:08:52,700
notice that it shows me every word in the file that has the letters cat somewhere in

116
00:08:52,700 --> 00:08:53,700
the word.

117
00:08:53,740 --> 00:08:58,140
So that's what the color coded command line is we can actually see the matches.

118
00:08:58,140 --> 00:09:03,340
So that's kind of a nice feature for learning how to use regular expressions.

119
00:09:03,340 --> 00:09:07,300
And you'll also notice that this is a really big file so at some point we'll look at we're

120
00:09:07,300 --> 00:09:10,020
always going to see letters at the end of the alphabet just because of the way we're

121
00:09:10,020 --> 00:09:11,020
doing this.

122
00:09:11,020 --> 00:09:15,020
So let's clear this and take a look at that pattern again.

123
00:09:15,020 --> 00:09:21,500
My pattern is called cat and for the rest of the exercise is the other things or is cat.

124
00:09:21,500 --> 00:09:24,100
And I'm going to put these in double quotes because it'll make it a little bit easier to

125
00:09:24,100 --> 00:09:30,660
see where our pattern is within these lectures and it'll also help us deal with any non-standard

126
00:09:30,660 --> 00:09:31,660
characters.

127
00:09:31,660 --> 00:09:35,340
In other words any characters that we want to match in our pattern but have special meaning

128
00:09:35,340 --> 00:09:39,980
to the shell we want to make sure that those are not processed by the shell in a way that

129
00:09:39,980 --> 00:09:44,100
the shell wants to process them putting them in double quotes kind of fixes that.

130
00:09:44,100 --> 00:09:45,620
So what does this pattern say?

131
00:09:45,620 --> 00:09:50,660
It says well look for a C followed by an A followed by a T and what you found out again

132
00:09:50,660 --> 00:09:54,940
is when I run that command it doesn't really care if there's any characters before the

133
00:09:54,940 --> 00:10:02,700
cat or after the word cat it just looks for those three characters in order.

134
00:10:02,700 --> 00:10:05,540
So that's pretty interesting.

135
00:10:05,540 --> 00:10:11,460
What if we wanted to look for not just cat but you were wondering like well I wonder

136
00:10:11,460 --> 00:10:15,940
if there's a word that looks like cat that has another word in the middle.

137
00:10:15,940 --> 00:10:22,380
And maybe you were thinking of like cut or cot and you wanted to find all of these.

138
00:10:22,380 --> 00:10:26,180
Well regular expressions come with a special character which is the dot character and the

139
00:10:26,180 --> 00:10:30,420
dot character will match one of any character.

140
00:10:30,420 --> 00:10:39,920
So if there's actually a word called C2T then putting a dot there would match it.

141
00:10:39,920 --> 00:10:45,060
So what this will match is a C followed by any one character followed by the letter T.

142
00:10:46,060 --> 00:10:50,740
So you can just see in this little bit of information that we got I didn't even think

143
00:10:50,740 --> 00:10:55,060
about words like yachts which have Cht or watchtower.

144
00:10:55,060 --> 00:11:03,420
So we matched Cht, Cat, Cut, Cot and that's pretty cool.

145
00:11:03,420 --> 00:11:04,420
Why?

146
00:11:04,420 --> 00:11:07,580
Because the pattern used a dot.

147
00:11:07,580 --> 00:11:11,180
So let's talk about why this is and let's look at some other patterns that we might have

148
00:11:11,180 --> 00:11:13,020
available to us.

149
00:11:13,020 --> 00:11:16,220
So what we just looked at was this idea of basic elements.

150
00:11:16,220 --> 00:11:20,580
You can literally type a string and that will match the string or the series of characters

151
00:11:20,580 --> 00:11:26,020
and in this case we can also then use dots in our series of characters to represent any

152
00:11:26,020 --> 00:11:29,420
given one instance of any given character.

153
00:11:29,420 --> 00:11:32,500
So notice my first example matches bat, cat, mat.

154
00:11:32,500 --> 00:11:37,420
Finally if I just give the letters DOG it would match the literal string dog but found

155
00:11:37,420 --> 00:11:40,940
anywhere in a word.

156
00:11:41,020 --> 00:11:45,100
What's cool with regular expressions is we can start to get tricky.

157
00:11:45,100 --> 00:11:49,380
And so in our previous example we found we used the dot to find any character but let's

158
00:11:49,380 --> 00:11:54,620
say we only wanted to limit ourselves to finding a subset of any character and we can actually

159
00:11:54,620 --> 00:11:57,380
create what are called classes of characters.

160
00:11:57,380 --> 00:12:02,180
So we can have classes of characters by putting them into hard brackets and A-C will search

161
00:12:02,180 --> 00:12:10,540
for an A or a B or a C followed by an A and a T and this would match bat and cat but not

162
00:12:10,620 --> 00:12:11,620
rat.

163
00:12:11,620 --> 00:12:14,260
And let's take a look at this in the command line in a second.

164
00:12:14,260 --> 00:12:21,620
You can also use character classes to find uppercase, lowercase as well as numbers within

165
00:12:21,620 --> 00:12:22,620
your strings.

166
00:12:22,620 --> 00:12:26,500
Now again this is not looking for the number nine, this is looking for the character nine,

167
00:12:26,500 --> 00:12:28,620
the symbol that represents the value nine.

168
00:12:28,620 --> 00:12:35,180
So this is really just looking for a character zero through nine followed by another character

169
00:12:35,180 --> 00:12:39,340
zero through nine and this would match forty two, thirty seven, ninety nine, zero one.

170
00:12:39,340 --> 00:12:45,220
So basically match any two characters next to each other anywhere in a word.

171
00:12:45,220 --> 00:12:47,180
So let's take a look at that.

172
00:12:47,180 --> 00:12:55,100
So previously when we used the C dot T we matched cut, cat, cut.

173
00:12:55,100 --> 00:12:57,180
So the O, the A and the U.

174
00:12:57,180 --> 00:13:02,540
So let's say I don't want these watchtowers, CHT, I just want like C followed by a vowel

175
00:13:02,540 --> 00:13:05,820
followed by a T.

176
00:13:05,820 --> 00:13:11,380
So we can do that instead of using the dot I can create a character class.

177
00:13:11,380 --> 00:13:19,300
And if I want I can try to match any vowel, I don't know what we'll get but we'll see.

178
00:13:19,300 --> 00:13:24,620
And so what this says is look for the letter C followed by A, E, I, O, or U, just one of

179
00:13:24,620 --> 00:13:28,300
those but it can choose amongst all of the values in that set followed by the letter

180
00:13:28,300 --> 00:13:30,100
T.

181
00:13:30,100 --> 00:13:39,340
And now if I look at my output I get veracity, I get wainscot, I get vocatives, I get wildcat

182
00:13:39,340 --> 00:13:47,540
so I'm matching all the vowels between the letters C and T. All because of this character

183
00:13:47,540 --> 00:13:50,140
set that I've made.

184
00:13:50,140 --> 00:13:53,300
If you want to try and find any words in the dictionary, so that's character sets.

185
00:13:53,300 --> 00:13:56,820
And by the way you can use these and we'll see these in a second, if you want to match

186
00:13:56,820 --> 00:14:01,860
all lowercase characters you would do A through Z. You can also say find all lowercase and

187
00:14:01,860 --> 00:14:07,100
all uppercase characters which maybe you're looking for usernames or something along those

188
00:14:07,100 --> 00:14:08,100
lines.

189
00:14:08,100 --> 00:14:12,260
And then if you wanted to you could also add 0 through 9 and say like the underbar.

190
00:14:12,260 --> 00:14:15,740
And what that would do is match for all of those characters so you can have these sets

191
00:14:15,740 --> 00:14:19,820
of characters be as small or as large as you want them to be.

192
00:14:19,820 --> 00:14:24,180
I'm going to do is changes, let's see if there's any words that have 0 through 9, I doubt it.

193
00:14:24,180 --> 00:14:25,740
And nothing matches that pattern.

194
00:14:25,740 --> 00:14:29,260
That's what happens when you put in a pattern that doesn't match.

195
00:14:29,260 --> 00:14:32,500
Let's see if there's anything in the dictionary that matches against a number.

196
00:14:32,500 --> 00:14:38,020
Nope, so there are no numbers in the American English dictionary on the Unix system.

197
00:14:38,020 --> 00:14:40,020
So it's kind of helpful.

198
00:14:40,020 --> 00:14:45,340
There's a couple other things that we could actually use if we wanted to grep numbers.

199
00:14:45,340 --> 00:14:49,420
What I'll do right now is just to look at what we could possibly grep for a number would

200
00:14:49,420 --> 00:14:51,780
be the Etsy password file.

201
00:14:51,780 --> 00:14:54,220
And if I grep that I know there's a lot of numbers in there so I'm going to get a lot

202
00:14:54,220 --> 00:15:00,380
of matches and you'll notice that it matched all of these lines because all of the lines

203
00:15:00,380 --> 00:15:01,700
have a number in them.

204
00:15:01,700 --> 00:15:05,860
Again, the Etsy password files just shows you all the user accounts on the system and

205
00:15:05,860 --> 00:15:09,100
these numbers represent their user and group IDs.

206
00:15:09,100 --> 00:15:11,580
So I know that there were a lot of numeric matches in this file.

207
00:15:11,580 --> 00:15:17,540
So just to kind of demonstrate that you can match against numbers as well as words.

208
00:15:17,540 --> 00:15:20,900
So kind of helpful.

209
00:15:20,900 --> 00:15:25,340
Let's go back to an example where we can start to look at the English dictionary.

210
00:15:25,340 --> 00:15:31,780
So let's look at some other options for this feature, this ability to use character classes.

211
00:15:31,780 --> 00:15:37,980
Built into Unix is this idea of these really what I think are pretty ugly character classes.

212
00:15:37,980 --> 00:15:40,660
You'll see these sometimes built into the system.

213
00:15:40,660 --> 00:15:46,700
So bracket, bracket, colon, alpha, colon, bracket, bracket is the same as building your own character

214
00:15:46,700 --> 00:15:51,260
class that uses bracket A through Z, capital A through Z.

215
00:15:51,260 --> 00:15:57,100
And basically what these things on the left are are just ways of writing these out using

216
00:15:57,100 --> 00:16:01,660
words as opposed to using the categories A through Z.

217
00:16:01,660 --> 00:16:04,820
Pretty much if you haven't figured this out at this point in Unix, there's 50 ways to

218
00:16:04,820 --> 00:16:05,820
do everything.

219
00:16:05,820 --> 00:16:09,660
So these character class abbreviations can be helpful.

220
00:16:09,660 --> 00:16:11,860
They make things a little more readable in scripts.

221
00:16:11,860 --> 00:16:15,540
But the other thing if you haven't noticed is that regular expressions can get pretty

222
00:16:15,540 --> 00:16:18,900
big and pretty scary pretty fast.

223
00:16:18,900 --> 00:16:22,660
I would say the most useful character class that we're looking at right here is the one

224
00:16:22,660 --> 00:16:25,860
called space because that will match any white space characters.

225
00:16:25,860 --> 00:16:27,980
That includes tabs and spaces.

226
00:16:27,980 --> 00:16:33,300
That can be really helpful when trying to match words or sentences that have spaces.

227
00:16:33,300 --> 00:16:38,300
Or in my first example, we talked about last names and that would really be helpful for

228
00:16:38,300 --> 00:16:42,260
processing, finding somebody's last name.

229
00:16:42,260 --> 00:16:46,980
Because I don't like these, I'm mostly familiar with these character class abbreviations.

230
00:16:46,980 --> 00:16:49,460
So notice there's two character class abbreviations.

231
00:16:49,460 --> 00:16:53,020
The previous ones with the words like alpha, upper, and lower.

232
00:16:53,020 --> 00:16:58,580
But then there's also these character class abbreviations, slash D, slash W, slash S,

233
00:16:58,580 --> 00:17:05,420
slash S that make things a little bit more readable when we start to use these in larger

234
00:17:05,420 --> 00:17:06,980
regular expressions.

235
00:17:06,980 --> 00:17:10,820
I'll also mention that there are actually ways to negate character classes.

236
00:17:10,820 --> 00:17:17,060
If you notice the carrot inside of the bracket-based classes at the bottom here, you'll notice

237
00:17:17,060 --> 00:17:20,020
that that means does not match this character.

238
00:17:20,020 --> 00:17:25,580
And if you do slash capital D, slash capital W, slash capital S, that means that you do

239
00:17:25,580 --> 00:17:28,420
not want to match that character in that given position.

240
00:17:28,420 --> 00:17:31,620
I don't usually teach those when I introduce regular expressions because it's hard enough

241
00:17:31,620 --> 00:17:36,180
getting your head around regular expressions, let alone getting your head around negative

242
00:17:36,180 --> 00:17:37,540
logic at the same time.

243
00:17:37,540 --> 00:17:40,980
So we'll just kind of mention that they're there and just ignore that.

244
00:17:40,980 --> 00:17:48,540
So let's look at these two character class sets in operation.

245
00:17:48,540 --> 00:17:56,700
So let's say I want to find a word that has any letter in it.

246
00:17:56,700 --> 00:18:02,260
Well notice I just did that and I said that I wanted to find a slash D, but notice that

247
00:18:02,260 --> 00:18:06,780
it actually went ahead and found all of these words with the character D.

248
00:18:06,780 --> 00:18:07,780
Well that's a problem.

249
00:18:07,780 --> 00:18:13,260
You're thinking, well Jason, wait, you just showed us that slash D is a character class.

250
00:18:13,260 --> 00:18:14,260
But here's the thing.

251
00:18:14,260 --> 00:18:17,460
Remember earlier on I said there's grep and there's extended grep?

252
00:18:17,460 --> 00:18:20,140
Well these slash D character sets are actually part of extended grep.

253
00:18:20,140 --> 00:18:27,180
So if I switch to eGrep, it still doesn't work, which is a problem because I'm trying

254
00:18:27,180 --> 00:18:28,100
to explain this.

255
00:18:37,780 --> 00:18:43,380
Once you'll notice is that the slash D doesn't work, it actually goes ahead and finds the

256
00:18:43,380 --> 00:18:45,340
letter D within here.

257
00:18:45,340 --> 00:18:49,900
Slash D is actually a part of Perl regular expression.

258
00:18:49,900 --> 00:18:53,420
So if I actually add dash P, you'll note that it returns nothing.

259
00:18:53,420 --> 00:18:57,380
So that actually says u slash D, like it's a Perl regular expression and that'll pass

260
00:18:57,380 --> 00:18:58,380
numbers.

261
00:18:58,380 --> 00:19:01,060
So that doesn't actually work in grep or eGrep.

262
00:19:01,060 --> 00:19:05,540
But if I get rid of the dash P and just go with regular extended grep, what you'll find

263
00:19:05,540 --> 00:19:12,940
is I can actually utilize slash W. And that matches any character in any word that we

264
00:19:12,940 --> 00:19:13,940
might be looking at.

265
00:19:13,940 --> 00:19:16,380
So that one does work.

266
00:19:16,380 --> 00:19:22,580
And if we go ahead and we look at slash S, what you'll notice is that that also returns

267
00:19:22,580 --> 00:19:24,220
nothing.

268
00:19:24,220 --> 00:19:29,420
So it looks like slash D is one of those cases where that's more of a Perl thing than it

269
00:19:29,420 --> 00:19:31,900
is an extended grep thing.

270
00:19:31,900 --> 00:19:33,980
So I'll apologize for that and keep going.

271
00:19:33,980 --> 00:19:39,540
Or slash D is the same as typing 0 through 9.

272
00:19:39,540 --> 00:19:46,340
So you don't need to worry about the fact that slash D is not supported in eGrep.

273
00:19:46,340 --> 00:19:49,540
Let's take a look at some other ways that we can build patterns.

274
00:19:49,540 --> 00:19:54,260
We'll start out by taking a look at what are called anchors or positional anchors.

275
00:19:54,260 --> 00:19:58,980
In other words, we can say that a certain character has to match at a certain point on

276
00:19:58,980 --> 00:20:03,420
a line, either at the beginning of the line or at the end of the line.

277
00:20:03,420 --> 00:20:07,740
And you'll see that the characters that we're going to use for these beginning and end of

278
00:20:07,740 --> 00:20:12,740
line matches are a carrot and a dollar sign.

279
00:20:12,740 --> 00:20:17,100
And you'll notice that in the example in front of you, putting a carrot means to match only

280
00:20:17,100 --> 00:20:21,940
the word car, where car is the first line character on the line.

281
00:20:21,940 --> 00:20:28,020
So it would match car, cattle, and canine, where those are the first words on a line.

282
00:20:28,020 --> 00:20:31,660
And the second example, floating and sailing, would match because the G is at the end of

283
00:20:31,660 --> 00:20:34,580
the line if those are the only words on the line.

284
00:20:34,580 --> 00:20:39,380
And if you'd like to match situations where a word is the only word on a given line, such

285
00:20:39,380 --> 00:20:43,420
as cat, you would want a line that starts with the letter C, a line that ends with the

286
00:20:43,420 --> 00:20:46,060
letter T. We'll take a look at these in one second.

287
00:20:46,060 --> 00:20:50,460
Let's look at another possible anchor that we can use, which is a word boundary.

288
00:20:50,460 --> 00:20:54,500
So remember, the carrot character and the dollar sign character have to do with the beginning

289
00:20:54,500 --> 00:20:56,340
and the end of line.

290
00:20:56,340 --> 00:21:04,860
And word boundaries give us the ability to match on spaces, tabs, and basically these

291
00:21:04,860 --> 00:21:08,780
positions where there might be breaks between words.

292
00:21:08,780 --> 00:21:15,220
So in the example that I've got at the bottom, if I wanted to match Jason the prof, S-O-N

293
00:21:15,220 --> 00:21:17,300
is anchored on a word boundary.

294
00:21:17,300 --> 00:21:20,220
So there's a space between my name and the word the.

295
00:21:20,220 --> 00:21:23,300
So S-O-N slash B would match that line.

296
00:21:23,300 --> 00:21:27,340
Actually, there's no other instance of S-O-N on that line, but let's say I was in a file

297
00:21:27,340 --> 00:21:34,100
that had a lot of people named Jason, but I was the only one with the surname the prof.

298
00:21:34,100 --> 00:21:35,100
It would match.

299
00:21:35,100 --> 00:21:42,460
So let's take a look at how word boundaries and anchors work in real life.

300
00:21:42,460 --> 00:21:48,660
So to match items in word boundaries, we really need a file to do this.

301
00:21:48,660 --> 00:21:52,860
So what I'm going to do is take another look at the Etsy password file.

302
00:21:52,860 --> 00:21:57,100
I've also bumped up the font, so hopefully things are a little bit easier to see.

303
00:21:57,100 --> 00:22:00,940
So what you'll notice is in the Etsy password file, there's a number of lines here.

304
00:22:00,940 --> 00:22:04,500
So I've got root, demon, bin, sys.

305
00:22:04,500 --> 00:22:08,580
So let's say I only want to see lines that start with the letter S. There's a couple

306
00:22:08,580 --> 00:22:09,580
of them.

307
00:22:09,580 --> 00:22:15,020
So I'm going to use eGREP, and I'm going to say that I want to look at lines that start

308
00:22:15,020 --> 00:22:19,660
with the letter S, and I want to look at the Etsy password file.

309
00:22:19,660 --> 00:22:24,220
And what you'll notice is that shows me lines that just start with the letter S. Notice

310
00:22:24,220 --> 00:22:26,580
that the letter S might be in other parts of the line.

311
00:22:26,580 --> 00:22:32,780
If I take out that position qualifier, what you'll notice is that the letter S appears

312
00:22:32,780 --> 00:22:38,100
on many more lines, but I only want to be interested in those lines where the letter

313
00:22:38,100 --> 00:22:40,300
S is at the beginning.

314
00:22:41,060 --> 00:22:46,900
If I want to see which lines have at the end, the letter N, I can put a dollar sign, and

315
00:22:46,900 --> 00:22:51,860
it'll show me only the lines that end in the letter N. Let's try H. I was thinking bin,

316
00:22:51,860 --> 00:22:54,220
but I think I meant bash.

317
00:22:54,220 --> 00:23:02,060
And so what it'll show you is that many of these user accounts use the bash shell.

318
00:23:02,060 --> 00:23:06,820
And let's say, notice in this case I'm seeing bash and SH.

319
00:23:06,860 --> 00:23:12,460
Let's say I'm only concerned about those users in this file that have the login shell bash.

320
00:23:12,460 --> 00:23:15,220
So let's see how we can fix that.

321
00:23:15,220 --> 00:23:21,140
Instead of just saying H, I could say bash, and what this will say is the last letter

322
00:23:21,140 --> 00:23:27,940
on the line must be an H, but before it must come a B, A, and an S. And now I get exactly

323
00:23:27,940 --> 00:23:31,420
the information I want, lines that end with bash.

324
00:23:31,420 --> 00:23:40,980
So that's the concept behind positional values within regular expressions.

325
00:23:40,980 --> 00:23:45,420
What I have here is a file called demo that contains two lines.

326
00:23:45,420 --> 00:23:49,180
One is JSON space, the space prof, and the other line is JSONium.

327
00:23:49,180 --> 00:23:51,420
So maybe I have my own element.

328
00:23:51,420 --> 00:23:56,300
And if I grab this file for my name, what you're going to notice is that it shows me

329
00:23:56,300 --> 00:23:57,500
both lines.

330
00:23:57,580 --> 00:24:01,980
Maybe I only want to show those lines where it's actually my name and not my name embedded

331
00:24:01,980 --> 00:24:03,220
in another word.

332
00:24:03,220 --> 00:24:08,340
And the way I can do this is to add a word boundary to my regular expression.

333
00:24:08,340 --> 00:24:11,340
And remember slash B means word boundary.

334
00:24:11,340 --> 00:24:19,340
And so now it will only show me the JSON that is up against a word boundary.

335
00:24:19,340 --> 00:24:23,660
So it's pretty helpful when you know you have spaces in a file and you want to find words

336
00:24:23,660 --> 00:24:25,820
that you know are on a space.

337
00:24:25,820 --> 00:24:30,060
The last thing for us to review is the concept of quantifiers in a regular expression.

338
00:24:30,060 --> 00:24:35,420
Sometimes you want to look for zero or one or two or three of a certain character to

339
00:24:35,420 --> 00:24:37,140
appear in a certain spot.

340
00:24:37,140 --> 00:24:41,420
Other times you want to know exactly a specific number of items that you want to appear in

341
00:24:41,420 --> 00:24:44,340
a given spot in your regular expression.

342
00:24:44,340 --> 00:24:50,940
And so regular expressions come with the plus question mark and star operator.

343
00:24:50,940 --> 00:24:55,580
And while the star operator seems to work like it does on the shell, it's important to

344
00:24:55,580 --> 00:25:00,820
note that there is a slight difference between the file glob operator on the bash command

345
00:25:00,820 --> 00:25:05,180
line as opposed to the star operator within a regular expression.

346
00:25:05,180 --> 00:25:10,060
So how would we actually utilize these within some regular expressions?

347
00:25:10,060 --> 00:25:14,100
Well let's take a look at some sample regular expressions and then we'll go to the command

348
00:25:14,100 --> 00:25:15,940
line.

349
00:25:15,940 --> 00:25:23,460
So here's a sample regular expression that matches a phone number in the order of 555-555-5555.

350
00:25:23,460 --> 00:25:29,100
So typical US phone number, three digits dash, three digits dash, four digits.

351
00:25:29,100 --> 00:25:33,580
And you'll notice that I've got some positional notations here.

352
00:25:33,580 --> 00:25:37,580
So the line starts with a carrot and ends with a dollar sign.

353
00:25:37,580 --> 00:25:41,100
And notice that I've got a character class zero through nine.

354
00:25:41,100 --> 00:25:46,580
And since I know I want to match three characters, I could actually type bracket zero dash nine

355
00:25:46,580 --> 00:25:51,500
bracket, bracket zero dash nine bracket, bracket zero dash nine bracket dash.

356
00:25:51,540 --> 00:25:57,380
Or notice in this case I can use curly bracket three curly bracket, which says match exactly

357
00:25:57,380 --> 00:26:01,140
three of whatever you find before you.

358
00:26:01,140 --> 00:26:06,580
So we can actually use these curly bracket number, curly bracket notations to kind of

359
00:26:06,580 --> 00:26:09,580
make our regular expressions a little more condensed.

360
00:26:09,580 --> 00:26:13,300
So we'll look at this on the command line in a second and discuss.

361
00:26:13,300 --> 00:26:20,180
Also talked a little bit about the slash w slash b kind of type word boundary commands

362
00:26:20,180 --> 00:26:23,500
and the slash w character class commands.

363
00:26:23,500 --> 00:26:27,300
And you'll notice that I've written a really poor regular expression here that matches

364
00:26:27,300 --> 00:26:29,140
an email address.

365
00:26:29,140 --> 00:26:32,820
Regular expression email address matching can be helpful, but it's not something I would

366
00:26:32,820 --> 00:26:37,380
rely on because there's a number of email address formats and it's too complicated to

367
00:26:37,380 --> 00:26:39,580
really catch all of them.

368
00:26:39,580 --> 00:26:45,100
If you do a Google search for email address regular expression, take a look at some of

369
00:26:45,100 --> 00:26:46,100
the answers that you get.

370
00:26:46,100 --> 00:26:48,100
They're pretty long and detailed.

371
00:26:48,660 --> 00:26:53,140
But what you'll notice is this email address says it's also positionally situated.

372
00:26:53,140 --> 00:26:55,140
So it's got a carat and a dollar sign.

373
00:26:55,140 --> 00:26:57,340
So the only thing on this line should be an email address.

374
00:26:57,340 --> 00:27:01,020
It says find any number of word characters.

375
00:27:01,020 --> 00:27:04,300
So you'll notice that the star in this case says, and you'll notice the same thing with

376
00:27:04,300 --> 00:27:09,060
the number, the curly bracket three notation is it affects whatever is to the left of it.

377
00:27:09,060 --> 00:27:14,980
So this is look for any letter or number or valid email address character and then star

378
00:27:14,980 --> 00:27:21,300
after it means any number of valid email address characters, followed by an at, followed any

379
00:27:21,300 --> 00:27:27,060
number of valid characters, letters or numbers, followed by a dot, followed by any other number

380
00:27:27,060 --> 00:27:29,900
of valid letters or characters.

381
00:27:29,900 --> 00:27:33,100
Notice also that because I actually wanted a dot here, I didn't want to look for, remember

382
00:27:33,100 --> 00:27:36,140
that a dot has a special meaning with regular expressions.

383
00:27:36,140 --> 00:27:41,300
Anytime you want to tell a regular expression to use the actual character and not interpret

384
00:27:41,300 --> 00:27:46,060
it as a special regular expression character, you just put a slash in front of it.

385
00:27:46,060 --> 00:27:50,580
So let's take a look at how some of these components can work on the command line.

386
00:27:50,580 --> 00:27:55,860
I have a file that might be the file you're using for your lab.

387
00:27:55,860 --> 00:27:59,540
And if we look at the file lab3test.txt, what you're going to notice is it's a file full

388
00:27:59,540 --> 00:28:01,900
of names and phone numbers.

389
00:28:01,900 --> 00:28:04,380
So we're just going to look at matching the phone numbers since I've already given you

390
00:28:04,380 --> 00:28:06,180
a regular expression that does that.

391
00:28:06,180 --> 00:28:08,020
Let's see how that works.

392
00:28:08,020 --> 00:28:14,820
I want to build a regular expression to match just valid phone numbers in this file.

393
00:28:14,820 --> 00:28:18,420
So I'm going to use egrep and I'm going to put my pattern in here and I'm going to use

394
00:28:18,420 --> 00:28:21,100
lab3test.txt as my file.

395
00:28:21,100 --> 00:28:28,020
So before I said if I really wanted to match a phone number, I could write a regular expression

396
00:28:28,020 --> 00:28:32,140
that looks like this.

397
00:28:32,140 --> 00:28:35,780
And if I just run that, I'm not going to type, notice it matches any line that has three

398
00:28:35,780 --> 00:28:39,460
numbers in a row, or any instance of three numbers in a row.

399
00:28:39,460 --> 00:28:43,100
But notice it also gets these kind of user IDs over here.

400
00:28:43,100 --> 00:28:51,380
So then I could say as well, what if I match a dash, let me clear this, and then what if

401
00:28:51,380 --> 00:28:52,380
I add a dash?

402
00:28:52,380 --> 00:28:56,900
Well now we're getting better, we're getting closer, because it's matching, it's no longer

403
00:28:56,900 --> 00:28:58,700
matching these IDs on the left.

404
00:28:58,700 --> 00:29:03,180
But it is matching these two multi-formatted phone numbers and by the way, if anybody's

405
00:29:03,180 --> 00:29:07,500
dealt with large amounts of data that was input by humans over a period of time, you've

406
00:29:07,500 --> 00:29:11,940
probably run into situations like this where you have inconsistent data entry.

407
00:29:11,940 --> 00:29:14,660
So again you say, well I kind of just want these dash formats, because these are the

408
00:29:14,660 --> 00:29:17,060
only ones I really want to identify.

409
00:29:17,060 --> 00:29:23,780
So let's clear this and go back and look at how to fix a regular expression.

410
00:29:23,780 --> 00:29:27,980
So what I could do is just add one more number and I'm getting better.

411
00:29:27,980 --> 00:29:32,780
But still notice it's still matching out on these other numbers.

412
00:29:32,780 --> 00:29:38,140
So you notice that these are greedy matches, in other words, it keeps trying to match things.

413
00:29:38,140 --> 00:29:43,300
So I can keep adding these until I get the total number of characters that I want, but

414
00:29:43,300 --> 00:29:45,860
this is getting hard to read and getting long.

415
00:29:45,860 --> 00:29:46,940
So we just talked about characters.

416
00:29:46,940 --> 00:29:50,860
So I know my phone number is going to have three characters.

417
00:29:50,860 --> 00:29:57,020
So what this says is, look for a value that could be any value between zero and nine,

418
00:29:57,580 --> 00:29:59,060
look for three of them in a row.

419
00:29:59,060 --> 00:30:02,900
And they don't need to be the same number, like 222, it could be 215 or whatever.

420
00:30:02,900 --> 00:30:05,460
Then follow that with a dash.

421
00:30:05,460 --> 00:30:10,660
Then look for another series of numbers, zero through nine, and look for three of those.

422
00:30:10,660 --> 00:30:12,580
Let's run it.

423
00:30:12,580 --> 00:30:15,620
And it's still being a little too greedy, so we're going to have to extend it out here

424
00:30:15,620 --> 00:30:17,180
to get these four numbers.

425
00:30:17,180 --> 00:30:21,260
Also notice this file is a broken phone number in it.

426
00:30:21,260 --> 00:30:23,500
That's there on purpose, but we'll skip that for this exercise.

427
00:30:24,460 --> 00:30:30,900
Now I'm going to put another dash in, zero through nine, and I'm going to put the number four.

428
00:30:30,900 --> 00:30:37,300
And so what this says is, find three numbers, followed by a dash, followed by three numbers,

429
00:30:37,300 --> 00:30:41,500
followed by a dash, followed by four numbers.

430
00:30:41,500 --> 00:30:47,940
By the way, notice I'm using eGrep for this, and notice that it gave me the valid answer.

431
00:30:47,940 --> 00:30:53,460
If I use plain grep, I just want to point out that you'll get an error because in these

432
00:30:53,460 --> 00:30:57,420
curly brackets, there is a way to make them work in grep, but it's just easier to use

433
00:30:57,420 --> 00:31:03,580
eGrep because these curly brackets are part of the extended grep syntax.

434
00:31:03,580 --> 00:31:14,660
So just be sure that when you utilize numeric quantifiers that you utilize eGrep to do that.

435
00:31:14,660 --> 00:31:21,060
Now let's look at the plus question mark and star operators, and we'll go back to searching

436
00:31:21,060 --> 00:31:23,780
through files in the dictionary file.

437
00:31:23,780 --> 00:31:35,220
So let's say I wanted to find some words that have, start with a B, have an O, and then

438
00:31:35,220 --> 00:31:39,580
have the letter T, like bot.

439
00:31:39,580 --> 00:31:46,580
So I get a lot of things, saboteurs, robots, lobotomy, but what's interesting about that

440
00:31:46,580 --> 00:31:49,900
is it's definitely more information than I want.

441
00:31:49,900 --> 00:31:59,900
So let's say I'm curious about if there are words that have zero or one O's in them.

442
00:31:59,900 --> 00:32:07,860
And if I put a question mark, a question mark will say in this specific case that the O,

443
00:32:07,860 --> 00:32:10,940
there could be zero O's or there could be one O's.

444
00:32:10,940 --> 00:32:12,860
Let's see if we can make any changes.

445
00:32:12,860 --> 00:32:13,860
And I do.

446
00:32:13,860 --> 00:32:18,860
Notice that it matches subtropical and it matches turbot.

447
00:32:18,860 --> 00:32:24,740
It says, well, match any characters where there is an O or not an O.

448
00:32:24,740 --> 00:32:28,540
There could be zero O's or there could be one O.

449
00:32:28,540 --> 00:32:33,980
The plus sign will match one or more of a character.

450
00:32:33,980 --> 00:32:37,860
So in this case, it brings in toll booth as well as sabotage and robot.

451
00:32:37,860 --> 00:32:43,700
So notice there's two O's there, one O there.

452
00:32:43,700 --> 00:32:52,780
And then finally, we could use the star, which means zero to infinity.

453
00:32:52,780 --> 00:33:04,260
And so notice that star actually gives us the two O's, zero O's, and one O.

454
00:33:04,260 --> 00:33:09,100
Up to this point, we've been using grep to filter information so we can target stuff

455
00:33:09,100 --> 00:33:11,060
that we want in more detail.

456
00:33:11,060 --> 00:33:14,860
But we can also use regular expressions to find things and modify them.

457
00:33:14,860 --> 00:33:16,780
The set command is the stream editor.

458
00:33:16,780 --> 00:33:20,620
And while it can be a very powerful tool, what I want to do here is just kind of introduce

459
00:33:20,620 --> 00:33:25,220
how it works very basically so we have an idea how we can use regular expressions in

460
00:33:25,220 --> 00:33:26,900
a new and different way.

461
00:33:26,900 --> 00:33:33,180
So what this allows us to do is we can basically use the set editor to take stream of data

462
00:33:33,180 --> 00:33:39,300
and match against a pattern and then modify that information that matches that pattern

463
00:33:39,300 --> 00:33:40,300
in some way.

464
00:33:40,740 --> 00:33:44,860
One obvious way you could use this is to go through a bunch of files and find the old

465
00:33:44,860 --> 00:33:48,060
boss's name and replace it with the new boss's name.

466
00:33:48,060 --> 00:33:50,260
It's one way that I've actually used this.

467
00:33:50,260 --> 00:33:53,020
And there's a couple other things that are useful, so it's a great way to find something

468
00:33:53,020 --> 00:33:54,020
and replace it.

469
00:33:54,020 --> 00:33:55,940
So you can use set to find and replace stuff.

470
00:33:55,940 --> 00:33:59,480
It's a really powerful tool and we're going to only look at one aspect of it.

471
00:33:59,480 --> 00:34:04,540
So we're going to look at a command very similar to this one that's in this example.

472
00:34:04,540 --> 00:34:06,660
Let's jump over to the command line.

473
00:34:06,660 --> 00:34:09,020
Let's take a look at how set works.

474
00:34:09,020 --> 00:34:11,060
For this to work, we're going to actually need a file to edit.

475
00:34:11,060 --> 00:34:13,380
And so we're not going to actually edit the file in place today.

476
00:34:13,380 --> 00:34:17,940
We're just going to dump data out to standard output and what we're going to do is just

477
00:34:17,940 --> 00:34:20,620
modify what's printed to standard output.

478
00:34:20,620 --> 00:34:24,020
We could obviously redirect that back to another file.

479
00:34:24,020 --> 00:34:28,020
We could actually edit the file in place, but these are all some more advanced things.

480
00:34:28,020 --> 00:34:30,580
We just want to look at using regular expressions in a new way.

481
00:34:30,580 --> 00:34:35,900
So I am going to actually utilize the Etsy password file for this.

482
00:34:35,900 --> 00:34:39,820
And actually, if we just look at that file real quick, which you'll notice is that everything

483
00:34:39,820 --> 00:34:42,540
in here is separated by colons.

484
00:34:42,540 --> 00:34:45,220
So let's say I want to get rid of those colons.

485
00:34:45,220 --> 00:34:46,220
So let's use set.

486
00:34:46,220 --> 00:34:47,860
We'll get rid of this.

487
00:34:47,860 --> 00:34:52,620
So set dash E and dash E means I'm going to give set an expression.

488
00:34:52,620 --> 00:34:55,660
In this case, I'm going to use single quotes and a couple of things.

489
00:34:55,660 --> 00:34:59,100
I'm going to set this up and talk a little bit about what it means.

490
00:34:59,100 --> 00:35:03,860
Notice I've got single quote S slash slash slash G single quote.

491
00:35:03,860 --> 00:35:07,580
So whatever I want to find goes between the first two slashes.

492
00:35:07,580 --> 00:35:10,620
So in this case, I'm saying find the colon.

493
00:35:10,620 --> 00:35:14,220
And now I'm going to say replace it with three dashes.

494
00:35:14,220 --> 00:35:18,300
And what this will do is, said we'll go through the file, find every instance, and by the

495
00:35:18,300 --> 00:35:20,660
way, G stands for global.

496
00:35:20,660 --> 00:35:24,020
And that means it will find every instance of a colon in the file and replace it with

497
00:35:24,020 --> 00:35:25,020
three dashes.

498
00:35:25,020 --> 00:35:29,980
And if you look at my output, now instead of colons, you see a bunch of three dashes.

499
00:35:29,980 --> 00:35:35,420
So this can be really helpful for a bunch of reasons.

500
00:35:35,420 --> 00:35:39,260
One of the things that we can do too is we can use all of our new found regular expression

501
00:35:39,260 --> 00:35:40,420
powers in this file.

502
00:35:40,420 --> 00:35:45,820
So if we take another look at that password file, one of the things you'll notice at the

503
00:35:45,820 --> 00:35:48,940
top is, let's say there's a user called bin.

504
00:35:48,940 --> 00:35:52,540
But then you'll also notice that the word bin shows up a lot of times in this file.

505
00:35:52,540 --> 00:35:55,740
Let's say I just want to change that user bin.

506
00:35:55,740 --> 00:35:59,020
But I don't want to change any other instance of bin.

507
00:35:59,020 --> 00:36:04,620
So what I could do is, go back up to my previous command, and what I'm going to do is, instead

508
00:36:04,620 --> 00:36:08,500
of just match bin, which would match everything, I'm going to actually go ahead and what am

509
00:36:08,500 --> 00:36:09,500
I going to replace bin with?

510
00:36:09,500 --> 00:36:12,460
I'm going to replace it with JSON, really big.

511
00:36:12,460 --> 00:36:19,300
So if I just do that, notice it replaces every instance of bin in this file with the word

512
00:36:19,300 --> 00:36:20,300
JSON.

513
00:36:20,300 --> 00:36:23,940
It replaced the one I want, but then it replaced all these other instances.

514
00:36:23,940 --> 00:36:31,940
So what I want to do is, use an anchor.

515
00:36:31,940 --> 00:36:36,220
So I'm going to say, only match the bin that's at the start of the line.

516
00:36:36,220 --> 00:36:40,460
And now you'll notice that all the other bins are left in place, but if I scroll back up

517
00:36:40,460 --> 00:36:45,100
and look, it only replaced the one that was at the start of the line.

518
00:36:45,100 --> 00:36:49,140
So said it's a really powerful tool and we'll take a look at it more as the semester progresses.

519
00:36:49,140 --> 00:36:53,580
But in this case, I just want to show you that you can use your new found regular expression

520
00:36:53,580 --> 00:36:57,780
powers, not just a filter data for viewing, but filter data for editing.

