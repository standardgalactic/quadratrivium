start	end	text
0	7200	In this video lecture we're going to talk about regular expressions.
7200	11360	We'll also take a look at the command line utilities grep and sed.
11360	13080	So what are regular expressions?
13080	19400	Well regular expressions are patterns that we can build to match against specific series
19400	25020	of characters, you know, words, in a programming sense we can say strings.
25020	29800	We can use these patterns to pull out specific pieces of information from a larger set of
29800	31720	information that we're interested in.
31720	37400	So if we're looking at something like a very large log file, we can use a regular expression
37400	41560	to just isolate those aspects of the log file that we're interested in.
41560	47400	This is really great when you've got a lot of data to pick through on the command line.
47400	51920	We can also use regular expressions for finding data and then acting upon it and we'll take
51920	56480	a brief look at sed which is the stream editor later on in this video lecture.
56480	62040	So for now we're going to look at mostly a tool called grep which allows us to show
62040	69080	or not show specific aspects of a file that conform to one of our regular expression patterns.
69080	76600	So the command line grep utility is used to apply patterns to either standard input or
76600	78800	to a specific file.
78800	83000	And so we might have a very large file and what we're interested in doing is just taking
83000	85360	a look at certain aspects of it.
85360	90480	There's actually two forms of grep and grep stands for get regular expression and there's
90480	91480	also grep and egrep.
91480	97120	And what you're going to find is that because Unix is so old, it's had a lot of time to evolve
97120	102120	and sometimes people have gone on and extended aspects of Unix and in their sense of making
102120	103120	it better.
103120	107920	So the idea of grep and egrep is that grep is the original grep and egrep is extended
107920	108920	grep.
108920	112120	And extended grep actually supports extended regular expressions.
112120	116360	So anytime a language has been around for a long time, people try to start to add to
116360	120200	it when they start to notice failings in that language.
120200	126240	And what I'll mention is that we'll look at both extended and regular, regular expressions.
126240	128880	There's also pearl regular expressions, which I'm most familiar with.
128880	132380	So I also throw that out there when I'm talking about regular expressions.
132380	136900	Anytime I make an error, I will probably be thinking in terms of pearl regular expressions.
136900	142560	So enough about what regular expressions are, what utilities we're going to use, what
142560	148140	does a regular expression do and look like?
148140	155040	Let's think about a typical pattern that we might want to apply in this case.
155040	160140	Let's say that I have asked someone to look through the phone book or a directory of employees
160140	164860	and show me everybody whose last name starts with the letter s.
164860	166020	So I've given you a pattern.
166020	168300	I've given you a few bits of information.
168300	177820	I've said, okay, I want you to look at last name, oops, and I want that last name to start
177820	179580	with the letter s.
179580	190420	So if I have somebody whose name is, right, like John Smith, this would match my pattern
190420	195700	because I look at the last name and the first letter of that last name is an s.
195700	203260	Their name was Steve, John, I guess we'll stick with people with two first names.
203260	208860	Well, the first name starts with the letter s, but the last name doesn't, so it doesn't
208860	210220	match my pattern.
210220	217660	So we define patterns and we do so programmatically and we use those patterns to filter or match
217660	224340	against information that we're most interested in.
225060	230180	Let's look at some really basic ways that we can apply patterns on the command line.
230180	235820	I'm currently in my home directory and there's a number of folders and at least two files
235820	237420	in my home directory.
237420	243980	So there's actually some basic pattern matching capabilities built into the Bash shell.
243980	247020	So for example, if I want to see all of the folders that start with the capital letter
247020	252820	d, notice that if I just put the letter d, I get an error because it's going to say,
252820	260900	I can't find a folder or file named d, but if I add a star after the word d, I get a
260900	262580	lot of information.
262580	267460	In fact, I wanted to look just for folders, I would do dash d, which would give me information
267460	272100	about the directories as opposed to items inside the directories.
272100	278100	And this star character on the shell is called the file glob operator and basically you can
278100	280460	think of it like a wild card match.
280460	285140	And the pattern that I've essentially given the ls command here is that the ls command
285140	291140	should display all folders that start with the capital d and then folders that have any
291140	293580	number of characters following it.
293580	298980	So when I mean wild card, I mean any number from zero to an infinite amount and I mean
298980	300340	any type of character.
300340	305580	So basically this would match any folder that starts with d and goes ahead and has a bunch
305580	307340	of stuff in front of it.
307340	311500	You can also use a wild card at the front of a string, so I'm going to see any folder
311500	316900	that starts with the letter s and notice it shows me documents, downloads, pictures, templates
316900	319660	and videos because all of those end with a lower case s.
319660	324660	And remember that the command line is case sensitive, so if I do capital s, I get nothing.
324660	328980	You can also do something along the lines of putting two stars on the command line.
328980	333700	So I could say something like show me all directories that have any number of characters,
333700	338380	the letter l in them and then any number of characters on the other side.
338380	342820	And in this case it shows me downloads, examples.desktop, public and templates because all of these
342820	347540	have a letter l in the middle that we can see in each one of these and on either side
347540	354020	there is any given number of characters that match this wild card pattern.
354020	358020	So this is built into the shell and this can be really useful if you wanted to show say
358020	361460	all files in a directory and so if we look back up into the shell it will notice that
361460	365140	in my desktop directory I have a couple .txt files.
365140	373820	Let's clear this and let's say I wanted to do ls-l desktop star .txt and what this would
373820	379220	do is say okay go into my desktop directory, show me files that have any name and then
379220	387980	have a .txt extension and if I hit enter I see those two files sitting in my home directory.
387980	393740	So pretty cool that those exist and that this capability exists.
393740	399140	But what we want to do is we want to actually look at how we can utilize grep to get more
399140	406260	detail information about things like file directory listings and actual files themselves.
406260	409860	So ls is great when you're looking for just information about some listings and the wild
409860	414180	card is helpful for getting some basic pattern matching going.
414180	416860	But to learn regular expressions what we're going to do is we're going to look at a very
416860	425020	specific file on the Unix system and that file is the American English dictionary used
425020	427620	for spell checking and other things by the system.
427620	431500	So I'm going to pass the American English dictionary file which is found in slash user
431500	435940	slash share slash dict slash American English into the less command so we can see what's
435940	442020	in there and what you'll notice is this is a very large file that goes on and on and
442020	446060	on and on and keeps going and there's lots of words in it.
446060	452820	So this is really useful for our pattern matching exercises so I'm going to hit Q and we're
452820	458820	going to start to talk about some really basic regular expressions.
458820	462740	And the way we're going to do this is we're going to actually use the command grep.
462740	465640	Remember that I had mentioned there are actually grep and egrep.
465640	467900	So what we'll do is we'll use grep until it breaks.
467900	471140	In other words we'll use grep until we run into a feature that is an extended regular
471140	475900	expression and then we will jump over to using the egrep command.
475900	480100	Actually it's a better habit to just get into using egrep all the time and that way
480100	484940	you don't have to worry about what is an extended and what isn't an extended regular expression.
484940	488660	But I kind of want to mention, show you that at some point some of these features will
488660	489660	not work.
489660	499380	So I am going to actually set this up so that we can grep this file and the way greps work
499380	505660	is that we give the grep command what we'll do is right in here we'll put a pattern and
505660	509700	then we will actually go ahead and match it against a file.
509700	513700	And so the easiest pattern that I can put in here is I want to look for say words that
513700	514700	have cat in it.
514700	518460	So let's use cat and see what we get.
518460	521900	What you'll notice is a lot of words scroll by.
521900	526420	I gave the pattern cat and maybe you were thinking well I'll only see the word cat but
526420	532700	notice that it shows me every word in the file that has the letters cat somewhere in
532700	533700	the word.
533740	538140	So that's what the color coded command line is we can actually see the matches.
538140	543340	So that's kind of a nice feature for learning how to use regular expressions.
543340	547300	And you'll also notice that this is a really big file so at some point we'll look at we're
547300	550020	always going to see letters at the end of the alphabet just because of the way we're
550020	551020	doing this.
551020	555020	So let's clear this and take a look at that pattern again.
555020	561500	My pattern is called cat and for the rest of the exercise is the other things or is cat.
561500	564100	And I'm going to put these in double quotes because it'll make it a little bit easier to
564100	570660	see where our pattern is within these lectures and it'll also help us deal with any non-standard
570660	571660	characters.
571660	575340	In other words any characters that we want to match in our pattern but have special meaning
575340	579980	to the shell we want to make sure that those are not processed by the shell in a way that
579980	584100	the shell wants to process them putting them in double quotes kind of fixes that.
584100	585620	So what does this pattern say?
585620	590660	It says well look for a C followed by an A followed by a T and what you found out again
590660	594940	is when I run that command it doesn't really care if there's any characters before the
594940	602700	cat or after the word cat it just looks for those three characters in order.
602700	605540	So that's pretty interesting.
605540	611460	What if we wanted to look for not just cat but you were wondering like well I wonder
611460	615940	if there's a word that looks like cat that has another word in the middle.
615940	622380	And maybe you were thinking of like cut or cot and you wanted to find all of these.
622380	626180	Well regular expressions come with a special character which is the dot character and the
626180	630420	dot character will match one of any character.
630420	639920	So if there's actually a word called C2T then putting a dot there would match it.
639920	645060	So what this will match is a C followed by any one character followed by the letter T.
646060	650740	So you can just see in this little bit of information that we got I didn't even think
650740	655060	about words like yachts which have Cht or watchtower.
655060	663420	So we matched Cht, Cat, Cut, Cot and that's pretty cool.
663420	664420	Why?
664420	667580	Because the pattern used a dot.
667580	671180	So let's talk about why this is and let's look at some other patterns that we might have
671180	673020	available to us.
673020	676220	So what we just looked at was this idea of basic elements.
676220	680580	You can literally type a string and that will match the string or the series of characters
680580	686020	and in this case we can also then use dots in our series of characters to represent any
686020	689420	given one instance of any given character.
689420	692500	So notice my first example matches bat, cat, mat.
692500	697420	Finally if I just give the letters DOG it would match the literal string dog but found
697420	700940	anywhere in a word.
701020	705100	What's cool with regular expressions is we can start to get tricky.
705100	709380	And so in our previous example we found we used the dot to find any character but let's
709380	714620	say we only wanted to limit ourselves to finding a subset of any character and we can actually
714620	717380	create what are called classes of characters.
717380	722180	So we can have classes of characters by putting them into hard brackets and A-C will search
722180	730540	for an A or a B or a C followed by an A and a T and this would match bat and cat but not
730620	731620	rat.
731620	734260	And let's take a look at this in the command line in a second.
734260	741620	You can also use character classes to find uppercase, lowercase as well as numbers within
741620	742620	your strings.
742620	746500	Now again this is not looking for the number nine, this is looking for the character nine,
746500	748620	the symbol that represents the value nine.
748620	755180	So this is really just looking for a character zero through nine followed by another character
755180	759340	zero through nine and this would match forty two, thirty seven, ninety nine, zero one.
759340	765220	So basically match any two characters next to each other anywhere in a word.
765220	767180	So let's take a look at that.
767180	775100	So previously when we used the C dot T we matched cut, cat, cut.
775100	777180	So the O, the A and the U.
777180	782540	So let's say I don't want these watchtowers, CHT, I just want like C followed by a vowel
782540	785820	followed by a T.
785820	791380	So we can do that instead of using the dot I can create a character class.
791380	799300	And if I want I can try to match any vowel, I don't know what we'll get but we'll see.
799300	804620	And so what this says is look for the letter C followed by A, E, I, O, or U, just one of
804620	808300	those but it can choose amongst all of the values in that set followed by the letter
808300	810100	T.
810100	819340	And now if I look at my output I get veracity, I get wainscot, I get vocatives, I get wildcat
819340	827540	so I'm matching all the vowels between the letters C and T. All because of this character
827540	830140	set that I've made.
830140	833300	If you want to try and find any words in the dictionary, so that's character sets.
833300	836820	And by the way you can use these and we'll see these in a second, if you want to match
836820	841860	all lowercase characters you would do A through Z. You can also say find all lowercase and
841860	847100	all uppercase characters which maybe you're looking for usernames or something along those
847100	848100	lines.
848100	852260	And then if you wanted to you could also add 0 through 9 and say like the underbar.
852260	855740	And what that would do is match for all of those characters so you can have these sets
855740	859820	of characters be as small or as large as you want them to be.
859820	864180	I'm going to do is changes, let's see if there's any words that have 0 through 9, I doubt it.
864180	865740	And nothing matches that pattern.
865740	869260	That's what happens when you put in a pattern that doesn't match.
869260	872500	Let's see if there's anything in the dictionary that matches against a number.
872500	878020	Nope, so there are no numbers in the American English dictionary on the Unix system.
878020	880020	So it's kind of helpful.
880020	885340	There's a couple other things that we could actually use if we wanted to grep numbers.
885340	889420	What I'll do right now is just to look at what we could possibly grep for a number would
889420	891780	be the Etsy password file.
891780	894220	And if I grep that I know there's a lot of numbers in there so I'm going to get a lot
894220	900380	of matches and you'll notice that it matched all of these lines because all of the lines
900380	901700	have a number in them.
901700	905860	Again, the Etsy password files just shows you all the user accounts on the system and
905860	909100	these numbers represent their user and group IDs.
909100	911580	So I know that there were a lot of numeric matches in this file.
911580	917540	So just to kind of demonstrate that you can match against numbers as well as words.
917540	920900	So kind of helpful.
920900	925340	Let's go back to an example where we can start to look at the English dictionary.
925340	931780	So let's look at some other options for this feature, this ability to use character classes.
931780	937980	Built into Unix is this idea of these really what I think are pretty ugly character classes.
937980	940660	You'll see these sometimes built into the system.
940660	946700	So bracket, bracket, colon, alpha, colon, bracket, bracket is the same as building your own character
946700	951260	class that uses bracket A through Z, capital A through Z.
951260	957100	And basically what these things on the left are are just ways of writing these out using
957100	961660	words as opposed to using the categories A through Z.
961660	964820	Pretty much if you haven't figured this out at this point in Unix, there's 50 ways to
964820	965820	do everything.
965820	969660	So these character class abbreviations can be helpful.
969660	971860	They make things a little more readable in scripts.
971860	975540	But the other thing if you haven't noticed is that regular expressions can get pretty
975540	978900	big and pretty scary pretty fast.
978900	982660	I would say the most useful character class that we're looking at right here is the one
982660	985860	called space because that will match any white space characters.
985860	987980	That includes tabs and spaces.
987980	993300	That can be really helpful when trying to match words or sentences that have spaces.
993300	998300	Or in my first example, we talked about last names and that would really be helpful for
998300	1002260	processing, finding somebody's last name.
1002260	1006980	Because I don't like these, I'm mostly familiar with these character class abbreviations.
1006980	1009460	So notice there's two character class abbreviations.
1009460	1013020	The previous ones with the words like alpha, upper, and lower.
1013020	1018580	But then there's also these character class abbreviations, slash D, slash W, slash S,
1018580	1025420	slash S that make things a little bit more readable when we start to use these in larger
1025420	1026980	regular expressions.
1026980	1030820	I'll also mention that there are actually ways to negate character classes.
1030820	1037060	If you notice the carrot inside of the bracket-based classes at the bottom here, you'll notice
1037060	1040020	that that means does not match this character.
1040020	1045580	And if you do slash capital D, slash capital W, slash capital S, that means that you do
1045580	1048420	not want to match that character in that given position.
1048420	1051620	I don't usually teach those when I introduce regular expressions because it's hard enough
1051620	1056180	getting your head around regular expressions, let alone getting your head around negative
1056180	1057540	logic at the same time.
1057540	1060980	So we'll just kind of mention that they're there and just ignore that.
1060980	1068540	So let's look at these two character class sets in operation.
1068540	1076700	So let's say I want to find a word that has any letter in it.
1076700	1082260	Well notice I just did that and I said that I wanted to find a slash D, but notice that
1082260	1086780	it actually went ahead and found all of these words with the character D.
1086780	1087780	Well that's a problem.
1087780	1093260	You're thinking, well Jason, wait, you just showed us that slash D is a character class.
1093260	1094260	But here's the thing.
1094260	1097460	Remember earlier on I said there's grep and there's extended grep?
1097460	1100140	Well these slash D character sets are actually part of extended grep.
1100140	1107180	So if I switch to eGrep, it still doesn't work, which is a problem because I'm trying
1107180	1108100	to explain this.
1117780	1123380	Once you'll notice is that the slash D doesn't work, it actually goes ahead and finds the
1123380	1125340	letter D within here.
1125340	1129900	Slash D is actually a part of Perl regular expression.
1129900	1133420	So if I actually add dash P, you'll note that it returns nothing.
1133420	1137380	So that actually says u slash D, like it's a Perl regular expression and that'll pass
1137380	1138380	numbers.
1138380	1141060	So that doesn't actually work in grep or eGrep.
1141060	1145540	But if I get rid of the dash P and just go with regular extended grep, what you'll find
1145540	1152940	is I can actually utilize slash W. And that matches any character in any word that we
1152940	1153940	might be looking at.
1153940	1156380	So that one does work.
1156380	1162580	And if we go ahead and we look at slash S, what you'll notice is that that also returns
1162580	1164220	nothing.
1164220	1169420	So it looks like slash D is one of those cases where that's more of a Perl thing than it
1169420	1171900	is an extended grep thing.
1171900	1173980	So I'll apologize for that and keep going.
1173980	1179540	Or slash D is the same as typing 0 through 9.
1179540	1186340	So you don't need to worry about the fact that slash D is not supported in eGrep.
1186340	1189540	Let's take a look at some other ways that we can build patterns.
1189540	1194260	We'll start out by taking a look at what are called anchors or positional anchors.
1194260	1198980	In other words, we can say that a certain character has to match at a certain point on
1198980	1203420	a line, either at the beginning of the line or at the end of the line.
1203420	1207740	And you'll see that the characters that we're going to use for these beginning and end of
1207740	1212740	line matches are a carrot and a dollar sign.
1212740	1217100	And you'll notice that in the example in front of you, putting a carrot means to match only
1217100	1221940	the word car, where car is the first line character on the line.
1221940	1228020	So it would match car, cattle, and canine, where those are the first words on a line.
1228020	1231660	And the second example, floating and sailing, would match because the G is at the end of
1231660	1234580	the line if those are the only words on the line.
1234580	1239380	And if you'd like to match situations where a word is the only word on a given line, such
1239380	1243420	as cat, you would want a line that starts with the letter C, a line that ends with the
1243420	1246060	letter T. We'll take a look at these in one second.
1246060	1250460	Let's look at another possible anchor that we can use, which is a word boundary.
1250460	1254500	So remember, the carrot character and the dollar sign character have to do with the beginning
1254500	1256340	and the end of line.
1256340	1264860	And word boundaries give us the ability to match on spaces, tabs, and basically these
1264860	1268780	positions where there might be breaks between words.
1268780	1275220	So in the example that I've got at the bottom, if I wanted to match Jason the prof, S-O-N
1275220	1277300	is anchored on a word boundary.
1277300	1280220	So there's a space between my name and the word the.
1280220	1283300	So S-O-N slash B would match that line.
1283300	1287340	Actually, there's no other instance of S-O-N on that line, but let's say I was in a file
1287340	1294100	that had a lot of people named Jason, but I was the only one with the surname the prof.
1294100	1295100	It would match.
1295100	1302460	So let's take a look at how word boundaries and anchors work in real life.
1302460	1308660	So to match items in word boundaries, we really need a file to do this.
1308660	1312860	So what I'm going to do is take another look at the Etsy password file.
1312860	1317100	I've also bumped up the font, so hopefully things are a little bit easier to see.
1317100	1320940	So what you'll notice is in the Etsy password file, there's a number of lines here.
1320940	1324500	So I've got root, demon, bin, sys.
1324500	1328580	So let's say I only want to see lines that start with the letter S. There's a couple
1328580	1329580	of them.
1329580	1335020	So I'm going to use eGREP, and I'm going to say that I want to look at lines that start
1335020	1339660	with the letter S, and I want to look at the Etsy password file.
1339660	1344220	And what you'll notice is that shows me lines that just start with the letter S. Notice
1344220	1346580	that the letter S might be in other parts of the line.
1346580	1352780	If I take out that position qualifier, what you'll notice is that the letter S appears
1352780	1358100	on many more lines, but I only want to be interested in those lines where the letter
1358100	1360300	S is at the beginning.
1361060	1366900	If I want to see which lines have at the end, the letter N, I can put a dollar sign, and
1366900	1371860	it'll show me only the lines that end in the letter N. Let's try H. I was thinking bin,
1371860	1374220	but I think I meant bash.
1374220	1382060	And so what it'll show you is that many of these user accounts use the bash shell.
1382060	1386820	And let's say, notice in this case I'm seeing bash and SH.
1386860	1392460	Let's say I'm only concerned about those users in this file that have the login shell bash.
1392460	1395220	So let's see how we can fix that.
1395220	1401140	Instead of just saying H, I could say bash, and what this will say is the last letter
1401140	1407940	on the line must be an H, but before it must come a B, A, and an S. And now I get exactly
1407940	1411420	the information I want, lines that end with bash.
1411420	1420980	So that's the concept behind positional values within regular expressions.
1420980	1425420	What I have here is a file called demo that contains two lines.
1425420	1429180	One is JSON space, the space prof, and the other line is JSONium.
1429180	1431420	So maybe I have my own element.
1431420	1436300	And if I grab this file for my name, what you're going to notice is that it shows me
1436300	1437500	both lines.
1437580	1441980	Maybe I only want to show those lines where it's actually my name and not my name embedded
1441980	1443220	in another word.
1443220	1448340	And the way I can do this is to add a word boundary to my regular expression.
1448340	1451340	And remember slash B means word boundary.
1451340	1459340	And so now it will only show me the JSON that is up against a word boundary.
1459340	1463660	So it's pretty helpful when you know you have spaces in a file and you want to find words
1463660	1465820	that you know are on a space.
1465820	1470060	The last thing for us to review is the concept of quantifiers in a regular expression.
1470060	1475420	Sometimes you want to look for zero or one or two or three of a certain character to
1475420	1477140	appear in a certain spot.
1477140	1481420	Other times you want to know exactly a specific number of items that you want to appear in
1481420	1484340	a given spot in your regular expression.
1484340	1490940	And so regular expressions come with the plus question mark and star operator.
1490940	1495580	And while the star operator seems to work like it does on the shell, it's important to
1495580	1500820	note that there is a slight difference between the file glob operator on the bash command
1500820	1505180	line as opposed to the star operator within a regular expression.
1505180	1510060	So how would we actually utilize these within some regular expressions?
1510060	1514100	Well let's take a look at some sample regular expressions and then we'll go to the command
1514100	1515940	line.
1515940	1523460	So here's a sample regular expression that matches a phone number in the order of 555-555-5555.
1523460	1529100	So typical US phone number, three digits dash, three digits dash, four digits.
1529100	1533580	And you'll notice that I've got some positional notations here.
1533580	1537580	So the line starts with a carrot and ends with a dollar sign.
1537580	1541100	And notice that I've got a character class zero through nine.
1541100	1546580	And since I know I want to match three characters, I could actually type bracket zero dash nine
1546580	1551500	bracket, bracket zero dash nine bracket, bracket zero dash nine bracket dash.
1551540	1557380	Or notice in this case I can use curly bracket three curly bracket, which says match exactly
1557380	1561140	three of whatever you find before you.
1561140	1566580	So we can actually use these curly bracket number, curly bracket notations to kind of
1566580	1569580	make our regular expressions a little more condensed.
1569580	1573300	So we'll look at this on the command line in a second and discuss.
1573300	1580180	Also talked a little bit about the slash w slash b kind of type word boundary commands
1580180	1583500	and the slash w character class commands.
1583500	1587300	And you'll notice that I've written a really poor regular expression here that matches
1587300	1589140	an email address.
1589140	1592820	Regular expression email address matching can be helpful, but it's not something I would
1592820	1597380	rely on because there's a number of email address formats and it's too complicated to
1597380	1599580	really catch all of them.
1599580	1605100	If you do a Google search for email address regular expression, take a look at some of
1605100	1606100	the answers that you get.
1606100	1608100	They're pretty long and detailed.
1608660	1613140	But what you'll notice is this email address says it's also positionally situated.
1613140	1615140	So it's got a carat and a dollar sign.
1615140	1617340	So the only thing on this line should be an email address.
1617340	1621020	It says find any number of word characters.
1621020	1624300	So you'll notice that the star in this case says, and you'll notice the same thing with
1624300	1629060	the number, the curly bracket three notation is it affects whatever is to the left of it.
1629060	1634980	So this is look for any letter or number or valid email address character and then star
1634980	1641300	after it means any number of valid email address characters, followed by an at, followed any
1641300	1647060	number of valid characters, letters or numbers, followed by a dot, followed by any other number
1647060	1649900	of valid letters or characters.
1649900	1653100	Notice also that because I actually wanted a dot here, I didn't want to look for, remember
1653100	1656140	that a dot has a special meaning with regular expressions.
1656140	1661300	Anytime you want to tell a regular expression to use the actual character and not interpret
1661300	1666060	it as a special regular expression character, you just put a slash in front of it.
1666060	1670580	So let's take a look at how some of these components can work on the command line.
1670580	1675860	I have a file that might be the file you're using for your lab.
1675860	1679540	And if we look at the file lab3test.txt, what you're going to notice is it's a file full
1679540	1681900	of names and phone numbers.
1681900	1684380	So we're just going to look at matching the phone numbers since I've already given you
1684380	1686180	a regular expression that does that.
1686180	1688020	Let's see how that works.
1688020	1694820	I want to build a regular expression to match just valid phone numbers in this file.
1694820	1698420	So I'm going to use egrep and I'm going to put my pattern in here and I'm going to use
1698420	1701100	lab3test.txt as my file.
1701100	1708020	So before I said if I really wanted to match a phone number, I could write a regular expression
1708020	1712140	that looks like this.
1712140	1715780	And if I just run that, I'm not going to type, notice it matches any line that has three
1715780	1719460	numbers in a row, or any instance of three numbers in a row.
1719460	1723100	But notice it also gets these kind of user IDs over here.
1723100	1731380	So then I could say as well, what if I match a dash, let me clear this, and then what if
1731380	1732380	I add a dash?
1732380	1736900	Well now we're getting better, we're getting closer, because it's matching, it's no longer
1736900	1738700	matching these IDs on the left.
1738700	1743180	But it is matching these two multi-formatted phone numbers and by the way, if anybody's
1743180	1747500	dealt with large amounts of data that was input by humans over a period of time, you've
1747500	1751940	probably run into situations like this where you have inconsistent data entry.
1751940	1754660	So again you say, well I kind of just want these dash formats, because these are the
1754660	1757060	only ones I really want to identify.
1757060	1763780	So let's clear this and go back and look at how to fix a regular expression.
1763780	1767980	So what I could do is just add one more number and I'm getting better.
1767980	1772780	But still notice it's still matching out on these other numbers.
1772780	1778140	So you notice that these are greedy matches, in other words, it keeps trying to match things.
1778140	1783300	So I can keep adding these until I get the total number of characters that I want, but
1783300	1785860	this is getting hard to read and getting long.
1785860	1786940	So we just talked about characters.
1786940	1790860	So I know my phone number is going to have three characters.
1790860	1797020	So what this says is, look for a value that could be any value between zero and nine,
1797580	1799060	look for three of them in a row.
1799060	1802900	And they don't need to be the same number, like 222, it could be 215 or whatever.
1802900	1805460	Then follow that with a dash.
1805460	1810660	Then look for another series of numbers, zero through nine, and look for three of those.
1810660	1812580	Let's run it.
1812580	1815620	And it's still being a little too greedy, so we're going to have to extend it out here
1815620	1817180	to get these four numbers.
1817180	1821260	Also notice this file is a broken phone number in it.
1821260	1823500	That's there on purpose, but we'll skip that for this exercise.
1824460	1830900	Now I'm going to put another dash in, zero through nine, and I'm going to put the number four.
1830900	1837300	And so what this says is, find three numbers, followed by a dash, followed by three numbers,
1837300	1841500	followed by a dash, followed by four numbers.
1841500	1847940	By the way, notice I'm using eGrep for this, and notice that it gave me the valid answer.
1847940	1853460	If I use plain grep, I just want to point out that you'll get an error because in these
1853460	1857420	curly brackets, there is a way to make them work in grep, but it's just easier to use
1857420	1863580	eGrep because these curly brackets are part of the extended grep syntax.
1863580	1874660	So just be sure that when you utilize numeric quantifiers that you utilize eGrep to do that.
1874660	1881060	Now let's look at the plus question mark and star operators, and we'll go back to searching
1881060	1883780	through files in the dictionary file.
1883780	1895220	So let's say I wanted to find some words that have, start with a B, have an O, and then
1895220	1899580	have the letter T, like bot.
1899580	1906580	So I get a lot of things, saboteurs, robots, lobotomy, but what's interesting about that
1906580	1909900	is it's definitely more information than I want.
1909900	1919900	So let's say I'm curious about if there are words that have zero or one O's in them.
1919900	1927860	And if I put a question mark, a question mark will say in this specific case that the O,
1927860	1930940	there could be zero O's or there could be one O's.
1930940	1932860	Let's see if we can make any changes.
1932860	1933860	And I do.
1933860	1938860	Notice that it matches subtropical and it matches turbot.
1938860	1944740	It says, well, match any characters where there is an O or not an O.
1944740	1948540	There could be zero O's or there could be one O.
1948540	1953980	The plus sign will match one or more of a character.
1953980	1957860	So in this case, it brings in toll booth as well as sabotage and robot.
1957860	1963700	So notice there's two O's there, one O there.
1963700	1972780	And then finally, we could use the star, which means zero to infinity.
1972780	1984260	And so notice that star actually gives us the two O's, zero O's, and one O.
1984260	1989100	Up to this point, we've been using grep to filter information so we can target stuff
1989100	1991060	that we want in more detail.
1991060	1994860	But we can also use regular expressions to find things and modify them.
1994860	1996780	The set command is the stream editor.
1996780	2000620	And while it can be a very powerful tool, what I want to do here is just kind of introduce
2000620	2005220	how it works very basically so we have an idea how we can use regular expressions in
2005220	2006900	a new and different way.
2006900	2013180	So what this allows us to do is we can basically use the set editor to take stream of data
2013180	2019300	and match against a pattern and then modify that information that matches that pattern
2019300	2020300	in some way.
2020740	2024860	One obvious way you could use this is to go through a bunch of files and find the old
2024860	2028060	boss's name and replace it with the new boss's name.
2028060	2030260	It's one way that I've actually used this.
2030260	2033020	And there's a couple other things that are useful, so it's a great way to find something
2033020	2034020	and replace it.
2034020	2035940	So you can use set to find and replace stuff.
2035940	2039480	It's a really powerful tool and we're going to only look at one aspect of it.
2039480	2044540	So we're going to look at a command very similar to this one that's in this example.
2044540	2046660	Let's jump over to the command line.
2046660	2049020	Let's take a look at how set works.
2049020	2051060	For this to work, we're going to actually need a file to edit.
2051060	2053380	And so we're not going to actually edit the file in place today.
2053380	2057940	We're just going to dump data out to standard output and what we're going to do is just
2057940	2060620	modify what's printed to standard output.
2060620	2064020	We could obviously redirect that back to another file.
2064020	2068020	We could actually edit the file in place, but these are all some more advanced things.
2068020	2070580	We just want to look at using regular expressions in a new way.
2070580	2075900	So I am going to actually utilize the Etsy password file for this.
2075900	2079820	And actually, if we just look at that file real quick, which you'll notice is that everything
2079820	2082540	in here is separated by colons.
2082540	2085220	So let's say I want to get rid of those colons.
2085220	2086220	So let's use set.
2086220	2087860	We'll get rid of this.
2087860	2092620	So set dash E and dash E means I'm going to give set an expression.
2092620	2095660	In this case, I'm going to use single quotes and a couple of things.
2095660	2099100	I'm going to set this up and talk a little bit about what it means.
2099100	2103860	Notice I've got single quote S slash slash slash G single quote.
2103860	2107580	So whatever I want to find goes between the first two slashes.
2107580	2110620	So in this case, I'm saying find the colon.
2110620	2114220	And now I'm going to say replace it with three dashes.
2114220	2118300	And what this will do is, said we'll go through the file, find every instance, and by the
2118300	2120660	way, G stands for global.
2120660	2124020	And that means it will find every instance of a colon in the file and replace it with
2124020	2125020	three dashes.
2125020	2129980	And if you look at my output, now instead of colons, you see a bunch of three dashes.
2129980	2135420	So this can be really helpful for a bunch of reasons.
2135420	2139260	One of the things that we can do too is we can use all of our new found regular expression
2139260	2140420	powers in this file.
2140420	2145820	So if we take another look at that password file, one of the things you'll notice at the
2145820	2148940	top is, let's say there's a user called bin.
2148940	2152540	But then you'll also notice that the word bin shows up a lot of times in this file.
2152540	2155740	Let's say I just want to change that user bin.
2155740	2159020	But I don't want to change any other instance of bin.
2159020	2164620	So what I could do is, go back up to my previous command, and what I'm going to do is, instead
2164620	2168500	of just match bin, which would match everything, I'm going to actually go ahead and what am
2168500	2169500	I going to replace bin with?
2169500	2172460	I'm going to replace it with JSON, really big.
2172460	2179300	So if I just do that, notice it replaces every instance of bin in this file with the word
2179300	2180300	JSON.
2180300	2183940	It replaced the one I want, but then it replaced all these other instances.
2183940	2191940	So what I want to do is, use an anchor.
2191940	2196220	So I'm going to say, only match the bin that's at the start of the line.
2196220	2200460	And now you'll notice that all the other bins are left in place, but if I scroll back up
2200460	2205100	and look, it only replaced the one that was at the start of the line.
2205100	2209140	So said it's a really powerful tool and we'll take a look at it more as the semester progresses.
2209140	2213580	But in this case, I just want to show you that you can use your new found regular expression
2213580	2217780	powers, not just a filter data for viewing, but filter data for editing.
