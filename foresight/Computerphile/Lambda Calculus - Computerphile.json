{"text": " Today we're going to talk about one of my favourite topics in computer science, which is the lambda calculus, and in particular we're going to talk about three things. We're going to think what actually is it, why is it useful, and where did it actually come from. So we're going to start with the last question here, where did it actually come from? This is Alonzo Church, who was a mathematician at Princeton University in the United States, and he was the person who invented the lambda calculus, and what he was interested in is what is the notion of a function from a computational perspective? And his answer to this question is what we now know as the lambda calculus. And there's an interesting piece of history here, which many people don't know, so it turns out that Alonzo Church was the PhD supervisor of someone very famous in computer science, Alan Turing. And of course Alan Turing, amongst many other things which he did, he invented Turing machines, which Computerphile has done a number of videos on, and Turing machines capture a basic state-based model of computation. And it's interesting that his PhD supervisor, Alonzo Church, he captured a basic functional notion of computation with his lambda calculus. And it turns out that these two quite different notions, one functional and one state-based, turn out to be equivalent. And this is what's called the Church Turing Hypothesis, or part of the Church Turing Hypothesis. So for Church, a function was a black box that you're not allowed to look inside, and what it does is it takes some input, so maybe it takes a number like x, and it's going to process it in some way, and it's going to produce an output. So maybe it produces the output x plus one. So this would be a function that takes a single input, a number called x, processes it in some way, and then produces a single output, which is the number x plus one. Then we could have a slightly more interesting example. Maybe we have a box with two inputs, x and y, and we process them in some way, and maybe we produce their sum as the output. So this would be a function which takes two inputs, x and y, processes them in some way, and then produces their sum x plus y. And there's two important things about functions in this sense. The first is that they're black boxes. You're not allowed to look inside them. You can't see the mechanics of what's going on inside this box. All you can do is put something in and observe what comes out the other side. And the second important thing is that these functions are pure. They have no internal state. So all that happens when you map x across to x plus one is the magic goes on inside the box, and there's no internal state. There's no hidden information that we can use. And this is quite different from the notion of computation that Alan Turing was interested in with his Turing machines. He had internal state. There's no internal state. These are pure mathematical functions. Now we can think how do you actually define functions in the lambda calculus? And there's a very, very simple syntax for this which I'll introduce to you now. So let's think about the increment function in the lambda calculus. What you do is you write down a lambda symbol. So this is the Greek lowercase letter lambda. And that says we're introducing a function at this point. And then you just write down the name of the input. So that was x. And then you have a dot. And then you say how the output is calculated in terms of the input. So that's x plus one. So we could do the same with addition. You just need two lambdas. You write lambda x dot lambda y dot x plus y. So this is the function that takes two inputs, x and y, and then delivers the result x plus y. And this is written down formally in Church's lambda calculus exactly like this. So when you've got a function, what can you do with it? Well, all you can do is give it some input, let it do its thing, and it will give you some output. So let's have a simple example of this. If we take a function like increment, which was lambda x, x plus one, and we apply it to a number like five, what actually happens? It's a basic process of substitution. We're essentially substituting the number five here into the body of this lambda expression. And then x becomes five. So we get five plus one. And then we get the result six on the other side. And this is basically all there is to the lambda calculus. It's only got three things. It's got variables like x, y and z. It's got a way of building functions, this lambda notation, and it's got a way of applying functions. This is the only three things that you have in this setting. What is actually the point of the lambda calculus? We've introduced this very simple notation. Why should you be interested in learning about it? I think there's three answers which I would give to this. The first point I'd make is that the lambda calculus can encode any computation. If you write a program in any programming language, which has ever been invented or ever will be invented or really any sequential programming language, it can in some way be encoded in the lambda calculus. And of course it may be extremely inefficient when you do that, but that's not the point. This is a basic idea of computation and we want to think how many, what kind of programs can we encode in this? And actually you can encode anything. And this is really the kind of church-turing hypothesis which I mentioned. Alan Turing, you can code anything in his Turing machines and in churches lambda calculus you can encode anything. And actually these two systems are formally equivalent. Any Turing machine program can be translated into equivalent lambda calculus program and vice versa. They're formally equivalent. The second point I would make is that lambda calculus can also be regarded as the basis for functional programming languages like Haskell. So these are becoming increasingly popular these days and actually a very sophisticated language like Haskell is compiled down to a very small core language which is essentially a glorified form of lambda calculus. So if you're interested in functional programming names like Haskell or the ML family, these are all fundamentally based on the lambda calculus. It's just kind of a glorified syntax on top of that. The third point which I would make is that the lambda calculus is actually now present in most major programming languages. So this wasn't the case 10 or 15 years ago, but it is the case today. So if you look at languages like Java, like C-sharp, even Visual Basic, F-sharp and so on, all of these languages now encode lambda calculus or include lambda calculus as a fundamental component. So every computer scientist today needs to know about lambda calculus. What I'd like to end up with is a couple of little examples of what you can do with it. So the lambda calculus has basically got nothing in it. It's got variables, it's got a way of building functions and it's got a way of applying functions. It doesn't have any built-in data types like numbers or logical values, recursion and things like that. So if you want to do these things in the lambda calculus, you need to encode them. So I'll end up showing you a simple encoding. And the encoding which I'm going to show you is the logical values, true and false. And the key to this is to think, what do you do with logical values in a programming language? And the basic observation is that you use them to make a choice between doing two things. You say, if something is true, do one thing. If something is false, do another thing. And we're going to use this idea of making a choice between two things to actually encode true and false. So the trick is for true, you write down this lambda expression. So what it does is it takes two things x and y and then it chooses the first. And false does the opposite. It's going to take two things and it's going to choose the second. So we've got two lambda expressions here, both of which take two inputs x and y, and one chooses the first one x and one chooses the second one y. So fair enough, what can we actually do with this? Well, let's think how we could define a little logical operator. So not is the most simple logical operator, which I could think of. It's going to flip true to false and false to true. It's logical negation. Based upon this encoding, how could I actually define the not operator or the not function? Well, it's very easy to do. I will take in a logical value or a Boolean, as it's normally called in computer science, after George Boo who first studied kind of formal logic. So we take a Boolean, which will be one of true or false. And here's what we do. We apply it to false and we apply it to true. And I claim that this is a valid definition for a not function. But I can very easily convince you that it's the case because I can do a little calculation. So let's check if we apply not to true that we actually get false. And just a few steps using the lambda calculus magic, we'll find that this actually works out. So what can we do here? Well, the only thing we can do is start to expand definitions. So we know what the definition of not is. It was lambda b, b applied to false and true, and then we just copy down the true. So all I've done in the first step here is I've expanded my definition of not. Not was defined to be this lambda calculus expression here. Now I've got a function, which is this thing, and it's applied to an input. So I can just apply it. Okay. And the function says if I take in a b, I just apply that b to false and true. So the thing I'm applying it to is true here. So I just do the little substitution, rather than b, I write true, and then I copy down the false and copy down the true, and I get down to here. And at this point, you might quite rightly be thinking this looks like complete rubbish. I mean, I've just written true, false, true. What does that mean? It means absolutely nothing. But it means something in the lambda calculus because we continue to expand. So what we can do now is expand the definition of true. We said that true takes two things and chooses the first one. So let's expand it out. So true is lambda x, lambda y, x. So it chooses the first thing of two things. And then we just copy down the two inputs, false and true. And you can see what's going to happen now. We've got a function here, which takes two things and chooses the first thing. Here, the first thing is false. So when we apply the function, we just get back false. So what you see has happened here. In just a few steps, we've shown how using this encoding of true and false and not, we can actually get the desired behavior. And it's very easy to check for yourself. If you apply not to false, you'll get true. And I'd like to set your little kind of puzzle at this point. Think how you could define logical and or logical or in this style as well. Okay, and I'm interested to see what kind of definitions people come up with in the comments. So the very last thing I'd like to show you is this lambda expression here, which is a very famous lambda calculus expression called the y combinator or the y operator. And actually, this is the key to doing recursion in the lambda calculus. So as I mentioned, lambda calculus has basically nothing in it, or it's only got three things in it, variables x, y and z, and so on, a way of building functions and a way of applying functions. It's got no other control structures, no other data types, no anything. So if you want to do recursion, which is the basic mechanism for defining things in terms of themselves, again, computer files had videos on this, you need to encode it. It turns out that this expression here is the key to encoding recursion in the lambda calculus. And this expression was invented by someone called Haskell Curry. And this is the Haskell that gives his name to the Haskell programming language. And he was a PhD student of David Hilbert, who's a very famous mathematician. The last observation I'd like to leave you with here is something that's interested me for many years. I think there's a connection between this piece of kind of abstract computer science or abstract mathematics and biology. If you look at human DNA, you have this double helix structure. You have two copies of the same thing side by side. And this is the key to allowing DNA to self replicate. If you look at the structure of this lambda expression here, you have two copies of the same thing side by side. You have lambda x f applied to xx and exactly the same here. And this is the key to doing recursion, which is kind of related to self replication in a programming language or in the lambda calculus. And for me, I don't think this is a coincidence. I think it's a kind of interesting philosophical observation. The lambda calculus has this kind of very clever way of doing recursion, which would take a video on its own to explain how it actually works. But you can look it up on Wikipedia. And there's a link here, I think, to biology. Somebody actually found the Y Combinator so interesting that they've had it tattooed permanently on their arm. And you can find the picture of this if you do a quick web search. What would people search for the Y Combinator? The Y Combinator in mathematics or computer science. And tattoo, I'm guessing.", "segments": [{"id": 0, "seek": 0, "start": 0.0, "end": 3.84, "text": " Today we're going to talk about one of my favourite topics in computer science,", "tokens": [50364, 2692, 321, 434, 516, 281, 751, 466, 472, 295, 452, 10696, 8378, 294, 3820, 3497, 11, 50556], "temperature": 0.0, "avg_logprob": -0.1462085524270701, "compression_ratio": 1.8229166666666667, "no_speech_prob": 0.003367119934409857}, {"id": 1, "seek": 0, "start": 3.84, "end": 8.56, "text": " which is the lambda calculus, and in particular we're going to talk about three things.", "tokens": [50556, 597, 307, 264, 13607, 33400, 11, 293, 294, 1729, 321, 434, 516, 281, 751, 466, 1045, 721, 13, 50792], "temperature": 0.0, "avg_logprob": -0.1462085524270701, "compression_ratio": 1.8229166666666667, "no_speech_prob": 0.003367119934409857}, {"id": 2, "seek": 0, "start": 8.56, "end": 15.44, "text": " We're going to think what actually is it, why is it useful, and where did it actually come from.", "tokens": [50792, 492, 434, 516, 281, 519, 437, 767, 307, 309, 11, 983, 307, 309, 4420, 11, 293, 689, 630, 309, 767, 808, 490, 13, 51136], "temperature": 0.0, "avg_logprob": -0.1462085524270701, "compression_ratio": 1.8229166666666667, "no_speech_prob": 0.003367119934409857}, {"id": 3, "seek": 0, "start": 15.44, "end": 20.240000000000002, "text": " So we're going to start with the last question here, where did it actually come from?", "tokens": [51136, 407, 321, 434, 516, 281, 722, 365, 264, 1036, 1168, 510, 11, 689, 630, 309, 767, 808, 490, 30, 51376], "temperature": 0.0, "avg_logprob": -0.1462085524270701, "compression_ratio": 1.8229166666666667, "no_speech_prob": 0.003367119934409857}, {"id": 4, "seek": 2024, "start": 20.24, "end": 30.32, "text": " This is Alonzo Church, who was a mathematician at Princeton University in the United States,", "tokens": [50364, 639, 307, 967, 266, 4765, 7882, 11, 567, 390, 257, 48281, 412, 36592, 3535, 294, 264, 2824, 3040, 11, 50868], "temperature": 0.0, "avg_logprob": -0.12172324482987566, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.004833942279219627}, {"id": 5, "seek": 2024, "start": 30.88, "end": 37.12, "text": " and he was the person who invented the lambda calculus, and what he was interested in is", "tokens": [50896, 293, 415, 390, 264, 954, 567, 14479, 264, 13607, 33400, 11, 293, 437, 415, 390, 3102, 294, 307, 51208], "temperature": 0.0, "avg_logprob": -0.12172324482987566, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.004833942279219627}, {"id": 6, "seek": 2024, "start": 37.12, "end": 42.56, "text": " what is the notion of a function from a computational perspective? And his answer", "tokens": [51208, 437, 307, 264, 10710, 295, 257, 2445, 490, 257, 28270, 4585, 30, 400, 702, 1867, 51480], "temperature": 0.0, "avg_logprob": -0.12172324482987566, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.004833942279219627}, {"id": 7, "seek": 2024, "start": 42.56, "end": 48.480000000000004, "text": " to this question is what we now know as the lambda calculus. And there's an interesting piece of", "tokens": [51480, 281, 341, 1168, 307, 437, 321, 586, 458, 382, 264, 13607, 33400, 13, 400, 456, 311, 364, 1880, 2522, 295, 51776], "temperature": 0.0, "avg_logprob": -0.12172324482987566, "compression_ratio": 1.643835616438356, "no_speech_prob": 0.004833942279219627}, {"id": 8, "seek": 4848, "start": 48.48, "end": 53.919999999999995, "text": " history here, which many people don't know, so it turns out that Alonzo Church was the PhD", "tokens": [50364, 2503, 510, 11, 597, 867, 561, 500, 380, 458, 11, 370, 309, 4523, 484, 300, 967, 266, 4765, 7882, 390, 264, 14476, 50636], "temperature": 0.0, "avg_logprob": -0.09378597192596971, "compression_ratio": 1.7657992565055762, "no_speech_prob": 0.0037484567146748304}, {"id": 9, "seek": 4848, "start": 53.919999999999995, "end": 59.44, "text": " supervisor of someone very famous in computer science, Alan Turing. And of course Alan Turing,", "tokens": [50636, 24610, 295, 1580, 588, 4618, 294, 3820, 3497, 11, 16442, 314, 1345, 13, 400, 295, 1164, 16442, 314, 1345, 11, 50912], "temperature": 0.0, "avg_logprob": -0.09378597192596971, "compression_ratio": 1.7657992565055762, "no_speech_prob": 0.0037484567146748304}, {"id": 10, "seek": 4848, "start": 59.44, "end": 64.88, "text": " amongst many other things which he did, he invented Turing machines, which Computerphile has done a", "tokens": [50912, 12918, 867, 661, 721, 597, 415, 630, 11, 415, 14479, 314, 1345, 8379, 11, 597, 22289, 950, 794, 575, 1096, 257, 51184], "temperature": 0.0, "avg_logprob": -0.09378597192596971, "compression_ratio": 1.7657992565055762, "no_speech_prob": 0.0037484567146748304}, {"id": 11, "seek": 4848, "start": 64.88, "end": 71.03999999999999, "text": " number of videos on, and Turing machines capture a basic state-based model of computation. And", "tokens": [51184, 1230, 295, 2145, 322, 11, 293, 314, 1345, 8379, 7983, 257, 3875, 1785, 12, 6032, 2316, 295, 24903, 13, 400, 51492], "temperature": 0.0, "avg_logprob": -0.09378597192596971, "compression_ratio": 1.7657992565055762, "no_speech_prob": 0.0037484567146748304}, {"id": 12, "seek": 4848, "start": 71.03999999999999, "end": 76.4, "text": " it's interesting that his PhD supervisor, Alonzo Church, he captured a basic functional notion", "tokens": [51492, 309, 311, 1880, 300, 702, 14476, 24610, 11, 967, 266, 4765, 7882, 11, 415, 11828, 257, 3875, 11745, 10710, 51760], "temperature": 0.0, "avg_logprob": -0.09378597192596971, "compression_ratio": 1.7657992565055762, "no_speech_prob": 0.0037484567146748304}, {"id": 13, "seek": 7640, "start": 76.4, "end": 82.48, "text": " of computation with his lambda calculus. And it turns out that these two quite different notions,", "tokens": [50364, 295, 24903, 365, 702, 13607, 33400, 13, 400, 309, 4523, 484, 300, 613, 732, 1596, 819, 35799, 11, 50668], "temperature": 0.0, "avg_logprob": -0.07552773182786356, "compression_ratio": 1.7963636363636364, "no_speech_prob": 0.006156653631478548}, {"id": 14, "seek": 7640, "start": 82.48, "end": 87.68, "text": " one functional and one state-based, turn out to be equivalent. And this is what's called the Church", "tokens": [50668, 472, 11745, 293, 472, 1785, 12, 6032, 11, 1261, 484, 281, 312, 10344, 13, 400, 341, 307, 437, 311, 1219, 264, 7882, 50928], "temperature": 0.0, "avg_logprob": -0.07552773182786356, "compression_ratio": 1.7963636363636364, "no_speech_prob": 0.006156653631478548}, {"id": 15, "seek": 7640, "start": 87.68, "end": 93.44, "text": " Turing Hypothesis, or part of the Church Turing Hypothesis. So for Church, a function was a black", "tokens": [50928, 314, 1345, 45649, 4624, 271, 11, 420, 644, 295, 264, 7882, 314, 1345, 45649, 4624, 271, 13, 407, 337, 7882, 11, 257, 2445, 390, 257, 2211, 51216], "temperature": 0.0, "avg_logprob": -0.07552773182786356, "compression_ratio": 1.7963636363636364, "no_speech_prob": 0.006156653631478548}, {"id": 16, "seek": 7640, "start": 93.44, "end": 99.04, "text": " box that you're not allowed to look inside, and what it does is it takes some input, so maybe it", "tokens": [51216, 2424, 300, 291, 434, 406, 4350, 281, 574, 1854, 11, 293, 437, 309, 775, 307, 309, 2516, 512, 4846, 11, 370, 1310, 309, 51496], "temperature": 0.0, "avg_logprob": -0.07552773182786356, "compression_ratio": 1.7963636363636364, "no_speech_prob": 0.006156653631478548}, {"id": 17, "seek": 7640, "start": 99.04, "end": 105.44, "text": " takes a number like x, and it's going to process it in some way, and it's going to produce an output.", "tokens": [51496, 2516, 257, 1230, 411, 2031, 11, 293, 309, 311, 516, 281, 1399, 309, 294, 512, 636, 11, 293, 309, 311, 516, 281, 5258, 364, 5598, 13, 51816], "temperature": 0.0, "avg_logprob": -0.07552773182786356, "compression_ratio": 1.7963636363636364, "no_speech_prob": 0.006156653631478548}, {"id": 18, "seek": 10544, "start": 105.44, "end": 112.32, "text": " So maybe it produces the output x plus one. So this would be a function that takes a single input,", "tokens": [50364, 407, 1310, 309, 14725, 264, 5598, 2031, 1804, 472, 13, 407, 341, 576, 312, 257, 2445, 300, 2516, 257, 2167, 4846, 11, 50708], "temperature": 0.0, "avg_logprob": -0.054727337577126244, "compression_ratio": 1.8101851851851851, "no_speech_prob": 0.0008266179938800633}, {"id": 19, "seek": 10544, "start": 112.32, "end": 118.4, "text": " a number called x, processes it in some way, and then produces a single output, which is the number", "tokens": [50708, 257, 1230, 1219, 2031, 11, 7555, 309, 294, 512, 636, 11, 293, 550, 14725, 257, 2167, 5598, 11, 597, 307, 264, 1230, 51012], "temperature": 0.0, "avg_logprob": -0.054727337577126244, "compression_ratio": 1.8101851851851851, "no_speech_prob": 0.0008266179938800633}, {"id": 20, "seek": 10544, "start": 118.4, "end": 123.6, "text": " x plus one. Then we could have a slightly more interesting example. Maybe we have a box with", "tokens": [51012, 2031, 1804, 472, 13, 1396, 321, 727, 362, 257, 4748, 544, 1880, 1365, 13, 2704, 321, 362, 257, 2424, 365, 51272], "temperature": 0.0, "avg_logprob": -0.054727337577126244, "compression_ratio": 1.8101851851851851, "no_speech_prob": 0.0008266179938800633}, {"id": 21, "seek": 10544, "start": 123.6, "end": 131.52, "text": " two inputs, x and y, and we process them in some way, and maybe we produce their sum as the output.", "tokens": [51272, 732, 15743, 11, 2031, 293, 288, 11, 293, 321, 1399, 552, 294, 512, 636, 11, 293, 1310, 321, 5258, 641, 2408, 382, 264, 5598, 13, 51668], "temperature": 0.0, "avg_logprob": -0.054727337577126244, "compression_ratio": 1.8101851851851851, "no_speech_prob": 0.0008266179938800633}, {"id": 22, "seek": 13152, "start": 131.52, "end": 136.64000000000001, "text": " So this would be a function which takes two inputs, x and y, processes them in some way,", "tokens": [50364, 407, 341, 576, 312, 257, 2445, 597, 2516, 732, 15743, 11, 2031, 293, 288, 11, 7555, 552, 294, 512, 636, 11, 50620], "temperature": 0.0, "avg_logprob": -0.04240495124749378, "compression_ratio": 1.7718631178707225, "no_speech_prob": 0.0006135705043561757}, {"id": 23, "seek": 13152, "start": 136.64000000000001, "end": 143.04000000000002, "text": " and then produces their sum x plus y. And there's two important things about functions in this sense.", "tokens": [50620, 293, 550, 14725, 641, 2408, 2031, 1804, 288, 13, 400, 456, 311, 732, 1021, 721, 466, 6828, 294, 341, 2020, 13, 50940], "temperature": 0.0, "avg_logprob": -0.04240495124749378, "compression_ratio": 1.7718631178707225, "no_speech_prob": 0.0006135705043561757}, {"id": 24, "seek": 13152, "start": 143.04000000000002, "end": 147.44, "text": " The first is that they're black boxes. You're not allowed to look inside them. You can't see", "tokens": [50940, 440, 700, 307, 300, 436, 434, 2211, 9002, 13, 509, 434, 406, 4350, 281, 574, 1854, 552, 13, 509, 393, 380, 536, 51160], "temperature": 0.0, "avg_logprob": -0.04240495124749378, "compression_ratio": 1.7718631178707225, "no_speech_prob": 0.0006135705043561757}, {"id": 25, "seek": 13152, "start": 147.44, "end": 151.36, "text": " the mechanics of what's going on inside this box. All you can do is put something in and", "tokens": [51160, 264, 12939, 295, 437, 311, 516, 322, 1854, 341, 2424, 13, 1057, 291, 393, 360, 307, 829, 746, 294, 293, 51356], "temperature": 0.0, "avg_logprob": -0.04240495124749378, "compression_ratio": 1.7718631178707225, "no_speech_prob": 0.0006135705043561757}, {"id": 26, "seek": 13152, "start": 151.36, "end": 155.84, "text": " observe what comes out the other side. And the second important thing is that these functions", "tokens": [51356, 11441, 437, 1487, 484, 264, 661, 1252, 13, 400, 264, 1150, 1021, 551, 307, 300, 613, 6828, 51580], "temperature": 0.0, "avg_logprob": -0.04240495124749378, "compression_ratio": 1.7718631178707225, "no_speech_prob": 0.0006135705043561757}, {"id": 27, "seek": 15584, "start": 155.84, "end": 162.24, "text": " are pure. They have no internal state. So all that happens when you map x across to x plus one", "tokens": [50364, 366, 6075, 13, 814, 362, 572, 6920, 1785, 13, 407, 439, 300, 2314, 562, 291, 4471, 2031, 2108, 281, 2031, 1804, 472, 50684], "temperature": 0.0, "avg_logprob": -0.05346906712624879, "compression_ratio": 1.8339622641509434, "no_speech_prob": 0.008861454203724861}, {"id": 28, "seek": 15584, "start": 162.24, "end": 167.28, "text": " is the magic goes on inside the box, and there's no internal state. There's no hidden information", "tokens": [50684, 307, 264, 5585, 1709, 322, 1854, 264, 2424, 11, 293, 456, 311, 572, 6920, 1785, 13, 821, 311, 572, 7633, 1589, 50936], "temperature": 0.0, "avg_logprob": -0.05346906712624879, "compression_ratio": 1.8339622641509434, "no_speech_prob": 0.008861454203724861}, {"id": 29, "seek": 15584, "start": 167.28, "end": 172.0, "text": " that we can use. And this is quite different from the notion of computation that Alan Turing was", "tokens": [50936, 300, 321, 393, 764, 13, 400, 341, 307, 1596, 819, 490, 264, 10710, 295, 24903, 300, 16442, 314, 1345, 390, 51172], "temperature": 0.0, "avg_logprob": -0.05346906712624879, "compression_ratio": 1.8339622641509434, "no_speech_prob": 0.008861454203724861}, {"id": 30, "seek": 15584, "start": 172.0, "end": 176.88, "text": " interested in with his Turing machines. He had internal state. There's no internal state. These", "tokens": [51172, 3102, 294, 365, 702, 314, 1345, 8379, 13, 634, 632, 6920, 1785, 13, 821, 311, 572, 6920, 1785, 13, 1981, 51416], "temperature": 0.0, "avg_logprob": -0.05346906712624879, "compression_ratio": 1.8339622641509434, "no_speech_prob": 0.008861454203724861}, {"id": 31, "seek": 15584, "start": 176.88, "end": 183.2, "text": " are pure mathematical functions. Now we can think how do you actually define functions in the lambda", "tokens": [51416, 366, 6075, 18894, 6828, 13, 823, 321, 393, 519, 577, 360, 291, 767, 6964, 6828, 294, 264, 13607, 51732], "temperature": 0.0, "avg_logprob": -0.05346906712624879, "compression_ratio": 1.8339622641509434, "no_speech_prob": 0.008861454203724861}, {"id": 32, "seek": 18320, "start": 183.2, "end": 188.32, "text": " calculus? And there's a very, very simple syntax for this which I'll introduce to you now. So let's", "tokens": [50364, 33400, 30, 400, 456, 311, 257, 588, 11, 588, 2199, 28431, 337, 341, 597, 286, 603, 5366, 281, 291, 586, 13, 407, 718, 311, 50620], "temperature": 0.0, "avg_logprob": -0.06624847745138501, "compression_ratio": 1.8470149253731343, "no_speech_prob": 0.02260410040616989}, {"id": 33, "seek": 18320, "start": 188.32, "end": 192.95999999999998, "text": " think about the increment function in the lambda calculus. What you do is you write down a lambda", "tokens": [50620, 519, 466, 264, 26200, 2445, 294, 264, 13607, 33400, 13, 708, 291, 360, 307, 291, 2464, 760, 257, 13607, 50852], "temperature": 0.0, "avg_logprob": -0.06624847745138501, "compression_ratio": 1.8470149253731343, "no_speech_prob": 0.02260410040616989}, {"id": 34, "seek": 18320, "start": 192.95999999999998, "end": 197.83999999999997, "text": " symbol. So this is the Greek lowercase letter lambda. And that says we're introducing a function at this", "tokens": [50852, 5986, 13, 407, 341, 307, 264, 10281, 3126, 9765, 5063, 13607, 13, 400, 300, 1619, 321, 434, 15424, 257, 2445, 412, 341, 51096], "temperature": 0.0, "avg_logprob": -0.06624847745138501, "compression_ratio": 1.8470149253731343, "no_speech_prob": 0.02260410040616989}, {"id": 35, "seek": 18320, "start": 197.83999999999997, "end": 203.44, "text": " point. And then you just write down the name of the input. So that was x. And then you have a dot.", "tokens": [51096, 935, 13, 400, 550, 291, 445, 2464, 760, 264, 1315, 295, 264, 4846, 13, 407, 300, 390, 2031, 13, 400, 550, 291, 362, 257, 5893, 13, 51376], "temperature": 0.0, "avg_logprob": -0.06624847745138501, "compression_ratio": 1.8470149253731343, "no_speech_prob": 0.02260410040616989}, {"id": 36, "seek": 18320, "start": 203.44, "end": 209.76, "text": " And then you say how the output is calculated in terms of the input. So that's x plus one. So", "tokens": [51376, 400, 550, 291, 584, 577, 264, 5598, 307, 15598, 294, 2115, 295, 264, 4846, 13, 407, 300, 311, 2031, 1804, 472, 13, 407, 51692], "temperature": 0.0, "avg_logprob": -0.06624847745138501, "compression_ratio": 1.8470149253731343, "no_speech_prob": 0.02260410040616989}, {"id": 37, "seek": 20976, "start": 209.76, "end": 215.76, "text": " we could do the same with addition. You just need two lambdas. You write lambda x dot lambda y", "tokens": [50364, 321, 727, 360, 264, 912, 365, 4500, 13, 509, 445, 643, 732, 10097, 27476, 13, 509, 2464, 13607, 2031, 5893, 13607, 288, 50664], "temperature": 0.0, "avg_logprob": -0.07427088916301727, "compression_ratio": 1.7610294117647058, "no_speech_prob": 0.012118344195187092}, {"id": 38, "seek": 20976, "start": 215.76, "end": 222.95999999999998, "text": " dot x plus y. So this is the function that takes two inputs, x and y, and then delivers the result", "tokens": [50664, 5893, 2031, 1804, 288, 13, 407, 341, 307, 264, 2445, 300, 2516, 732, 15743, 11, 2031, 293, 288, 11, 293, 550, 24860, 264, 1874, 51024], "temperature": 0.0, "avg_logprob": -0.07427088916301727, "compression_ratio": 1.7610294117647058, "no_speech_prob": 0.012118344195187092}, {"id": 39, "seek": 20976, "start": 222.95999999999998, "end": 228.88, "text": " x plus y. And this is written down formally in Church's lambda calculus exactly like this. So", "tokens": [51024, 2031, 1804, 288, 13, 400, 341, 307, 3720, 760, 25983, 294, 7882, 311, 13607, 33400, 2293, 411, 341, 13, 407, 51320], "temperature": 0.0, "avg_logprob": -0.07427088916301727, "compression_ratio": 1.7610294117647058, "no_speech_prob": 0.012118344195187092}, {"id": 40, "seek": 20976, "start": 228.88, "end": 234.23999999999998, "text": " when you've got a function, what can you do with it? Well, all you can do is give it some input,", "tokens": [51320, 562, 291, 600, 658, 257, 2445, 11, 437, 393, 291, 360, 365, 309, 30, 1042, 11, 439, 291, 393, 360, 307, 976, 309, 512, 4846, 11, 51588], "temperature": 0.0, "avg_logprob": -0.07427088916301727, "compression_ratio": 1.7610294117647058, "no_speech_prob": 0.012118344195187092}, {"id": 41, "seek": 20976, "start": 234.23999999999998, "end": 238.95999999999998, "text": " let it do its thing, and it will give you some output. So let's have a simple example of this.", "tokens": [51588, 718, 309, 360, 1080, 551, 11, 293, 309, 486, 976, 291, 512, 5598, 13, 407, 718, 311, 362, 257, 2199, 1365, 295, 341, 13, 51824], "temperature": 0.0, "avg_logprob": -0.07427088916301727, "compression_ratio": 1.7610294117647058, "no_speech_prob": 0.012118344195187092}, {"id": 42, "seek": 23896, "start": 238.96, "end": 245.84, "text": " If we take a function like increment, which was lambda x, x plus one, and we apply it to a number", "tokens": [50364, 759, 321, 747, 257, 2445, 411, 26200, 11, 597, 390, 13607, 2031, 11, 2031, 1804, 472, 11, 293, 321, 3079, 309, 281, 257, 1230, 50708], "temperature": 0.0, "avg_logprob": -0.06564412154550628, "compression_ratio": 1.7841726618705036, "no_speech_prob": 0.0008623931207694113}, {"id": 43, "seek": 23896, "start": 245.84, "end": 252.0, "text": " like five, what actually happens? It's a basic process of substitution. We're essentially substituting", "tokens": [50708, 411, 1732, 11, 437, 767, 2314, 30, 467, 311, 257, 3875, 1399, 295, 35827, 13, 492, 434, 4476, 26441, 10861, 51016], "temperature": 0.0, "avg_logprob": -0.06564412154550628, "compression_ratio": 1.7841726618705036, "no_speech_prob": 0.0008623931207694113}, {"id": 44, "seek": 23896, "start": 252.0, "end": 258.8, "text": " the number five here into the body of this lambda expression. And then x becomes five. So we get five", "tokens": [51016, 264, 1230, 1732, 510, 666, 264, 1772, 295, 341, 13607, 6114, 13, 400, 550, 2031, 3643, 1732, 13, 407, 321, 483, 1732, 51356], "temperature": 0.0, "avg_logprob": -0.06564412154550628, "compression_ratio": 1.7841726618705036, "no_speech_prob": 0.0008623931207694113}, {"id": 45, "seek": 23896, "start": 258.8, "end": 263.12, "text": " plus one. And then we get the result six on the other side. And this is basically all there is", "tokens": [51356, 1804, 472, 13, 400, 550, 321, 483, 264, 1874, 2309, 322, 264, 661, 1252, 13, 400, 341, 307, 1936, 439, 456, 307, 51572], "temperature": 0.0, "avg_logprob": -0.06564412154550628, "compression_ratio": 1.7841726618705036, "no_speech_prob": 0.0008623931207694113}, {"id": 46, "seek": 23896, "start": 263.12, "end": 268.8, "text": " to the lambda calculus. It's only got three things. It's got variables like x, y and z. It's got a", "tokens": [51572, 281, 264, 13607, 33400, 13, 467, 311, 787, 658, 1045, 721, 13, 467, 311, 658, 9102, 411, 2031, 11, 288, 293, 710, 13, 467, 311, 658, 257, 51856], "temperature": 0.0, "avg_logprob": -0.06564412154550628, "compression_ratio": 1.7841726618705036, "no_speech_prob": 0.0008623931207694113}, {"id": 47, "seek": 26880, "start": 268.8, "end": 274.16, "text": " way of building functions, this lambda notation, and it's got a way of applying functions. This is", "tokens": [50364, 636, 295, 2390, 6828, 11, 341, 13607, 24657, 11, 293, 309, 311, 658, 257, 636, 295, 9275, 6828, 13, 639, 307, 50632], "temperature": 0.0, "avg_logprob": -0.05898177154420867, "compression_ratio": 1.8169934640522876, "no_speech_prob": 0.000896110781468451}, {"id": 48, "seek": 26880, "start": 274.16, "end": 278.88, "text": " the only three things that you have in this setting. What is actually the point of the", "tokens": [50632, 264, 787, 1045, 721, 300, 291, 362, 294, 341, 3287, 13, 708, 307, 767, 264, 935, 295, 264, 50868], "temperature": 0.0, "avg_logprob": -0.05898177154420867, "compression_ratio": 1.8169934640522876, "no_speech_prob": 0.000896110781468451}, {"id": 49, "seek": 26880, "start": 278.88, "end": 282.8, "text": " lambda calculus? We've introduced this very simple notation. Why should you be interested", "tokens": [50868, 13607, 33400, 30, 492, 600, 7268, 341, 588, 2199, 24657, 13, 1545, 820, 291, 312, 3102, 51064], "temperature": 0.0, "avg_logprob": -0.05898177154420867, "compression_ratio": 1.8169934640522876, "no_speech_prob": 0.000896110781468451}, {"id": 50, "seek": 26880, "start": 282.8, "end": 287.12, "text": " in learning about it? I think there's three answers which I would give to this. The first", "tokens": [51064, 294, 2539, 466, 309, 30, 286, 519, 456, 311, 1045, 6338, 597, 286, 576, 976, 281, 341, 13, 440, 700, 51280], "temperature": 0.0, "avg_logprob": -0.05898177154420867, "compression_ratio": 1.8169934640522876, "no_speech_prob": 0.000896110781468451}, {"id": 51, "seek": 26880, "start": 287.12, "end": 292.48, "text": " point I'd make is that the lambda calculus can encode any computation. If you write a program", "tokens": [51280, 935, 286, 1116, 652, 307, 300, 264, 13607, 33400, 393, 2058, 1429, 604, 24903, 13, 759, 291, 2464, 257, 1461, 51548], "temperature": 0.0, "avg_logprob": -0.05898177154420867, "compression_ratio": 1.8169934640522876, "no_speech_prob": 0.000896110781468451}, {"id": 52, "seek": 26880, "start": 292.48, "end": 297.36, "text": " in any programming language, which has ever been invented or ever will be invented or really any", "tokens": [51548, 294, 604, 9410, 2856, 11, 597, 575, 1562, 668, 14479, 420, 1562, 486, 312, 14479, 420, 534, 604, 51792], "temperature": 0.0, "avg_logprob": -0.05898177154420867, "compression_ratio": 1.8169934640522876, "no_speech_prob": 0.000896110781468451}, {"id": 53, "seek": 29736, "start": 297.36, "end": 302.0, "text": " sequential programming language, it can in some way be encoded in the lambda calculus. And of", "tokens": [50364, 42881, 9410, 2856, 11, 309, 393, 294, 512, 636, 312, 2058, 12340, 294, 264, 13607, 33400, 13, 400, 295, 50596], "temperature": 0.0, "avg_logprob": -0.0975438089513067, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.0007824720814824104}, {"id": 54, "seek": 29736, "start": 302.0, "end": 306.72, "text": " course it may be extremely inefficient when you do that, but that's not the point. This is a basic", "tokens": [50596, 1164, 309, 815, 312, 4664, 43495, 562, 291, 360, 300, 11, 457, 300, 311, 406, 264, 935, 13, 639, 307, 257, 3875, 50832], "temperature": 0.0, "avg_logprob": -0.0975438089513067, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.0007824720814824104}, {"id": 55, "seek": 29736, "start": 306.72, "end": 311.68, "text": " idea of computation and we want to think how many, what kind of programs can we encode in this?", "tokens": [50832, 1558, 295, 24903, 293, 321, 528, 281, 519, 577, 867, 11, 437, 733, 295, 4268, 393, 321, 2058, 1429, 294, 341, 30, 51080], "temperature": 0.0, "avg_logprob": -0.0975438089513067, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.0007824720814824104}, {"id": 56, "seek": 29736, "start": 311.68, "end": 316.32, "text": " And actually you can encode anything. And this is really the kind of church-turing hypothesis", "tokens": [51080, 400, 767, 291, 393, 2058, 1429, 1340, 13, 400, 341, 307, 534, 264, 733, 295, 4128, 12, 83, 1345, 17291, 51312], "temperature": 0.0, "avg_logprob": -0.0975438089513067, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.0007824720814824104}, {"id": 57, "seek": 29736, "start": 316.32, "end": 322.8, "text": " which I mentioned. Alan Turing, you can code anything in his Turing machines and in churches", "tokens": [51312, 597, 286, 2835, 13, 16442, 314, 1345, 11, 291, 393, 3089, 1340, 294, 702, 314, 1345, 8379, 293, 294, 15381, 51636], "temperature": 0.0, "avg_logprob": -0.0975438089513067, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.0007824720814824104}, {"id": 58, "seek": 29736, "start": 322.8, "end": 326.8, "text": " lambda calculus you can encode anything. And actually these two systems are formally equivalent.", "tokens": [51636, 13607, 33400, 291, 393, 2058, 1429, 1340, 13, 400, 767, 613, 732, 3652, 366, 25983, 10344, 13, 51836], "temperature": 0.0, "avg_logprob": -0.0975438089513067, "compression_ratio": 1.8571428571428572, "no_speech_prob": 0.0007824720814824104}, {"id": 59, "seek": 32680, "start": 326.8, "end": 331.52000000000004, "text": " Any Turing machine program can be translated into equivalent lambda calculus program and vice", "tokens": [50364, 2639, 314, 1345, 3479, 1461, 393, 312, 16805, 666, 10344, 13607, 33400, 1461, 293, 11964, 50600], "temperature": 0.0, "avg_logprob": -0.05513875795447308, "compression_ratio": 1.8874172185430464, "no_speech_prob": 0.0003532404953148216}, {"id": 60, "seek": 32680, "start": 331.52000000000004, "end": 336.96000000000004, "text": " versa. They're formally equivalent. The second point I would make is that lambda calculus can", "tokens": [50600, 25650, 13, 814, 434, 25983, 10344, 13, 440, 1150, 935, 286, 576, 652, 307, 300, 13607, 33400, 393, 50872], "temperature": 0.0, "avg_logprob": -0.05513875795447308, "compression_ratio": 1.8874172185430464, "no_speech_prob": 0.0003532404953148216}, {"id": 61, "seek": 32680, "start": 336.96000000000004, "end": 341.44, "text": " also be regarded as the basis for functional programming languages like Haskell. So these", "tokens": [50872, 611, 312, 26047, 382, 264, 5143, 337, 11745, 9410, 8650, 411, 8646, 43723, 13, 407, 613, 51096], "temperature": 0.0, "avg_logprob": -0.05513875795447308, "compression_ratio": 1.8874172185430464, "no_speech_prob": 0.0003532404953148216}, {"id": 62, "seek": 32680, "start": 341.44, "end": 346.72, "text": " are becoming increasingly popular these days and actually a very sophisticated language like Haskell", "tokens": [51096, 366, 5617, 12980, 3743, 613, 1708, 293, 767, 257, 588, 16950, 2856, 411, 8646, 43723, 51360], "temperature": 0.0, "avg_logprob": -0.05513875795447308, "compression_ratio": 1.8874172185430464, "no_speech_prob": 0.0003532404953148216}, {"id": 63, "seek": 32680, "start": 346.72, "end": 352.32, "text": " is compiled down to a very small core language which is essentially a glorified form of lambda", "tokens": [51360, 307, 36548, 760, 281, 257, 588, 1359, 4965, 2856, 597, 307, 4476, 257, 26623, 2587, 1254, 295, 13607, 51640], "temperature": 0.0, "avg_logprob": -0.05513875795447308, "compression_ratio": 1.8874172185430464, "no_speech_prob": 0.0003532404953148216}, {"id": 64, "seek": 32680, "start": 352.32, "end": 356.48, "text": " calculus. So if you're interested in functional programming names like Haskell or the ML family,", "tokens": [51640, 33400, 13, 407, 498, 291, 434, 3102, 294, 11745, 9410, 5288, 411, 8646, 43723, 420, 264, 21601, 1605, 11, 51848], "temperature": 0.0, "avg_logprob": -0.05513875795447308, "compression_ratio": 1.8874172185430464, "no_speech_prob": 0.0003532404953148216}, {"id": 65, "seek": 35648, "start": 356.48, "end": 360.8, "text": " these are all fundamentally based on the lambda calculus. It's just kind of a glorified syntax", "tokens": [50364, 613, 366, 439, 17879, 2361, 322, 264, 13607, 33400, 13, 467, 311, 445, 733, 295, 257, 26623, 2587, 28431, 50580], "temperature": 0.0, "avg_logprob": -0.053946030550989614, "compression_ratio": 1.6594982078853047, "no_speech_prob": 0.00027641592896543443}, {"id": 66, "seek": 35648, "start": 360.8, "end": 366.8, "text": " on top of that. The third point which I would make is that the lambda calculus is actually now", "tokens": [50580, 322, 1192, 295, 300, 13, 440, 2636, 935, 597, 286, 576, 652, 307, 300, 264, 13607, 33400, 307, 767, 586, 50880], "temperature": 0.0, "avg_logprob": -0.053946030550989614, "compression_ratio": 1.6594982078853047, "no_speech_prob": 0.00027641592896543443}, {"id": 67, "seek": 35648, "start": 366.8, "end": 372.24, "text": " present in most major programming languages. So this wasn't the case 10 or 15 years ago,", "tokens": [50880, 1974, 294, 881, 2563, 9410, 8650, 13, 407, 341, 2067, 380, 264, 1389, 1266, 420, 2119, 924, 2057, 11, 51152], "temperature": 0.0, "avg_logprob": -0.053946030550989614, "compression_ratio": 1.6594982078853047, "no_speech_prob": 0.00027641592896543443}, {"id": 68, "seek": 35648, "start": 372.24, "end": 377.44, "text": " but it is the case today. So if you look at languages like Java, like C-sharp, even Visual", "tokens": [51152, 457, 309, 307, 264, 1389, 965, 13, 407, 498, 291, 574, 412, 8650, 411, 10745, 11, 411, 383, 12, 2716, 6529, 11, 754, 23187, 51412], "temperature": 0.0, "avg_logprob": -0.053946030550989614, "compression_ratio": 1.6594982078853047, "no_speech_prob": 0.00027641592896543443}, {"id": 69, "seek": 35648, "start": 377.44, "end": 383.52000000000004, "text": " Basic, F-sharp and so on, all of these languages now encode lambda calculus or include lambda", "tokens": [51412, 31598, 11, 479, 12, 2716, 6529, 293, 370, 322, 11, 439, 295, 613, 8650, 586, 2058, 1429, 13607, 33400, 420, 4090, 13607, 51716], "temperature": 0.0, "avg_logprob": -0.053946030550989614, "compression_ratio": 1.6594982078853047, "no_speech_prob": 0.00027641592896543443}, {"id": 70, "seek": 38352, "start": 383.52, "end": 388.96, "text": " calculus as a fundamental component. So every computer scientist today needs to know about", "tokens": [50364, 33400, 382, 257, 8088, 6542, 13, 407, 633, 3820, 12662, 965, 2203, 281, 458, 466, 50636], "temperature": 0.0, "avg_logprob": -0.052807375362941195, "compression_ratio": 1.8603896103896105, "no_speech_prob": 0.005497084464877844}, {"id": 71, "seek": 38352, "start": 388.96, "end": 394.71999999999997, "text": " lambda calculus. What I'd like to end up with is a couple of little examples of what you can do", "tokens": [50636, 13607, 33400, 13, 708, 286, 1116, 411, 281, 917, 493, 365, 307, 257, 1916, 295, 707, 5110, 295, 437, 291, 393, 360, 50924], "temperature": 0.0, "avg_logprob": -0.052807375362941195, "compression_ratio": 1.8603896103896105, "no_speech_prob": 0.005497084464877844}, {"id": 72, "seek": 38352, "start": 394.71999999999997, "end": 399.12, "text": " with it. So the lambda calculus has basically got nothing in it. It's got variables, it's got a way", "tokens": [50924, 365, 309, 13, 407, 264, 13607, 33400, 575, 1936, 658, 1825, 294, 309, 13, 467, 311, 658, 9102, 11, 309, 311, 658, 257, 636, 51144], "temperature": 0.0, "avg_logprob": -0.052807375362941195, "compression_ratio": 1.8603896103896105, "no_speech_prob": 0.005497084464877844}, {"id": 73, "seek": 38352, "start": 399.12, "end": 403.68, "text": " of building functions and it's got a way of applying functions. It doesn't have any built-in data types", "tokens": [51144, 295, 2390, 6828, 293, 309, 311, 658, 257, 636, 295, 9275, 6828, 13, 467, 1177, 380, 362, 604, 3094, 12, 259, 1412, 3467, 51372], "temperature": 0.0, "avg_logprob": -0.052807375362941195, "compression_ratio": 1.8603896103896105, "no_speech_prob": 0.005497084464877844}, {"id": 74, "seek": 38352, "start": 403.68, "end": 408.4, "text": " like numbers or logical values, recursion and things like that. So if you want to do these", "tokens": [51372, 411, 3547, 420, 14978, 4190, 11, 20560, 313, 293, 721, 411, 300, 13, 407, 498, 291, 528, 281, 360, 613, 51608], "temperature": 0.0, "avg_logprob": -0.052807375362941195, "compression_ratio": 1.8603896103896105, "no_speech_prob": 0.005497084464877844}, {"id": 75, "seek": 38352, "start": 408.4, "end": 413.28, "text": " things in the lambda calculus, you need to encode them. So I'll end up showing you a simple", "tokens": [51608, 721, 294, 264, 13607, 33400, 11, 291, 643, 281, 2058, 1429, 552, 13, 407, 286, 603, 917, 493, 4099, 291, 257, 2199, 51852], "temperature": 0.0, "avg_logprob": -0.052807375362941195, "compression_ratio": 1.8603896103896105, "no_speech_prob": 0.005497084464877844}, {"id": 76, "seek": 41328, "start": 413.28, "end": 418.23999999999995, "text": " encoding. And the encoding which I'm going to show you is the logical values, true and false.", "tokens": [50364, 43430, 13, 400, 264, 43430, 597, 286, 478, 516, 281, 855, 291, 307, 264, 14978, 4190, 11, 2074, 293, 7908, 13, 50612], "temperature": 0.0, "avg_logprob": -0.06932524045308432, "compression_ratio": 1.9058823529411764, "no_speech_prob": 0.001870933803729713}, {"id": 77, "seek": 41328, "start": 419.03999999999996, "end": 424.4, "text": " And the key to this is to think, what do you do with logical values in a programming language?", "tokens": [50652, 400, 264, 2141, 281, 341, 307, 281, 519, 11, 437, 360, 291, 360, 365, 14978, 4190, 294, 257, 9410, 2856, 30, 50920], "temperature": 0.0, "avg_logprob": -0.06932524045308432, "compression_ratio": 1.9058823529411764, "no_speech_prob": 0.001870933803729713}, {"id": 78, "seek": 41328, "start": 424.4, "end": 429.59999999999997, "text": " And the basic observation is that you use them to make a choice between doing two things. You say,", "tokens": [50920, 400, 264, 3875, 14816, 307, 300, 291, 764, 552, 281, 652, 257, 3922, 1296, 884, 732, 721, 13, 509, 584, 11, 51180], "temperature": 0.0, "avg_logprob": -0.06932524045308432, "compression_ratio": 1.9058823529411764, "no_speech_prob": 0.001870933803729713}, {"id": 79, "seek": 41328, "start": 429.59999999999997, "end": 435.2, "text": " if something is true, do one thing. If something is false, do another thing. And we're going to use", "tokens": [51180, 498, 746, 307, 2074, 11, 360, 472, 551, 13, 759, 746, 307, 7908, 11, 360, 1071, 551, 13, 400, 321, 434, 516, 281, 764, 51460], "temperature": 0.0, "avg_logprob": -0.06932524045308432, "compression_ratio": 1.9058823529411764, "no_speech_prob": 0.001870933803729713}, {"id": 80, "seek": 41328, "start": 435.2, "end": 441.52, "text": " this idea of making a choice between two things to actually encode true and false. So the trick is", "tokens": [51460, 341, 1558, 295, 1455, 257, 3922, 1296, 732, 721, 281, 767, 2058, 1429, 2074, 293, 7908, 13, 407, 264, 4282, 307, 51776], "temperature": 0.0, "avg_logprob": -0.06932524045308432, "compression_ratio": 1.9058823529411764, "no_speech_prob": 0.001870933803729713}, {"id": 81, "seek": 44152, "start": 441.52, "end": 448.32, "text": " for true, you write down this lambda expression. So what it does is it takes two things x and y", "tokens": [50364, 337, 2074, 11, 291, 2464, 760, 341, 13607, 6114, 13, 407, 437, 309, 775, 307, 309, 2516, 732, 721, 2031, 293, 288, 50704], "temperature": 0.0, "avg_logprob": -0.06157727638880412, "compression_ratio": 1.8605577689243027, "no_speech_prob": 0.00391289871186018}, {"id": 82, "seek": 44152, "start": 448.32, "end": 453.2, "text": " and then it chooses the first. And false does the opposite. It's going to take two things", "tokens": [50704, 293, 550, 309, 25963, 264, 700, 13, 400, 7908, 775, 264, 6182, 13, 467, 311, 516, 281, 747, 732, 721, 50948], "temperature": 0.0, "avg_logprob": -0.06157727638880412, "compression_ratio": 1.8605577689243027, "no_speech_prob": 0.00391289871186018}, {"id": 83, "seek": 44152, "start": 453.2, "end": 458.0, "text": " and it's going to choose the second. So we've got two lambda expressions here, both of which take", "tokens": [50948, 293, 309, 311, 516, 281, 2826, 264, 1150, 13, 407, 321, 600, 658, 732, 13607, 15277, 510, 11, 1293, 295, 597, 747, 51188], "temperature": 0.0, "avg_logprob": -0.06157727638880412, "compression_ratio": 1.8605577689243027, "no_speech_prob": 0.00391289871186018}, {"id": 84, "seek": 44152, "start": 458.0, "end": 464.79999999999995, "text": " two inputs x and y, and one chooses the first one x and one chooses the second one y. So fair", "tokens": [51188, 732, 15743, 2031, 293, 288, 11, 293, 472, 25963, 264, 700, 472, 2031, 293, 472, 25963, 264, 1150, 472, 288, 13, 407, 3143, 51528], "temperature": 0.0, "avg_logprob": -0.06157727638880412, "compression_ratio": 1.8605577689243027, "no_speech_prob": 0.00391289871186018}, {"id": 85, "seek": 44152, "start": 464.79999999999995, "end": 469.68, "text": " enough, what can we actually do with this? Well, let's think how we could define a little", "tokens": [51528, 1547, 11, 437, 393, 321, 767, 360, 365, 341, 30, 1042, 11, 718, 311, 519, 577, 321, 727, 6964, 257, 707, 51772], "temperature": 0.0, "avg_logprob": -0.06157727638880412, "compression_ratio": 1.8605577689243027, "no_speech_prob": 0.00391289871186018}, {"id": 86, "seek": 46968, "start": 469.68, "end": 474.24, "text": " logical operator. So not is the most simple logical operator, which I could think of. It's", "tokens": [50364, 14978, 12973, 13, 407, 406, 307, 264, 881, 2199, 14978, 12973, 11, 597, 286, 727, 519, 295, 13, 467, 311, 50592], "temperature": 0.0, "avg_logprob": -0.09186941034653608, "compression_ratio": 1.7232472324723247, "no_speech_prob": 0.0010756534757092595}, {"id": 87, "seek": 46968, "start": 474.24, "end": 480.32, "text": " going to flip true to false and false to true. It's logical negation. Based upon this encoding,", "tokens": [50592, 516, 281, 7929, 2074, 281, 7908, 293, 7908, 281, 2074, 13, 467, 311, 14978, 2485, 399, 13, 18785, 3564, 341, 43430, 11, 50896], "temperature": 0.0, "avg_logprob": -0.09186941034653608, "compression_ratio": 1.7232472324723247, "no_speech_prob": 0.0010756534757092595}, {"id": 88, "seek": 46968, "start": 480.32, "end": 485.44, "text": " how could I actually define the not operator or the not function? Well, it's very easy to do.", "tokens": [50896, 577, 727, 286, 767, 6964, 264, 406, 12973, 420, 264, 406, 2445, 30, 1042, 11, 309, 311, 588, 1858, 281, 360, 13, 51152], "temperature": 0.0, "avg_logprob": -0.09186941034653608, "compression_ratio": 1.7232472324723247, "no_speech_prob": 0.0010756534757092595}, {"id": 89, "seek": 46968, "start": 486.0, "end": 491.04, "text": " I will take in a logical value or a Boolean, as it's normally called in computer science,", "tokens": [51180, 286, 486, 747, 294, 257, 14978, 2158, 420, 257, 23351, 28499, 11, 382, 309, 311, 5646, 1219, 294, 3820, 3497, 11, 51432], "temperature": 0.0, "avg_logprob": -0.09186941034653608, "compression_ratio": 1.7232472324723247, "no_speech_prob": 0.0010756534757092595}, {"id": 90, "seek": 46968, "start": 491.04, "end": 496.48, "text": " after George Boo who first studied kind of formal logic. So we take a Boolean, which will be one", "tokens": [51432, 934, 7136, 23351, 567, 700, 9454, 733, 295, 9860, 9952, 13, 407, 321, 747, 257, 23351, 28499, 11, 597, 486, 312, 472, 51704], "temperature": 0.0, "avg_logprob": -0.09186941034653608, "compression_ratio": 1.7232472324723247, "no_speech_prob": 0.0010756534757092595}, {"id": 91, "seek": 49648, "start": 496.48, "end": 502.96000000000004, "text": " of true or false. And here's what we do. We apply it to false and we apply it to true. And I claim", "tokens": [50364, 295, 2074, 420, 7908, 13, 400, 510, 311, 437, 321, 360, 13, 492, 3079, 309, 281, 7908, 293, 321, 3079, 309, 281, 2074, 13, 400, 286, 3932, 50688], "temperature": 0.0, "avg_logprob": -0.07408631692721149, "compression_ratio": 1.789090909090909, "no_speech_prob": 0.010411097668111324}, {"id": 92, "seek": 49648, "start": 502.96000000000004, "end": 508.40000000000003, "text": " that this is a valid definition for a not function. But I can very easily convince you that it's the", "tokens": [50688, 300, 341, 307, 257, 7363, 7123, 337, 257, 406, 2445, 13, 583, 286, 393, 588, 3612, 13447, 291, 300, 309, 311, 264, 50960], "temperature": 0.0, "avg_logprob": -0.07408631692721149, "compression_ratio": 1.789090909090909, "no_speech_prob": 0.010411097668111324}, {"id": 93, "seek": 49648, "start": 508.40000000000003, "end": 514.4, "text": " case because I can do a little calculation. So let's check if we apply not to true that we actually", "tokens": [50960, 1389, 570, 286, 393, 360, 257, 707, 17108, 13, 407, 718, 311, 1520, 498, 321, 3079, 406, 281, 2074, 300, 321, 767, 51260], "temperature": 0.0, "avg_logprob": -0.07408631692721149, "compression_ratio": 1.789090909090909, "no_speech_prob": 0.010411097668111324}, {"id": 94, "seek": 49648, "start": 514.4, "end": 518.8000000000001, "text": " get false. And just a few steps using the lambda calculus magic, we'll find that this actually", "tokens": [51260, 483, 7908, 13, 400, 445, 257, 1326, 4439, 1228, 264, 13607, 33400, 5585, 11, 321, 603, 915, 300, 341, 767, 51480], "temperature": 0.0, "avg_logprob": -0.07408631692721149, "compression_ratio": 1.789090909090909, "no_speech_prob": 0.010411097668111324}, {"id": 95, "seek": 49648, "start": 518.8000000000001, "end": 523.84, "text": " works out. So what can we do here? Well, the only thing we can do is start to expand definitions.", "tokens": [51480, 1985, 484, 13, 407, 437, 393, 321, 360, 510, 30, 1042, 11, 264, 787, 551, 321, 393, 360, 307, 722, 281, 5268, 21988, 13, 51732], "temperature": 0.0, "avg_logprob": -0.07408631692721149, "compression_ratio": 1.789090909090909, "no_speech_prob": 0.010411097668111324}, {"id": 96, "seek": 52384, "start": 523.84, "end": 530.32, "text": " So we know what the definition of not is. It was lambda b, b applied to false and true,", "tokens": [50364, 407, 321, 458, 437, 264, 7123, 295, 406, 307, 13, 467, 390, 13607, 272, 11, 272, 6456, 281, 7908, 293, 2074, 11, 50688], "temperature": 0.0, "avg_logprob": -0.09335650378511152, "compression_ratio": 1.839080459770115, "no_speech_prob": 0.002319625113159418}, {"id": 97, "seek": 52384, "start": 530.32, "end": 534.96, "text": " and then we just copy down the true. So all I've done in the first step here is I've expanded", "tokens": [50688, 293, 550, 321, 445, 5055, 760, 264, 2074, 13, 407, 439, 286, 600, 1096, 294, 264, 700, 1823, 510, 307, 286, 600, 14342, 50920], "temperature": 0.0, "avg_logprob": -0.09335650378511152, "compression_ratio": 1.839080459770115, "no_speech_prob": 0.002319625113159418}, {"id": 98, "seek": 52384, "start": 534.96, "end": 540.0, "text": " my definition of not. Not was defined to be this lambda calculus expression here. Now I've got a", "tokens": [50920, 452, 7123, 295, 406, 13, 1726, 390, 7642, 281, 312, 341, 13607, 33400, 6114, 510, 13, 823, 286, 600, 658, 257, 51172], "temperature": 0.0, "avg_logprob": -0.09335650378511152, "compression_ratio": 1.839080459770115, "no_speech_prob": 0.002319625113159418}, {"id": 99, "seek": 52384, "start": 540.0, "end": 545.6, "text": " function, which is this thing, and it's applied to an input. So I can just apply it. Okay. And the", "tokens": [51172, 2445, 11, 597, 307, 341, 551, 11, 293, 309, 311, 6456, 281, 364, 4846, 13, 407, 286, 393, 445, 3079, 309, 13, 1033, 13, 400, 264, 51452], "temperature": 0.0, "avg_logprob": -0.09335650378511152, "compression_ratio": 1.839080459770115, "no_speech_prob": 0.002319625113159418}, {"id": 100, "seek": 52384, "start": 545.6, "end": 550.96, "text": " function says if I take in a b, I just apply that b to false and true. So the thing I'm applying it to", "tokens": [51452, 2445, 1619, 498, 286, 747, 294, 257, 272, 11, 286, 445, 3079, 300, 272, 281, 7908, 293, 2074, 13, 407, 264, 551, 286, 478, 9275, 309, 281, 51720], "temperature": 0.0, "avg_logprob": -0.09335650378511152, "compression_ratio": 1.839080459770115, "no_speech_prob": 0.002319625113159418}, {"id": 101, "seek": 55096, "start": 550.96, "end": 556.96, "text": " is true here. So I just do the little substitution, rather than b, I write true, and then I copy down", "tokens": [50364, 307, 2074, 510, 13, 407, 286, 445, 360, 264, 707, 35827, 11, 2831, 813, 272, 11, 286, 2464, 2074, 11, 293, 550, 286, 5055, 760, 50664], "temperature": 0.0, "avg_logprob": -0.08164163915122427, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.020605135709047318}, {"id": 102, "seek": 55096, "start": 556.96, "end": 561.36, "text": " the false and copy down the true, and I get down to here. And at this point, you might quite rightly", "tokens": [50664, 264, 7908, 293, 5055, 760, 264, 2074, 11, 293, 286, 483, 760, 281, 510, 13, 400, 412, 341, 935, 11, 291, 1062, 1596, 32879, 50884], "temperature": 0.0, "avg_logprob": -0.08164163915122427, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.020605135709047318}, {"id": 103, "seek": 55096, "start": 561.36, "end": 564.8000000000001, "text": " be thinking this looks like complete rubbish. I mean, I've just written true, false, true. What", "tokens": [50884, 312, 1953, 341, 1542, 411, 3566, 29978, 13, 286, 914, 11, 286, 600, 445, 3720, 2074, 11, 7908, 11, 2074, 13, 708, 51056], "temperature": 0.0, "avg_logprob": -0.08164163915122427, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.020605135709047318}, {"id": 104, "seek": 55096, "start": 564.8000000000001, "end": 568.24, "text": " does that mean? It means absolutely nothing. But it means something in the lambda calculus because", "tokens": [51056, 775, 300, 914, 30, 467, 1355, 3122, 1825, 13, 583, 309, 1355, 746, 294, 264, 13607, 33400, 570, 51228], "temperature": 0.0, "avg_logprob": -0.08164163915122427, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.020605135709047318}, {"id": 105, "seek": 55096, "start": 568.24, "end": 574.8000000000001, "text": " we continue to expand. So what we can do now is expand the definition of true. We said that true", "tokens": [51228, 321, 2354, 281, 5268, 13, 407, 437, 321, 393, 360, 586, 307, 5268, 264, 7123, 295, 2074, 13, 492, 848, 300, 2074, 51556], "temperature": 0.0, "avg_logprob": -0.08164163915122427, "compression_ratio": 1.7272727272727273, "no_speech_prob": 0.020605135709047318}, {"id": 106, "seek": 57480, "start": 574.8, "end": 582.0799999999999, "text": " takes two things and chooses the first one. So let's expand it out. So true is lambda x, lambda y,", "tokens": [50364, 2516, 732, 721, 293, 25963, 264, 700, 472, 13, 407, 718, 311, 5268, 309, 484, 13, 407, 2074, 307, 13607, 2031, 11, 13607, 288, 11, 50728], "temperature": 0.0, "avg_logprob": -0.07083020683463292, "compression_ratio": 1.9641434262948207, "no_speech_prob": 0.045709576457738876}, {"id": 107, "seek": 57480, "start": 582.0799999999999, "end": 587.12, "text": " x. So it chooses the first thing of two things. And then we just copy down the two inputs, false", "tokens": [50728, 2031, 13, 407, 309, 25963, 264, 700, 551, 295, 732, 721, 13, 400, 550, 321, 445, 5055, 760, 264, 732, 15743, 11, 7908, 50980], "temperature": 0.0, "avg_logprob": -0.07083020683463292, "compression_ratio": 1.9641434262948207, "no_speech_prob": 0.045709576457738876}, {"id": 108, "seek": 57480, "start": 587.12, "end": 591.04, "text": " and true. And you can see what's going to happen now. We've got a function here, which takes two", "tokens": [50980, 293, 2074, 13, 400, 291, 393, 536, 437, 311, 516, 281, 1051, 586, 13, 492, 600, 658, 257, 2445, 510, 11, 597, 2516, 732, 51176], "temperature": 0.0, "avg_logprob": -0.07083020683463292, "compression_ratio": 1.9641434262948207, "no_speech_prob": 0.045709576457738876}, {"id": 109, "seek": 57480, "start": 591.04, "end": 595.8399999999999, "text": " things and chooses the first thing. Here, the first thing is false. So when we apply the function,", "tokens": [51176, 721, 293, 25963, 264, 700, 551, 13, 1692, 11, 264, 700, 551, 307, 7908, 13, 407, 562, 321, 3079, 264, 2445, 11, 51416], "temperature": 0.0, "avg_logprob": -0.07083020683463292, "compression_ratio": 1.9641434262948207, "no_speech_prob": 0.045709576457738876}, {"id": 110, "seek": 57480, "start": 595.8399999999999, "end": 601.68, "text": " we just get back false. So what you see has happened here. In just a few steps, we've shown how using", "tokens": [51416, 321, 445, 483, 646, 7908, 13, 407, 437, 291, 536, 575, 2011, 510, 13, 682, 445, 257, 1326, 4439, 11, 321, 600, 4898, 577, 1228, 51708], "temperature": 0.0, "avg_logprob": -0.07083020683463292, "compression_ratio": 1.9641434262948207, "no_speech_prob": 0.045709576457738876}, {"id": 111, "seek": 60168, "start": 601.68, "end": 607.12, "text": " this encoding of true and false and not, we can actually get the desired behavior. And it's very", "tokens": [50364, 341, 43430, 295, 2074, 293, 7908, 293, 406, 11, 321, 393, 767, 483, 264, 14721, 5223, 13, 400, 309, 311, 588, 50636], "temperature": 0.0, "avg_logprob": -0.06475323073718013, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.0025302038993686438}, {"id": 112, "seek": 60168, "start": 607.12, "end": 613.76, "text": " easy to check for yourself. If you apply not to false, you'll get true. And I'd like to set your", "tokens": [50636, 1858, 281, 1520, 337, 1803, 13, 759, 291, 3079, 406, 281, 7908, 11, 291, 603, 483, 2074, 13, 400, 286, 1116, 411, 281, 992, 428, 50968], "temperature": 0.0, "avg_logprob": -0.06475323073718013, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.0025302038993686438}, {"id": 113, "seek": 60168, "start": 613.76, "end": 619.5999999999999, "text": " little kind of puzzle at this point. Think how you could define logical and or logical or in this", "tokens": [50968, 707, 733, 295, 12805, 412, 341, 935, 13, 6557, 577, 291, 727, 6964, 14978, 293, 420, 14978, 420, 294, 341, 51260], "temperature": 0.0, "avg_logprob": -0.06475323073718013, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.0025302038993686438}, {"id": 114, "seek": 60168, "start": 619.5999999999999, "end": 624.0, "text": " style as well. Okay, and I'm interested to see what kind of definitions people come up with in the", "tokens": [51260, 3758, 382, 731, 13, 1033, 11, 293, 286, 478, 3102, 281, 536, 437, 733, 295, 21988, 561, 808, 493, 365, 294, 264, 51480], "temperature": 0.0, "avg_logprob": -0.06475323073718013, "compression_ratio": 1.598360655737705, "no_speech_prob": 0.0025302038993686438}, {"id": 115, "seek": 62400, "start": 624.0, "end": 632.08, "text": " comments. So the very last thing I'd like to show you is this lambda expression here, which is a", "tokens": [50364, 3053, 13, 407, 264, 588, 1036, 551, 286, 1116, 411, 281, 855, 291, 307, 341, 13607, 6114, 510, 11, 597, 307, 257, 50768], "temperature": 0.0, "avg_logprob": -0.08444155364477333, "compression_ratio": 1.7992565055762082, "no_speech_prob": 0.057534974068403244}, {"id": 116, "seek": 62400, "start": 632.08, "end": 638.24, "text": " very famous lambda calculus expression called the y combinator or the y operator. And actually,", "tokens": [50768, 588, 4618, 13607, 33400, 6114, 1219, 264, 288, 2512, 31927, 420, 264, 288, 12973, 13, 400, 767, 11, 51076], "temperature": 0.0, "avg_logprob": -0.08444155364477333, "compression_ratio": 1.7992565055762082, "no_speech_prob": 0.057534974068403244}, {"id": 117, "seek": 62400, "start": 638.24, "end": 643.28, "text": " this is the key to doing recursion in the lambda calculus. So as I mentioned, lambda calculus", "tokens": [51076, 341, 307, 264, 2141, 281, 884, 20560, 313, 294, 264, 13607, 33400, 13, 407, 382, 286, 2835, 11, 13607, 33400, 51328], "temperature": 0.0, "avg_logprob": -0.08444155364477333, "compression_ratio": 1.7992565055762082, "no_speech_prob": 0.057534974068403244}, {"id": 118, "seek": 62400, "start": 643.28, "end": 648.24, "text": " has basically nothing in it, or it's only got three things in it, variables x, y and z, and so on,", "tokens": [51328, 575, 1936, 1825, 294, 309, 11, 420, 309, 311, 787, 658, 1045, 721, 294, 309, 11, 9102, 2031, 11, 288, 293, 710, 11, 293, 370, 322, 11, 51576], "temperature": 0.0, "avg_logprob": -0.08444155364477333, "compression_ratio": 1.7992565055762082, "no_speech_prob": 0.057534974068403244}, {"id": 119, "seek": 62400, "start": 648.24, "end": 653.12, "text": " a way of building functions and a way of applying functions. It's got no other control structures,", "tokens": [51576, 257, 636, 295, 2390, 6828, 293, 257, 636, 295, 9275, 6828, 13, 467, 311, 658, 572, 661, 1969, 9227, 11, 51820], "temperature": 0.0, "avg_logprob": -0.08444155364477333, "compression_ratio": 1.7992565055762082, "no_speech_prob": 0.057534974068403244}, {"id": 120, "seek": 65312, "start": 653.12, "end": 658.4, "text": " no other data types, no anything. So if you want to do recursion, which is the basic mechanism for", "tokens": [50364, 572, 661, 1412, 3467, 11, 572, 1340, 13, 407, 498, 291, 528, 281, 360, 20560, 313, 11, 597, 307, 264, 3875, 7513, 337, 50628], "temperature": 0.0, "avg_logprob": -0.07028309788022723, "compression_ratio": 1.7380073800738007, "no_speech_prob": 0.0004012133867945522}, {"id": 121, "seek": 65312, "start": 658.4, "end": 663.2, "text": " defining things in terms of themselves, again, computer files had videos on this, you need to", "tokens": [50628, 17827, 721, 294, 2115, 295, 2969, 11, 797, 11, 3820, 7098, 632, 2145, 322, 341, 11, 291, 643, 281, 50868], "temperature": 0.0, "avg_logprob": -0.07028309788022723, "compression_ratio": 1.7380073800738007, "no_speech_prob": 0.0004012133867945522}, {"id": 122, "seek": 65312, "start": 663.2, "end": 668.4, "text": " encode it. It turns out that this expression here is the key to encoding recursion in the lambda", "tokens": [50868, 2058, 1429, 309, 13, 467, 4523, 484, 300, 341, 6114, 510, 307, 264, 2141, 281, 43430, 20560, 313, 294, 264, 13607, 51128], "temperature": 0.0, "avg_logprob": -0.07028309788022723, "compression_ratio": 1.7380073800738007, "no_speech_prob": 0.0004012133867945522}, {"id": 123, "seek": 65312, "start": 668.4, "end": 672.88, "text": " calculus. And this expression was invented by someone called Haskell Curry. And this is the", "tokens": [51128, 33400, 13, 400, 341, 6114, 390, 14479, 538, 1580, 1219, 8646, 43723, 34789, 13, 400, 341, 307, 264, 51352], "temperature": 0.0, "avg_logprob": -0.07028309788022723, "compression_ratio": 1.7380073800738007, "no_speech_prob": 0.0004012133867945522}, {"id": 124, "seek": 65312, "start": 672.88, "end": 677.6, "text": " Haskell that gives his name to the Haskell programming language. And he was a PhD student", "tokens": [51352, 8646, 43723, 300, 2709, 702, 1315, 281, 264, 8646, 43723, 9410, 2856, 13, 400, 415, 390, 257, 14476, 3107, 51588], "temperature": 0.0, "avg_logprob": -0.07028309788022723, "compression_ratio": 1.7380073800738007, "no_speech_prob": 0.0004012133867945522}, {"id": 125, "seek": 67760, "start": 677.6, "end": 683.12, "text": " of David Hilbert, who's a very famous mathematician. The last observation I'd like to leave you with", "tokens": [50364, 295, 4389, 19914, 4290, 11, 567, 311, 257, 588, 4618, 48281, 13, 440, 1036, 14816, 286, 1116, 411, 281, 1856, 291, 365, 50640], "temperature": 0.0, "avg_logprob": -0.05231498195006784, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.005564979277551174}, {"id": 126, "seek": 67760, "start": 683.12, "end": 688.48, "text": " here is something that's interested me for many years. I think there's a connection between this", "tokens": [50640, 510, 307, 746, 300, 311, 3102, 385, 337, 867, 924, 13, 286, 519, 456, 311, 257, 4984, 1296, 341, 50908], "temperature": 0.0, "avg_logprob": -0.05231498195006784, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.005564979277551174}, {"id": 127, "seek": 67760, "start": 688.48, "end": 693.9200000000001, "text": " piece of kind of abstract computer science or abstract mathematics and biology. If you look at", "tokens": [50908, 2522, 295, 733, 295, 12649, 3820, 3497, 420, 12649, 18666, 293, 14956, 13, 759, 291, 574, 412, 51180], "temperature": 0.0, "avg_logprob": -0.05231498195006784, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.005564979277551174}, {"id": 128, "seek": 67760, "start": 693.9200000000001, "end": 699.44, "text": " human DNA, you have this double helix structure. You have two copies of the same thing side by", "tokens": [51180, 1952, 8272, 11, 291, 362, 341, 3834, 801, 970, 3877, 13, 509, 362, 732, 14341, 295, 264, 912, 551, 1252, 538, 51456], "temperature": 0.0, "avg_logprob": -0.05231498195006784, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.005564979277551174}, {"id": 129, "seek": 67760, "start": 699.44, "end": 705.0400000000001, "text": " side. And this is the key to allowing DNA to self replicate. If you look at the structure of this", "tokens": [51456, 1252, 13, 400, 341, 307, 264, 2141, 281, 8293, 8272, 281, 2698, 25356, 13, 759, 291, 574, 412, 264, 3877, 295, 341, 51736], "temperature": 0.0, "avg_logprob": -0.05231498195006784, "compression_ratio": 1.6782006920415224, "no_speech_prob": 0.005564979277551174}, {"id": 130, "seek": 70504, "start": 705.04, "end": 711.36, "text": " lambda expression here, you have two copies of the same thing side by side. You have lambda x f", "tokens": [50364, 13607, 6114, 510, 11, 291, 362, 732, 14341, 295, 264, 912, 551, 1252, 538, 1252, 13, 509, 362, 13607, 2031, 283, 50680], "temperature": 0.0, "avg_logprob": -0.07172859026038128, "compression_ratio": 1.795539033457249, "no_speech_prob": 0.00036653236020356417}, {"id": 131, "seek": 70504, "start": 711.36, "end": 716.4, "text": " applied to xx and exactly the same here. And this is the key to doing recursion, which is kind of", "tokens": [50680, 6456, 281, 2031, 87, 293, 2293, 264, 912, 510, 13, 400, 341, 307, 264, 2141, 281, 884, 20560, 313, 11, 597, 307, 733, 295, 50932], "temperature": 0.0, "avg_logprob": -0.07172859026038128, "compression_ratio": 1.795539033457249, "no_speech_prob": 0.00036653236020356417}, {"id": 132, "seek": 70504, "start": 716.4, "end": 722.56, "text": " related to self replication in a programming language or in the lambda calculus. And for me,", "tokens": [50932, 4077, 281, 2698, 39911, 294, 257, 9410, 2856, 420, 294, 264, 13607, 33400, 13, 400, 337, 385, 11, 51240], "temperature": 0.0, "avg_logprob": -0.07172859026038128, "compression_ratio": 1.795539033457249, "no_speech_prob": 0.00036653236020356417}, {"id": 133, "seek": 70504, "start": 722.56, "end": 726.64, "text": " I don't think this is a coincidence. I think it's a kind of interesting philosophical observation.", "tokens": [51240, 286, 500, 380, 519, 341, 307, 257, 22137, 13, 286, 519, 309, 311, 257, 733, 295, 1880, 25066, 14816, 13, 51444], "temperature": 0.0, "avg_logprob": -0.07172859026038128, "compression_ratio": 1.795539033457249, "no_speech_prob": 0.00036653236020356417}, {"id": 134, "seek": 70504, "start": 726.64, "end": 732.3199999999999, "text": " The lambda calculus has this kind of very clever way of doing recursion, which would take a video", "tokens": [51444, 440, 13607, 33400, 575, 341, 733, 295, 588, 13494, 636, 295, 884, 20560, 313, 11, 597, 576, 747, 257, 960, 51728], "temperature": 0.0, "avg_logprob": -0.07172859026038128, "compression_ratio": 1.795539033457249, "no_speech_prob": 0.00036653236020356417}, {"id": 135, "seek": 73232, "start": 732.32, "end": 737.5200000000001, "text": " on its own to explain how it actually works. But you can look it up on Wikipedia. And there's a link", "tokens": [50364, 322, 1080, 1065, 281, 2903, 577, 309, 767, 1985, 13, 583, 291, 393, 574, 309, 493, 322, 28999, 13, 400, 456, 311, 257, 2113, 50624], "temperature": 0.0, "avg_logprob": -0.12901108872656727, "compression_ratio": 1.6265060240963856, "no_speech_prob": 0.0002253657439723611}, {"id": 136, "seek": 73232, "start": 737.5200000000001, "end": 746.08, "text": " here, I think, to biology. Somebody actually found the Y Combinator so interesting that they've had", "tokens": [50624, 510, 11, 286, 519, 11, 281, 14956, 13, 13463, 767, 1352, 264, 398, 2432, 13496, 1639, 370, 1880, 300, 436, 600, 632, 51052], "temperature": 0.0, "avg_logprob": -0.12901108872656727, "compression_ratio": 1.6265060240963856, "no_speech_prob": 0.0002253657439723611}, {"id": 137, "seek": 73232, "start": 746.08, "end": 750.32, "text": " it tattooed permanently on their arm. And you can find the picture of this if you do a quick web search.", "tokens": [51052, 309, 15080, 292, 24042, 322, 641, 3726, 13, 400, 291, 393, 915, 264, 3036, 295, 341, 498, 291, 360, 257, 1702, 3670, 3164, 13, 51264], "temperature": 0.0, "avg_logprob": -0.12901108872656727, "compression_ratio": 1.6265060240963856, "no_speech_prob": 0.0002253657439723611}, {"id": 138, "seek": 73232, "start": 751.7600000000001, "end": 757.0400000000001, "text": " What would people search for the Y Combinator? The Y Combinator in mathematics or computer science.", "tokens": [51336, 708, 576, 561, 3164, 337, 264, 398, 2432, 13496, 1639, 30, 440, 398, 2432, 13496, 1639, 294, 18666, 420, 3820, 3497, 13, 51600], "temperature": 0.0, "avg_logprob": -0.12901108872656727, "compression_ratio": 1.6265060240963856, "no_speech_prob": 0.0002253657439723611}, {"id": 139, "seek": 75704, "start": 757.04, "end": 758.24, "text": " And tattoo, I'm guessing.", "tokens": [50364, 400, 15080, 11, 286, 478, 17939, 13, 50424], "temperature": 0.0, "avg_logprob": -0.40818257331848146, "compression_ratio": 0.7575757575757576, "no_speech_prob": 0.0052560120820999146}], "language": "en"}