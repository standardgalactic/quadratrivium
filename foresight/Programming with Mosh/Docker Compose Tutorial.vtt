WEBVTT

00:00.000 --> 00:05.640
In this video, you're going to learn about Docker Compose, so by the end of this video,

00:05.640 --> 00:08.160
you'll be able to use Docker commands with confidence.

00:08.160 --> 00:13.240
Hi, I'm Mosh Hamidani, and I've taught millions of people how to code through this channel

00:13.240 --> 00:16.000
at my online school code with Mosh.com.

00:16.000 --> 00:20.560
This video is part of my ultimate Docker course, so once you finish this video, if you want

00:20.560 --> 00:23.520
to learn more, you may want to look at the complete course.

00:23.520 --> 00:29.960
Now let's jump in and get started.

00:29.960 --> 00:32.920
Welcome back to another section of the ultimate Docker course.

00:32.920 --> 00:36.640
In this section, we're going to talk about running multi-container applications.

00:36.640 --> 00:41.160
So I'm going to give you a real-world application with three building blocks, a front-end built

00:41.160 --> 00:45.840
with React, a back-end built with Node, and a MongoDB database.

00:45.840 --> 00:49.200
Once again, you don't need to be familiar or use any of these tools.

00:49.200 --> 00:52.800
Our focus here is on Docker and not on development tools.

00:52.800 --> 00:56.520
I think this is the most exciting part of this course, where you can see everything coming

00:56.520 --> 00:57.520
together.

00:57.520 --> 01:02.080
So we're going to talk about Docker Compose for building and running multi-container applications.

01:02.080 --> 01:07.400
We'll also talk about Docker networking, database migration, and running automated tests.

01:07.400 --> 01:20.360
So let's jump in and get started.

01:20.360 --> 01:24.040
In this section, we're going to use a tool called Docker Compose, which is built on top

01:24.040 --> 01:25.480
of Docker Engine.

01:25.480 --> 01:29.880
It makes it incredibly easy to start applications with multiple containers.

01:29.880 --> 01:32.280
So Google Docker Compose install.

01:32.280 --> 01:37.720
You will find this page, docs.docker.com, slash compose, slash install.

01:37.720 --> 01:40.040
On this page, you can see the installation instructions.

01:40.040 --> 01:46.240
Now at the time of recording this, Docker Compose is shipped with Docker desktop for Mac

01:46.240 --> 01:47.240
and Windows.

01:47.240 --> 01:50.240
So if you're on Mac or Windows, you don't have to do anything extra.

01:50.240 --> 01:52.240
You already have Docker Compose.

01:52.240 --> 01:58.960
To verify it, just go to the terminal window and type Docker Compose dash dash version.

01:58.960 --> 02:03.360
So I'm running Docker Compose version 1.28.5.

02:03.360 --> 02:05.760
Make sure your version is the same or newer.

02:05.760 --> 02:11.160
If you're using an older version, again, Google upgrade Docker Compose, or you might

02:11.160 --> 02:14.320
just install the latest version of Docker.

02:14.320 --> 02:16.240
Now back to this page.

02:16.240 --> 02:19.960
If you're using Windows Server or Linux, there are specific instructions you have to

02:19.960 --> 02:22.760
follow to install Docker Compose.

02:22.760 --> 02:33.280
So go ahead and install Docker Compose and I will see you in the next lesson.

02:33.280 --> 02:36.320
Before we get started, I want to show you a couple of techniques for cleaning up our

02:36.320 --> 02:37.680
workspace.

02:37.680 --> 02:42.400
So on this machine, we have a bunch of images and some running containers.

02:42.400 --> 02:43.400
They're getting in the way.

02:43.400 --> 02:45.120
I want to get rid of them all.

02:45.120 --> 02:46.120
How do we do this?

02:46.120 --> 02:50.920
Well, you know that we can remove images using Docker image remove command.

02:50.920 --> 02:54.120
And here we can type one or more image IDs.

02:54.120 --> 02:57.040
Now how can we get all image IDs and pass them here?

02:57.040 --> 02:58.560
Let me show you a cool trick.

02:58.560 --> 03:01.680
So we can run Docker image LS.

03:01.680 --> 03:03.320
We see all the images, right?

03:03.320 --> 03:08.040
But if you pass dash Q at the end, we only get image IDs.

03:08.040 --> 03:11.880
Now we can pass this as an argument to Docker image remove.

03:11.880 --> 03:13.800
So Docker image remove.

03:14.480 --> 03:19.720
Now here we add a dollar sign and in parenthesis, we type that other command.

03:19.720 --> 03:22.960
So Docker image LS dash Q.

03:22.960 --> 03:26.960
Now if we run this, we're going to get an error because some of these images are already

03:26.960 --> 03:30.280
in running containers or stopped containers.

03:30.280 --> 03:32.120
So we should always remove containers first.

03:32.120 --> 03:34.800
We're going to do that using the same technique.

03:34.800 --> 03:38.680
So I'm going to replace image with container.

03:38.680 --> 03:45.960
So we get all container IDs and then we're going to remove them all in one go.

03:45.960 --> 03:49.840
Also I would like to add dash A here as well.

03:49.840 --> 03:52.960
This will bring stopped containers as well, okay?

03:52.960 --> 03:55.520
We can also combine switches.

03:55.520 --> 03:56.880
That's another technique.

03:56.880 --> 03:57.880
Let's go ahead.

03:57.880 --> 04:02.960
All right, we get an error saying you cannot remove a running container because I forgot

04:02.960 --> 04:04.880
to pass the force option.

04:04.880 --> 04:07.920
So let's bring this up one more time.

04:07.920 --> 04:12.440
When removing, we're going to use dash F, okay?

04:12.440 --> 04:13.880
Great.

04:13.880 --> 04:16.520
So all these containers are removed.

04:16.520 --> 04:17.680
Now let's remove the images.

04:17.680 --> 04:25.320
So Docker image LS and Docker image remove.

04:25.320 --> 04:27.400
Great.

04:27.400 --> 04:29.160
Now take a look.

04:29.160 --> 04:34.800
We don't have any images here and no containers, including stopped containers.

04:34.800 --> 04:36.560
So we have a clean workspace.

04:36.560 --> 04:37.560
That's one way.

04:37.560 --> 04:39.640
There is a shortcut for this as well.

04:39.640 --> 04:43.600
If you're on Mac, you can find the Docker icon on the top status bar.

04:43.600 --> 04:46.880
If you're on Windows, you will find it in your notification tray.

04:46.880 --> 04:51.080
Let's click on this and then go to preferences.

04:51.080 --> 04:54.640
Now on this page, let's click on the troubleshoot icon.

04:54.640 --> 04:57.200
On this page, we have a bunch of useful utilities.

04:57.200 --> 05:00.080
For example, we can restart Docker desktop.

05:00.080 --> 05:02.640
We can also clean and purge data.

05:02.640 --> 05:07.140
This will essentially remove everything in Docker, your images, your containers, your

05:07.140 --> 05:08.640
volumes and so on.

05:08.640 --> 05:14.040
Now be aware that if you click on this, this is going to restart Docker engine.

05:14.040 --> 05:19.280
So on the top, look, you can see this animation showing that the Docker engine is not started

05:19.280 --> 05:20.280
yet.

05:20.280 --> 05:24.360
So at this point, if you go to the terminal window and execute any of Docker commands,

05:24.360 --> 05:25.560
you're going to get an error.

05:25.560 --> 05:29.720
So you'll have to wait about half a minute for the Docker engine to start.

05:29.720 --> 05:30.880
That's another way.

05:30.880 --> 05:41.440
So now that we have a clean workspace, next we're going to talk about our application.

05:41.440 --> 05:44.360
So in this next section, we're going to look at a real-world application with multiple

05:44.360 --> 05:48.380
building blocks, a front end, a back end and a database.

05:48.380 --> 05:50.960
So below this video, I've attached a Z file.

05:50.960 --> 05:52.600
Go ahead and download it.

05:52.600 --> 05:55.360
Inside that Z file, you're going to find this folder structure.

05:55.360 --> 05:58.840
We have this backend folder, which is our node project.

05:58.840 --> 06:04.120
This is a basic node project that starts a web server on port 3001.

06:04.120 --> 06:07.640
Once again, you don't need to know node to go through this section.

06:07.640 --> 06:11.680
Then we have the front end project, which is a React application that talks to the back

06:11.680 --> 06:12.680
end.

06:12.680 --> 06:16.920
Now, if you want to run this application outside of Docker, there are a number of steps

06:16.920 --> 06:17.920
we have to follow.

06:17.920 --> 06:22.520
Let's say we just check this out from a GitHub repository.

06:22.520 --> 06:26.920
First we have to go to our back end project, install all dependencies and then start the

06:26.920 --> 06:27.920
web server.

06:28.000 --> 06:33.000
At the same time, we have to open up another terminal window and do the same steps with

06:33.000 --> 06:34.320
our front end project.

06:34.320 --> 06:39.440
So we have to go to the front end project, install all the dependencies and then start

06:39.440 --> 06:40.440
the web server.

06:40.440 --> 06:45.760
And of course, we need two more terminal windows for running our front end and back end tests.

06:45.760 --> 06:50.560
And not to mention that, we should also download and install MongoDB on this machine.

06:50.560 --> 06:54.520
So there are so many steps we have to follow the moment we check out the source code from

06:54.520 --> 06:56.280
our GitHub repository.

06:56.280 --> 06:59.400
Now with Docker, we don't have to do any of these things.

06:59.400 --> 07:01.840
All we have to do is run a single command.

07:01.840 --> 07:02.840
Let me show you.

07:02.840 --> 07:06.720
So I'm going to get outside of the front end folder.

07:06.720 --> 07:08.520
Now we are in the root of this project.

07:08.520 --> 07:14.600
If you look, here we have a file called Docker Compose, which is used for composing a multi-container

07:14.600 --> 07:15.600
application.

07:15.600 --> 07:17.960
We're going to talk about that in detail soon.

07:17.960 --> 07:24.800
Now, once we have this file in our project, we can simply run Docker Compose up.

07:24.800 --> 07:26.560
That's all we have to do.

07:26.560 --> 07:31.960
Now, Docker is automatically downloading this particular version of MongoDB, so it's downloading

07:31.960 --> 07:33.520
all these layers.

07:33.520 --> 07:37.320
Then at the same time, it's going to install all the dependencies for our front end and

07:37.320 --> 07:38.320
back end projects.

07:38.320 --> 07:42.520
It will start web servers and run automated tests all in this window.

07:42.520 --> 07:46.760
Now, this is going to take a little while, so I'll be right back.

07:46.760 --> 07:54.200
All right, our application is up and running, and we can access it at localhost for 3000.

07:54.200 --> 07:56.120
So here's what we get.

07:56.120 --> 07:58.800
We have a mini application for managing a list of movies.

07:58.800 --> 08:00.880
Now, you know what's the beauty here?

08:00.880 --> 08:05.680
The beauty is that our database is populated with these movies as part of bringing up our

08:05.680 --> 08:06.680
application.

08:06.680 --> 08:09.760
I didn't have to manually insert these movies in our database.

08:09.760 --> 08:15.120
So we have a migration script for populating our database, and Docker automatically executed

08:15.120 --> 08:18.680
our migration script as part of bringing up this application.

08:18.680 --> 08:20.800
This is a very common real-world scenario.

08:21.360 --> 08:27.400
Now, here we can add new movies, movie one, movie two, whatever, and we can also delete

08:27.400 --> 08:28.400
these movies.

08:28.400 --> 08:31.440
So, we brought up this application using a single command.

08:31.440 --> 08:35.920
Now, I briefly mentioned this file, docker-compose.yaml.

08:35.920 --> 08:39.480
Before we talk about this file, first you need to understand the YAML format.

08:39.480 --> 08:41.760
This is a format that a lot of people are not familiar with.

08:41.760 --> 08:45.240
So in the next lesson, we're going to talk about JSON and YAML formats.

08:51.800 --> 08:54.840
Let's talk about JSON and YAML formats.

08:54.840 --> 08:58.240
If you know this format as well, feel free to skip this lesson.

08:58.240 --> 09:04.920
So in the root of this project, we're going to add a new file called data.json.json, as

09:04.920 --> 09:09.960
you probably know is a language, it's a human-readable language for representing data.

09:09.960 --> 09:14.160
So in this JSON file, we can have an object or an array, let's say we want to represent

09:14.160 --> 09:15.160
a course.

09:15.160 --> 09:18.600
A course can have properties like name, price, and so on.

09:18.600 --> 09:22.480
So in this object, we can add one or more key value pairs.

09:22.480 --> 09:25.120
Our keys should always be surrounded in double quotes.

09:25.120 --> 09:30.800
So we can add a key called name, and set its value to, we can use a string, the ultimate

09:30.800 --> 09:35.880
docker course, then we add a comma to define the next key value pair.

09:35.880 --> 09:40.800
So we can say price, we can set this to a number.

09:40.800 --> 09:45.600
Now the value can also be a boolean, so we can define another key value pair, and set

09:45.600 --> 09:48.600
the value to true or false.

09:48.600 --> 09:51.840
We can define another key value pair, and set the value to an array.

09:51.840 --> 09:54.600
So we define an array using square brackets.

09:54.600 --> 09:57.720
Now in this array, we can have any valid objects.

09:57.720 --> 10:01.960
So we can have strings, numbers, booleans, or other objects.

10:01.960 --> 10:07.720
So I'm going to add a couple of strings, let's say software and DevOps.

10:07.720 --> 10:12.840
And one last key value pair, author, I'm going to make this an object, so once again we use

10:12.840 --> 10:15.380
curly braces to define an object.

10:15.380 --> 10:23.220
In this object, we add a couple of key value pairs, first name is mosh, and last name is

10:23.220 --> 10:24.220
what?

10:24.220 --> 10:29.620
I'm a darling, and yes, I am Iranian, I get that question all the time.

10:29.620 --> 10:34.260
Alright, so here we have a JSON file, now let's see how we can convert this to YAML.

10:34.260 --> 10:39.380
YAML is another language for presenting data, but it has less clutter than JSON, it's easier

10:39.380 --> 10:40.460
to read.

10:40.460 --> 10:45.740
So I'm going to copy all this code, here in the project, we're going to add a new file

10:45.740 --> 10:52.740
called datum.yaml, the extension can be YAML or YML.

10:52.740 --> 10:58.980
Now on the top, we add three hyphens to indicate the beginning of a YAML file, then we paste

10:58.980 --> 10:59.980
our code.

10:59.980 --> 11:04.540
Now in YAML, we don't use curly braces to indicate hierarchy.

11:04.540 --> 11:08.860
This idea has come from Python, if you have programmed in Python, you know that in Python

11:08.940 --> 11:13.580
we use indentation to represent hierarchy, so we don't have curly braces.

11:13.580 --> 11:19.340
So let's get rid of these braces, and remove the indentation, good.

11:19.340 --> 11:23.420
Now the next thing you need to know about YAML is that we don't have to use quotes.

11:23.420 --> 11:30.300
So we can bring up the replace dialog, and replace all these double quotes with nothing.

11:30.300 --> 11:33.180
That immediately takes a lot of clutter away.

11:33.180 --> 11:39.540
Also, we're not going to use commas to separate key value pairs.

11:39.540 --> 11:44.940
So on the top, we have name, price is published, and how do we represent a list or an array?

11:44.940 --> 11:46.220
We use hyphens.

11:46.220 --> 11:53.060
So I'm going to remove this, we press enter, add a tab on a new line, we type hyphen to

11:53.060 --> 11:58.980
define the first item in the list, software, then at the same indentation, we add the next

11:58.980 --> 12:01.260
item, DevOps.

12:01.260 --> 12:06.700
Now author is an object, but as I told you, we don't use curly braces, we use indentation.

12:06.700 --> 12:12.020
So because these two properties are indented, they belong to the author property, okay?

12:12.020 --> 12:16.740
So this is our YAML file, let's compare this with JSON.

12:16.740 --> 12:20.340
As you can see, YAML is easier to read and understand.

12:20.340 --> 12:22.820
Now why don't we use YAML all the time?

12:22.820 --> 12:27.900
Well, because parsing YAML files is a little bit slower than parsing JSON files, because

12:27.900 --> 12:32.500
the parser doesn't know if this is a string or a number, so it has to read everything

12:32.500 --> 12:35.380
as a string and then try to evaluate it.

12:35.380 --> 12:40.660
In contrast, in JSON, strings are represented using quotes and more specifically double

12:40.660 --> 12:45.980
quotes, so the parser knows that this is a string and it shouldn't evaluate it, okay?

12:45.980 --> 12:51.180
So quite often we use YAML files for configuration files and JSON for exchanging data between

12:51.180 --> 12:54.060
multiple computers, like a client and a server.

12:54.060 --> 12:59.740
So now that you understand these formats, next we're going to talk about compose files.

12:59.740 --> 13:08.300
Alright, let's see how we can create a compose file from scratch.

13:08.300 --> 13:15.420
So for this lesson, I'm going to rename this file to underline docker compose.

13:15.420 --> 13:19.140
We want to set it aside and create a new compose file from scratch.

13:19.140 --> 13:23.700
So here we are, the new file called docker-compose.

13:23.700 --> 13:28.580
All in lowercase, make sure to spell it properly, otherwise docker-compose is not going to find

13:28.580 --> 13:33.460
this file, because this is the default name that docker-compose assumes, okay?

13:33.460 --> 13:35.460
So YAML.

13:35.460 --> 13:39.900
Now the first thing that we need to set here is the version property.

13:39.900 --> 13:41.100
What version should we use?

13:41.100 --> 13:45.260
Well, let's search for docker-compose file.

13:45.260 --> 13:51.540
On this page, you can see various compose file formats and their compatibility with

13:51.540 --> 13:52.540
docker-engine.

13:52.540 --> 13:57.780
We are using the latest version of docker-engine, so I want to use the latest compose file format

13:57.780 --> 14:00.300
so we have access to the latest features.

14:00.300 --> 14:03.420
So we're going to set this to 3.8.

14:03.420 --> 14:08.380
Now here we need to wrap this number with double quotes, otherwise it will be evaluated

14:08.380 --> 14:12.740
as a number, but docker-compose expects this value to be a string.

14:12.740 --> 14:13.740
Why?

14:13.740 --> 14:14.740
I have no clue.

14:15.220 --> 14:16.220
Here's the version.

14:16.220 --> 14:21.260
Now in this file, we define various building blocks or services of our application.

14:21.260 --> 14:24.020
So we have a property called services.

14:24.020 --> 14:25.860
Now what services do we need here?

14:25.860 --> 14:31.540
Well, our application has a front-end, a back-end, and a database.

14:31.540 --> 14:35.860
Your application might have other moving parts, so you can define them here.

14:35.860 --> 14:38.860
Now these names are arbitrary, so we can call them anything.

14:38.860 --> 14:46.540
We can change this to db, we can change the back-end to api, and the front-end to well.

14:46.540 --> 14:51.900
The idea here is that we're defining various services and telling docker how to build images

14:51.900 --> 14:54.980
for each service and how to run these images.

14:54.980 --> 14:59.620
So here we're going to have properties, and the value of these properties will eventually

14:59.620 --> 15:02.380
be used when running our containers.

15:02.380 --> 15:07.780
So in the previous section, we had to manually run our containers using docker-run, and here

15:07.820 --> 15:13.260
we used parameters like dash-p for port mapping or dash-v for volume mapping.

15:13.260 --> 15:16.420
We also had to specify an image like react-app.

15:16.420 --> 15:19.780
All these values can be defined in our compose file.

15:19.780 --> 15:22.620
So we don't have to manually start our containers.

15:22.620 --> 15:27.020
Docker compose will take care of starting our containers under the hood.

15:27.020 --> 15:32.140
So for each service, we need to tell docker how to build an image for that service.

15:32.140 --> 15:36.860
So here we can use the build property and tell docker compose where it can find a docker

15:36.940 --> 15:38.060
file.

15:38.060 --> 15:44.060
So if you look at this project, you can see that in our back-end and front-end folders,

15:44.060 --> 15:46.620
we have a docker file.

15:46.620 --> 15:51.140
This docker file is almost identical to the one we created in the previous section.

15:51.140 --> 15:56.420
So we start from a node image, we create a user, we set our working directory, copy all

15:56.420 --> 16:03.420
the files and install the dependencies, then expose port 3001 and start the web server.

16:03.420 --> 16:06.620
We have a similar docker file in our front-end project.

16:06.620 --> 16:08.180
Let's have a quick look.

16:08.180 --> 16:14.420
So that was the back-end, here's the front-end, and here we have a docker file, almost identical.

16:14.420 --> 16:18.900
But the front-end application or the front-end server starts on a different port.

16:18.900 --> 16:20.340
That is the only difference.

16:20.340 --> 16:24.620
So each service should have its own docker file, okay?

16:24.620 --> 16:30.180
Now back to our compose file, for our web or front-end, we're going to set the build

16:30.180 --> 16:35.140
property to period, meaning current folder, slash front-end.

16:35.140 --> 16:37.500
This is where we have a docker file.

16:37.500 --> 16:42.540
For our API, we're going to set build to back-end.

16:42.540 --> 16:46.100
Now for our database, we're not going to build an image, we're going to pull an image from

16:46.100 --> 16:47.500
docker hop.

16:47.500 --> 16:51.500
So instead of the build property, we're going to use the image property.

16:51.500 --> 16:57.180
Now for this application, I'm going to use Mongo version 4.0-Xenial.

16:57.180 --> 17:02.340
So that is Mongo version 4 built on top of Xenial, which is Ubuntu version 16.

17:02.340 --> 17:07.420
Now if you look at docker hop, you can see that Mongo also has images built on top of

17:07.420 --> 17:11.700
Windows, but Windows images are very large, over two gigabytes.

17:11.700 --> 17:14.860
So that's why I prefer to use Linux images.

17:14.860 --> 17:19.860
So for any of these services, we can either build an image or pull it down.

17:19.860 --> 17:23.700
Now here we also have port mappings, so we set ports to.

17:23.700 --> 17:28.900
Now because we can have multiple port mappings, here we need to use the array or list syntax.

17:28.900 --> 17:32.020
So we use a hyphen, and then define a port mapping.

17:32.020 --> 17:35.620
So our frontend application starts on port 3000.

17:35.620 --> 17:42.060
So I want to map port 3000 of the host to port 3000 of the container running this image.

17:42.060 --> 17:46.700
That's similarly for our API, we're going to define a port mapping.

17:46.700 --> 17:50.860
This one is going to be 3001 to 3001.

17:50.860 --> 17:59.420
Now MongoDB by default, listens on port 27017.

17:59.420 --> 18:05.700
So I want to map the same port, so we can access MongoDB using a MongoDB client like

18:05.700 --> 18:07.340
MongoDB Compass.

18:07.340 --> 18:11.980
If you don't use MongoDB, you have the same concept with other database engines.

18:11.980 --> 18:14.860
All these database engines listen on a default port.

18:14.860 --> 18:19.340
You want to map that port so you can connect to your database engine using your favorite

18:19.340 --> 18:21.540
database client.

18:21.540 --> 18:23.540
What else do we have here?

18:23.540 --> 18:25.580
Back to this page for compose file.

18:25.580 --> 18:30.860
If you look at version three, on the right, you can see all valid properties.

18:30.860 --> 18:34.860
Now a lot of these are for really special cases, so you don't need to use them all the

18:34.860 --> 18:38.860
time, but the ones that we use most of the time are build or image.

18:38.860 --> 18:42.820
You also use ports, volumes, environment, and so on.

18:42.820 --> 18:48.860
So our API project needs an environment variable that tells where our database is.

18:48.860 --> 18:55.500
So here we set environment, and here we can use the list syntax because we can have multiple

18:55.500 --> 18:57.060
environment variables.

18:57.060 --> 19:03.540
So we set DB underline URL to, here we need to type a MongoDB connection string.

19:03.540 --> 19:09.020
These connection strings always start with MongoDB, colon, two forward slashes.

19:09.020 --> 19:11.020
Here we need to type the name of a host.

19:11.020 --> 19:15.860
So as I'll show you later in this section, when we start an application with Docker compose

19:15.860 --> 19:18.780
under the hood, a network is created.

19:18.780 --> 19:21.700
On this network, we're going to have three hosts.

19:21.700 --> 19:25.540
The name of these hosts are equal to the names we have defined here.

19:25.540 --> 19:27.820
So we're going to have a host called DB.

19:27.820 --> 19:31.580
So that is the connection string to our MongoDB server.

19:31.580 --> 19:34.140
Now on this server, we can have multiple databases.

19:34.140 --> 19:39.100
So we're going to specify the database name and the connection string as well.

19:39.100 --> 19:42.700
So this is one way to set an environment variable.

19:42.700 --> 19:47.820
But instead of using the list syntax, we can also use the object or property value syntax.

19:47.820 --> 19:50.300
So we get rid of the hyphen.

19:50.300 --> 19:56.020
We say DB URL is a property and this is the value of that property.

19:56.020 --> 20:00.820
I find the syntax more readable because we get color coding and it's just cleaner.

20:00.820 --> 20:04.300
That similarly we can add additional environment variables.

20:04.300 --> 20:05.700
Now we're almost there.

20:05.700 --> 20:10.860
The last thing we want to add here is a volume because we don't want MongoDB to rate data

20:10.860 --> 20:13.900
to the temporary file system of the container.

20:13.900 --> 20:23.100
So here we set volumes and again, we can have one or more volume mappings.

20:23.100 --> 20:24.260
So we had a hyphen.

20:24.260 --> 20:28.860
We're going to map a volume called Widley and of course we can call it anything.

20:28.860 --> 20:32.580
Widley is the name of this application in case you didn't notice.

20:32.580 --> 20:38.220
So we're going to map this volume to a directory inside the container.

20:38.220 --> 20:43.860
Now if you look at the documentation of MongoDB on Docker Hub or just a typical MongoDB

20:43.860 --> 20:51.900
documentation, you know that by default MongoDB stores its data in slash data slash DB.

20:51.900 --> 20:55.180
So we want to map this volume to this directory.

20:55.180 --> 20:59.860
So whatever that is written inside this directory is actually outside of this container.

20:59.860 --> 21:03.500
It's somewhere else in our volume.

21:03.500 --> 21:07.780
Now because we have used this volume here, we have to define it in our compose file.

21:07.780 --> 21:11.020
So we press enter, remove all the indentations.

21:11.020 --> 21:15.380
So now we are at the same level as services.

21:15.380 --> 21:21.540
Here we're going to define another property called volumes and here we're going to add

21:21.540 --> 21:24.540
another property called Widley with no value.

21:24.540 --> 21:28.620
I know this looks a little bit weird, but this is the syntax we have to follow.

21:28.620 --> 21:32.620
We just have to define the volume first before we can use it.

21:32.620 --> 21:34.860
So this is our compose file.

21:34.860 --> 21:40.700
Now we can make this more readable by adding line breaks in between these properties.

21:40.700 --> 21:43.460
We can also order these services any way we want.

21:43.460 --> 21:46.380
So currently I'm ordering them from front to back.

21:46.380 --> 21:48.340
We can also order them from back to front.

21:48.340 --> 21:52.460
So we will put database first, then API and then web.

21:52.460 --> 21:54.340
So we're done with our compose file.

21:54.340 --> 22:03.420
Next I'm going to show you how to build the images.

22:03.420 --> 22:07.860
Earlier I told you that Docker compose is built on top of Docker engine.

22:07.860 --> 22:12.420
So everything we have done with Docker engine like building images, listing them, starting

22:12.420 --> 22:17.620
containers and so on, all of these operations are also available using Docker compose.

22:17.620 --> 22:18.700
Let me show you.

22:18.700 --> 22:25.140
So we type Docker compose, without any arguments, enter, look, we have all these subcommands

22:25.140 --> 22:31.940
like we have RM for removing stopped containers, we have run, we have push, pull and so on.

22:31.940 --> 22:36.580
The difference is that any of these commands will apply to our application as a whole.

22:36.580 --> 22:42.700
So most of these commands will impact multiple services or multiple containers in our application.

22:42.700 --> 22:49.780
So let's look at Docker compose build and also use the help option.

22:49.780 --> 22:51.500
So we have a bunch of options here.

22:51.500 --> 22:55.860
A couple of them I want to point out that are useful to know is no cache.

22:55.860 --> 22:59.020
With this we can prevent caching when building the image.

22:59.020 --> 23:03.380
Sometimes you encounter weird issues and you want to make sure that cache is not used.

23:03.380 --> 23:05.540
In that case, you use this option.

23:05.540 --> 23:08.220
Another useful option is dash dash pull.

23:08.220 --> 23:12.740
With this, we can always pull a newer version of the image.

23:12.740 --> 23:14.240
That is also good to know.

23:14.240 --> 23:16.820
So in this lesson, I'm not going to use any of these.

23:16.820 --> 23:21.220
We're just going to run Docker compose build.

23:21.220 --> 23:26.860
This built our web and API services and as you noticed, our build was super fast because

23:26.860 --> 23:29.260
pretty much everything came from the cache.

23:29.260 --> 23:32.740
So let's run Docker images.

23:32.740 --> 23:35.020
So I have five images on this machine.

23:35.020 --> 23:40.300
With the front end, with the web, with the API, with the back end and Mongo.

23:40.300 --> 23:42.380
Mongo obviously came from Docker Hub.

23:42.380 --> 23:47.980
Now as part of this build process in this lesson, we built with the web and with the

23:47.980 --> 23:49.260
API.

23:49.260 --> 23:53.260
These two other images with the front end and back end were built when we started this

23:53.260 --> 23:54.980
application earlier.

23:54.980 --> 23:57.100
So back to our project.

23:57.100 --> 24:02.500
In this original compose file that I included in this project, look, I call these services

24:02.500 --> 24:06.180
front end and back end instead of web and API.

24:06.180 --> 24:11.940
That is why we have these two images, with the front end and with the back end.

24:11.940 --> 24:17.500
Also as you have noticed, when building images with Docker compose, our images are prefixed

24:17.500 --> 24:18.900
with the name of our application.

24:18.900 --> 24:20.500
Now where does this come from?

24:20.500 --> 24:22.620
It is the name of the directory.

24:22.620 --> 24:27.220
So currently we are inside a directory called Widley and that is why all these images are

24:27.220 --> 24:28.860
prefixed with Widley.

24:28.860 --> 24:30.100
I think this is a great convention.

24:30.100 --> 24:32.260
I got a question for you.

24:32.260 --> 24:36.740
If you look at the created column, you can see all these images were created an hour

24:36.740 --> 24:37.740
ago.

24:37.740 --> 24:40.420
But didn't we just build the web and API images?

24:40.420 --> 24:41.780
Why do you think this happened?

24:41.780 --> 24:43.020
Here's the answer.

24:43.020 --> 24:47.140
Because I built these images front end and back end an hour ago when I was recording the

24:47.140 --> 24:49.020
first lesson in this section.

24:49.020 --> 24:53.900
Now when building these new images, Docker used everything in the cache because all those

24:53.900 --> 24:57.220
files were already available, all those layers were there.

24:57.220 --> 25:00.340
So Docker didn't have to do a full rebuild.

25:00.340 --> 25:04.500
That is why we are still using the build from an hour ago.

25:04.500 --> 25:11.420
Now if you want to force a full rebuild, we can say Docker compose build dash dash no

25:11.420 --> 25:12.420
cache.

25:12.420 --> 25:16.540
All right, this is going to take a few seconds.

25:16.540 --> 25:18.540
So I'll be right back.

25:18.540 --> 25:21.740
All right, our images are built.

25:21.740 --> 25:24.460
So let's run Docker images.

25:24.460 --> 25:25.460
There you go.

25:25.460 --> 25:29.780
Look at the first two images, API and web were built less than a minute ago.

25:29.780 --> 25:41.100
So that's all about building images, next we're going to talk about starting the application.

25:41.100 --> 25:44.500
You briefly saw how we can start an application with Docker compose.

25:44.500 --> 25:47.540
We just type Docker compose up.

25:47.540 --> 25:52.220
Now if the images are ready, Docker compose will run them inside containers, otherwise

25:52.220 --> 25:54.660
it's going to build the images automatically.

25:54.660 --> 25:59.220
Now before executing this, let's look at the available options.

25:59.220 --> 26:04.300
So here we have a ton of options, a couple of them that are useful are build.

26:04.300 --> 26:08.180
With this we can force a rebuild every time we want to start our application.

26:08.180 --> 26:14.380
So we don't have to explicitly run Docker compose build and then up.

26:14.380 --> 26:18.060
We can combine the two using the build option.

26:18.060 --> 26:21.860
The other useful option is dash D for detached mode.

26:21.860 --> 26:24.460
So we will start these containers in the background.

26:24.460 --> 26:26.460
So take a look.

26:26.460 --> 26:27.460
All right.

26:27.460 --> 26:35.900
Now if we run Docker compose PS, we can see all the containers relevant to this application.

26:35.900 --> 26:40.820
In contrast, if you type Docker PS, we can see all the running containers across all

26:40.820 --> 26:42.820
applications.

26:42.820 --> 26:49.300
So here we have three containers, Vidly, API one, Vidly DB one and web one.

26:49.300 --> 26:50.620
Now what is this one?

26:50.620 --> 26:54.140
Well, we can start multiple containers from the same image.

26:54.140 --> 26:57.180
And this is used for high availability and scalability.

26:57.180 --> 26:59.220
And something we'll look at in the future.

26:59.220 --> 27:00.780
So here you can see the container.

27:00.780 --> 27:03.660
You can see what command started that container.

27:03.660 --> 27:07.020
So for our API, that was npm start.

27:07.020 --> 27:12.120
For our database, that was MongoD or MongoDemon process.

27:12.120 --> 27:15.900
And for our web front end, that was npm start as well.

27:15.900 --> 27:18.500
You can see all these containers are up and running.

27:18.500 --> 27:21.540
And over here, you can see port mappings.

27:21.540 --> 27:25.860
So now if we go to local host, port 3000, we can see our application.

27:25.860 --> 27:26.860
Beautiful.

27:27.220 --> 27:28.380
How do we take this down?

27:28.380 --> 27:32.820
Let's say we're done with this application and we want to free up resources.

27:32.820 --> 27:37.260
Back to the terminal, we type Docker compose down.

27:37.260 --> 27:39.580
This will stop and remove these containers.

27:39.580 --> 27:41.340
But the images are still there.

27:41.340 --> 27:52.100
So next time we want to start the application, our application will start pretty quickly.

27:52.100 --> 27:53.700
Let's talk about networking in Docker.

27:53.700 --> 27:56.540
Let me run our application with Docker compose.

27:56.540 --> 28:01.500
Docker compose will automatically create a network and add our containers on that network.

28:01.500 --> 28:03.700
So these containers can talk to each other.

28:03.700 --> 28:04.780
Let's see this in action.

28:04.780 --> 28:09.300
So I'm going to bring up the application one more time in the detach mode.

28:09.300 --> 28:10.300
Good.

28:10.300 --> 28:12.580
Now look at the first line.

28:12.580 --> 28:15.100
Creating network with the default.

28:15.100 --> 28:20.220
So we can run Docker network LS.

28:20.220 --> 28:22.460
Here we can see all the networks on this machine.

28:22.460 --> 28:25.740
I think every Docker installation has three networks.

28:25.860 --> 28:27.780
Bridge, host, and none.

28:27.780 --> 28:31.900
Honestly, I'm not sure what these networks are for, but what matters here is that we

28:31.900 --> 28:34.860
have a network called Widley default.

28:34.860 --> 28:39.460
The driver for this network is bridge on Linux or NAT on Windows.

28:39.460 --> 28:47.540
Now this network contains three hosts or three containers, web, API, and DB.

28:47.540 --> 28:51.740
So these hosts or these containers can talk to each other using their name.

28:51.740 --> 28:53.020
Let's see this in action.

28:53.020 --> 28:57.580
So back to the terminal, let's look at the running containers.

28:57.580 --> 29:00.620
So we have Mongo, web, and API.

29:00.620 --> 29:05.740
Now we're going to start a shell session on the web container and ping the API container.

29:05.740 --> 29:06.740
Take a look.

29:06.740 --> 29:10.100
So we're going to execute in the interactive mode.

29:10.100 --> 29:15.540
The container ID is 8c6 and we're going to run shell.

29:15.540 --> 29:17.060
So let's ping API.

29:17.060 --> 29:21.900
We get a permission error because we have logged in with the app user that comes from

29:21.900 --> 29:23.780
our Docker file, remember?

29:23.780 --> 29:28.020
So we have logged in with the app user and this user doesn't have ping permission.

29:28.020 --> 29:30.700
So let's exit.

29:30.700 --> 29:32.300
I'm going to bring up the last command.

29:32.300 --> 29:36.100
Now here we have to use an extra option for setting the user.

29:36.100 --> 29:39.460
We're going to log in as the root user.

29:39.460 --> 29:40.460
Good.

29:40.460 --> 29:42.100
Now look at the shell prompt.

29:42.100 --> 29:45.580
We have a pound sign, which means we have the highest privileges.

29:45.580 --> 29:47.220
So here we can ping API.

29:47.220 --> 29:53.500
Now look, we're getting responses from a machine with this IP address.

29:53.500 --> 29:56.220
Now on your machine, this IP might be different.

29:56.220 --> 29:59.260
Now let's press Ctrl and C to get out of this.

29:59.260 --> 30:01.740
So this is what happens under the hood.

30:01.740 --> 30:07.420
Docker comes with an embedded DNS server that contains the name and IP of these containers.

30:07.420 --> 30:12.060
Now inside each container, we have a component called the DNS resolver.

30:12.060 --> 30:17.940
This DNS resolver talks to the DNS server to find the IP address of the target container.

30:17.940 --> 30:24.140
So when we ping the API container, this DNS resolver asks the server, what is the IP address

30:24.140 --> 30:27.220
of the API machine or API container?

30:27.220 --> 30:32.340
The DNS server returns the IP address and then the web container can directly talk to

30:32.340 --> 30:35.220
the API container using its IP address.

30:35.220 --> 30:39.300
So each container has an IP address and is part of a network.

30:39.300 --> 30:40.780
Let me show you one more thing.

30:40.780 --> 30:46.940
So back to the terminal, here we can run ifconfig to see the IP address of this container.

30:46.940 --> 30:47.940
Take a look.

30:47.940 --> 30:55.380
So this container has two network adapters, one of them is Ethernet zero and over here

30:55.380 --> 30:58.300
you can see the IP address of this container.

30:58.300 --> 31:04.700
So 172.21.02 is the IP address of the web container.

31:04.700 --> 31:10.100
Now back to our compose file, earlier when we defined the API service, we added an environment

31:10.100 --> 31:13.860
variable that contains a database connection string.

31:13.860 --> 31:18.820
In this connection string we have DB, which is the name of a host, that is the DB host

31:18.820 --> 31:20.340
or the DB container.

31:20.340 --> 31:24.940
You saw that our API container can talk to this container because both these containers

31:24.940 --> 31:29.100
or all containers in this application are part of the same network.

31:29.100 --> 31:34.540
Now one thing I want you to understand here is that this host is only available inside

31:34.540 --> 31:36.220
the Docker environment.

31:36.220 --> 31:42.580
So if I open up my browser and go to localhost slash DB, I'm not going to get anything.

31:42.580 --> 31:48.020
So the API container can directly talk to the DB container, but if you want to access

31:48.020 --> 31:54.420
this container we need port mappings and that is why we have this port mapping over here.

31:54.420 --> 31:59.260
So this port on the host is mapped to this port on the container.

31:59.260 --> 32:04.540
So if you open up MongoDB Compass, which is a popular MongoDB client, we can establish

32:04.540 --> 32:11.780
a connection to localhost port 27017, because this port is mapped to our container.

32:11.780 --> 32:13.340
Let's verify this real quick.

32:13.340 --> 32:15.340
So connect, great.

32:15.340 --> 32:19.660
So here we can see all our databases, here's our vitli database and in this database we

32:19.660 --> 32:22.980
have a collection called movies with four documents.

32:22.980 --> 32:27.260
So here are the movies that we currently have in the database.

32:27.260 --> 32:34.060
So this is all about Docker networking, next we're going to talk about viewing logs.

32:34.060 --> 32:35.860
Thank you so much for watching this video.

32:35.860 --> 32:40.620
As I said, this video is part of my ultimate Docker course that teaches you everything you

32:40.620 --> 32:44.420
need to know about Docker from the basics to more advanced concepts.

32:44.420 --> 32:47.940
So if you want to learn more, I highly encourage you to take a full course.

32:47.940 --> 32:51.820
It's much faster and better than jumping from one tutorial to another.

32:51.820 --> 32:54.580
If you're interested, the link is below this video.

32:54.580 --> 32:55.380
Thank you and have a great day.

