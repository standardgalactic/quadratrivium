1
00:00:00,000 --> 00:00:05,640
In this video, you're going to learn about Docker Compose, so by the end of this video,

2
00:00:05,640 --> 00:00:08,160
you'll be able to use Docker commands with confidence.

3
00:00:08,160 --> 00:00:13,240
Hi, I'm Mosh Hamidani, and I've taught millions of people how to code through this channel

4
00:00:13,240 --> 00:00:16,000
at my online school code with Mosh.com.

5
00:00:16,000 --> 00:00:20,560
This video is part of my ultimate Docker course, so once you finish this video, if you want

6
00:00:20,560 --> 00:00:23,520
to learn more, you may want to look at the complete course.

7
00:00:23,520 --> 00:00:29,960
Now let's jump in and get started.

8
00:00:29,960 --> 00:00:32,920
Welcome back to another section of the ultimate Docker course.

9
00:00:32,920 --> 00:00:36,640
In this section, we're going to talk about running multi-container applications.

10
00:00:36,640 --> 00:00:41,160
So I'm going to give you a real-world application with three building blocks, a front-end built

11
00:00:41,160 --> 00:00:45,840
with React, a back-end built with Node, and a MongoDB database.

12
00:00:45,840 --> 00:00:49,200
Once again, you don't need to be familiar or use any of these tools.

13
00:00:49,200 --> 00:00:52,800
Our focus here is on Docker and not on development tools.

14
00:00:52,800 --> 00:00:56,520
I think this is the most exciting part of this course, where you can see everything coming

15
00:00:56,520 --> 00:00:57,520
together.

16
00:00:57,520 --> 00:01:02,080
So we're going to talk about Docker Compose for building and running multi-container applications.

17
00:01:02,080 --> 00:01:07,400
We'll also talk about Docker networking, database migration, and running automated tests.

18
00:01:07,400 --> 00:01:20,360
So let's jump in and get started.

19
00:01:20,360 --> 00:01:24,040
In this section, we're going to use a tool called Docker Compose, which is built on top

20
00:01:24,040 --> 00:01:25,480
of Docker Engine.

21
00:01:25,480 --> 00:01:29,880
It makes it incredibly easy to start applications with multiple containers.

22
00:01:29,880 --> 00:01:32,280
So Google Docker Compose install.

23
00:01:32,280 --> 00:01:37,720
You will find this page, docs.docker.com, slash compose, slash install.

24
00:01:37,720 --> 00:01:40,040
On this page, you can see the installation instructions.

25
00:01:40,040 --> 00:01:46,240
Now at the time of recording this, Docker Compose is shipped with Docker desktop for Mac

26
00:01:46,240 --> 00:01:47,240
and Windows.

27
00:01:47,240 --> 00:01:50,240
So if you're on Mac or Windows, you don't have to do anything extra.

28
00:01:50,240 --> 00:01:52,240
You already have Docker Compose.

29
00:01:52,240 --> 00:01:58,960
To verify it, just go to the terminal window and type Docker Compose dash dash version.

30
00:01:58,960 --> 00:02:03,360
So I'm running Docker Compose version 1.28.5.

31
00:02:03,360 --> 00:02:05,760
Make sure your version is the same or newer.

32
00:02:05,760 --> 00:02:11,160
If you're using an older version, again, Google upgrade Docker Compose, or you might

33
00:02:11,160 --> 00:02:14,320
just install the latest version of Docker.

34
00:02:14,320 --> 00:02:16,240
Now back to this page.

35
00:02:16,240 --> 00:02:19,960
If you're using Windows Server or Linux, there are specific instructions you have to

36
00:02:19,960 --> 00:02:22,760
follow to install Docker Compose.

37
00:02:22,760 --> 00:02:33,280
So go ahead and install Docker Compose and I will see you in the next lesson.

38
00:02:33,280 --> 00:02:36,320
Before we get started, I want to show you a couple of techniques for cleaning up our

39
00:02:36,320 --> 00:02:37,680
workspace.

40
00:02:37,680 --> 00:02:42,400
So on this machine, we have a bunch of images and some running containers.

41
00:02:42,400 --> 00:02:43,400
They're getting in the way.

42
00:02:43,400 --> 00:02:45,120
I want to get rid of them all.

43
00:02:45,120 --> 00:02:46,120
How do we do this?

44
00:02:46,120 --> 00:02:50,920
Well, you know that we can remove images using Docker image remove command.

45
00:02:50,920 --> 00:02:54,120
And here we can type one or more image IDs.

46
00:02:54,120 --> 00:02:57,040
Now how can we get all image IDs and pass them here?

47
00:02:57,040 --> 00:02:58,560
Let me show you a cool trick.

48
00:02:58,560 --> 00:03:01,680
So we can run Docker image LS.

49
00:03:01,680 --> 00:03:03,320
We see all the images, right?

50
00:03:03,320 --> 00:03:08,040
But if you pass dash Q at the end, we only get image IDs.

51
00:03:08,040 --> 00:03:11,880
Now we can pass this as an argument to Docker image remove.

52
00:03:11,880 --> 00:03:13,800
So Docker image remove.

53
00:03:14,480 --> 00:03:19,720
Now here we add a dollar sign and in parenthesis, we type that other command.

54
00:03:19,720 --> 00:03:22,960
So Docker image LS dash Q.

55
00:03:22,960 --> 00:03:26,960
Now if we run this, we're going to get an error because some of these images are already

56
00:03:26,960 --> 00:03:30,280
in running containers or stopped containers.

57
00:03:30,280 --> 00:03:32,120
So we should always remove containers first.

58
00:03:32,120 --> 00:03:34,800
We're going to do that using the same technique.

59
00:03:34,800 --> 00:03:38,680
So I'm going to replace image with container.

60
00:03:38,680 --> 00:03:45,960
So we get all container IDs and then we're going to remove them all in one go.

61
00:03:45,960 --> 00:03:49,840
Also I would like to add dash A here as well.

62
00:03:49,840 --> 00:03:52,960
This will bring stopped containers as well, okay?

63
00:03:52,960 --> 00:03:55,520
We can also combine switches.

64
00:03:55,520 --> 00:03:56,880
That's another technique.

65
00:03:56,880 --> 00:03:57,880
Let's go ahead.

66
00:03:57,880 --> 00:04:02,960
All right, we get an error saying you cannot remove a running container because I forgot

67
00:04:02,960 --> 00:04:04,880
to pass the force option.

68
00:04:04,880 --> 00:04:07,920
So let's bring this up one more time.

69
00:04:07,920 --> 00:04:12,440
When removing, we're going to use dash F, okay?

70
00:04:12,440 --> 00:04:13,880
Great.

71
00:04:13,880 --> 00:04:16,520
So all these containers are removed.

72
00:04:16,520 --> 00:04:17,680
Now let's remove the images.

73
00:04:17,680 --> 00:04:25,320
So Docker image LS and Docker image remove.

74
00:04:25,320 --> 00:04:27,400
Great.

75
00:04:27,400 --> 00:04:29,160
Now take a look.

76
00:04:29,160 --> 00:04:34,800
We don't have any images here and no containers, including stopped containers.

77
00:04:34,800 --> 00:04:36,560
So we have a clean workspace.

78
00:04:36,560 --> 00:04:37,560
That's one way.

79
00:04:37,560 --> 00:04:39,640
There is a shortcut for this as well.

80
00:04:39,640 --> 00:04:43,600
If you're on Mac, you can find the Docker icon on the top status bar.

81
00:04:43,600 --> 00:04:46,880
If you're on Windows, you will find it in your notification tray.

82
00:04:46,880 --> 00:04:51,080
Let's click on this and then go to preferences.

83
00:04:51,080 --> 00:04:54,640
Now on this page, let's click on the troubleshoot icon.

84
00:04:54,640 --> 00:04:57,200
On this page, we have a bunch of useful utilities.

85
00:04:57,200 --> 00:05:00,080
For example, we can restart Docker desktop.

86
00:05:00,080 --> 00:05:02,640
We can also clean and purge data.

87
00:05:02,640 --> 00:05:07,140
This will essentially remove everything in Docker, your images, your containers, your

88
00:05:07,140 --> 00:05:08,640
volumes and so on.

89
00:05:08,640 --> 00:05:14,040
Now be aware that if you click on this, this is going to restart Docker engine.

90
00:05:14,040 --> 00:05:19,280
So on the top, look, you can see this animation showing that the Docker engine is not started

91
00:05:19,280 --> 00:05:20,280
yet.

92
00:05:20,280 --> 00:05:24,360
So at this point, if you go to the terminal window and execute any of Docker commands,

93
00:05:24,360 --> 00:05:25,560
you're going to get an error.

94
00:05:25,560 --> 00:05:29,720
So you'll have to wait about half a minute for the Docker engine to start.

95
00:05:29,720 --> 00:05:30,880
That's another way.

96
00:05:30,880 --> 00:05:41,440
So now that we have a clean workspace, next we're going to talk about our application.

97
00:05:41,440 --> 00:05:44,360
So in this next section, we're going to look at a real-world application with multiple

98
00:05:44,360 --> 00:05:48,380
building blocks, a front end, a back end and a database.

99
00:05:48,380 --> 00:05:50,960
So below this video, I've attached a Z file.

100
00:05:50,960 --> 00:05:52,600
Go ahead and download it.

101
00:05:52,600 --> 00:05:55,360
Inside that Z file, you're going to find this folder structure.

102
00:05:55,360 --> 00:05:58,840
We have this backend folder, which is our node project.

103
00:05:58,840 --> 00:06:04,120
This is a basic node project that starts a web server on port 3001.

104
00:06:04,120 --> 00:06:07,640
Once again, you don't need to know node to go through this section.

105
00:06:07,640 --> 00:06:11,680
Then we have the front end project, which is a React application that talks to the back

106
00:06:11,680 --> 00:06:12,680
end.

107
00:06:12,680 --> 00:06:16,920
Now, if you want to run this application outside of Docker, there are a number of steps

108
00:06:16,920 --> 00:06:17,920
we have to follow.

109
00:06:17,920 --> 00:06:22,520
Let's say we just check this out from a GitHub repository.

110
00:06:22,520 --> 00:06:26,920
First we have to go to our back end project, install all dependencies and then start the

111
00:06:26,920 --> 00:06:27,920
web server.

112
00:06:28,000 --> 00:06:33,000
At the same time, we have to open up another terminal window and do the same steps with

113
00:06:33,000 --> 00:06:34,320
our front end project.

114
00:06:34,320 --> 00:06:39,440
So we have to go to the front end project, install all the dependencies and then start

115
00:06:39,440 --> 00:06:40,440
the web server.

116
00:06:40,440 --> 00:06:45,760
And of course, we need two more terminal windows for running our front end and back end tests.

117
00:06:45,760 --> 00:06:50,560
And not to mention that, we should also download and install MongoDB on this machine.

118
00:06:50,560 --> 00:06:54,520
So there are so many steps we have to follow the moment we check out the source code from

119
00:06:54,520 --> 00:06:56,280
our GitHub repository.

120
00:06:56,280 --> 00:06:59,400
Now with Docker, we don't have to do any of these things.

121
00:06:59,400 --> 00:07:01,840
All we have to do is run a single command.

122
00:07:01,840 --> 00:07:02,840
Let me show you.

123
00:07:02,840 --> 00:07:06,720
So I'm going to get outside of the front end folder.

124
00:07:06,720 --> 00:07:08,520
Now we are in the root of this project.

125
00:07:08,520 --> 00:07:14,600
If you look, here we have a file called Docker Compose, which is used for composing a multi-container

126
00:07:14,600 --> 00:07:15,600
application.

127
00:07:15,600 --> 00:07:17,960
We're going to talk about that in detail soon.

128
00:07:17,960 --> 00:07:24,800
Now, once we have this file in our project, we can simply run Docker Compose up.

129
00:07:24,800 --> 00:07:26,560
That's all we have to do.

130
00:07:26,560 --> 00:07:31,960
Now, Docker is automatically downloading this particular version of MongoDB, so it's downloading

131
00:07:31,960 --> 00:07:33,520
all these layers.

132
00:07:33,520 --> 00:07:37,320
Then at the same time, it's going to install all the dependencies for our front end and

133
00:07:37,320 --> 00:07:38,320
back end projects.

134
00:07:38,320 --> 00:07:42,520
It will start web servers and run automated tests all in this window.

135
00:07:42,520 --> 00:07:46,760
Now, this is going to take a little while, so I'll be right back.

136
00:07:46,760 --> 00:07:54,200
All right, our application is up and running, and we can access it at localhost for 3000.

137
00:07:54,200 --> 00:07:56,120
So here's what we get.

138
00:07:56,120 --> 00:07:58,800
We have a mini application for managing a list of movies.

139
00:07:58,800 --> 00:08:00,880
Now, you know what's the beauty here?

140
00:08:00,880 --> 00:08:05,680
The beauty is that our database is populated with these movies as part of bringing up our

141
00:08:05,680 --> 00:08:06,680
application.

142
00:08:06,680 --> 00:08:09,760
I didn't have to manually insert these movies in our database.

143
00:08:09,760 --> 00:08:15,120
So we have a migration script for populating our database, and Docker automatically executed

144
00:08:15,120 --> 00:08:18,680
our migration script as part of bringing up this application.

145
00:08:18,680 --> 00:08:20,800
This is a very common real-world scenario.

146
00:08:21,360 --> 00:08:27,400
Now, here we can add new movies, movie one, movie two, whatever, and we can also delete

147
00:08:27,400 --> 00:08:28,400
these movies.

148
00:08:28,400 --> 00:08:31,440
So, we brought up this application using a single command.

149
00:08:31,440 --> 00:08:35,920
Now, I briefly mentioned this file, docker-compose.yaml.

150
00:08:35,920 --> 00:08:39,480
Before we talk about this file, first you need to understand the YAML format.

151
00:08:39,480 --> 00:08:41,760
This is a format that a lot of people are not familiar with.

152
00:08:41,760 --> 00:08:45,240
So in the next lesson, we're going to talk about JSON and YAML formats.

153
00:08:51,800 --> 00:08:54,840
Let's talk about JSON and YAML formats.

154
00:08:54,840 --> 00:08:58,240
If you know this format as well, feel free to skip this lesson.

155
00:08:58,240 --> 00:09:04,920
So in the root of this project, we're going to add a new file called data.json.json, as

156
00:09:04,920 --> 00:09:09,960
you probably know is a language, it's a human-readable language for representing data.

157
00:09:09,960 --> 00:09:14,160
So in this JSON file, we can have an object or an array, let's say we want to represent

158
00:09:14,160 --> 00:09:15,160
a course.

159
00:09:15,160 --> 00:09:18,600
A course can have properties like name, price, and so on.

160
00:09:18,600 --> 00:09:22,480
So in this object, we can add one or more key value pairs.

161
00:09:22,480 --> 00:09:25,120
Our keys should always be surrounded in double quotes.

162
00:09:25,120 --> 00:09:30,800
So we can add a key called name, and set its value to, we can use a string, the ultimate

163
00:09:30,800 --> 00:09:35,880
docker course, then we add a comma to define the next key value pair.

164
00:09:35,880 --> 00:09:40,800
So we can say price, we can set this to a number.

165
00:09:40,800 --> 00:09:45,600
Now the value can also be a boolean, so we can define another key value pair, and set

166
00:09:45,600 --> 00:09:48,600
the value to true or false.

167
00:09:48,600 --> 00:09:51,840
We can define another key value pair, and set the value to an array.

168
00:09:51,840 --> 00:09:54,600
So we define an array using square brackets.

169
00:09:54,600 --> 00:09:57,720
Now in this array, we can have any valid objects.

170
00:09:57,720 --> 00:10:01,960
So we can have strings, numbers, booleans, or other objects.

171
00:10:01,960 --> 00:10:07,720
So I'm going to add a couple of strings, let's say software and DevOps.

172
00:10:07,720 --> 00:10:12,840
And one last key value pair, author, I'm going to make this an object, so once again we use

173
00:10:12,840 --> 00:10:15,380
curly braces to define an object.

174
00:10:15,380 --> 00:10:23,220
In this object, we add a couple of key value pairs, first name is mosh, and last name is

175
00:10:23,220 --> 00:10:24,220
what?

176
00:10:24,220 --> 00:10:29,620
I'm a darling, and yes, I am Iranian, I get that question all the time.

177
00:10:29,620 --> 00:10:34,260
Alright, so here we have a JSON file, now let's see how we can convert this to YAML.

178
00:10:34,260 --> 00:10:39,380
YAML is another language for presenting data, but it has less clutter than JSON, it's easier

179
00:10:39,380 --> 00:10:40,460
to read.

180
00:10:40,460 --> 00:10:45,740
So I'm going to copy all this code, here in the project, we're going to add a new file

181
00:10:45,740 --> 00:10:52,740
called datum.yaml, the extension can be YAML or YML.

182
00:10:52,740 --> 00:10:58,980
Now on the top, we add three hyphens to indicate the beginning of a YAML file, then we paste

183
00:10:58,980 --> 00:10:59,980
our code.

184
00:10:59,980 --> 00:11:04,540
Now in YAML, we don't use curly braces to indicate hierarchy.

185
00:11:04,540 --> 00:11:08,860
This idea has come from Python, if you have programmed in Python, you know that in Python

186
00:11:08,940 --> 00:11:13,580
we use indentation to represent hierarchy, so we don't have curly braces.

187
00:11:13,580 --> 00:11:19,340
So let's get rid of these braces, and remove the indentation, good.

188
00:11:19,340 --> 00:11:23,420
Now the next thing you need to know about YAML is that we don't have to use quotes.

189
00:11:23,420 --> 00:11:30,300
So we can bring up the replace dialog, and replace all these double quotes with nothing.

190
00:11:30,300 --> 00:11:33,180
That immediately takes a lot of clutter away.

191
00:11:33,180 --> 00:11:39,540
Also, we're not going to use commas to separate key value pairs.

192
00:11:39,540 --> 00:11:44,940
So on the top, we have name, price is published, and how do we represent a list or an array?

193
00:11:44,940 --> 00:11:46,220
We use hyphens.

194
00:11:46,220 --> 00:11:53,060
So I'm going to remove this, we press enter, add a tab on a new line, we type hyphen to

195
00:11:53,060 --> 00:11:58,980
define the first item in the list, software, then at the same indentation, we add the next

196
00:11:58,980 --> 00:12:01,260
item, DevOps.

197
00:12:01,260 --> 00:12:06,700
Now author is an object, but as I told you, we don't use curly braces, we use indentation.

198
00:12:06,700 --> 00:12:12,020
So because these two properties are indented, they belong to the author property, okay?

199
00:12:12,020 --> 00:12:16,740
So this is our YAML file, let's compare this with JSON.

200
00:12:16,740 --> 00:12:20,340
As you can see, YAML is easier to read and understand.

201
00:12:20,340 --> 00:12:22,820
Now why don't we use YAML all the time?

202
00:12:22,820 --> 00:12:27,900
Well, because parsing YAML files is a little bit slower than parsing JSON files, because

203
00:12:27,900 --> 00:12:32,500
the parser doesn't know if this is a string or a number, so it has to read everything

204
00:12:32,500 --> 00:12:35,380
as a string and then try to evaluate it.

205
00:12:35,380 --> 00:12:40,660
In contrast, in JSON, strings are represented using quotes and more specifically double

206
00:12:40,660 --> 00:12:45,980
quotes, so the parser knows that this is a string and it shouldn't evaluate it, okay?

207
00:12:45,980 --> 00:12:51,180
So quite often we use YAML files for configuration files and JSON for exchanging data between

208
00:12:51,180 --> 00:12:54,060
multiple computers, like a client and a server.

209
00:12:54,060 --> 00:12:59,740
So now that you understand these formats, next we're going to talk about compose files.

210
00:12:59,740 --> 00:13:08,300
Alright, let's see how we can create a compose file from scratch.

211
00:13:08,300 --> 00:13:15,420
So for this lesson, I'm going to rename this file to underline docker compose.

212
00:13:15,420 --> 00:13:19,140
We want to set it aside and create a new compose file from scratch.

213
00:13:19,140 --> 00:13:23,700
So here we are, the new file called docker-compose.

214
00:13:23,700 --> 00:13:28,580
All in lowercase, make sure to spell it properly, otherwise docker-compose is not going to find

215
00:13:28,580 --> 00:13:33,460
this file, because this is the default name that docker-compose assumes, okay?

216
00:13:33,460 --> 00:13:35,460
So YAML.

217
00:13:35,460 --> 00:13:39,900
Now the first thing that we need to set here is the version property.

218
00:13:39,900 --> 00:13:41,100
What version should we use?

219
00:13:41,100 --> 00:13:45,260
Well, let's search for docker-compose file.

220
00:13:45,260 --> 00:13:51,540
On this page, you can see various compose file formats and their compatibility with

221
00:13:51,540 --> 00:13:52,540
docker-engine.

222
00:13:52,540 --> 00:13:57,780
We are using the latest version of docker-engine, so I want to use the latest compose file format

223
00:13:57,780 --> 00:14:00,300
so we have access to the latest features.

224
00:14:00,300 --> 00:14:03,420
So we're going to set this to 3.8.

225
00:14:03,420 --> 00:14:08,380
Now here we need to wrap this number with double quotes, otherwise it will be evaluated

226
00:14:08,380 --> 00:14:12,740
as a number, but docker-compose expects this value to be a string.

227
00:14:12,740 --> 00:14:13,740
Why?

228
00:14:13,740 --> 00:14:14,740
I have no clue.

229
00:14:15,220 --> 00:14:16,220
Here's the version.

230
00:14:16,220 --> 00:14:21,260
Now in this file, we define various building blocks or services of our application.

231
00:14:21,260 --> 00:14:24,020
So we have a property called services.

232
00:14:24,020 --> 00:14:25,860
Now what services do we need here?

233
00:14:25,860 --> 00:14:31,540
Well, our application has a front-end, a back-end, and a database.

234
00:14:31,540 --> 00:14:35,860
Your application might have other moving parts, so you can define them here.

235
00:14:35,860 --> 00:14:38,860
Now these names are arbitrary, so we can call them anything.

236
00:14:38,860 --> 00:14:46,540
We can change this to db, we can change the back-end to api, and the front-end to well.

237
00:14:46,540 --> 00:14:51,900
The idea here is that we're defining various services and telling docker how to build images

238
00:14:51,900 --> 00:14:54,980
for each service and how to run these images.

239
00:14:54,980 --> 00:14:59,620
So here we're going to have properties, and the value of these properties will eventually

240
00:14:59,620 --> 00:15:02,380
be used when running our containers.

241
00:15:02,380 --> 00:15:07,780
So in the previous section, we had to manually run our containers using docker-run, and here

242
00:15:07,820 --> 00:15:13,260
we used parameters like dash-p for port mapping or dash-v for volume mapping.

243
00:15:13,260 --> 00:15:16,420
We also had to specify an image like react-app.

244
00:15:16,420 --> 00:15:19,780
All these values can be defined in our compose file.

245
00:15:19,780 --> 00:15:22,620
So we don't have to manually start our containers.

246
00:15:22,620 --> 00:15:27,020
Docker compose will take care of starting our containers under the hood.

247
00:15:27,020 --> 00:15:32,140
So for each service, we need to tell docker how to build an image for that service.

248
00:15:32,140 --> 00:15:36,860
So here we can use the build property and tell docker compose where it can find a docker

249
00:15:36,940 --> 00:15:38,060
file.

250
00:15:38,060 --> 00:15:44,060
So if you look at this project, you can see that in our back-end and front-end folders,

251
00:15:44,060 --> 00:15:46,620
we have a docker file.

252
00:15:46,620 --> 00:15:51,140
This docker file is almost identical to the one we created in the previous section.

253
00:15:51,140 --> 00:15:56,420
So we start from a node image, we create a user, we set our working directory, copy all

254
00:15:56,420 --> 00:16:03,420
the files and install the dependencies, then expose port 3001 and start the web server.

255
00:16:03,420 --> 00:16:06,620
We have a similar docker file in our front-end project.

256
00:16:06,620 --> 00:16:08,180
Let's have a quick look.

257
00:16:08,180 --> 00:16:14,420
So that was the back-end, here's the front-end, and here we have a docker file, almost identical.

258
00:16:14,420 --> 00:16:18,900
But the front-end application or the front-end server starts on a different port.

259
00:16:18,900 --> 00:16:20,340
That is the only difference.

260
00:16:20,340 --> 00:16:24,620
So each service should have its own docker file, okay?

261
00:16:24,620 --> 00:16:30,180
Now back to our compose file, for our web or front-end, we're going to set the build

262
00:16:30,180 --> 00:16:35,140
property to period, meaning current folder, slash front-end.

263
00:16:35,140 --> 00:16:37,500
This is where we have a docker file.

264
00:16:37,500 --> 00:16:42,540
For our API, we're going to set build to back-end.

265
00:16:42,540 --> 00:16:46,100
Now for our database, we're not going to build an image, we're going to pull an image from

266
00:16:46,100 --> 00:16:47,500
docker hop.

267
00:16:47,500 --> 00:16:51,500
So instead of the build property, we're going to use the image property.

268
00:16:51,500 --> 00:16:57,180
Now for this application, I'm going to use Mongo version 4.0-Xenial.

269
00:16:57,180 --> 00:17:02,340
So that is Mongo version 4 built on top of Xenial, which is Ubuntu version 16.

270
00:17:02,340 --> 00:17:07,420
Now if you look at docker hop, you can see that Mongo also has images built on top of

271
00:17:07,420 --> 00:17:11,700
Windows, but Windows images are very large, over two gigabytes.

272
00:17:11,700 --> 00:17:14,860
So that's why I prefer to use Linux images.

273
00:17:14,860 --> 00:17:19,860
So for any of these services, we can either build an image or pull it down.

274
00:17:19,860 --> 00:17:23,700
Now here we also have port mappings, so we set ports to.

275
00:17:23,700 --> 00:17:28,900
Now because we can have multiple port mappings, here we need to use the array or list syntax.

276
00:17:28,900 --> 00:17:32,020
So we use a hyphen, and then define a port mapping.

277
00:17:32,020 --> 00:17:35,620
So our frontend application starts on port 3000.

278
00:17:35,620 --> 00:17:42,060
So I want to map port 3000 of the host to port 3000 of the container running this image.

279
00:17:42,060 --> 00:17:46,700
That's similarly for our API, we're going to define a port mapping.

280
00:17:46,700 --> 00:17:50,860
This one is going to be 3001 to 3001.

281
00:17:50,860 --> 00:17:59,420
Now MongoDB by default, listens on port 27017.

282
00:17:59,420 --> 00:18:05,700
So I want to map the same port, so we can access MongoDB using a MongoDB client like

283
00:18:05,700 --> 00:18:07,340
MongoDB Compass.

284
00:18:07,340 --> 00:18:11,980
If you don't use MongoDB, you have the same concept with other database engines.

285
00:18:11,980 --> 00:18:14,860
All these database engines listen on a default port.

286
00:18:14,860 --> 00:18:19,340
You want to map that port so you can connect to your database engine using your favorite

287
00:18:19,340 --> 00:18:21,540
database client.

288
00:18:21,540 --> 00:18:23,540
What else do we have here?

289
00:18:23,540 --> 00:18:25,580
Back to this page for compose file.

290
00:18:25,580 --> 00:18:30,860
If you look at version three, on the right, you can see all valid properties.

291
00:18:30,860 --> 00:18:34,860
Now a lot of these are for really special cases, so you don't need to use them all the

292
00:18:34,860 --> 00:18:38,860
time, but the ones that we use most of the time are build or image.

293
00:18:38,860 --> 00:18:42,820
You also use ports, volumes, environment, and so on.

294
00:18:42,820 --> 00:18:48,860
So our API project needs an environment variable that tells where our database is.

295
00:18:48,860 --> 00:18:55,500
So here we set environment, and here we can use the list syntax because we can have multiple

296
00:18:55,500 --> 00:18:57,060
environment variables.

297
00:18:57,060 --> 00:19:03,540
So we set DB underline URL to, here we need to type a MongoDB connection string.

298
00:19:03,540 --> 00:19:09,020
These connection strings always start with MongoDB, colon, two forward slashes.

299
00:19:09,020 --> 00:19:11,020
Here we need to type the name of a host.

300
00:19:11,020 --> 00:19:15,860
So as I'll show you later in this section, when we start an application with Docker compose

301
00:19:15,860 --> 00:19:18,780
under the hood, a network is created.

302
00:19:18,780 --> 00:19:21,700
On this network, we're going to have three hosts.

303
00:19:21,700 --> 00:19:25,540
The name of these hosts are equal to the names we have defined here.

304
00:19:25,540 --> 00:19:27,820
So we're going to have a host called DB.

305
00:19:27,820 --> 00:19:31,580
So that is the connection string to our MongoDB server.

306
00:19:31,580 --> 00:19:34,140
Now on this server, we can have multiple databases.

307
00:19:34,140 --> 00:19:39,100
So we're going to specify the database name and the connection string as well.

308
00:19:39,100 --> 00:19:42,700
So this is one way to set an environment variable.

309
00:19:42,700 --> 00:19:47,820
But instead of using the list syntax, we can also use the object or property value syntax.

310
00:19:47,820 --> 00:19:50,300
So we get rid of the hyphen.

311
00:19:50,300 --> 00:19:56,020
We say DB URL is a property and this is the value of that property.

312
00:19:56,020 --> 00:20:00,820
I find the syntax more readable because we get color coding and it's just cleaner.

313
00:20:00,820 --> 00:20:04,300
That similarly we can add additional environment variables.

314
00:20:04,300 --> 00:20:05,700
Now we're almost there.

315
00:20:05,700 --> 00:20:10,860
The last thing we want to add here is a volume because we don't want MongoDB to rate data

316
00:20:10,860 --> 00:20:13,900
to the temporary file system of the container.

317
00:20:13,900 --> 00:20:23,100
So here we set volumes and again, we can have one or more volume mappings.

318
00:20:23,100 --> 00:20:24,260
So we had a hyphen.

319
00:20:24,260 --> 00:20:28,860
We're going to map a volume called Widley and of course we can call it anything.

320
00:20:28,860 --> 00:20:32,580
Widley is the name of this application in case you didn't notice.

321
00:20:32,580 --> 00:20:38,220
So we're going to map this volume to a directory inside the container.

322
00:20:38,220 --> 00:20:43,860
Now if you look at the documentation of MongoDB on Docker Hub or just a typical MongoDB

323
00:20:43,860 --> 00:20:51,900
documentation, you know that by default MongoDB stores its data in slash data slash DB.

324
00:20:51,900 --> 00:20:55,180
So we want to map this volume to this directory.

325
00:20:55,180 --> 00:20:59,860
So whatever that is written inside this directory is actually outside of this container.

326
00:20:59,860 --> 00:21:03,500
It's somewhere else in our volume.

327
00:21:03,500 --> 00:21:07,780
Now because we have used this volume here, we have to define it in our compose file.

328
00:21:07,780 --> 00:21:11,020
So we press enter, remove all the indentations.

329
00:21:11,020 --> 00:21:15,380
So now we are at the same level as services.

330
00:21:15,380 --> 00:21:21,540
Here we're going to define another property called volumes and here we're going to add

331
00:21:21,540 --> 00:21:24,540
another property called Widley with no value.

332
00:21:24,540 --> 00:21:28,620
I know this looks a little bit weird, but this is the syntax we have to follow.

333
00:21:28,620 --> 00:21:32,620
We just have to define the volume first before we can use it.

334
00:21:32,620 --> 00:21:34,860
So this is our compose file.

335
00:21:34,860 --> 00:21:40,700
Now we can make this more readable by adding line breaks in between these properties.

336
00:21:40,700 --> 00:21:43,460
We can also order these services any way we want.

337
00:21:43,460 --> 00:21:46,380
So currently I'm ordering them from front to back.

338
00:21:46,380 --> 00:21:48,340
We can also order them from back to front.

339
00:21:48,340 --> 00:21:52,460
So we will put database first, then API and then web.

340
00:21:52,460 --> 00:21:54,340
So we're done with our compose file.

341
00:21:54,340 --> 00:22:03,420
Next I'm going to show you how to build the images.

342
00:22:03,420 --> 00:22:07,860
Earlier I told you that Docker compose is built on top of Docker engine.

343
00:22:07,860 --> 00:22:12,420
So everything we have done with Docker engine like building images, listing them, starting

344
00:22:12,420 --> 00:22:17,620
containers and so on, all of these operations are also available using Docker compose.

345
00:22:17,620 --> 00:22:18,700
Let me show you.

346
00:22:18,700 --> 00:22:25,140
So we type Docker compose, without any arguments, enter, look, we have all these subcommands

347
00:22:25,140 --> 00:22:31,940
like we have RM for removing stopped containers, we have run, we have push, pull and so on.

348
00:22:31,940 --> 00:22:36,580
The difference is that any of these commands will apply to our application as a whole.

349
00:22:36,580 --> 00:22:42,700
So most of these commands will impact multiple services or multiple containers in our application.

350
00:22:42,700 --> 00:22:49,780
So let's look at Docker compose build and also use the help option.

351
00:22:49,780 --> 00:22:51,500
So we have a bunch of options here.

352
00:22:51,500 --> 00:22:55,860
A couple of them I want to point out that are useful to know is no cache.

353
00:22:55,860 --> 00:22:59,020
With this we can prevent caching when building the image.

354
00:22:59,020 --> 00:23:03,380
Sometimes you encounter weird issues and you want to make sure that cache is not used.

355
00:23:03,380 --> 00:23:05,540
In that case, you use this option.

356
00:23:05,540 --> 00:23:08,220
Another useful option is dash dash pull.

357
00:23:08,220 --> 00:23:12,740
With this, we can always pull a newer version of the image.

358
00:23:12,740 --> 00:23:14,240
That is also good to know.

359
00:23:14,240 --> 00:23:16,820
So in this lesson, I'm not going to use any of these.

360
00:23:16,820 --> 00:23:21,220
We're just going to run Docker compose build.

361
00:23:21,220 --> 00:23:26,860
This built our web and API services and as you noticed, our build was super fast because

362
00:23:26,860 --> 00:23:29,260
pretty much everything came from the cache.

363
00:23:29,260 --> 00:23:32,740
So let's run Docker images.

364
00:23:32,740 --> 00:23:35,020
So I have five images on this machine.

365
00:23:35,020 --> 00:23:40,300
With the front end, with the web, with the API, with the back end and Mongo.

366
00:23:40,300 --> 00:23:42,380
Mongo obviously came from Docker Hub.

367
00:23:42,380 --> 00:23:47,980
Now as part of this build process in this lesson, we built with the web and with the

368
00:23:47,980 --> 00:23:49,260
API.

369
00:23:49,260 --> 00:23:53,260
These two other images with the front end and back end were built when we started this

370
00:23:53,260 --> 00:23:54,980
application earlier.

371
00:23:54,980 --> 00:23:57,100
So back to our project.

372
00:23:57,100 --> 00:24:02,500
In this original compose file that I included in this project, look, I call these services

373
00:24:02,500 --> 00:24:06,180
front end and back end instead of web and API.

374
00:24:06,180 --> 00:24:11,940
That is why we have these two images, with the front end and with the back end.

375
00:24:11,940 --> 00:24:17,500
Also as you have noticed, when building images with Docker compose, our images are prefixed

376
00:24:17,500 --> 00:24:18,900
with the name of our application.

377
00:24:18,900 --> 00:24:20,500
Now where does this come from?

378
00:24:20,500 --> 00:24:22,620
It is the name of the directory.

379
00:24:22,620 --> 00:24:27,220
So currently we are inside a directory called Widley and that is why all these images are

380
00:24:27,220 --> 00:24:28,860
prefixed with Widley.

381
00:24:28,860 --> 00:24:30,100
I think this is a great convention.

382
00:24:30,100 --> 00:24:32,260
I got a question for you.

383
00:24:32,260 --> 00:24:36,740
If you look at the created column, you can see all these images were created an hour

384
00:24:36,740 --> 00:24:37,740
ago.

385
00:24:37,740 --> 00:24:40,420
But didn't we just build the web and API images?

386
00:24:40,420 --> 00:24:41,780
Why do you think this happened?

387
00:24:41,780 --> 00:24:43,020
Here's the answer.

388
00:24:43,020 --> 00:24:47,140
Because I built these images front end and back end an hour ago when I was recording the

389
00:24:47,140 --> 00:24:49,020
first lesson in this section.

390
00:24:49,020 --> 00:24:53,900
Now when building these new images, Docker used everything in the cache because all those

391
00:24:53,900 --> 00:24:57,220
files were already available, all those layers were there.

392
00:24:57,220 --> 00:25:00,340
So Docker didn't have to do a full rebuild.

393
00:25:00,340 --> 00:25:04,500
That is why we are still using the build from an hour ago.

394
00:25:04,500 --> 00:25:11,420
Now if you want to force a full rebuild, we can say Docker compose build dash dash no

395
00:25:11,420 --> 00:25:12,420
cache.

396
00:25:12,420 --> 00:25:16,540
All right, this is going to take a few seconds.

397
00:25:16,540 --> 00:25:18,540
So I'll be right back.

398
00:25:18,540 --> 00:25:21,740
All right, our images are built.

399
00:25:21,740 --> 00:25:24,460
So let's run Docker images.

400
00:25:24,460 --> 00:25:25,460
There you go.

401
00:25:25,460 --> 00:25:29,780
Look at the first two images, API and web were built less than a minute ago.

402
00:25:29,780 --> 00:25:41,100
So that's all about building images, next we're going to talk about starting the application.

403
00:25:41,100 --> 00:25:44,500
You briefly saw how we can start an application with Docker compose.

404
00:25:44,500 --> 00:25:47,540
We just type Docker compose up.

405
00:25:47,540 --> 00:25:52,220
Now if the images are ready, Docker compose will run them inside containers, otherwise

406
00:25:52,220 --> 00:25:54,660
it's going to build the images automatically.

407
00:25:54,660 --> 00:25:59,220
Now before executing this, let's look at the available options.

408
00:25:59,220 --> 00:26:04,300
So here we have a ton of options, a couple of them that are useful are build.

409
00:26:04,300 --> 00:26:08,180
With this we can force a rebuild every time we want to start our application.

410
00:26:08,180 --> 00:26:14,380
So we don't have to explicitly run Docker compose build and then up.

411
00:26:14,380 --> 00:26:18,060
We can combine the two using the build option.

412
00:26:18,060 --> 00:26:21,860
The other useful option is dash D for detached mode.

413
00:26:21,860 --> 00:26:24,460
So we will start these containers in the background.

414
00:26:24,460 --> 00:26:26,460
So take a look.

415
00:26:26,460 --> 00:26:27,460
All right.

416
00:26:27,460 --> 00:26:35,900
Now if we run Docker compose PS, we can see all the containers relevant to this application.

417
00:26:35,900 --> 00:26:40,820
In contrast, if you type Docker PS, we can see all the running containers across all

418
00:26:40,820 --> 00:26:42,820
applications.

419
00:26:42,820 --> 00:26:49,300
So here we have three containers, Vidly, API one, Vidly DB one and web one.

420
00:26:49,300 --> 00:26:50,620
Now what is this one?

421
00:26:50,620 --> 00:26:54,140
Well, we can start multiple containers from the same image.

422
00:26:54,140 --> 00:26:57,180
And this is used for high availability and scalability.

423
00:26:57,180 --> 00:26:59,220
And something we'll look at in the future.

424
00:26:59,220 --> 00:27:00,780
So here you can see the container.

425
00:27:00,780 --> 00:27:03,660
You can see what command started that container.

426
00:27:03,660 --> 00:27:07,020
So for our API, that was npm start.

427
00:27:07,020 --> 00:27:12,120
For our database, that was MongoD or MongoDemon process.

428
00:27:12,120 --> 00:27:15,900
And for our web front end, that was npm start as well.

429
00:27:15,900 --> 00:27:18,500
You can see all these containers are up and running.

430
00:27:18,500 --> 00:27:21,540
And over here, you can see port mappings.

431
00:27:21,540 --> 00:27:25,860
So now if we go to local host, port 3000, we can see our application.

432
00:27:25,860 --> 00:27:26,860
Beautiful.

433
00:27:27,220 --> 00:27:28,380
How do we take this down?

434
00:27:28,380 --> 00:27:32,820
Let's say we're done with this application and we want to free up resources.

435
00:27:32,820 --> 00:27:37,260
Back to the terminal, we type Docker compose down.

436
00:27:37,260 --> 00:27:39,580
This will stop and remove these containers.

437
00:27:39,580 --> 00:27:41,340
But the images are still there.

438
00:27:41,340 --> 00:27:52,100
So next time we want to start the application, our application will start pretty quickly.

439
00:27:52,100 --> 00:27:53,700
Let's talk about networking in Docker.

440
00:27:53,700 --> 00:27:56,540
Let me run our application with Docker compose.

441
00:27:56,540 --> 00:28:01,500
Docker compose will automatically create a network and add our containers on that network.

442
00:28:01,500 --> 00:28:03,700
So these containers can talk to each other.

443
00:28:03,700 --> 00:28:04,780
Let's see this in action.

444
00:28:04,780 --> 00:28:09,300
So I'm going to bring up the application one more time in the detach mode.

445
00:28:09,300 --> 00:28:10,300
Good.

446
00:28:10,300 --> 00:28:12,580
Now look at the first line.

447
00:28:12,580 --> 00:28:15,100
Creating network with the default.

448
00:28:15,100 --> 00:28:20,220
So we can run Docker network LS.

449
00:28:20,220 --> 00:28:22,460
Here we can see all the networks on this machine.

450
00:28:22,460 --> 00:28:25,740
I think every Docker installation has three networks.

451
00:28:25,860 --> 00:28:27,780
Bridge, host, and none.

452
00:28:27,780 --> 00:28:31,900
Honestly, I'm not sure what these networks are for, but what matters here is that we

453
00:28:31,900 --> 00:28:34,860
have a network called Widley default.

454
00:28:34,860 --> 00:28:39,460
The driver for this network is bridge on Linux or NAT on Windows.

455
00:28:39,460 --> 00:28:47,540
Now this network contains three hosts or three containers, web, API, and DB.

456
00:28:47,540 --> 00:28:51,740
So these hosts or these containers can talk to each other using their name.

457
00:28:51,740 --> 00:28:53,020
Let's see this in action.

458
00:28:53,020 --> 00:28:57,580
So back to the terminal, let's look at the running containers.

459
00:28:57,580 --> 00:29:00,620
So we have Mongo, web, and API.

460
00:29:00,620 --> 00:29:05,740
Now we're going to start a shell session on the web container and ping the API container.

461
00:29:05,740 --> 00:29:06,740
Take a look.

462
00:29:06,740 --> 00:29:10,100
So we're going to execute in the interactive mode.

463
00:29:10,100 --> 00:29:15,540
The container ID is 8c6 and we're going to run shell.

464
00:29:15,540 --> 00:29:17,060
So let's ping API.

465
00:29:17,060 --> 00:29:21,900
We get a permission error because we have logged in with the app user that comes from

466
00:29:21,900 --> 00:29:23,780
our Docker file, remember?

467
00:29:23,780 --> 00:29:28,020
So we have logged in with the app user and this user doesn't have ping permission.

468
00:29:28,020 --> 00:29:30,700
So let's exit.

469
00:29:30,700 --> 00:29:32,300
I'm going to bring up the last command.

470
00:29:32,300 --> 00:29:36,100
Now here we have to use an extra option for setting the user.

471
00:29:36,100 --> 00:29:39,460
We're going to log in as the root user.

472
00:29:39,460 --> 00:29:40,460
Good.

473
00:29:40,460 --> 00:29:42,100
Now look at the shell prompt.

474
00:29:42,100 --> 00:29:45,580
We have a pound sign, which means we have the highest privileges.

475
00:29:45,580 --> 00:29:47,220
So here we can ping API.

476
00:29:47,220 --> 00:29:53,500
Now look, we're getting responses from a machine with this IP address.

477
00:29:53,500 --> 00:29:56,220
Now on your machine, this IP might be different.

478
00:29:56,220 --> 00:29:59,260
Now let's press Ctrl and C to get out of this.

479
00:29:59,260 --> 00:30:01,740
So this is what happens under the hood.

480
00:30:01,740 --> 00:30:07,420
Docker comes with an embedded DNS server that contains the name and IP of these containers.

481
00:30:07,420 --> 00:30:12,060
Now inside each container, we have a component called the DNS resolver.

482
00:30:12,060 --> 00:30:17,940
This DNS resolver talks to the DNS server to find the IP address of the target container.

483
00:30:17,940 --> 00:30:24,140
So when we ping the API container, this DNS resolver asks the server, what is the IP address

484
00:30:24,140 --> 00:30:27,220
of the API machine or API container?

485
00:30:27,220 --> 00:30:32,340
The DNS server returns the IP address and then the web container can directly talk to

486
00:30:32,340 --> 00:30:35,220
the API container using its IP address.

487
00:30:35,220 --> 00:30:39,300
So each container has an IP address and is part of a network.

488
00:30:39,300 --> 00:30:40,780
Let me show you one more thing.

489
00:30:40,780 --> 00:30:46,940
So back to the terminal, here we can run ifconfig to see the IP address of this container.

490
00:30:46,940 --> 00:30:47,940
Take a look.

491
00:30:47,940 --> 00:30:55,380
So this container has two network adapters, one of them is Ethernet zero and over here

492
00:30:55,380 --> 00:30:58,300
you can see the IP address of this container.

493
00:30:58,300 --> 00:31:04,700
So 172.21.02 is the IP address of the web container.

494
00:31:04,700 --> 00:31:10,100
Now back to our compose file, earlier when we defined the API service, we added an environment

495
00:31:10,100 --> 00:31:13,860
variable that contains a database connection string.

496
00:31:13,860 --> 00:31:18,820
In this connection string we have DB, which is the name of a host, that is the DB host

497
00:31:18,820 --> 00:31:20,340
or the DB container.

498
00:31:20,340 --> 00:31:24,940
You saw that our API container can talk to this container because both these containers

499
00:31:24,940 --> 00:31:29,100
or all containers in this application are part of the same network.

500
00:31:29,100 --> 00:31:34,540
Now one thing I want you to understand here is that this host is only available inside

501
00:31:34,540 --> 00:31:36,220
the Docker environment.

502
00:31:36,220 --> 00:31:42,580
So if I open up my browser and go to localhost slash DB, I'm not going to get anything.

503
00:31:42,580 --> 00:31:48,020
So the API container can directly talk to the DB container, but if you want to access

504
00:31:48,020 --> 00:31:54,420
this container we need port mappings and that is why we have this port mapping over here.

505
00:31:54,420 --> 00:31:59,260
So this port on the host is mapped to this port on the container.

506
00:31:59,260 --> 00:32:04,540
So if you open up MongoDB Compass, which is a popular MongoDB client, we can establish

507
00:32:04,540 --> 00:32:11,780
a connection to localhost port 27017, because this port is mapped to our container.

508
00:32:11,780 --> 00:32:13,340
Let's verify this real quick.

509
00:32:13,340 --> 00:32:15,340
So connect, great.

510
00:32:15,340 --> 00:32:19,660
So here we can see all our databases, here's our vitli database and in this database we

511
00:32:19,660 --> 00:32:22,980
have a collection called movies with four documents.

512
00:32:22,980 --> 00:32:27,260
So here are the movies that we currently have in the database.

513
00:32:27,260 --> 00:32:34,060
So this is all about Docker networking, next we're going to talk about viewing logs.

514
00:32:34,060 --> 00:32:35,860
Thank you so much for watching this video.

515
00:32:35,860 --> 00:32:40,620
As I said, this video is part of my ultimate Docker course that teaches you everything you

516
00:32:40,620 --> 00:32:44,420
need to know about Docker from the basics to more advanced concepts.

517
00:32:44,420 --> 00:32:47,940
So if you want to learn more, I highly encourage you to take a full course.

518
00:32:47,940 --> 00:32:51,820
It's much faster and better than jumping from one tutorial to another.

519
00:32:51,820 --> 00:32:54,580
If you're interested, the link is below this video.

520
00:32:54,580 --> 00:32:55,380
Thank you and have a great day.

