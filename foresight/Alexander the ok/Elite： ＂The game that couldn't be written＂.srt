1
00:00:00,000 --> 00:00:14,080
Let's go back to 1984 in the UK.

2
00:00:14,080 --> 00:00:19,880
In a few short years, home computers have gone from practically non-existent to commonplace.

3
00:00:19,880 --> 00:00:24,760
Almost every child in the country has access to a BBC microcomputer at school, and the

4
00:00:24,760 --> 00:00:28,160
ZX Spectrum is topping out Christmas wish lists.

5
00:00:28,160 --> 00:00:33,240
And despite a crash in the video games market in the USA, games are still flying off the

6
00:00:33,240 --> 00:00:34,240
shelves here.

7
00:00:34,240 --> 00:00:39,840
While there's plenty choice, almost every game available to play at home is some variation

8
00:00:39,840 --> 00:00:40,840
of the same thing.

9
00:00:40,840 --> 00:00:46,240
A 10 minute tops arcade style run at a high score.

10
00:00:46,240 --> 00:00:52,240
Longer form strategy and adventure games do exist, largely in the form of text adventures,

11
00:00:52,240 --> 00:00:57,560
sometimes with accompanying imagery, but not with real time graphics, and certainly not

12
00:00:57,560 --> 00:00:59,920
in an open world.

13
00:00:59,920 --> 00:01:05,120
Home computers are more popular than consoles in the UK, and let's be honest, many of the

14
00:01:05,120 --> 00:01:10,920
games on these look, well, take a look for yourself.

15
00:01:10,920 --> 00:01:15,440
As for 3D graphics, the choices are even more limited.

16
00:01:15,440 --> 00:01:22,120
Every 3D game on the market is either not actually 3D, or is not really a game.

17
00:01:22,120 --> 00:01:29,720
There are a few flight simulators, technically impressive for the day, but not exactly immersive.

18
00:01:29,720 --> 00:01:37,040
Sublogix FS1 Flight Simulator was arguably the first full 3D game created for the home,

19
00:01:37,040 --> 00:01:38,680
and it looks like this.

20
00:01:38,680 --> 00:01:42,760
Doesn't this gameplay look fun?

21
00:01:42,760 --> 00:01:48,720
And the frame rate, let's just say, it has a frame rate.

22
00:01:48,720 --> 00:01:54,960
Microsoft Flight Simulator 2 has just released, but that requires a $5,000 IBM PC to play,

23
00:01:54,960 --> 00:01:59,480
and no one had one of those outside the office.

24
00:01:59,480 --> 00:02:04,480
Arcade cabinets with more specialized hardware have taken a step into 3D gaming, but I can't

25
00:02:04,480 --> 00:02:12,160
find a single example of a true 3D game that isn't a flight simulator prior to 1984.

26
00:02:12,160 --> 00:02:17,800
Battle zones are competitor, but movement and object tracking is restricted to two axes,

27
00:02:17,800 --> 00:02:21,520
a sort of pseudo 3D game.

28
00:02:21,520 --> 00:02:27,400
And there are a few other on-rails shooters, limited in scope, and always a slave to the

29
00:02:27,400 --> 00:02:30,120
high score.

30
00:02:30,120 --> 00:02:34,720
The best-selling games at the moment are Pac-Man and Space Invaders.

31
00:02:34,720 --> 00:02:38,280
You probably remember them looking like this.

32
00:02:38,280 --> 00:02:41,360
Problem is, those are the arcade versions.

33
00:02:41,360 --> 00:02:48,880
If you wanted to play them at home on your Atari 2600, this is what they looked like.

34
00:02:48,880 --> 00:02:51,640
Then Elite was released.

35
00:02:51,640 --> 00:03:08,960
Elite looked like this.

36
00:03:08,960 --> 00:03:12,680
It changed gaming in Europe overnight.

37
00:03:12,680 --> 00:03:15,080
It was an open universe game.

38
00:03:15,080 --> 00:03:20,320
No high score, no restrictions, and full, true 3D graphics.

39
00:03:20,320 --> 00:03:27,760
A procedurally generated universe, a backstory in the form of a novella, pirates, trading,

40
00:03:27,760 --> 00:03:34,240
asteroid mining, an economy, and you could play it at home or at school.

41
00:03:34,240 --> 00:03:38,920
Non-European viewers are unlikely to be familiar with the impact Elite had on gaming and computing.

42
00:03:38,920 --> 00:03:46,640
But here in the UK, the 20th of September 1984, was the day computer games became a

43
00:03:46,640 --> 00:04:03,920
serious business.

44
00:04:03,920 --> 00:04:08,160
This is a story I've been obsessed with since I was a teenager.

45
00:04:08,160 --> 00:04:12,880
It shaped my life personally, and there is a direct path between some of the innovations

46
00:04:12,880 --> 00:04:17,480
made by Elite's creators and my professional work today.

47
00:04:17,480 --> 00:04:22,320
This may come as a surprise to some subscribers, but I previously worked in the computer games

48
00:04:22,320 --> 00:04:23,720
industry.

49
00:04:23,720 --> 00:04:28,760
Not for very long, but my first role as a data scientist after quitting engineering

50
00:04:28,760 --> 00:04:32,280
was for a UK-based games developer in Dundee.

51
00:04:32,280 --> 00:04:37,040
I even learned Unity and coded up a couple of games myself during this period.

52
00:04:37,040 --> 00:04:42,520
Of course, I wouldn't use Unity now after recent events.

53
00:04:42,520 --> 00:04:45,840
The story of Elite's creation is already told on YouTube.

54
00:04:45,840 --> 00:04:50,800
However, I'm not going to focus too much on the history and the individuals.

55
00:04:50,800 --> 00:04:55,240
Instead, I'd like to dive into some of the technical details on how the game was even

56
00:04:55,240 --> 00:04:59,320
possible and how some of its major challenges were tackled.

57
00:04:59,320 --> 00:05:03,960
And I promise, absolutely zero programming knowledge is necessary to understand what

58
00:05:03,960 --> 00:05:06,640
I'll be discussing.

59
00:05:06,640 --> 00:05:13,440
Before we get into the full story, I'd like to make a quick political disclaimer.

60
00:05:13,440 --> 00:05:16,740
Elite is very much a British success story.

61
00:05:16,740 --> 00:05:22,040
It was a rare case of government, industry, the academic sector, and even state-funded

62
00:05:22,040 --> 00:05:27,040
media inadvertently working together to produce something amazing.

63
00:05:27,040 --> 00:05:32,160
The government at the time, however, was one of the most contentious in UK history.

64
00:05:32,160 --> 00:05:33,520
The Thatcher government.

65
00:05:34,080 --> 00:05:39,000
Now, I try to adopt a policy on this channel of not getting bogged down in politics, but

66
00:05:39,000 --> 00:05:41,800
also not skirting around them.

67
00:05:41,800 --> 00:05:45,480
I don't see it as my role to tell viewers what to think politically.

68
00:05:45,480 --> 00:05:51,120
So, let's just say that sometimes bad governments do good things, and sometimes good governments

69
00:05:51,120 --> 00:05:53,000
do bad things.

70
00:05:53,000 --> 00:05:56,520
And it's up to you to decide if that applies here.

71
00:05:56,520 --> 00:06:07,960
Let's take a look at the machine Elite was originally coded on and created for.

72
00:06:07,960 --> 00:06:11,440
This is the BBC Micro.

73
00:06:11,440 --> 00:06:15,520
This video was a good excuse for me to finally get one.

74
00:06:15,520 --> 00:06:19,720
Of course, I got hold of a broken one to bring back to life.

75
00:06:19,720 --> 00:06:24,640
When dealing with technology that's older than me, I always feel to be worthy.

76
00:06:24,640 --> 00:06:27,280
I have to fix it first.

77
00:06:27,280 --> 00:06:30,800
I'll overlay some footage of the restoration here.

78
00:06:30,800 --> 00:06:36,200
In fact, mine came with a cassette recorder, with a copy of Elite ready to go.

79
00:06:36,200 --> 00:06:41,960
Yes, I could have just bought an SD card reader, but loading a game from a cassette tape was

80
00:06:41,960 --> 00:06:47,280
one of those little things I just had to experience.

81
00:06:47,280 --> 00:06:52,800
In the late 1970s, the UK was staring a disaster in the face.

82
00:06:52,800 --> 00:06:57,440
Over in the US, the development of cheap microcontrollers had, in the space of a couple

83
00:06:57,440 --> 00:07:03,240
of years, transformed computers from cabinet-sized mainframes that cost tens or even hundreds

84
00:07:03,240 --> 00:07:11,520
of thousands of dollars to the likes of the Apple II, the TRS-80 and the Commodore PET.

85
00:07:11,520 --> 00:07:16,360
Government and businesses in the US, and in Japan, and even other Western European countries

86
00:07:16,360 --> 00:07:18,920
were quickly embracing the change.

87
00:07:18,920 --> 00:07:24,640
In a small but dedicated portion of their population were becoming proficient in computing,

88
00:07:24,640 --> 00:07:28,920
be it at home or in the workplace.

89
00:07:28,920 --> 00:07:33,120
The UK was emerging from a financial crisis.

90
00:07:33,120 --> 00:07:36,480
When isn't the UK in a financial crisis?

91
00:07:36,480 --> 00:07:41,080
Traditional manufacturing industries such as mining, steelworking and shipbuilding were

92
00:07:41,080 --> 00:07:43,600
either dying or dead.

93
00:07:43,600 --> 00:07:46,120
No one was thinking about computers.

94
00:07:46,480 --> 00:07:51,520
Likewise, the government was preoccupied with all of the above.

95
00:07:51,520 --> 00:07:55,800
An unlikely contender resolved to address the issue before it was too late.

96
00:07:55,800 --> 00:08:02,840
The UK's state-funded, but not state-controlled, broadcaster, the BBC.

97
00:08:02,840 --> 00:08:07,120
The BBC acted fast and they acted decisively.

98
00:08:07,120 --> 00:08:11,720
The Compute Alliteracy Project was to be a collection of TV and radio series intended

99
00:08:11,720 --> 00:08:19,000
to teach the nation that computers weren't scary, obscure or just for nerds.

100
00:08:19,000 --> 00:08:24,520
A tender was put out for a computer model to be adopted by the BBC for these broadcasts

101
00:08:24,520 --> 00:08:30,760
and crucially it was to be adopted by schools too, with the government subsidising half

102
00:08:30,760 --> 00:08:35,320
of the cost of every computer purchased by a school.

103
00:08:35,320 --> 00:08:39,960
By this point, Clive Sinclair had released the ZX81.

104
00:08:39,960 --> 00:08:47,040
This was an absolute bare-bones computer, but it was cheap, incredibly cheap.

105
00:08:47,040 --> 00:08:51,680
And for that reason, I'll never knock it as many others do these days.

106
00:08:51,680 --> 00:08:58,360
For less than £200 in 2023 money, a family could have a fully functioning 8-bit computer

107
00:08:58,360 --> 00:09:00,360
at home.

108
00:09:00,360 --> 00:09:04,880
Sinclair put it forward to the BBC for consideration, but was rejected.

109
00:09:04,880 --> 00:09:08,280
It didn't come close to their specifications.

110
00:09:08,280 --> 00:09:15,000
In what seems like a rare case of due consideration, the BBC required a surprisingly capable system

111
00:09:15,000 --> 00:09:20,840
with network capability, full colour graphics and expansion capability.

112
00:09:20,840 --> 00:09:27,880
Acorn Compute has rushed out a prototype for the BBC in four days.

113
00:09:27,880 --> 00:09:29,960
This resistor here?

114
00:09:29,960 --> 00:09:33,120
That simulates an engineer's finger on the board.

115
00:09:33,120 --> 00:09:35,440
The system wouldn't boot without it.

116
00:09:35,440 --> 00:09:39,680
And no one really knows what purpose it serves to this day.

117
00:09:39,680 --> 00:09:44,320
Despite its whirlwind conception, Acorn's prototype was the only system that met the

118
00:09:44,320 --> 00:09:46,280
BBC's specifications.

119
00:09:46,280 --> 00:09:52,680
It exceeded some, with blisteringly fast RAM for the day, and a frankly wonderful potential

120
00:09:52,680 --> 00:09:54,800
for expansion.

121
00:09:54,800 --> 00:10:03,200
The BBC Micro Model B used a MOS 6502 CPU clocked at 2GHz, and it pushed it to its limits given

122
00:10:03,200 --> 00:10:05,560
the Micro's IO capability.

123
00:10:05,560 --> 00:10:11,680
32KB of RAM was available, along with an operating system that included a modified version of

124
00:10:11,680 --> 00:10:15,640
BASIC, known as BBC BASIC.

125
00:10:15,640 --> 00:10:18,760
BASIC was the programming language of the time.

126
00:10:18,760 --> 00:10:22,120
In fact, the Micro boots straight into it.

127
00:10:22,120 --> 00:10:27,640
Uniquely, assembly code can be inserted in line with BASIC commands.

128
00:10:27,640 --> 00:10:32,880
If you're not familiar with assembly, don't worry, we'll get there soon.

129
00:10:33,560 --> 00:10:38,160
The BASIC capability was provided via Acorn's proprietary Econet, and the capability for

130
00:10:38,160 --> 00:10:43,680
a second co-processor was even provided via the tube interface.

131
00:10:43,680 --> 00:10:49,360
This can even be used today to connect a Raspberry Pi, something I will definitely be doing in

132
00:10:49,360 --> 00:10:51,880
the future.

133
00:10:51,880 --> 00:10:57,960
The BBC Micro isn't a looker, but that large form factor makes it easy to add expansion

134
00:10:57,960 --> 00:11:02,160
boards, just four screws to undo it and you're in.

135
00:11:02,160 --> 00:11:06,480
There are plenty of empty ROM sockets for you to add more functionality.

136
00:11:06,480 --> 00:11:08,520
And I have to mention the keyboard.

137
00:11:08,520 --> 00:11:13,040
The Micro has a really nice mechanical keyboard.

138
00:11:13,040 --> 00:11:15,480
Apparently that contributed significantly to the cost.

139
00:11:15,480 --> 00:11:19,680
Right, okay, this is me back again three weeks after saying that.

140
00:11:19,680 --> 00:11:24,160
Totally unscripted here by the way, and I've just spent an hour tapping away on that keyboard.

141
00:11:24,160 --> 00:11:29,920
Yeah, it's very well built in that like a school child isn't going to destroy it.

142
00:11:29,920 --> 00:11:31,920
It's a very slow keyboard though.

143
00:11:31,920 --> 00:11:34,600
I don't know if I'd say it's a fantastic keyboard now.

144
00:11:34,600 --> 00:11:37,840
Right, okay, back to three weeks ago Alex.

145
00:11:37,840 --> 00:11:40,880
And indeed the Micro was not cheap.

146
00:11:40,880 --> 00:11:45,360
About £1,600 in 2023 money.

147
00:11:45,360 --> 00:11:50,280
Though I will note that was about the same cost as a Commodore 64, which is probably

148
00:11:50,280 --> 00:11:53,680
the closest equivalent machine on the US market.

149
00:11:53,680 --> 00:11:59,720
Yet, and this seems unbelievable today, the government still agreed to subsidise this

150
00:11:59,720 --> 00:12:02,240
cost to schools.

151
00:12:02,240 --> 00:12:08,040
By the end of the computer literacy project, 85% of UK primary and almost every secondary

152
00:12:08,040 --> 00:12:11,880
school had at least one BBC Micro.

153
00:12:11,880 --> 00:12:17,120
Almost every child in the country had free access to a good computer and free tuition

154
00:12:17,120 --> 00:12:22,680
via the BBC, a project that seems almost too good to be true today, and probably the reason

155
00:12:22,680 --> 00:12:28,920
why anyone born between about 1970 and 2000 in the UK seems to be perfectly proficient

156
00:12:28,920 --> 00:12:35,720
with a computer.

157
00:12:35,720 --> 00:12:37,880
Now let's look at the game itself.

158
00:12:37,880 --> 00:12:41,920
Elite is an open world space exploration game.

159
00:12:41,920 --> 00:12:48,080
We begin docked at Lavais station with 100 credits, 3 missiles, a pulse laser and a Cobra

160
00:12:48,080 --> 00:12:50,680
Mark 3 spacecraft.

161
00:12:50,680 --> 00:12:55,720
Leaving the station, we make a hyperspace jump to another system of our choice.

162
00:12:55,720 --> 00:12:59,760
Every system has a summary screen denoting the government type and system wealth and

163
00:12:59,760 --> 00:13:02,360
major industry.

164
00:13:02,360 --> 00:13:06,960
Until we can afford to better equip our ship, novice players must now make a mad dash to

165
00:13:06,960 --> 00:13:11,640
the system planet, where they'll find it's respective space station.

166
00:13:11,640 --> 00:13:13,300
Time to dock.

167
00:13:13,300 --> 00:13:19,640
This is notoriously difficult, though I'm not really sure why, here's how to do it.

168
00:13:19,640 --> 00:13:24,760
Just ignore the manual and go in at half speed.

169
00:13:24,760 --> 00:13:28,980
Every system has different commodity prices, and we're able to make a profit by trading

170
00:13:28,980 --> 00:13:31,560
between appropriate systems.

171
00:13:31,560 --> 00:13:35,880
This is a surprisingly involved process, so keep a notebook handy.

172
00:13:35,880 --> 00:13:39,360
And probably don't trade anything illegal for now unless you want the galactic police

173
00:13:39,360 --> 00:13:42,200
on your case.

174
00:13:42,200 --> 00:13:44,600
Of course it's rarely this simple.

175
00:13:44,600 --> 00:13:50,840
If you've warped into an anarchic system, get ready to be constantly harassed by pirates.

176
00:13:50,840 --> 00:13:55,960
Even in the safest systems, it's rare to make a clean run to the home planet.

177
00:13:55,960 --> 00:13:59,600
Later in the game, when we're better equipped, we can make a profit by bounty hunting these

178
00:13:59,600 --> 00:14:01,200
pirates.

179
00:14:01,200 --> 00:14:04,000
But for now, better get saving for that beam laser.

180
00:14:04,000 --> 00:14:06,760
Oh and there are Tharguides too.

181
00:14:06,760 --> 00:14:11,040
Those are aliens with tough flying saucers that spawn drones, and they're equipped with

182
00:14:11,040 --> 00:14:15,200
electronic countermeasures so they'll render your missiles useless.

183
00:14:15,200 --> 00:14:17,560
And that's the essence of it really.

184
00:14:17,560 --> 00:14:22,680
It was a complete step change in computer games in 1984.

185
00:14:22,680 --> 00:14:27,200
Short of the flight simulators I mentioned earlier, which as I said I would only loosely

186
00:14:27,200 --> 00:14:34,200
define as games, there was nothing else with true 3D graphics available on an arcade machine,

187
00:14:34,200 --> 00:14:36,960
let alone a home computer.

188
00:14:36,960 --> 00:14:42,720
The universe of 8 galaxies, each consisting of 256 stars, along with their descriptions,

189
00:14:42,720 --> 00:14:47,160
market prices and system characteristics, was procedurally generated.

190
00:14:48,160 --> 00:14:53,680
The closest the game has to a high score is the player ranking, starting at harmless

191
00:14:53,680 --> 00:14:58,320
and eventually reaching elite for only the most dedicated players.

192
00:14:58,320 --> 00:15:03,000
You can be a trader, a bounty hunter, a pirate, an asteroid miner, or some combination of

193
00:15:03,000 --> 00:15:05,000
all of these.

194
00:15:05,000 --> 00:15:09,280
Truly an open world game with infinite choice and potential.

195
00:15:09,280 --> 00:15:13,960
Sophie Wilson called it the program that couldn't have been written, and Steve Furber said it

196
00:15:13,960 --> 00:15:17,480
had the BBC design team staggered.

197
00:15:17,480 --> 00:15:19,920
Who are Sophie Wilson and Steve Furber?

198
00:15:19,920 --> 00:15:27,600
Oh, they're just the pair that built the BBC Micro prototype in four days.

199
00:15:27,600 --> 00:15:32,440
In what's now regarded as one of the greatest programming feats of all time, Elite was created

200
00:15:32,440 --> 00:15:37,320
over the course of two years by Ian Bell and David Braben.

201
00:15:37,320 --> 00:15:42,720
Both met while studying at Cambridge, though it seemed almost unfathomable for such a complex

202
00:15:42,760 --> 00:15:45,760
game to be created by just two individuals.

203
00:15:45,760 --> 00:15:49,920
This was actually unusual in UK development at the time.

204
00:15:49,920 --> 00:15:55,280
Almost every game published in the UK prior to Elite had been coded by sole developers.

205
00:15:55,280 --> 00:16:00,840
The UK games industry consisted almost exclusively of bedroom coders, sending in cassettes to

206
00:16:00,840 --> 00:16:05,440
various small publishers, hopefully in exchange for a few hundred pounds and some bragging

207
00:16:05,440 --> 00:16:07,560
rights.

208
00:16:07,560 --> 00:16:12,680
When Bell approached Acornsoft, the software wing of Acorn computers, it was clear they'd

209
00:16:12,680 --> 00:16:16,320
created something that had never been seen before.

210
00:16:16,320 --> 00:16:21,400
Acornsoft therefore not only agreed to publish, but also decided to stage the first major

211
00:16:21,400 --> 00:16:25,000
and highly publicised release of a game in the UK.

212
00:16:25,000 --> 00:16:29,720
They ran TV adverts and hired out a theme park for the launch.

213
00:16:29,720 --> 00:16:36,720
This seems trivial now, but this was completely unheard of in 1984.

214
00:16:36,720 --> 00:16:42,280
As I showed in the intro, Elite completely eclipsed any competition.

215
00:16:42,280 --> 00:16:47,640
Just immediately it became a national sensation, eventually selling over 100,000 copies for

216
00:16:47,640 --> 00:16:53,000
the BBC Micro and 600,000 across all platforms.

217
00:16:53,000 --> 00:17:02,000
Braben and Bell became celebrities who effectively jumpstarted the UK gaming industry.

218
00:17:03,240 --> 00:17:08,360
To build a universe in a 1980s computer, we must first do a deep dive into the hardware

219
00:17:08,360 --> 00:17:10,720
available at the time.

220
00:17:11,560 --> 00:17:16,440
To understand the code, it's necessary to understand the hardware first.

221
00:17:16,440 --> 00:17:20,640
There are far more comprehensive sources available in the description, so I'll keep it as brief

222
00:17:20,640 --> 00:17:22,360
as possible.

223
00:17:22,360 --> 00:17:28,200
By the end of this chapter, you'll understand how a CPU works.

224
00:17:28,200 --> 00:17:32,880
The BBC Micro was similar in architecture to rival machines of the time, using the same

225
00:17:32,880 --> 00:17:38,040
processor as the Apple II, Commodore 64 and the Atari 2600.

226
00:17:38,040 --> 00:17:44,920
That processor was the Moss 6502, a chip ubiquitous with the 1980s, and the driving force between

227
00:17:44,920 --> 00:17:47,920
the home computing revolution.

228
00:17:47,920 --> 00:17:54,080
The 6502 is able to receive and transmit 8 bits of data in a single cycle.

229
00:17:54,080 --> 00:17:59,960
Data in this case may refer to actual data moving to or from the CPU, or it may refer

230
00:17:59,960 --> 00:18:01,760
to commands.

231
00:18:01,760 --> 00:18:07,160
Each command the CPU is capable of carrying out is encodable as an 8-bit string.

232
00:18:07,160 --> 00:18:10,560
We'll see some examples later.

233
00:18:10,560 --> 00:18:19,000
This 8-bit or 1-byte data bus is why we refer to the 6502 as an 8-bit processor.

234
00:18:19,000 --> 00:18:23,680
In addition to the data bus is a 16-bit address bus.

235
00:18:23,680 --> 00:18:29,480
This is used to address individual locations, or addresses, in memory.

236
00:18:29,480 --> 00:18:34,520
Let's simplify the layout and see how this is achieved.

237
00:18:34,520 --> 00:18:39,720
To write a byte of data to memory, the CPU sends the chosen 16-bit address to the memory

238
00:18:39,720 --> 00:18:41,760
on the address bus.

239
00:18:41,760 --> 00:18:46,320
The byte of data to be stored is then sent down the data bus, and the memory ICs are

240
00:18:46,320 --> 00:18:49,760
configured to store that byte at the given location.

241
00:18:49,760 --> 00:18:54,320
Likewise, sending an address down the bus results in the byte stored at that address

242
00:18:54,320 --> 00:18:57,160
being returned to the CPU.

243
00:18:57,160 --> 00:19:01,960
Now let's have a look at the memory in the BBC Micro specifically.

244
00:19:01,960 --> 00:19:09,120
If we imagine zooming in on it, we can imagine every addressable byte being stored in sequence.

245
00:19:09,120 --> 00:19:12,040
Each address holds a single byte.

246
00:19:12,040 --> 00:19:18,280
As addresses are 16 bits in length, the maximum possible address is 2 to the power of 16,

247
00:19:18,280 --> 00:19:24,960
which equals 65,536 bytes in total, or 64 kilobytes.

248
00:19:24,960 --> 00:19:29,280
And indeed, the Micro had 64 kilobytes of memory available.

249
00:19:29,640 --> 00:19:33,840
However, 32 kilobytes of this is read-only.

250
00:19:33,840 --> 00:19:39,320
It contained the operating system itself, and is therefore not writable.

251
00:19:39,320 --> 00:19:45,640
The other 32 kilobytes is the RAM, and is the sum total space available to hold programs

252
00:19:45,640 --> 00:19:48,080
and any stored variables.

253
00:19:48,080 --> 00:19:52,200
However, not all of this is usable as such.

254
00:19:52,200 --> 00:19:57,240
When I began studying the architecture, one of the first questions I asked was,

255
00:19:57,240 --> 00:19:59,520
but where is the video memory?

256
00:19:59,520 --> 00:20:03,520
Which sort of shows how clueless I was.

257
00:20:03,520 --> 00:20:09,320
Every time we send a frame to display on the screen, that frame must be stored somewhere.

258
00:20:09,320 --> 00:20:16,720
I hadn't anticipated that back in the 1980s, this somewhere, or frame buffer, as we call it,

259
00:20:16,720 --> 00:20:19,440
also lived in main memory.

260
00:20:19,440 --> 00:20:24,160
Every location on the screen maps to a location in memory.

261
00:20:24,160 --> 00:20:29,280
Change the value of a byte in the frame buffer, and the corresponding pixel, or set of pixels,

262
00:20:29,280 --> 00:20:32,160
on the screen will also change.

263
00:20:32,160 --> 00:20:34,520
We'll go into more detail later.

264
00:20:34,520 --> 00:20:41,080
But in the case of Elite, 7,936 bytes were reserved as the frame buffer,

265
00:20:41,080 --> 00:20:46,360
used solely for storing the values for physical pixels to be drawn on screen.

266
00:20:46,360 --> 00:20:52,600
This area of memory is read by a collection of chips referred to as the Vidproc, or video processor,

267
00:20:52,600 --> 00:21:00,320
responsible for translating the byte value at each memory location to a physical pixel on screen.

268
00:21:00,320 --> 00:21:02,120
We're still not done.

269
00:21:02,120 --> 00:21:07,800
The first 3,584 bytes of memory are allocated to workspaces,

270
00:21:07,800 --> 00:21:13,760
which are, loosely speaking, areas that may be used to store variables, but not code.

271
00:21:13,760 --> 00:21:16,960
Let's take a closer look.

272
00:21:16,960 --> 00:21:21,800
Memory is actually split into 256 byte pages.

273
00:21:21,840 --> 00:21:29,240
The first is the zero page, and may be used to store variables that require fast access by the CPU.

274
00:21:29,240 --> 00:21:35,600
As zero page addresses can be defined in just 8 bits, the CPU is able to access them more quickly,

275
00:21:35,600 --> 00:21:39,560
and they were used extensively in Elite's source code.

276
00:21:39,560 --> 00:21:41,600
Next is the stack.

277
00:21:41,600 --> 00:21:44,960
This is another temporary storage area for variables.

278
00:21:44,960 --> 00:21:48,120
The stack operates on a first in, first out basis.

279
00:21:48,120 --> 00:21:55,800
Pushing a byte to the stack means that byte will be the first retrieved when subsequently calling from the stack.

280
00:21:55,800 --> 00:22:02,680
Most of the remaining space here is allocated to other workspaces that can be used to store temporary variables.

281
00:22:02,680 --> 00:22:07,560
However, one kilobyte is available as the language workspace.

282
00:22:07,560 --> 00:22:13,320
This isn't usable for code storage, but it could be used to store text expressions.

283
00:22:13,320 --> 00:22:16,800
And this was most certainly used by Bell and Braben.

284
00:22:16,800 --> 00:22:24,560
These expressions are persistent and defined in the source code, so they very much form part of it.

285
00:22:24,560 --> 00:22:31,280
The remaining 21,248 bytes of memory are available to store our program.

286
00:22:31,280 --> 00:22:40,000
So this gives a total of 21,248 bytes of program memory and 1,024 bytes in the language workspace.

287
00:22:40,000 --> 00:22:46,880
By my reckoning, that's a total of 22,272 bytes available.

288
00:22:46,880 --> 00:22:53,640
Reading around some other sources, the actual memory available was actually 21,952.

289
00:22:53,640 --> 00:22:56,200
Perhaps I missed a page somewhere.

290
00:22:56,200 --> 00:23:04,280
Either way, that's less than 22 kilobytes to fit an entire Open World 3D universe.

291
00:23:04,280 --> 00:23:07,680
And Elite fit within that 22 kilobytes.

292
00:23:07,680 --> 00:23:09,840
It's not very much.

293
00:23:09,880 --> 00:23:16,120
To add some context, if I go to PC Partpicker and look at a £1,600 PC,

294
00:23:16,120 --> 00:23:19,720
which is about the cost of a BBC Micro in today's money,

295
00:23:19,720 --> 00:23:25,000
we come up with something with an AMD Ryzen 7 CPU.

296
00:23:25,000 --> 00:23:29,080
Obviously, Elite would fit into the main memory millions of times over.

297
00:23:29,080 --> 00:23:32,400
But modern systems don't just use standard RAM.

298
00:23:32,400 --> 00:23:38,560
CPUs incorporate relatively tiny amounts of extremely high-speed memory on the chip itself.

299
00:23:38,560 --> 00:23:40,480
This is called the cache.

300
00:23:40,480 --> 00:23:44,480
Would 22 kilobytes fit on a modern CPU cache?

301
00:23:44,480 --> 00:23:48,160
The question is barely worth asking.

302
00:23:48,160 --> 00:23:51,240
We have to zoom in to the individual compute cores.

303
00:23:51,240 --> 00:23:53,640
The Ryzen 7 has eight of them.

304
00:23:53,640 --> 00:23:56,880
Each has its own dedicated Level 2 cache.

305
00:23:56,880 --> 00:24:00,040
It's still not even worth asking the question at that point.

306
00:24:00,040 --> 00:24:04,280
We have to go inside each core to the Level 1 cache,

307
00:24:04,280 --> 00:24:07,240
the fastest memory available in the system.

308
00:24:07,280 --> 00:24:09,760
The 64 kilobytes per core.

309
00:24:09,760 --> 00:24:14,760
So Elite would fit inside each core of a modern processor twice.

310
00:24:14,760 --> 00:24:21,200
In fact, it had also sit inside the Level 1 cache of every compute module of the GPU.

311
00:24:21,200 --> 00:24:25,520
And it had fit inside the controller chip for the SSD as well.

312
00:24:25,520 --> 00:24:29,760
It's genuinely difficult to find a place Elite wouldn't fit.

313
00:24:29,760 --> 00:24:31,760
So we get the point.

314
00:24:31,760 --> 00:24:35,760
Braben and Bell were severely constrained when it came to memory.

315
00:24:35,760 --> 00:24:40,360
And that's probably the most discussed limitation they were able to overcome.

316
00:24:40,360 --> 00:24:45,280
But I'd argue they were similarly, if not more limited, when it came to compute.

317
00:24:45,280 --> 00:24:49,280
Just recall the frame rate on those early flight simulators.

318
00:24:49,280 --> 00:24:54,280
Let's take a look at how the 6502 worked.

319
00:24:54,280 --> 00:24:57,360
We see our data and address buses.

320
00:24:57,360 --> 00:24:59,360
I'm going to include the memory here.

321
00:24:59,360 --> 00:25:01,360
Obviously it wasn't inside the chip,

322
00:25:01,360 --> 00:25:06,360
but showing it connected to the buses makes this section much easier to understand.

323
00:25:06,360 --> 00:25:09,360
CPUs contain registers.

324
00:25:09,360 --> 00:25:12,360
These are simply storage cells,

325
00:25:12,360 --> 00:25:15,360
able to hold a single piece of data.

326
00:25:15,360 --> 00:25:21,360
The 6502 has a one 16-bit register, the program counter.

327
00:25:21,360 --> 00:25:26,360
This holds the address of the current byte in memory that's currently being read.

328
00:25:26,360 --> 00:25:32,360
This may be thought of as the current position within the program being executed.

329
00:25:32,360 --> 00:25:38,360
Next to the index registers, there are two of them, referred to X and Y.

330
00:25:38,360 --> 00:25:41,360
They're both 8 bits in size.

331
00:25:41,360 --> 00:25:49,360
In addition to holding a single byte value, they can be incremented or decremented by one throughout the use of appropriate commands.

332
00:25:49,360 --> 00:25:53,360
This makes these registers useful as loop counters.

333
00:25:53,360 --> 00:25:57,360
The accumulator is another 8-bit register.

334
00:25:57,360 --> 00:26:03,360
Any arithmetic operations must be carried out using the value stored in the accumulator.

335
00:26:03,360 --> 00:26:08,360
For this reason, the accumulator is connected directly to the arithmetic logic unit.

336
00:26:08,360 --> 00:26:14,360
This is a collection of logic gates able to perform basic arithmetic operations.

337
00:26:14,360 --> 00:26:19,360
The value from the accumulator is fed in, along with a second value from the data bus,

338
00:26:19,360 --> 00:26:22,360
and the ALU performs the required operation.

339
00:26:22,360 --> 00:26:28,360
In the case of the 6502, the ALU is able to add and subtract 2 8-bit numbers,

340
00:26:28,360 --> 00:26:35,360
along with a few bitwise operations, specifically OR and bit shifts and bit rotations.

341
00:26:35,360 --> 00:26:43,360
That's it. The 6502 is only able to perform very simple arithmetic and logical operations.

342
00:26:43,360 --> 00:26:49,360
And remember, we can only operate on 8 bits. It can only count up to 255.

343
00:26:50,360 --> 00:26:56,360
The result from these operations is stored back in the accumulator.

344
00:26:56,360 --> 00:27:04,360
The status register is an 8-bit register, where each bit signifies a result from the last executed operation.

345
00:27:04,360 --> 00:27:13,360
For example, if an addition is performed and the resulting value is above 255, i.e. not storable in the accumulator,

346
00:27:13,360 --> 00:27:21,360
the 8 least significant bits will still be stored in the accumulator, and the carry flag will be set to high.

347
00:27:21,360 --> 00:27:31,360
In addition to the carry flag, the other bits flag 0 value, interrupt disable, decimal mode, break, overflow, and negative value.

348
00:27:31,360 --> 00:27:38,360
We won't worry too much about these for now, but know that they can be used to trigger branches in a program.

349
00:27:38,360 --> 00:27:44,360
Remember that second page of memory that formed the stack? It's represented here.

350
00:27:44,360 --> 00:27:51,360
The final register is the stack pointer, which stores the address of the highest populated location in the stack.

351
00:27:51,360 --> 00:27:57,360
We won't be directly referring to it again, I've just included it to be complete.

352
00:27:57,360 --> 00:28:09,360
And that's all we have to work with. By today's standards incredibly simple, but still a fully functioning CPU, with less than 4,000 transistors.

353
00:28:09,360 --> 00:28:14,360
There are three main families of commands that the 6502 is able to execute.

354
00:28:14,360 --> 00:28:22,360
Commands, or instructions as they're referred to more correctly, are represented by three-letter operation codes.

355
00:28:22,360 --> 00:28:27,360
Physically, each is just a byte sent down the address bus.

356
00:28:27,360 --> 00:28:33,360
The first family is instructions that move data to or from the registers and memory.

357
00:28:33,360 --> 00:28:38,360
Let's see what happens when we run the store accumulator instruction.

358
00:28:38,360 --> 00:28:43,360
This simply stores the value currently in the accumulator to memory.

359
00:28:43,360 --> 00:28:48,360
First, the desired address to store the value at is sent to memory via the address bus.

360
00:28:48,360 --> 00:28:53,360
Then the 8-bit value in the accumulator is sent to memory via the data bus.

361
00:28:53,360 --> 00:29:00,360
I'll leave it visible for now so we can imagine a byte of memory at a given address.

362
00:29:00,360 --> 00:29:08,360
We could then load this value into the X register using the LDX instruction, or loadX.

363
00:29:08,360 --> 00:29:13,360
The address is sent via the address bus, and the value is copied to the X register.

364
00:29:14,360 --> 00:29:20,360
With similar commands, we can send data between all available registers and memory.

365
00:29:20,360 --> 00:29:24,360
The next family are the arithmetic commands.

366
00:29:24,360 --> 00:29:29,360
AddWithCarrie adds a value from memory to the current accumulator value.

367
00:29:29,360 --> 00:29:36,360
Here the memory address is sent via the address bus, and the byte in memory is sent to the ALU.

368
00:29:36,360 --> 00:29:42,360
The value currently in the accumulator is also sent to the ALU, where the two are added.

369
00:29:42,360 --> 00:29:46,360
The result is stored in the accumulator.

370
00:29:46,360 --> 00:29:48,360
Remember the carry flag.

371
00:29:48,360 --> 00:29:54,360
If the resulting value is greater than 255, the carry flag is set to 1.

372
00:29:54,360 --> 00:30:00,360
But for now, let's assume there's no carry so the flag remains at 0.

373
00:30:00,360 --> 00:30:06,360
And that leads us to the final family of instructions, branches and jumps.

374
00:30:06,360 --> 00:30:13,360
The branch on carry clear causes a jump to a different location of our program if the carry flag is 0.

375
00:30:13,360 --> 00:30:15,360
Here's how it works.

376
00:30:15,360 --> 00:30:24,360
The carry flag is checked, and if it's 0, the address to which we want to jump is passed into the program counter.

377
00:30:24,360 --> 00:30:31,360
Remember addresses are 16 bits, so two separate bytes must be passed down the data bus to achieve this.

378
00:30:31,360 --> 00:30:35,360
This means the next address will be that of the jump location.

379
00:30:35,360 --> 00:30:39,360
This is how we implement if statements.

380
00:30:39,360 --> 00:30:41,360
And finally a jump itself.

381
00:30:41,360 --> 00:30:49,360
The JSR, or jump to subroutine instruction, is a direct instruction to jump somewhere else in the program.

382
00:30:49,360 --> 00:30:54,360
When we execute it, the current program address is pushed to the stack.

383
00:30:54,360 --> 00:31:00,360
This allows us to subsequently return to the current location by pulling from the stack.

384
00:31:00,360 --> 00:31:06,360
The new program location is then passed into the program counter via the data bus.

385
00:31:06,360 --> 00:31:08,360
And that's everything.

386
00:31:08,360 --> 00:31:15,360
We can move 8 bit values, do simple arithmetic on them and jump to different places in our code.

387
00:31:15,360 --> 00:31:17,360
That is it.

388
00:31:17,360 --> 00:31:29,360
Let's have a look at my attempt to turn these simple instructions into something on screen.

389
00:31:30,360 --> 00:31:36,360
The three families of operation codes discussed collectively form the 6502 assembly language.

390
00:31:36,360 --> 00:31:43,360
Almost all programming today is done with higher level languages, where we don't need to worry about physical hardware so much.

391
00:31:43,360 --> 00:31:49,360
Even in the 1980s, most coding was done using the likes of BASIC, C and FORTRAN.

392
00:31:49,360 --> 00:31:54,360
However, high level languages require considerably higher memory usage.

393
00:31:54,360 --> 00:32:01,360
And they must be compiled to assembly, resulting in less efficient use of the CPU and therefore slower running.

394
00:32:01,360 --> 00:32:05,360
Elite, therefore, was programmed in assembly.

395
00:32:05,360 --> 00:32:14,360
I decided the only way I could possibly do Elite justice and make an actually informative video was to learn 6502 assembly.

396
00:32:14,360 --> 00:32:21,360
And, well, let's just say my 10 years of programming experience were almost useless.

397
00:32:21,360 --> 00:32:28,360
I set myself the challenge of creating anything in 3D on the micro, but using assembly only.

398
00:32:28,360 --> 00:32:35,360
I'm happy to say I managed to achieve this, but it took longer than producing any other part of this video.

399
00:32:35,360 --> 00:32:39,360
So, enough tiptoeing around, let's see the final result.

400
00:32:39,360 --> 00:32:42,360
Prepare to be underwhelmed.

401
00:32:42,360 --> 00:32:46,360
So, yeah, that took me 5 days.

402
00:32:46,360 --> 00:32:52,360
It uses lookup tables to plot the positions of the vertices in 3D space.

403
00:32:52,360 --> 00:32:56,360
The tables are called from a subroutine which draws a single line.

404
00:32:56,360 --> 00:33:04,360
The appropriate value from each table is retrieved by using the values in the Y register, which increments every time a line is drawn.

405
00:33:04,360 --> 00:33:11,360
It's tiny because I cheated and used an inbuilt line drawing routine from the operating system.

406
00:33:11,360 --> 00:33:17,360
But that divides the screen into 1200 by 1200 points.

407
00:33:17,360 --> 00:33:21,360
But we can only count to 256 with this 8-bit system.

408
00:33:21,360 --> 00:33:30,360
And I definitely wasn't going to go and get my head around dealing with that, so I just made the whole thing 250 by 250 units in size.

409
00:33:30,360 --> 00:33:38,360
It flickers like mad too, but that's true of Elite as well, so I don't feel too bad about that part.

410
00:33:38,360 --> 00:33:48,360
Okay, now let's go and see how to code in 6502 assembly properly.

411
00:33:48,360 --> 00:33:52,360
Elite was initially released on both tape and disc versions.

412
00:33:52,360 --> 00:33:58,360
The tape version is the 22 kilobytes one, as it had to fit entirely within memory.

413
00:33:58,360 --> 00:34:01,360
Loading from a tape during gameplay is not really possible.

414
00:34:01,360 --> 00:34:07,360
The disc version has a few more features, like additional ships, and you can only do asteroid mining in that version.

415
00:34:07,360 --> 00:34:11,360
As these could be loaded in from the disc while the player was docked.

416
00:34:11,360 --> 00:34:15,360
The code itself for the two versions is essentially the same.

417
00:34:15,360 --> 00:34:19,360
The disc version just contains some more stored variables.

418
00:34:19,360 --> 00:34:27,360
And in case you're wondering, a tape version was absolutely necessary if ACONsoft wanted to actually sell any copies to the home market.

419
00:34:27,360 --> 00:34:34,360
Back in 1984, a disc drive in the UK cost as much as the BBC Micro itself.

420
00:34:34,360 --> 00:34:43,360
Although the memory constraints not as tight when loading from disc, the limited compute capability of the 6502 was still a huge challenge.

421
00:34:43,360 --> 00:34:47,360
Just recall the one frame per second flight simulator I showed earlier.

422
00:34:47,360 --> 00:34:51,360
For every frame in flight, every vertex on screen needs calculating.

423
00:34:51,360 --> 00:34:54,360
Every line between them must be calculated.

424
00:34:54,360 --> 00:34:57,360
An individual pixel is inserted into screen memory.

425
00:34:58,360 --> 00:35:04,360
The 6502 in the BBC Micro operated at 2 MHz, or 2 million cycles per second.

426
00:35:04,360 --> 00:35:14,360
This sounds like a lot at first, but as we go through some examples, we'll get a taste of how many individual operations need to be carried out to draw a single frame.

427
00:35:14,360 --> 00:35:21,360
Bear in mind, every assembly instruction requires two CPU cycles at absolute minimum.

428
00:35:21,360 --> 00:35:26,360
The subroutine for just drawing a single pixel requires 20 operations.

429
00:35:26,360 --> 00:35:32,360
And that's after all the necessary calculations have been performed to decide where to even draw that pixel.

430
00:35:32,360 --> 00:35:37,360
So for a full screen, it's easy to see how cycles are eaten up quickly.

431
00:35:37,360 --> 00:35:42,360
The code for Elite is essentially one large script of 6502 instructions.

432
00:35:42,360 --> 00:35:51,360
Trying to understand any of this is daunting at first, but it becomes much more manageable when we understand that it consists of a main gameplay loop.

433
00:35:51,360 --> 00:35:58,360
Depending on the current state of play, this loop calls upon individual subroutines as and when necessary.

434
00:35:58,360 --> 00:36:04,360
Each subroutine performs a simple task, such as drawing a line or updating the player's kill count.

435
00:36:04,360 --> 00:36:12,360
So the code is very much modular, and understanding individual modules allows us to build up to something bigger.

436
00:36:12,360 --> 00:36:15,360
The full source code for Elite is available on GitHub.

437
00:36:16,360 --> 00:36:23,360
When I set out to make this video, I was going to go through the main flow of the code and broadly explain how the main features are implemented.

438
00:36:23,360 --> 00:36:27,360
However, it turns out someone's already done all the work for me.

439
00:36:27,360 --> 00:36:35,360
Mark Mokson annotated every line of the original code and has a frankly incredible website which breaks down every element of it.

440
00:36:35,360 --> 00:36:41,360
It also includes many deep dive articles on some of the technical details of the code.

441
00:36:41,360 --> 00:36:43,360
This left me with a problem, however.

442
00:36:43,360 --> 00:36:49,360
I wasn't going to just regurgitate Mark's Herculean work here and try and take credit.

443
00:36:49,360 --> 00:36:58,360
So instead, this section of the video will walk through some choice examples and show how the code maps back to the 6502 itself.

444
00:36:58,360 --> 00:37:02,360
And I'll show some of my own visuals to make everything easier to understand.

445
00:37:02,360 --> 00:37:15,360
Remember how just under a quarter of the available memory was dedicated to storing pixel values to draw on the screen?

446
00:37:15,360 --> 00:37:17,360
Let's talk more about that.

447
00:37:17,360 --> 00:37:26,360
Drawing graphics on the BBC Micro is typically done at a resolution of 320 by 256, and eight colors are available.

448
00:37:26,360 --> 00:37:31,360
So every pixel would require three bits of memory to store its color value.

449
00:37:31,360 --> 00:37:36,360
That's because there are eight possible three-bit numbers, one for each color.

450
00:37:36,360 --> 00:37:43,360
So to store a frame at this resolution, we require 320 by 256 by three bits.

451
00:37:43,360 --> 00:37:50,360
That comes to 30 kilobytes just for the frame buffer, essentially leaving no room for our program.

452
00:37:50,360 --> 00:37:52,360
Oh dear.

453
00:37:52,360 --> 00:37:56,360
Okay, so we have two options to reduce the frame buffer.

454
00:37:56,360 --> 00:38:00,360
The first is to reduce the number of bits per pixel.

455
00:38:00,360 --> 00:38:05,360
Let's just represent each pixel with a single bit, one or zero.

456
00:38:05,360 --> 00:38:09,360
That reduces our frame buffer to 10 kilobytes, not bad.

457
00:38:09,360 --> 00:38:16,360
But with only a binary option for each pixel, that means we're limited to just black and white.

458
00:38:16,360 --> 00:38:21,360
The second option is to reduce the number of pixels to plot in the first place.

459
00:38:21,360 --> 00:38:28,360
By reducing our resolution to 160 by 256 and using say four colors only,

460
00:38:28,360 --> 00:38:32,360
we'd also reduce the frame buffer to about 10 kilobytes.

461
00:38:32,360 --> 00:38:37,360
So it looks like we'd have to choose between either high resolution or color.

462
00:38:37,360 --> 00:38:40,360
We can't have both.

463
00:38:40,360 --> 00:38:42,360
Or can we?

464
00:38:42,360 --> 00:38:44,360
Look closer.

465
00:38:44,360 --> 00:38:48,360
The combat viewing elite has high resolution but no color.

466
00:38:48,360 --> 00:38:52,360
The dashboard is in color but at low resolution.

467
00:38:52,360 --> 00:38:55,360
This was elite's first unique innovation.

468
00:38:55,360 --> 00:39:00,360
Before any pixels are plotted on an individual frame, a timer's started.

469
00:39:00,360 --> 00:39:03,360
We know the number of pixels to plot in high resolution.

470
00:39:03,360 --> 00:39:07,360
And we know the rate at which these pixels are plotted to the screen.

471
00:39:07,360 --> 00:39:11,360
It's one megahertz for the BBC Micro.

472
00:39:11,360 --> 00:39:16,360
So a timer is set to trigger after all the high res pixels have been plotted.

473
00:39:16,360 --> 00:39:21,360
The top half of the screen is drawn in the aforementioned high resolution.

474
00:39:21,360 --> 00:39:28,360
The timer then triggers an interrupt, which calls a subroutine, to switch to the lower resolution mode.

475
00:39:28,360 --> 00:39:36,360
This is achieved by switching registers in the video processing chip to convert it to low resolution for drawing the dashboard.

476
00:39:36,360 --> 00:39:40,360
And that's achievable through some assembly commands.

477
00:39:40,360 --> 00:39:46,360
As far as I can tell, this was the first game ever to use this split screen configuration.

478
00:39:46,360 --> 00:39:50,360
And it was definitely the first to do so on a BBC Micro.

479
00:39:51,360 --> 00:39:56,360
The end result is 7,936 bytes reserved for the frame buffer,

480
00:39:56,360 --> 00:40:00,360
leaving just enough room for the actual program.

481
00:40:00,360 --> 00:40:04,360
And a game that looks both sharp, yet colorful.

482
00:40:04,360 --> 00:40:07,360
Something not seen on a home computer before.

483
00:40:11,360 --> 00:40:16,360
Now let's take a look at a more obvious feature, the 3D graphics themselves.

484
00:40:16,360 --> 00:40:23,360
One reason they looked so good was that Elite was the first game playable at home to feature hidden line removal.

485
00:40:23,360 --> 00:40:29,360
Unlike earlier wireframe graphics, which themselves were barely existent in games at the time.

486
00:40:29,360 --> 00:40:33,360
If an edge on an object is obscured, it's not shown.

487
00:40:33,360 --> 00:40:36,360
This was a tricky problem to solve at the time.

488
00:40:36,360 --> 00:40:42,360
It still caused John Carmack a headache nearly 10 years later when optimizing Doom.

489
00:40:42,360 --> 00:40:46,360
In the case of Elite, the solution implemented was quite simple in concept,

490
00:40:46,360 --> 00:40:51,360
but required some clever design to be executed in acceptable speed.

491
00:40:51,360 --> 00:40:55,360
We start by looking at how objects are stored.

492
00:40:55,360 --> 00:40:59,360
The final few pages of memory are used to store the ship's blueprints.

493
00:40:59,360 --> 00:41:02,360
These are a series of lookup tables.

494
00:41:02,360 --> 00:41:08,360
The first table is a number of basic attributes, such as max speed and laser power.

495
00:41:08,360 --> 00:41:12,360
The second table for each ship is the vertices.

496
00:41:12,360 --> 00:41:17,360
This defines the position of each vertex relative to the center of the ship.

497
00:41:17,360 --> 00:41:23,360
I've seen it written before that blueprints contained only half a ship, with the other half generated on the fly.

498
00:41:23,360 --> 00:41:25,360
However, this is not true.

499
00:41:25,360 --> 00:41:30,360
We see the full vertex count for every ship when we look at the source code.

500
00:41:30,360 --> 00:41:32,360
Next is a table of edges.

501
00:41:32,360 --> 00:41:35,360
This is a list of plotable edges for the ship.

502
00:41:35,360 --> 00:41:40,360
Each defined by its starting and ending vertices and adjoining faces.

503
00:41:40,360 --> 00:41:46,360
The edge and vertex tables contain all the necessary data to plot a wireframe ship.

504
00:41:46,360 --> 00:41:53,360
However, in order to perform hidden line removal, the positions of the faces need to somehow be characterized.

505
00:41:53,360 --> 00:41:57,360
So, the final table for each ship is a list of faces.

506
00:41:57,360 --> 00:42:01,360
But how are these faces defined?

507
00:42:01,360 --> 00:42:05,360
Each one is characterized by what's called its normal vector.

508
00:42:05,360 --> 00:42:08,360
Let me explain what this looks like.

509
00:42:08,360 --> 00:42:13,360
Imagine drawing a line from the ship's center to the facing question.

510
00:42:13,360 --> 00:42:20,360
Now, the aim here is to draw this line so that it intersects the face at a 90-degree angle.

511
00:42:20,360 --> 00:42:26,360
Looking at a Tharguide ship as an example, this is easy enough to do for this face.

512
00:42:26,360 --> 00:42:28,360
But how about this one?

513
00:42:28,360 --> 00:42:33,360
We can imagine extending the face until a solution is found.

514
00:42:33,360 --> 00:42:43,360
These vectors are defined by three values, the x, y and z distance from the origin to the point of intersection on this extended face.

515
00:42:43,360 --> 00:42:52,360
Bell and Braben pre-computed these x, y, z distances and saved them in the face lookup table for every object in the game.

516
00:42:52,360 --> 00:42:56,360
Now, let's put the player's ship in our scene.

517
00:42:56,360 --> 00:43:00,360
This face here should be visible to the player.

518
00:43:00,360 --> 00:43:07,360
We know the position of the enemy ship relative to the player, so let's add the vector in for that too.

519
00:43:07,360 --> 00:43:13,360
Finally, the main flight loop calculates the rotation of every object in the scene.

520
00:43:13,360 --> 00:43:20,360
This is defined by three more vectors, one for each axis. Let's add those too.

521
00:43:20,360 --> 00:43:27,360
And with that, we have everything we need to remove the hidden lines, or I should say hidden faces.

522
00:43:27,360 --> 00:43:33,360
Rather than considering lines individually, faces as a whole are checked.

523
00:43:33,360 --> 00:43:36,360
First, we need to know the line of sight to the face.

524
00:43:36,360 --> 00:43:42,360
We can do that by summing the object's position vector and the face normal vector.

525
00:43:42,360 --> 00:43:49,360
Visually, vector addition works like this, so we now have a line of sight vector to our face.

526
00:43:50,360 --> 00:43:54,360
Every object in Elite was designed to be exclusively convex,

527
00:43:54,360 --> 00:44:01,360
so if a face's normal vector is pointing away from us, we know that face must be obscured.

528
00:44:01,360 --> 00:44:07,360
Or more formally, the angle between the normal vector and line of sight vector

529
00:44:07,360 --> 00:44:14,360
must be greater than 90 degrees for a face to be hidden, so we can perform this simple calculation.

530
00:44:14,360 --> 00:44:18,360
This is known as the dot product between the two vectors.

531
00:44:18,360 --> 00:44:23,360
Dot products are used all the time in 3D computation because they're very simple to calculate.

532
00:44:23,360 --> 00:44:27,360
Indeed, here's the subroutine Bell and Braben wrote,

533
00:44:27,360 --> 00:44:33,360
Crucially, a negative dot product denotes two vectors that are less than 90 degrees apart,

534
00:44:33,360 --> 00:44:38,360
and a positive one denotes two that are greater than 90 degrees apart.

535
00:44:38,360 --> 00:44:41,360
So, we calculate this dot product for our faces,

536
00:44:41,360 --> 00:44:49,360
and only plot edges associated with faces where the line of sight to the face normal dot product is less than one.

537
00:44:49,360 --> 00:44:52,360
Now, there is one minor step I missed out.

538
00:44:52,360 --> 00:44:58,360
In reality, face normal vectors are relative to the orientation of the ship to be plotted,

539
00:44:58,360 --> 00:45:04,360
so the player's x, y, z coordinates need to be translated to the ship's local coordinate system.

540
00:45:04,360 --> 00:45:08,360
This is done by modifying our line of sight vector as shown here,

541
00:45:08,360 --> 00:45:10,360
but the end result's the same.

542
00:45:10,360 --> 00:45:14,360
Faces are only plotted when the dot product is negative.

543
00:45:14,360 --> 00:45:20,360
See Mark Moxon's Deep Dive article for more details on this step if you need convincing why this is necessary.

544
00:45:27,360 --> 00:45:33,360
These three numbers and this simple formula define elite's entire universe.

545
00:45:33,360 --> 00:45:40,360
It's sometimes stated that the universe is randomly generated, but it's a little bit more elegant than that.

546
00:45:40,360 --> 00:45:43,360
It is in fact procedurally generated.

547
00:45:43,360 --> 00:45:46,360
That means the same universe is created every time.

548
00:45:46,360 --> 00:45:53,360
Elite wasn't the first game to feature procedural generation, but it was the first to apply it on such a scale.

549
00:45:53,360 --> 00:45:56,360
Let's see how those three numbers define a system.

550
00:45:56,360 --> 00:45:59,360
These numbers are referred to as seeds.

551
00:45:59,360 --> 00:46:03,360
Each is expressed as a 16-bit binary value.

552
00:46:03,360 --> 00:46:07,360
Now, different bits within each form parameters for the system.

553
00:46:07,360 --> 00:46:12,360
Two entire bytes define the coordinates of the system in the galaxy.

554
00:46:12,360 --> 00:46:18,360
These two bits define the system tech level, and these two define the prosperity level.

555
00:46:18,360 --> 00:46:25,360
They're used to bias a pseudo randomly generated number to decide the prices of commodities at the system.

556
00:46:25,360 --> 00:46:28,360
These three define the system's government type.

557
00:46:28,360 --> 00:46:38,360
In a similar manner to the economic variables, the value stored here increases or decreases the likelihood of encountering pirates at the system.

558
00:46:38,360 --> 00:46:41,360
And these three define the distance to the planet.

559
00:46:41,360 --> 00:46:46,360
All other system attributes are similarly defined with the remaining bits.

560
00:46:46,360 --> 00:46:50,360
The three numbers on screen define the first system plotted.

561
00:46:50,360 --> 00:46:54,360
Then, that deceptively simple formula is applied.

562
00:46:54,360 --> 00:47:00,360
We add the three values, append the result to our list, and discard the first value.

563
00:47:00,360 --> 00:47:04,360
And that gives us the three seed values for the next galaxy.

564
00:47:04,360 --> 00:47:11,360
The process is repeated 255 times to give a galaxy of 256 stars.

565
00:47:11,360 --> 00:47:17,360
If the result is greater than 16 bits in length, we just take the carry value and continue on.

566
00:47:17,360 --> 00:47:23,360
And the process itself is repeated a further 7 times to give a total of 8 galaxies.

567
00:47:23,360 --> 00:47:25,360
And that's all there is to it.

568
00:47:32,360 --> 00:47:35,360
The final feature I'd like to go through is the radar.

569
00:47:35,360 --> 00:47:38,360
This has an almost legendary status.

570
00:47:38,360 --> 00:47:42,360
It was the final few lines of code written before Elite was released.

571
00:47:42,360 --> 00:47:46,360
Braben had to convince Aconsoft to add it in last minute.

572
00:47:46,360 --> 00:47:50,360
But it completely changes the nature of the combat sequences.

573
00:47:50,360 --> 00:47:56,360
It's quite funny watching videos of novices playing and not even realising the radar's there.

574
00:47:56,360 --> 00:48:00,360
They hear the sound of being shot at but don't know where it's coming from

575
00:48:00,360 --> 00:48:04,360
and kind of flail around pitching and rolling randomly.

576
00:48:04,360 --> 00:48:11,360
But once they realise the radar's there and how it works, it completely changes how they handle combat.

577
00:48:11,360 --> 00:48:13,360
It's simple to use.

578
00:48:13,360 --> 00:48:18,360
Objects within range of the player are shown as sticks with a little flag at the end.

579
00:48:18,360 --> 00:48:22,360
A stick behind the player represents an object behind them.

580
00:48:22,360 --> 00:48:25,360
And one in front is an object in front of them.

581
00:48:25,360 --> 00:48:29,360
Likewise a stick extending upwards mean the object is above the player

582
00:48:29,360 --> 00:48:32,360
and downwards means it's below them.

583
00:48:32,360 --> 00:48:37,360
So the radar provides a full representation of the 3D space around the player

584
00:48:37,360 --> 00:48:40,360
and can be understood at a glance.

585
00:48:40,360 --> 00:48:42,360
Genius!

586
00:48:42,360 --> 00:48:44,360
I'll go into full depth for this one.

587
00:48:44,360 --> 00:48:49,360
We've made it this far so let's go crazy and get my 6502 model on screen.

588
00:48:49,360 --> 00:48:53,360
The scan subroutine performs this task.

589
00:48:53,360 --> 00:49:00,360
Let's figure out how it draws a single dot representing another ship in the correct position on screen.

590
00:49:00,360 --> 00:49:05,360
Every object within range of the player's ship has a ship type variable.

591
00:49:05,360 --> 00:49:12,360
For the current ship, this variable along with the ship data is moved into the 0 page workspace for fast access.

592
00:49:12,360 --> 00:49:16,360
Therefore saving clock cycles.

593
00:49:16,360 --> 00:49:21,360
We load that object's ID from the workspace and into the accumulator.

594
00:49:21,360 --> 00:49:27,360
Objects such as planets and suns are designed to have their most significant bits set to 1 in the ID.

595
00:49:27,360 --> 00:49:30,360
And this sets the minus flag to 1.

596
00:49:30,360 --> 00:49:37,360
So a break if minus command causes us to return from the subroutine and not plot that object.

597
00:49:37,360 --> 00:49:46,360
For plot of the objects, the hex representation of the plot color, which is green for ships, is loaded into the x register.

598
00:49:46,360 --> 00:49:51,360
The color green is represented by ff in hex.

599
00:49:51,360 --> 00:49:56,360
This color variable is then stored in the workspace.

600
00:49:56,360 --> 00:50:02,360
The ship data in the workspace contains x, y and z coordinate values.

601
00:50:02,360 --> 00:50:07,360
Each is two bytes and represents the ship's position relative to the player.

602
00:50:07,360 --> 00:50:18,360
We load the most significant byte of the x coordinate into the accumulator and perform a logical or on the respective bytes from the y and z coordinates.

603
00:50:18,360 --> 00:50:27,360
One more logical and is performed on the result using the binary value 11000000.

604
00:50:27,360 --> 00:50:36,360
If the result is zero, the two most significant bits of all coordinate values are zero and the ship is in plotting range.

605
00:50:36,360 --> 00:50:39,360
So branch on not zero.

606
00:50:39,360 --> 00:50:44,360
A positive result here would return from the subroutine.

607
00:50:44,360 --> 00:50:49,360
Let's assume the ship is within plotting range.

608
00:50:49,360 --> 00:51:00,360
To convert a ship's world x position to an x coordinate on screen, i.e. on the scanner, we add 123 to the most significant byte of the x position.

609
00:51:00,360 --> 00:51:06,360
We don't need to go through why that is here, but let's just take it at face value.

610
00:51:07,360 --> 00:51:15,360
Assuming x is positive, we simply load the ship's high x byte into the accumulator and add 123.

611
00:51:15,360 --> 00:51:22,360
The resulting value is stored in location x1 in the zero page workspace.

612
00:51:22,360 --> 00:51:30,360
A similar process is carried out for the y coordinate, saving it in location y1 in the zero page workspace.

613
00:51:31,360 --> 00:51:39,360
Finally, an existing subroutine is called to draw a double length dot at the coordinates x1, y1.

614
00:51:39,360 --> 00:51:48,360
I definitely won't go into details of how this works, but in summary, it loads x1 and y1 into the accumulator and x register,

615
00:51:48,360 --> 00:51:53,360
converts the coordinate values into the correct locations in screen memory,

616
00:51:53,360 --> 00:51:58,360
and performs an exclusive OR operation on these locations.

617
00:51:58,360 --> 00:52:07,360
If nothing was plotted there before, the exclusive OR operation populates the pixel at the correct memory location with the color value we previously stored.

618
00:52:07,360 --> 00:52:11,360
Actually, let's take a second to think about that.

619
00:52:11,360 --> 00:52:20,360
When writing pixel values to the frame buffer, Elite's source code always uses an exclusive OR instead of just writing the value directly.

620
00:52:20,360 --> 00:52:27,360
Let's consider writing a single pixel and see what would happen if we just wrote the new value directly.

621
00:52:27,360 --> 00:52:31,360
The bottom row of this truth table is the important one here.

622
00:52:31,360 --> 00:52:33,360
Imagine us building up our frame.

623
00:52:33,360 --> 00:52:36,360
We may first add in the object for the star,

624
00:52:36,360 --> 00:52:44,360
but then adding all the lines for the spacecraft would just draw white lines in front of a white star, rendering the spacecraft invisible.

625
00:52:44,360 --> 00:52:48,360
Here's the truth table for the exclusive OR pixel right.

626
00:52:48,360 --> 00:52:52,360
Now a white on white pixel flips to black.

627
00:52:52,360 --> 00:52:55,360
So spacecraft are visible in front of white objects.

628
00:52:55,360 --> 00:52:57,360
They look like this.

629
00:52:57,360 --> 00:53:01,360
It doesn't even matter what order the objects are written to the frame buffering.

630
00:53:01,360 --> 00:53:07,360
Or if only part of the object occludes the star, this will always work.

631
00:53:07,360 --> 00:53:11,360
At the expense of a single instruction when writing pixel values,

632
00:53:11,360 --> 00:53:15,360
Braben and Bell never needed to worry about objects disappearing in front of stars.

633
00:53:15,360 --> 00:53:18,360
It was all handled automatically.

634
00:53:18,360 --> 00:53:21,360
Even with me skipping over how Y coordinates are calculated,

635
00:53:21,360 --> 00:53:24,360
how screen memory locations are determined,

636
00:53:24,360 --> 00:53:28,360
and how the stick from the object on the scanner is drawn,

637
00:53:28,360 --> 00:53:33,360
that was still a lot to go through just to get a single dot on screen.

638
00:53:33,360 --> 00:53:36,360
But that's how the source code was built up in general,

639
00:53:36,360 --> 00:53:39,360
by taking individual tasks,

640
00:53:39,360 --> 00:53:41,360
breaking them down into simple problems,

641
00:53:41,360 --> 00:53:46,360
and figuring out how to implement the solutions in assembly.

642
00:53:46,360 --> 00:53:49,360
Each solution was translated into a subroutine,

643
00:53:49,360 --> 00:53:53,360
and meticulously optimised to save memory and compute.

644
00:53:53,360 --> 00:53:59,360
No single subroutine is particularly complex or difficult to understand,

645
00:53:59,360 --> 00:54:08,360
but they combine to create an entire universe.

646
00:54:08,360 --> 00:54:13,360
It's difficult to quantify the effect Elite had on the computing sector as a whole.

647
00:54:13,360 --> 00:54:17,360
Every British software developer I've spoke to that went to school in the 1980s

648
00:54:17,360 --> 00:54:20,360
cites Elite as a reason they got into computing.

649
00:54:20,360 --> 00:54:23,360
Being able to code the game on the same machine you could play it on

650
00:54:23,360 --> 00:54:26,360
probably had something to do with that.

651
00:54:26,360 --> 00:54:28,360
Though I was born too late for Elite's release,

652
00:54:28,360 --> 00:54:31,360
we had a copy on our Acorn Archimedes at home.

653
00:54:31,360 --> 00:54:33,360
I liked it.

654
00:54:33,360 --> 00:54:37,360
I was told it was a big deal, but I didn't really understand why, because I was 8.

655
00:54:37,360 --> 00:54:41,360
A couple of years later, I realised the game was nearly 15 years old,

656
00:54:41,360 --> 00:54:45,360
which completely blew me away at the time.

657
00:54:45,360 --> 00:54:47,360
In the years following Elite's success,

658
00:54:47,360 --> 00:54:51,360
Bell gradually distanced himself from the gaming industry.

659
00:54:51,360 --> 00:54:55,360
I've heard he grew to dislike the proliferation of violent video games,

660
00:54:55,360 --> 00:54:57,360
something I can't really relate to,

661
00:54:57,360 --> 00:55:01,360
since I grew up with the likes of Doom, Half-Life and BioShock.

662
00:55:01,360 --> 00:55:07,360
His personal website is a quirky record of what the World Wide Web looked like in the 1990s.

663
00:55:07,360 --> 00:55:10,360
It also contains the source code for Elite,

664
00:55:11,360 --> 00:55:15,360
that did cause a bit of a legal kerfuffle between himself and Braben,

665
00:55:15,360 --> 00:55:18,360
but I understand the two have been back on speaking terms for years now,

666
00:55:18,360 --> 00:55:20,360
so that's nice.

667
00:55:20,360 --> 00:55:22,360
Braben on the other hand,

668
00:55:22,360 --> 00:55:25,360
he used the success of Elite to found Frontier Games,

669
00:55:25,360 --> 00:55:28,360
which remains a major UK developer to this day.

670
00:55:28,360 --> 00:55:32,360
In fact, he only stepped down as CEO in 2022.

671
00:55:32,360 --> 00:55:37,360
In 2014, Frontier released a modern day adaptation of Elite.

672
00:55:37,360 --> 00:55:39,360
Elite Dangerous.

673
00:55:39,360 --> 00:55:41,360
Backed by what was, at the time,

674
00:55:41,360 --> 00:55:44,360
the largest ever crowdfunding campaign in the UK.

675
00:55:44,360 --> 00:55:46,360
And it's amazing.

676
00:55:46,360 --> 00:55:49,360
A one-to-one scale map of the Milky Way,

677
00:55:49,360 --> 00:55:52,360
with 400 billion star systems to explore.

678
00:55:54,360 --> 00:55:56,360
Prior to that, in 2008,

679
00:55:56,360 --> 00:55:59,360
he became one of the co-founders of the Raspberry Pi Foundation,

680
00:55:59,360 --> 00:56:03,360
who went on to completely revolutionise access to cheap compute hardware,

681
00:56:03,360 --> 00:56:06,360
and spawned a new generation of hobbyists.

682
00:56:06,360 --> 00:56:08,360
I'm one of them.

683
00:56:08,360 --> 00:56:12,360
I pre-ordered my first Pi on the day they were announced.

684
00:56:12,360 --> 00:56:14,360
I was on an oil rig at the time,

685
00:56:14,360 --> 00:56:17,360
and though I'd been employed for less than a year,

686
00:56:17,360 --> 00:56:20,360
I was already looking for a way out of that industry.

687
00:56:20,360 --> 00:56:22,360
I learned how to navigate a Linux system,

688
00:56:22,360 --> 00:56:24,360
run distributed compute,

689
00:56:24,360 --> 00:56:28,360
and even how to containerise applications thanks to the Raspberry Pi.

690
00:56:32,360 --> 00:56:36,360
Elite was ported to every major platform it could viably run on.

691
00:56:36,360 --> 00:56:39,360
Of course, making it accessible to cheaper systems,

692
00:56:39,360 --> 00:56:41,360
such as the ZX Spectrum and Acorn Electron,

693
00:56:41,360 --> 00:56:44,360
played a huge part in the game's record sales.

694
00:56:44,360 --> 00:56:48,360
Perhaps most astonishing is the NES port.

695
00:56:48,360 --> 00:56:51,360
That's right, you could play Elite on the NES,

696
00:56:51,360 --> 00:56:55,360
a machine designed entirely not for 3D vector graphics.

697
00:56:55,360 --> 00:56:58,360
In fact, I've done just that.

698
00:56:58,360 --> 00:57:00,360
Back when I was at university,

699
00:57:00,360 --> 00:57:02,360
I owned an NES for retro gaming,

700
00:57:02,360 --> 00:57:04,360
and I had a copy of Elite.

701
00:57:04,360 --> 00:57:08,360
To be honest, it was the only game I used to play on the thing.

702
00:57:08,360 --> 00:57:12,360
An upgraded version was also released for MS-DOS,

703
00:57:12,360 --> 00:57:14,360
known as Elite Plus,

704
00:57:14,360 --> 00:57:18,360
coded entirely by another legendary UK gaming figure,

705
00:57:18,360 --> 00:57:19,360
Chris Sawyer.

706
00:57:19,360 --> 00:57:21,360
If you don't know that name,

707
00:57:21,360 --> 00:57:24,360
just keep an eye out on the outro sequence.

708
00:57:24,360 --> 00:57:28,360
Elite marked the end of the dominance of the arcade shooter.

709
00:57:28,360 --> 00:57:30,360
Less than one year after its release,

710
00:57:30,360 --> 00:57:33,360
the NES was debuted in the US and Europe,

711
00:57:33,360 --> 00:57:35,360
though most games for this platform

712
00:57:35,360 --> 00:57:37,360
didn't match Elite's level of complexity.

713
00:57:37,360 --> 00:57:39,360
Even relatively accessible titles,

714
00:57:39,360 --> 00:57:41,360
such as Super Mario Brothers and Zelda,

715
00:57:41,360 --> 00:57:43,360
provided a much richer experience

716
00:57:43,360 --> 00:57:46,360
than had been previously available.

717
00:57:46,360 --> 00:57:48,360
In retrospect, it really feels like

718
00:57:48,360 --> 00:57:50,360
Bell and Braben opened the floodgates

719
00:57:50,360 --> 00:57:54,360
by demonstrating what was possible with 8-bit hardware.

720
00:57:54,360 --> 00:57:57,360
Though they had pushed that hardware to its limits,

721
00:57:57,360 --> 00:58:00,360
and we'd have to wait until the 1990s

722
00:58:00,360 --> 00:58:02,360
and the rise of 32-bit systems

723
00:58:02,360 --> 00:58:06,360
to see an explosion in 3D rendering technology.

724
00:58:06,360 --> 00:58:09,360
By then, most major games were no longer produced

725
00:58:09,360 --> 00:58:11,360
by solitary bedroom coders,

726
00:58:11,360 --> 00:58:13,360
but by large studios,

727
00:58:13,360 --> 00:58:16,360
with large design and advertising budgets to match.

728
00:58:16,360 --> 00:58:18,360
By the end of the 1990s,

729
00:58:18,360 --> 00:58:20,360
another hardware wall was hit.

730
00:58:20,360 --> 00:58:22,360
Back in 1984,

731
00:58:22,360 --> 00:58:24,360
Elite required real-time calculation

732
00:58:24,360 --> 00:58:27,360
and plotting of several to dozens of polygons

733
00:58:27,360 --> 00:58:29,360
on screen at a given time.

734
00:58:29,360 --> 00:58:31,360
But by now, the polygon count

735
00:58:31,360 --> 00:58:33,360
that was demanded by designers

736
00:58:33,360 --> 00:58:36,360
was outpacing improvements in CPU speed.

737
00:58:36,360 --> 00:58:38,360
A new approach was needed.

738
00:58:38,360 --> 00:58:40,360
Wouldn't it be nice to calculate the positions

739
00:58:40,360 --> 00:58:42,360
of all these polygons in parallel?

740
00:58:42,360 --> 00:58:45,360
Thus, the GPU was born.

741
00:58:45,360 --> 00:58:47,360
Why use one very fast processor

742
00:58:47,360 --> 00:58:50,360
when you can use many slow ones at once?

743
00:58:50,360 --> 00:58:52,360
About 10 years later,

744
00:58:52,360 --> 00:58:55,360
something very unusual happened.

745
00:58:55,360 --> 00:58:58,360
Typically, new technologies start out relatively expensive

746
00:58:58,360 --> 00:59:01,360
and are only used experimentally,

747
00:59:01,360 --> 00:59:04,360
and then by commercial or government organizations,

748
00:59:04,360 --> 00:59:07,360
before becoming cheap enough to sell to consumers.

749
00:59:07,360 --> 00:59:10,360
But the opposite happened with GPUs.

750
00:59:10,360 --> 00:59:14,360
A new field was rapidly growing in the late 2000s,

751
00:59:14,360 --> 00:59:16,360
data science.

752
00:59:16,360 --> 00:59:18,360
It was realised that the computations

753
00:59:18,360 --> 00:59:20,360
necessary to train neural networks

754
00:59:20,360 --> 00:59:22,360
are similar in principle to those used

755
00:59:22,360 --> 00:59:25,360
to calculate polygons for 3D rendering.

756
00:59:25,360 --> 00:59:27,360
Data scientists realised that in some cases,

757
00:59:27,360 --> 00:59:29,360
cheap off-the-shelf gaming GPUs

758
00:59:29,360 --> 00:59:32,360
outperformed supercomputers.

759
00:59:32,360 --> 00:59:36,360
I first used a GPU to train up an algorithm in 2015,

760
00:59:36,360 --> 00:59:39,360
and now it's something I do on a daily basis.

761
00:59:39,360 --> 00:59:41,360
The algorithm that recommended this video to you

762
00:59:41,360 --> 00:59:44,360
was trained in a cluster of GPUs.

763
00:59:44,360 --> 00:59:47,360
The implications of large-scale deployment

764
00:59:47,360 --> 00:59:49,360
of advanced machine learning algorithms

765
00:59:49,360 --> 00:59:51,360
are not yet fully understood,

766
00:59:51,360 --> 00:59:53,360
and we would have got there without Elite,

767
00:59:53,360 --> 00:59:56,360
but I think it's fair to say we'd have got there slower.

768
00:59:57,360 --> 00:59:59,360
But back to gaming.

769
00:59:59,360 --> 01:00:02,360
UK gaming specifically.

770
01:00:02,360 --> 01:00:05,360
Elite was our breakout game, if you will.

771
01:00:05,360 --> 01:00:07,360
In the four decades that have followed,

772
01:00:07,360 --> 01:00:10,360
the UK gaming industry has birthed some of the most influential

773
01:00:10,360 --> 01:00:13,360
and best-selling games of all time,

774
01:00:13,360 --> 01:00:16,360
and they continue to do so.

775
01:00:16,360 --> 01:00:18,360
And not just huge developers, either.

776
01:00:18,360 --> 01:00:21,360
With the rise of accessible gaming engines,

777
01:00:21,360 --> 01:00:24,360
such as Unity, Unreal, and now Godot,

778
01:00:24,360 --> 01:00:26,360
it's again possible for small teams,

779
01:00:26,360 --> 01:00:29,360
and even individuals, to design, write,

780
01:00:29,360 --> 01:00:32,360
and publish great games.

781
01:00:32,360 --> 01:00:35,360
Bell and Braben set out to make a great game,

782
01:00:35,360 --> 01:00:38,360
but they also fostered an entire industry.

783
01:01:54,360 --> 01:01:57,360
Thank you.

