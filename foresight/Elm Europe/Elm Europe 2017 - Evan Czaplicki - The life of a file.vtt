WEBVTT

00:00.000 --> 00:08.440
Welcome, everyone. I want to start just saying thanks, everyone, for coming. This is kind

00:08.440 --> 00:18.080
of crazy. I'm Evan. I made Elm. It's very exciting to be here. So I want to say thanks

00:18.080 --> 00:23.080
one, thanks for folks for coming, thanks to Thibaut and Guillaume for setting things up,

00:23.080 --> 00:29.280
and then thanks to everyone who is helping get the technology set up, and then this thank

00:29.280 --> 00:37.520
you is like outer proportion. So thank you to who had the L have this tail. I really

00:37.520 --> 00:46.920
appreciate that. But yeah, so thanks, everyone, for coming. And I want to emphasize sort of

00:46.920 --> 00:54.800
a question that has sort of guided Elm for the last couple of years, which is how do

00:54.800 --> 01:00.640
I grow Elm code? And so this is a question that somehow always sounds topical. So who

01:00.640 --> 01:06.320
remembers Elm before the Elm architecture? Before the Elm architecture? Okay, there

01:06.320 --> 01:10.160
are people out there. Okay. So there was a time when that didn't exist and people would

01:10.160 --> 01:14.960
say how do I write a program? And so we sort of observed, okay, maybe we can call this

01:14.960 --> 01:18.400
thing there's a model, there's an update of you. We saw that pattern, and they were like,

01:18.400 --> 01:24.280
okay, that's cool. How do I grow an Elm program? Okay. So we had some more examples.

01:24.680 --> 01:30.800
And showed it, okay, you can reuse functions in this kind of way to help make a view. And

01:30.800 --> 01:35.240
people were like, okay, cool. But how do you grow an Elm program? So I want to take the

01:35.240 --> 01:42.720
next step in perhaps a never ending journey. And we're going to do that by tracing the

01:42.720 --> 01:49.920
life of a file. So we'll see it start small and gradually grow, and then grow a bit more,

01:49.960 --> 01:56.280
and then eventually break off into two. And I think as we go through this path, it won't

01:56.280 --> 02:01.920
necessarily be surprising or difficult. But I think it's hard to see if you're coming

02:01.920 --> 02:07.240
from JavaScript. So before we get started with the life of a file, I want to start with

02:07.240 --> 02:14.400
some JavaScript folk knowledge that may be leading people astray. So one thing that I

02:14.480 --> 02:21.280
see a lot is this idea that shorter files are better. So an extreme example of this is when I

02:21.280 --> 02:28.960
was doing the benchmark comparison between React and a bunch of other frameworks in Elm,

02:29.840 --> 02:35.200
the Ember one just had so many files, I just didn't get it. This is a greater than file.

02:36.080 --> 02:43.360
And it just felt like this surely isn't the easiest way. So when I see this thought process,

02:43.400 --> 02:51.520
it sort of feels bizarre to me. And so the way I can understand it is the context is as the lines

02:51.520 --> 02:57.120
of code increases, the probability of sneaky mutation approaches one. It's going to happen if

02:57.120 --> 03:01.640
you're writing JavaScript code. So if you have a thousand lines of code, there's going to be some

03:01.640 --> 03:05.440
object that accidentally gets shared, and two people are going to be mutating it. It's just going

03:05.440 --> 03:15.760
to happen. So therefore, for shorter files, it fills this very useful function. Another thing that

03:15.760 --> 03:20.640
people just know in JavaScript is you have to get the architecture right from the beginning or

03:20.640 --> 03:27.200
you're doomed. It's just not going to work out for your project. This you barely need a justification

03:27.200 --> 03:33.920
because obviously I'm sure many of us have seen this play out in companies we either work for or

03:33.920 --> 03:42.560
people we know. And the justification behind it is refactoring is very risky. Sometimes it's cheaper

03:42.560 --> 03:47.760
to just rewrite the code. And I think that accounts for some of the churn in JavaScript

03:47.760 --> 03:52.720
frameworks. People like, well, this didn't work. I could try to fix it, but it'd be just as easy

03:52.720 --> 04:00.400
to try a different thing that maybe doesn't suck. So we have these sort of intuitions and habits

04:00.400 --> 04:06.800
that are grown out of the actual constraints of JavaScript and the languages we use. But in Elm,

04:07.600 --> 04:11.840
the probability of sneaking mutation is zero. If you have a thousand lines or 10,000 lines,

04:11.840 --> 04:17.040
it's just like not possible that a value gets shared and suddenly there's spooky action at

04:17.040 --> 04:23.760
a distance between these two chunks of code. So this whole premise is gone. And so I don't see

04:23.760 --> 04:30.880
how we can draw the same conclusion anymore. Similarly, refactoring is cheap and reliable.

04:30.880 --> 04:35.280
Like you have types to help you out. The compiler is going to guide you through the process. So

04:36.080 --> 04:41.040
you can end up changing 10 or 20 files and be pretty confident to end that things are fine.

04:41.680 --> 04:46.960
So again, this premise is gone. And so this idea that the architecture has to be right from the

04:46.960 --> 04:56.720
start doesn't really play out in practice. So the big thing to note here is that the way Elma's

04:56.720 --> 05:01.840
design changes how you should grow a code base. And we have a lot of habits that come from,

05:01.840 --> 05:05.600
like we don't even necessarily all know the justification of these things, but we know like,

05:05.600 --> 05:11.200
oh, that file seems too long. That's probably, like we have these senses that guide how we write code.

05:12.160 --> 05:16.880
So the rest of the talk is sort of challenging these and providing a new way of seeing code

05:17.440 --> 05:26.240
that can help grow a program. Okay. So the life of a file. We might start out with a nice little

05:26.240 --> 05:32.400
file. Let's say I, and the blue is like the model, let's say the data structure and then there's

05:32.400 --> 05:38.320
some logic. And maybe this is, I have a personal like reading list and I want to just keep track

05:38.400 --> 05:46.320
of the books that I'm interested in. And maybe I have 200 lines of code. I'm not crazy. And so I

05:46.320 --> 05:52.160
add some features. I want to be able to mark the books as read or not. And maybe I want to reorder

05:52.160 --> 05:59.840
them depending on if one starts to seem more exciting. And so now I have about 400 lines.

05:59.840 --> 06:05.360
And I think a lot of folks at this point would be like, like something's wrong. There's a problem.

06:06.160 --> 06:12.320
That's generally not, that's not how I would approach programming in Elm. It's not how things

06:12.320 --> 06:17.520
work in Standard and Mellor or Camel or Haskell. It's just like having a file this long is pretty

06:17.520 --> 06:24.880
standard. So if I go through the compiler, like that's, I'd say the average. And so maybe add

06:24.880 --> 06:29.600
some more features. I can add annotations to each book of quotes that I really like.

06:30.560 --> 06:36.880
Things I want to remember. So now I have like 600 lines of code. And it's like, okay, now it's

06:36.880 --> 06:43.440
surely it's a problem. Not really. I don't know. I think you shouldn't be too scared of a file

06:43.440 --> 06:47.680
growing long. So this is something that will typically happen. Now, at this point, it's likely

06:47.680 --> 06:52.720
that I'll say, you know what, I think it'd be good to have the data structure for like my library

06:52.720 --> 06:58.640
where I can reorder books and a data structure for books. Where is it read or not? What are my notes?

06:59.600 --> 07:05.520
And then I can start to organize my code around those two data structures. So I can say, okay,

07:05.520 --> 07:10.720
mark this book as red, add this note. And so the functions in my code start to organize around

07:10.720 --> 07:18.480
those data structures. So, hey, we discovered this better data structure. So the next step that

07:18.480 --> 07:25.520
may happen is we split around the data structure, right? So once we discover that there's this other

07:25.760 --> 07:33.040
like chunk that we can grab onto, that can become the heart of a nice module. And so this is the

07:33.040 --> 07:38.800
typical process that I always follow. It's just basically grow until I find a data structure

07:38.800 --> 07:46.800
that I can split on. And if I don't find it, it's fine. So I'd encourage folks to sort of

07:46.800 --> 07:52.000
play with this in your own code. And sort of if you're feeling uncomfortable, like, oh, this seems

07:52.080 --> 07:57.600
like I have too much code here, just like push into that feeling and like see if it actually

07:58.480 --> 08:02.880
is warranted. Like, is there actually a problem? Or is it just like a feeling that you have based

08:02.880 --> 08:08.800
on experiences in other languages? So, okay. So at this point, this is basically just like

08:08.800 --> 08:15.440
an unsubstantiated claim. Let's see some more concrete examples, right? Ones where the code

08:15.440 --> 08:26.480
is more elaborate than lines. So, okay. So I want to look at two examples. One is

08:27.600 --> 08:31.040
the sort of settings. So you can imagine this is like the settings you'd have in

08:32.160 --> 08:36.400
a Facebook or Twitter or Pinterest or whatever. Like, do you get email notifications? Do you

08:36.400 --> 08:43.760
want video audio play? Do you want to use location? These kinds of things. And you could just say no,

08:43.760 --> 08:51.120
but they want to give you the option to say no. The other situation is checkbox is a bunch of

08:51.120 --> 08:56.880
fruits. Maybe I'm going to, you're going to get lunch and you are able to pick out which fruits

08:56.880 --> 09:01.440
you want, then you can have that one. So before we dig into this, I want to sort of take a second

09:01.440 --> 09:08.880
to and ask people, like, what are the questions and concerns when you see these two that pop into

09:08.880 --> 09:12.960
your mind? Like, when you think about how the code is probably going to look, what pops into your

09:12.960 --> 09:32.960
mind? Okay. Yeah. Someone said, oh, oh. Okay. Okay. Okay. We're good. We're good. Someone said generic

09:32.960 --> 09:39.120
checkbox list. So yeah, this idea of like, how do we share? Like, clearly we have checkboxes here.

09:39.120 --> 09:48.480
Like, sharing needs to happen. Okay. This, I'm going to proceed by showing how I would address

09:48.480 --> 09:54.640
these and then we'll see if that intuition plays out. So when I look at the settings, the first

09:54.640 --> 10:01.040
question I ask is, how do I model this information? Right? So do I use a record where I say there's

10:01.040 --> 10:08.160
email, there's video, there's location? Do I use a list of pairs where the string would be email

10:08.160 --> 10:17.040
and notifications true? Autoplay false? A location false? Do I choose a dictionary? Which would work

10:17.040 --> 10:23.760
similarly? But now it's unique on these things. Or do I do this other one that's, I have a list of

10:23.760 --> 10:28.640
strings. These are all options. So email, autoplay location, and then a set of which ones are selected.

10:28.640 --> 10:36.560
So this would just be email. And we can think of more. It's a good idea to get in the habit of

10:36.560 --> 10:41.680
just thinking, what are all the possible ways I can represent this? So at this point, you want to

10:41.680 --> 10:49.600
say, okay, well, which one should I do? So one trade-off here is this one gives us the benefit

10:49.600 --> 10:56.000
of types, right? So if we're messing around in our code and someone misspells email or misspells

10:56.000 --> 11:00.160
one of these things, the compiler is going to give us some help. So that's nice. And these other ones

11:00.480 --> 11:06.240
are stringly typed. So if there's some misspelling, it's sorry. Like, things are going to go weird.

11:08.160 --> 11:15.040
Another thing to think about is the order in this one is just determined by the view. So in my model,

11:15.040 --> 11:20.000
in my record, I can update however I want. It can appear however I want it to appear in my code.

11:20.000 --> 11:24.640
But ultimately in the view, I'm going to say, show the email, show the notification, show this. And

11:24.640 --> 11:30.720
if our designer says, okay, we actually want to move, use location above because everyone wants

11:30.720 --> 11:34.640
to turn that off and no one can find it, we get a lot of support tickets and they're really mad at

11:34.640 --> 11:42.640
us. So I get that. Just change it. And then it becomes very easy in this world. With this one,

11:42.640 --> 11:50.560
the order is stable, but you can actually change it in the update. So in the same time we're

11:50.560 --> 11:55.600
upping a bool from true to false, we could just swap, reverse the list. And so suddenly the UI

11:55.600 --> 12:00.080
is totally different based on stuff that's happening in the update code. So someone writing

12:00.080 --> 12:04.400
update code has to think about what was it that that designer said a while ago about support tickets.

12:06.720 --> 12:14.080
This one, order is dependent on the keys. It's just like not a good idea. And this one,

12:14.080 --> 12:19.760
the order is stable again. So it seems like we've got a pretty clear winner in this case. So let's

12:20.640 --> 12:36.080
run with this. So here's the initial version of it. We can check stuff. And we can, this is kind of

12:36.080 --> 12:47.600
small. But we can see people messing with the record. Oops. Okay. So when we look at the code,

12:47.600 --> 12:55.280
can people see this okay? Okay. The model is what we talked about. We have the record with our

12:55.280 --> 13:00.640
boolean fields. And the defaults, you know, everything needs to be true, right? We need

13:01.200 --> 13:08.320
autoplay to get that ad money. We need location on so that it can be location-specific advertising.

13:08.320 --> 13:13.120
Okay. I notice you're in the neighborhood of, and we need the email so that they can notify you

13:13.120 --> 13:22.160
to log in and see the autoplay has. And then in our update, things are relatively straightforward.

13:24.000 --> 13:30.720
We have a way to toggle each of these things. And if I mess up and say I want the model's

13:30.960 --> 13:40.640
email, it's like, hey, I think you have a typo. So we're getting that benefit that we wanted.

13:43.680 --> 13:50.960
And finally, we have a view. So we have a field set. There's labels. And each one contains a

13:50.960 --> 13:58.400
checkbox that we say, okay, here's the email notifications one. Is it checked? Here's the

13:58.400 --> 14:05.120
autoplay. Is it checked? Et cetera. Now, one of the things that you can do is say, okay,

14:05.120 --> 14:09.200
these actually are pretty much exactly the same. So we can factor out some of this code.

14:10.240 --> 14:22.640
So I can say view checkbox. I don't know if it makes sense to start with the type,

14:22.640 --> 14:34.480
but I practiced this so I know what it is. But we can essentially chop out this code,

14:34.480 --> 14:45.520
which appears a bunch of times, and fill in the blanks. So checked is checked. Message,

14:46.400 --> 14:55.840
description, and then where did my mouse go? Okay, there it is. And then we can say let's just

14:55.840 --> 15:09.680
replace all of these with the checkbox. Okay, so is it code shorter? Not really.

15:10.640 --> 15:16.880
But if we are applying styles to all of these in the same way, now it's a lot

15:16.880 --> 15:20.480
easier. We can do it in one place and be sure that it happens everywhere. So this is a nice

15:20.480 --> 15:28.560
refactor given the current state of affairs. So let's see if I did it right. Yeah, okay, cool.

15:30.640 --> 15:35.200
So we come back, we have this going. It's nice. And so we get a new feature,

15:36.080 --> 15:41.520
which is autoplay customizations. So instead of just autoplay, we want people to be able to use

15:41.520 --> 15:49.760
should it play audio by default? And should it play on Wi-Fi only or will people allow it on

15:49.760 --> 15:56.640
cellular data as well? So when we go back, the thing to look at is our model again. So one way

15:56.640 --> 16:04.800
to deal with this is, well, okay, we have two new things. So we have autoplay audio and autoplay

16:07.520 --> 16:16.080
Wi-Fi. I'm going to call it without Wi-Fi. I don't know because it helps me understand

16:16.080 --> 16:22.240
what the bull would be. And then we can go mess with our view. But this is kind of lame because

16:22.800 --> 16:30.000
we can do it that way and a designer will say, well, I want it to be where if there's no video

16:30.000 --> 16:34.560
autoplay, then you can't mess with the autoplay settings. Like you're not doing that. So those

16:34.560 --> 16:40.000
should be disabled. So suddenly we have this interaction between these three fields where

16:41.920 --> 16:46.640
we always have to check autoplay before we show this and that determines whether it's disabled.

16:46.640 --> 16:51.680
So we're starting to get these dependencies. So a better way to represent this would be

16:52.400 --> 17:02.160
to just actually model it directly. So autoplay is offer on. And if it's on, there's audio

17:03.120 --> 17:19.760
or without Wi-Fi. So in this version of reality, you can't mess with any of these options without

17:19.760 --> 17:25.360
pattern matching on or off. So if you want to change them, you have to say, okay, let me expand

17:25.440 --> 17:31.760
the autoplay. If it's off, oh, I don't need to deal with it. And that also means in your view,

17:32.640 --> 17:36.640
you handle these two scenarios and you say, okay, is autoplay on? In which case, I can show these

17:36.640 --> 17:42.720
things. If it's off, then I don't. So it's sort of forcing any future user of this code base

17:42.720 --> 17:50.160
to understand that there's a dependency between these fields. Now we say, okay, we'll show this to

17:50.160 --> 17:57.520
the designer again. But the thing is, if we turn things off, we lose all of our options. So we want

17:57.520 --> 18:06.000
those to be preserved. Some users will toggle this a lot and it's annoying. So what we can do is say,

18:06.000 --> 18:18.320
okay, type alias autoplay settings. And then we can actually just have it on both,

18:18.320 --> 18:23.040
but still force people to go through the on off check before you're doing any logic.

18:25.200 --> 18:28.400
So and then this will play out throughout the course of the code. We can

18:34.240 --> 18:39.280
a way to approach this was, well, now we have this autoplay idea. Maybe we can start to write

18:39.280 --> 18:44.880
some helper functions to make it nice to work with. So maybe we can say toggle autoplay and it

18:44.960 --> 18:49.680
switches between on and off in a nice way. And so as we create these helper functions, we start to

18:49.680 --> 18:54.960
have functions that are all built around the data structure, which is that pattern I was talking about.

18:54.960 --> 19:00.000
So once you start to see these kinds of chunks of code, you get these units that can break out and

19:00.000 --> 19:10.320
make your code nicer. Okay. So we have that going. So now we come to fruits. And at this point,

19:10.320 --> 19:13.200
the question asked yourself is like, do you think it's going to work out the same way?

19:15.840 --> 19:21.120
So yeah, so let's take a look. So again, we can choose between different data structures and

19:21.760 --> 19:28.240
I picked the same ones. So record, list of things, dictionary, the list of options and which ones

19:28.240 --> 19:37.440
are selected. So in this case, our constraints are very different. So we work at like fruits.com,

19:37.440 --> 19:43.920
I don't know. And the fruit availability, it's seasonal. We want to bring you the freshest

19:43.920 --> 19:50.320
seasonal fruits for your region. And like maybe we're out of bananas today. So we don't want to

19:50.320 --> 19:55.200
just let people say, oh, I definitely only want bananas. I'm sorry. Here's a mango.

19:58.160 --> 20:04.800
So if we use a record, does that mean we would have to ship code every time availability changed

20:04.800 --> 20:11.760
in a particular region? So that doesn't seem great. But in all these others, we can just load

20:11.760 --> 20:18.800
the options from the server. That seems like a benefit. From there, one thing we might consider

20:18.800 --> 20:23.440
is, well, which of these will be easier to just use? Which one will the code come out nicer?

20:23.440 --> 20:28.320
So in this case, we'll probably use list.map to do an update. We can scan through and say,

20:28.400 --> 20:35.280
if it's this fruit, then I'll toggle it or not. With dictionary, you can use update and say,

20:35.280 --> 20:43.120
okay, I want to change this particular fruit. And with this one, we can use set, insert and

20:43.120 --> 20:47.520
remove. So we don't have to ever mess with this. We can just say, okay, they want to add this to

20:47.520 --> 20:54.320
their set of their selected set, and they want to remove that one. And again, we have the ordering

20:54.320 --> 21:03.600
problems from before where maybe our head of fruit marketing is like, we need to put bananas up at

21:03.600 --> 21:12.160
the top because that's higher margin, and that's what we're all about here at fruits.com. Or maybe

21:12.160 --> 21:16.880
someone else is like, well, we really should put mangoes up at the top, think about the nutritional

21:16.880 --> 21:24.000
content, think about the bottom line. So there might be some need to change this around.

21:24.320 --> 21:28.560
Perhaps dynamically. So again, dictionary isn't ideal for that kind of scenario.

21:30.000 --> 21:38.400
So let's go with this one where it'll be kind of nice to add and remove things to the selection,

21:38.400 --> 21:45.920
and we can mess with the order quite easily. Okay, so now we can go look at our fruit situation.

21:46.000 --> 21:56.240
Which, and then we can just select, it's great. And if we look at how this goes,

21:59.120 --> 22:07.040
we have our fruit list, which is very stable, and then selected, which is changing as we mess with

22:07.040 --> 22:23.440
stuff. Okay, so let's check out how this code works. Fruits. Okay, so in our model we say

22:24.240 --> 22:29.920
we have two things, the fruits that are available, and the ones that are selected. And for our

22:29.920 --> 22:35.840
initial model, we're just pre-populating with some fruits, but you could load this from the server.

22:36.800 --> 22:46.240
And our selected set is none are selected. And then update logic, appreciate forward. If a fruit

22:46.240 --> 22:50.960
is selected, add it to the selected set. If it's deselected, remove it from the selected set.

22:52.640 --> 23:00.400
And then is this going to fit? Okay, cool. So in our view code, we again have a field set.

23:01.040 --> 23:08.320
Okay, you can see the mouse here. We have our field set, and then we're mapping over all the

23:08.320 --> 23:16.160
fruits. And so when we do that, we say, okay, I have a fruit. Is it in the selected fruit set?

23:16.160 --> 23:22.480
If so, it's checked. And then we draw things in a way that looks quite similar to what we saw

23:22.480 --> 23:28.000
in the previous example. So it's checkbox, whether it's checked or not, what the title is.

23:30.560 --> 23:35.840
But the thing that's actually interesting about this code isn't the shared part. The part that

23:35.840 --> 23:42.480
they have in common is, like, whatever, seven lines. It's not very crazy. And the chances that

23:42.480 --> 23:47.120
they're going to stay exactly the same between these two different chunks of code is very low.

23:47.120 --> 23:52.640
So thinking, like, focusing on just this, like, oh, I've seen a checkbox before somewhere.

23:53.840 --> 23:57.760
Like, doesn't really give you a lot in terms of the structure of your program.

23:57.840 --> 24:04.000
So at this point, we have a pretty good fruit set going on, fruit.com, business is booming,

24:04.800 --> 24:12.320
margins are good. Okay, but a new feature comes along, which is only two fruits can be selected.

24:12.320 --> 24:16.240
We have all these folks out there who want, like, three fruits, six fruits even.

24:17.840 --> 24:20.560
We don't have the distribution channels for that.

24:21.120 --> 24:28.800
So we want to cap out at two fruits per person, you know, pick a favorite, like, pick a side.

24:31.360 --> 24:38.800
So this is kind of a tricky situation we have found ourselves in. So we have this set,

24:38.800 --> 24:45.280
and we kind of need to limit the size somehow. Oh, oh, there's one other constraint, which is

24:45.280 --> 24:54.560
we need to check out a different fruit. No. Fruit's one, maybe. No.

24:58.880 --> 25:01.360
Okay, I deleted a file that I should not have deleted.

25:04.160 --> 25:10.480
But the thing that I wanted to show was we want to maintain the order that they were selected.

25:10.480 --> 25:15.520
So if I select apple, then apricot, then banana, I want the oldest thing to be the one that's

25:15.520 --> 25:20.400
forgotten. So I want to keep the most recently selected as I go through things.

25:23.760 --> 25:29.120
So with a set, it's really hard to keep track of what was the order that things were added. We

25:29.120 --> 25:33.280
can remove one of the things, but we don't know which of the two it was. You'll get this very

25:33.280 --> 25:41.280
wonky behavior. So at this point, we can ask, well, maybe it'd be good to think about the

25:41.280 --> 25:46.160
data structure we're using. So we want to choose two fruits in particular. So maybe we say, okay,

25:46.160 --> 25:52.640
so I'm going to choose a string and a string. But what happens when nothing's selected? We

25:52.640 --> 25:56.720
need to account for zero selections, one selection, two selections. So that's no good.

25:57.440 --> 25:59.200
Maybe we can say maybe string.

26:02.720 --> 26:08.400
So all of these can be optionally selected. But there's this weird case where if one thing is

26:08.400 --> 26:14.080
selected, we don't know if it's going to be the left or the right thing. So this doesn't seem great

26:14.080 --> 26:23.840
either. So maybe we can say, okay, there should be this type two, and it's either zero or one

26:24.560 --> 26:31.360
or two. Okay, that's pretty nice. You can imagine inserting into zero, you go to one,

26:31.360 --> 26:36.560
inserting into two, and then in two, you maintain some order moving things along.

26:38.080 --> 26:42.640
And that design seems okay, but we know head of fruits marketing.

26:44.000 --> 26:47.280
He's going to say, okay, well, in tropical areas, we can actually give them more fruits,

26:47.280 --> 26:52.640
so they're going to want a limit of three. But in Iceland, they only get half cucumbers there.

26:52.640 --> 26:54.960
That's just the rule. I don't know. That is actually how it works.

26:57.680 --> 27:01.600
So we're probably not going to be able to just stick with two. There may be some

27:01.600 --> 27:05.920
places where we need three or different limits. So another way we could do this is just a list

27:06.560 --> 27:12.160
of string and then limit the size. So essentially add to the front and take things,

27:12.160 --> 27:19.200
drop things off the back. So I don't know. It doesn't seem perfect. Clearly, you can just add

27:19.200 --> 27:25.120
20 things to it. But it sort of has potential. So let's explore that route.

27:28.080 --> 27:32.960
So instead of this being empty, this is an empty list. Oops.

27:36.640 --> 27:42.320
The cursor just disappears. Anyway, so when we select something, we want to say

27:42.800 --> 27:53.520
list.take2 fruit on the front of our selected list. So this is saying, put the fruit on the

27:53.520 --> 27:56.880
front and then just take the front two. So whatever else is there, we'll drop it.

27:59.840 --> 28:08.640
And then when we deselect, we can say list.filter. The fruit should not, any fruit,

28:08.640 --> 28:15.120
that's not the one we, that's a lot of nots in one sentence. We want to only keep fruits.

28:17.760 --> 28:21.680
You get it. We want that fruit to be deselected.

28:24.480 --> 28:33.680
And then in our checkbox code, we want to say and said list.member. And I think that's everything

28:34.240 --> 28:40.720
except we don't need that anymore. Okay. So let's see if I did this right.

28:43.920 --> 28:49.040
Hey. And so you can see it's maintaining the order that I clicked things. So if I,

28:51.440 --> 28:55.360
I don't know, it's kind of hard to remember. It's easy if you go in order and you can see.

28:55.360 --> 29:01.520
It's working nicely. Okay. So we're maintaining our two fruits per person situation. But when

29:01.520 --> 29:09.520
we come look back at our update code, it's getting, it feels like trickier, right? And as we grow

29:09.520 --> 29:19.920
fruits.com, like maybe someone won't realize the take two is not, oh, just some fine choice. It's

29:19.920 --> 29:24.560
like, head of fruits marketing decided that was two and you can't change that stuff. So we want

29:24.560 --> 29:30.400
to have some more security around this code. So one way we can do that is to start to break out

29:32.480 --> 29:39.440
the particular stuff around that data structure. So we, we know there's this selection list.

29:39.440 --> 29:41.520
We can make a function that is

29:41.600 --> 29:56.880
along these lines. So let's do it in the update part. Insert, oops, insert fruit list.

30:02.240 --> 30:05.120
I'm going to leave off types for now just for speed.

30:06.080 --> 30:16.240
And then I can say here, insert fruit. And then I can also say remove fruit from the list.

30:17.440 --> 30:18.640
And we'll do it the same way.

30:26.720 --> 30:30.800
So this code gets a bunch simpler as well. Remove fruit.

30:31.760 --> 30:38.800
And we can do the same thing with the checking for membership below. Now at this point it's sort

30:38.800 --> 30:44.720
of coalescing into, oh, there's this kind of data structure that's specifically about maintaining

30:44.720 --> 30:51.200
just two things in, in the list. So I'm going to check for time to see how much live coding I should

30:51.200 --> 31:00.400
do. Okay. Well, let's, let's start to follow this idea of like, we're starting to recognize

31:00.400 --> 31:06.560
a data structure. So let's try to break that out. So I can say fruit list.

31:09.680 --> 31:14.080
And I have this type alias fruit, selected fruit.

31:14.640 --> 31:25.280
So we're starting to see the, the beginnings of a, of a module, like things that we can

31:26.400 --> 31:32.000
box off and put in their own place. So I'm going to just skip ahead to a version of this

31:32.000 --> 31:37.840
in a different module. So the ideas, we have this thing called a bounded set.

31:38.560 --> 31:42.960
And yeah, no, I shouldn't skip ahead to this. That was a bad idea.

31:46.000 --> 31:49.200
So let's say, okay, we have this and we were going to put it in a new module,

31:49.200 --> 31:56.160
the selected fruit module. Exposing

31:56.160 --> 32:11.680
a selected fruit. And then in our fruits module, we can get rid of that. And we can import

32:16.880 --> 32:20.080
as selected fruits. And then

32:20.400 --> 32:31.280
we just have to go through and make a couple changes here. Oh, we'll come back to that.

32:35.120 --> 32:42.400
Selected fruit, that insert, remove, et cetera. So this is also selected fruit.

32:43.680 --> 32:48.400
We're kind of leaking details here. Okay. Let's see it. Okay. Check. Does this work? No.

32:49.200 --> 32:54.240
Selected fruits. It's singular.

33:04.320 --> 33:11.600
There's also a stray print. Spelling.

33:18.880 --> 33:21.680
It's nice that, yeah. Oh, geez. What the heck?

33:26.320 --> 33:41.760
Okay. Just imagine there wasn't a compiler there. Or just like, maybe that's wrong. I don't know.

33:42.720 --> 33:48.880
Okay. So this is still working. But we can kind of improve things by sort of closing down this

33:48.880 --> 33:54.080
module. Right now, we're exposing everything. But we could do better by saying, okay, from the

33:54.080 --> 34:02.000
outside, no one knows how selected fruit is implemented. It happens to be a list of string,

34:02.080 --> 34:13.440
but no one needs to know. So we have to do a little bit of selected.

34:15.840 --> 34:19.200
I'm disenchanted with this naming choice.

34:19.200 --> 34:32.240
Okay. So now, from the outside, no one knows how the particulars of this are implemented.

34:32.800 --> 34:35.120
So let's just run it. This is supposed to not work.

34:38.480 --> 34:43.840
So we're using list.member on a selected fruit, but we don't actually know the

34:43.920 --> 34:50.240
implementation deals of that anymore. And our selected, we're saying it's a list,

34:50.240 --> 34:55.440
but we don't have access to that information anymore. So we need to add, how do I make an

34:55.440 --> 35:07.680
empty selected fruit? And that would be selected fruit is empty. And then we need to test for membership.

35:14.720 --> 35:21.040
And then we can just say list member fruit list.

35:24.880 --> 35:27.680
Oh, it's still broken because they didn't actually change the broken code.

35:29.680 --> 35:35.920
So here we say selected fruit is empty. And then member, we say selected fruit member.

35:36.560 --> 35:46.720
Cool. So now we've sort of hidden all these implementation details, but we can do slightly

35:46.720 --> 35:54.560
better. So maybe we want to make a guarantee about the size in this data structure. So we can say

35:54.560 --> 35:58.640
we'll actually give the maximum size when we say it's empty or not.

35:58.880 --> 36:10.080
And then in all these cases, max size. So instead of taking two, we take the max size.

36:14.080 --> 36:21.280
And instead of removing, no, we do keep this the same, but we just have to keep the max size

36:21.280 --> 36:25.440
around. And then here we don't care about the max size. We just want to check.

36:26.720 --> 36:32.400
So we should have an error because we're just calling empty without saying how big it should be.

36:36.480 --> 36:42.880
Two. All right. And then things should work again. Cool.

36:45.280 --> 36:50.480
So at this point, we sort of taken all this complexity around maintaining the only two

36:50.480 --> 36:55.520
things are selected and put it in its own module. So the benefits of this is that when I'm reading

36:55.520 --> 37:02.320
through my normal code, all I know is there's some way to select fruits. I can say how many.

37:03.200 --> 37:08.320
And then I can insert and remove. And these things will just work out nicely. And I can check if

37:08.320 --> 37:14.960
something is a member of that. So you can go one level crazier with this, which we shouldn't get

37:14.960 --> 37:21.120
into, but you can. So the idea was you could generalize it so that it's a list of anything,

37:21.120 --> 37:26.080
not of strings or particular fruits. And then everything works the same, right? You choose

37:26.080 --> 37:31.200
the size. You can insert things into it. You can remove things from it. You can check membership.

37:31.760 --> 37:37.920
So all of these designs are possible. And the question is, which one is right for your situation,

37:37.920 --> 37:42.080
right? Should you go like, all right, I'm writing my own data structure that's generic in all

37:42.080 --> 37:46.880
sorts of things. And I'm going to optimize it. Or is it like, look, it's just a list. It's not a

37:46.880 --> 37:51.280
big deal. We're probably not going to get it wrong. And so that depends on what's likely to happen.

37:51.840 --> 37:58.320
Maybe at fruits.com, you'd make one choice. But at the new fruit stand startup, I don't know,

37:58.320 --> 38:08.160
they want to make different choices. Okay. So the big lesson here is that we started with two things

38:08.160 --> 38:13.600
that look basically the same and ended up with entirely different ways of approaching them.

38:13.600 --> 38:18.080
That was all about the data structure, right? And it is true that they share checkboxes, but that's

38:18.080 --> 38:23.120
such a small fraction of the actual difficult things that are going to happen in your code

38:23.120 --> 38:30.560
that it makes sense to emphasize the data structure instead. So I want to put a little extra emphasis

38:30.560 --> 38:38.640
on the module, right? So I showed this bounded set idea and it had, there's a bounded set.

38:39.440 --> 38:44.800
If it's empty, you can insert things into it. You can remove things from it. You can check

38:44.800 --> 38:52.080
membership. Now, the most important part of this module is the exposing line. Okay. So I'm not

38:52.080 --> 38:56.800
exposing everything in this module. And specifically, I'm not exposing the implementation of bounded

38:56.800 --> 39:03.520
set. So no one from outside can mess with the maximum size. And as long as these functions work,

39:04.240 --> 39:09.520
things are going to work. So I want to point out two little benefits that come from this.

39:09.520 --> 39:16.960
So if you reduce the public API to your module, if the implementation is hidden and if the public

39:16.960 --> 39:24.480
API works, the code works everywhere, right? So if I try to break this code by messing with

39:24.560 --> 39:31.440
these functions and I can't do it, anyone else who uses this code won't be able to do it either.

39:32.400 --> 39:36.960
So this is actually really nice for testing because it means you can test the public API

39:36.960 --> 39:41.280
very extensively. And that doesn't mean you have to test every particular usage, right? Using

39:41.840 --> 39:45.520
this data structure somewhere doesn't mean I can introduce bugs into that data structure

39:45.520 --> 39:50.480
retroactively. If it works, it's going to work well. The other thing that's nice is you get

39:50.560 --> 39:56.880
it easier refactoring. So I can change how things are implemented without worrying what's

39:56.880 --> 40:02.080
going to happen outside. And this happens in a couple ways. One is say there's an insert help

40:02.080 --> 40:08.880
function that's doing some extra special stuff. I know that it's not exposed outside, so I can

40:08.880 --> 40:14.800
mess with that. Arguments, add arguments, change shuffle things around and be sure that this is

40:14.800 --> 40:18.720
not going to have any effect in any other modules. I'm not going to have to go hunt stuff down.

40:19.360 --> 40:24.320
That's also nice because it means I don't have to worry about if it's used in 10 different

40:24.320 --> 40:30.000
places across the code, did they need it to work in a very particular way in each of those cases?

40:30.000 --> 40:34.880
And I'm covering all those cases. I can just say, oh, it's not publicly exposed. If it works in

40:34.880 --> 40:43.360
this file, it works. So the other thing that you can do by creating modules in this way is maintain

40:43.360 --> 40:49.280
invariance. So in our case, that's only two fruits. But generally speaking, this means there are

40:49.280 --> 40:54.960
rules that cannot be enforced entirely through data structure design. So we had our two, which is

40:54.960 --> 41:00.720
zero, one or two, but that wouldn't let us decide how many we want. So we now have a data structure

41:00.720 --> 41:06.720
that can let us decide. And by hiding all the details, we can still maintain that rule in a

41:06.720 --> 41:11.600
safe way, even though we can't do it purely through data. And one cool thing about finding

41:11.600 --> 41:17.680
invariance like this is that they're excellent for fuzz tests. So I know that whatever I do with

41:17.680 --> 41:23.200
this, if I say my bounded set has two things, no matter how many times I call insert, it should

41:23.200 --> 41:29.280
just have two things. So by thinking in this way, you also set yourself up to write tests that

41:29.280 --> 41:35.600
are nice and are checking the kinds of things you're worried about. So I want to add some warnings

41:36.160 --> 41:43.840
to this advice. So first, if you find yourself writing get and set, right, so we hid the max

41:43.840 --> 41:48.560
size, but maybe someone's like, well, I want the max size. I won't do a bad thing with it.

41:50.480 --> 41:55.280
Okay, this is a bad sign. This is a bad sign when you have get and set. So the whole point of having

41:55.280 --> 42:00.720
a module was that we were able to hide implementation details and say, if you use this public API,

42:00.720 --> 42:04.720
it will work. And inside, you don't have to worry about that. We tested it. We know it's good.

42:05.840 --> 42:14.000
Setters, their whole point is to expose those details. So you've done all this work to put

42:14.000 --> 42:18.080
it in a module, and we went through that together. It was like, it took too long.

42:22.800 --> 42:29.360
And now you're going to give setters that just totally defeat that entire exercise. So just use

42:29.360 --> 42:34.000
a record if you have data where you want people to have access, rather than hiding the details,

42:34.000 --> 42:40.000
then exposing get and setters. It's like, these details aren't hidden. So don't do the work to

42:40.000 --> 42:46.240
hide them. So another way to say this is expose as little as possible, but no less. Some things

42:46.240 --> 42:51.440
do need to be publicly available. So this shouldn't just be like, hide everything. That's better.

42:53.040 --> 42:59.680
The other thing is don't overdo it. So I'd wait until I have a problem in practice,

42:59.680 --> 43:04.720
and then solve that problem. So the goal shouldn't be let's just write modules, because modules help

43:04.720 --> 43:10.160
with this kind of stuff. It should be, hey, I'm having trouble understanding this code. I came

43:10.160 --> 43:14.960
back to it after a month, and it seemed kind of confusing. Maybe I can find parts that I can

43:16.080 --> 43:23.040
make things nicer. So if you find yourself asking, how do I make the sidebar reusable? Okay, try to

43:23.120 --> 43:30.720
remember to ask yourself why. Are you going to have multiple sidebars? Maybe not. In which case,

43:30.720 --> 43:36.640
like, why would you do the work to do that? If you are going to have multiple ones, a thing to

43:36.640 --> 43:43.120
think is, are these cases the same, or are they similar? If we're just talking about the HTML

43:43.120 --> 43:47.120
is going to look similar, but how it works behind the scenes is fundamentally different in both cases.

43:47.920 --> 43:53.920
I think it's probably not a good idea to, like, try to get all into how do we share code between

43:53.920 --> 43:59.600
these two. Focus on the data structure instead. Another thing that might happen is as you're

43:59.600 --> 44:04.560
growing your record, you don't have any interesting types. You don't have that autoplay thing where

44:04.560 --> 44:09.120
these fields are dependent on that field. It's just a bunch of independent stuff.

44:09.360 --> 44:17.520
If they're all independent, there's no problem. If I just have fields that have no relationship

44:17.520 --> 44:23.040
to each other, and I change one, there's not a chance that there's some bug elsewhere. But if I

44:23.040 --> 44:27.600
do have that relationship, that's a potential to start finding a data structure and do better

44:27.600 --> 44:33.360
modeling. So I'd say, like, don't be afraid to just grow your record and try to find these

44:34.240 --> 44:40.320
connections and how things fit together, as opposed to preemptively, like, ah, I'm worried

44:40.320 --> 44:47.280
about this code, so I'm just going to change it. So, yeah, just as there's premature optimization,

44:47.280 --> 44:53.200
there's premature refactoring. It's a thing, it's fun, right? It's like you get to play

44:53.200 --> 45:01.760
code golf at work. I don't think employers should encourage that, but people like to do it.

45:03.520 --> 45:14.160
Okay, so to take a step back, we saw how a file tends to grow, right? And if we focus on

45:14.160 --> 45:19.120
the data structures, we end up with these nice categorizations where, like, when I'm searching

45:19.200 --> 45:24.000
through a code base even, I say, hey, where's that stuff that's related to books? It's probably in

45:24.000 --> 45:30.000
the module about books, right? As opposed to, well, there's this update subdirectory, and all the

45:30.000 --> 45:37.440
update code is there, and the book stuff is just like, it's related to books. So, yeah, so big

45:37.440 --> 45:41.840
lessons are focus on data structures and choose the best representation available. So, like,

45:41.840 --> 45:46.800
actually think through as many cases as you can, and the others build modules around types

45:47.360 --> 45:57.200
and try to expose as little as possible, but no less. So, yeah, so I hope this will be a nice

45:57.200 --> 46:05.760
next advice in the, how do I grow my Elm code? And one of my goals was to write this up. So,

46:05.760 --> 46:12.880
I actually started a book that is about functional programming in Elm, and the goal of this book

46:12.880 --> 46:16.720
was essentially to write this talk so that people could read it online and it would work out.

46:17.440 --> 46:23.360
It turns out it's very hard to write that whole live coding section. So, instead, what I ended

46:23.360 --> 46:30.000
up with is some nice stuff about recursion and graphs. It's fun. Hopefully, I'll be able to

46:30.000 --> 46:34.960
distill this down into another chapter that actually emphasizes these things in a way where you

46:34.960 --> 46:52.000
don't have to see the live talk. But, yeah, so that's the life of a file. Thank you.

