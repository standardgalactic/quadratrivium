1
00:00:00,000 --> 00:00:08,440
Welcome, everyone. I want to start just saying thanks, everyone, for coming. This is kind

2
00:00:08,440 --> 00:00:18,080
of crazy. I'm Evan. I made Elm. It's very exciting to be here. So I want to say thanks

3
00:00:18,080 --> 00:00:23,080
one, thanks for folks for coming, thanks to Thibaut and Guillaume for setting things up,

4
00:00:23,080 --> 00:00:29,280
and then thanks to everyone who is helping get the technology set up, and then this thank

5
00:00:29,280 --> 00:00:37,520
you is like outer proportion. So thank you to who had the L have this tail. I really

6
00:00:37,520 --> 00:00:46,920
appreciate that. But yeah, so thanks, everyone, for coming. And I want to emphasize sort of

7
00:00:46,920 --> 00:00:54,800
a question that has sort of guided Elm for the last couple of years, which is how do

8
00:00:54,800 --> 00:01:00,640
I grow Elm code? And so this is a question that somehow always sounds topical. So who

9
00:01:00,640 --> 00:01:06,320
remembers Elm before the Elm architecture? Before the Elm architecture? Okay, there

10
00:01:06,320 --> 00:01:10,160
are people out there. Okay. So there was a time when that didn't exist and people would

11
00:01:10,160 --> 00:01:14,960
say how do I write a program? And so we sort of observed, okay, maybe we can call this

12
00:01:14,960 --> 00:01:18,400
thing there's a model, there's an update of you. We saw that pattern, and they were like,

13
00:01:18,400 --> 00:01:24,280
okay, that's cool. How do I grow an Elm program? Okay. So we had some more examples.

14
00:01:24,680 --> 00:01:30,800
And showed it, okay, you can reuse functions in this kind of way to help make a view. And

15
00:01:30,800 --> 00:01:35,240
people were like, okay, cool. But how do you grow an Elm program? So I want to take the

16
00:01:35,240 --> 00:01:42,720
next step in perhaps a never ending journey. And we're going to do that by tracing the

17
00:01:42,720 --> 00:01:49,920
life of a file. So we'll see it start small and gradually grow, and then grow a bit more,

18
00:01:49,960 --> 00:01:56,280
and then eventually break off into two. And I think as we go through this path, it won't

19
00:01:56,280 --> 00:02:01,920
necessarily be surprising or difficult. But I think it's hard to see if you're coming

20
00:02:01,920 --> 00:02:07,240
from JavaScript. So before we get started with the life of a file, I want to start with

21
00:02:07,240 --> 00:02:14,400
some JavaScript folk knowledge that may be leading people astray. So one thing that I

22
00:02:14,480 --> 00:02:21,280
see a lot is this idea that shorter files are better. So an extreme example of this is when I

23
00:02:21,280 --> 00:02:28,960
was doing the benchmark comparison between React and a bunch of other frameworks in Elm,

24
00:02:29,840 --> 00:02:35,200
the Ember one just had so many files, I just didn't get it. This is a greater than file.

25
00:02:36,080 --> 00:02:43,360
And it just felt like this surely isn't the easiest way. So when I see this thought process,

26
00:02:43,400 --> 00:02:51,520
it sort of feels bizarre to me. And so the way I can understand it is the context is as the lines

27
00:02:51,520 --> 00:02:57,120
of code increases, the probability of sneaky mutation approaches one. It's going to happen if

28
00:02:57,120 --> 00:03:01,640
you're writing JavaScript code. So if you have a thousand lines of code, there's going to be some

29
00:03:01,640 --> 00:03:05,440
object that accidentally gets shared, and two people are going to be mutating it. It's just going

30
00:03:05,440 --> 00:03:15,760
to happen. So therefore, for shorter files, it fills this very useful function. Another thing that

31
00:03:15,760 --> 00:03:20,640
people just know in JavaScript is you have to get the architecture right from the beginning or

32
00:03:20,640 --> 00:03:27,200
you're doomed. It's just not going to work out for your project. This you barely need a justification

33
00:03:27,200 --> 00:03:33,920
because obviously I'm sure many of us have seen this play out in companies we either work for or

34
00:03:33,920 --> 00:03:42,560
people we know. And the justification behind it is refactoring is very risky. Sometimes it's cheaper

35
00:03:42,560 --> 00:03:47,760
to just rewrite the code. And I think that accounts for some of the churn in JavaScript

36
00:03:47,760 --> 00:03:52,720
frameworks. People like, well, this didn't work. I could try to fix it, but it'd be just as easy

37
00:03:52,720 --> 00:04:00,400
to try a different thing that maybe doesn't suck. So we have these sort of intuitions and habits

38
00:04:00,400 --> 00:04:06,800
that are grown out of the actual constraints of JavaScript and the languages we use. But in Elm,

39
00:04:07,600 --> 00:04:11,840
the probability of sneaking mutation is zero. If you have a thousand lines or 10,000 lines,

40
00:04:11,840 --> 00:04:17,040
it's just like not possible that a value gets shared and suddenly there's spooky action at

41
00:04:17,040 --> 00:04:23,760
a distance between these two chunks of code. So this whole premise is gone. And so I don't see

42
00:04:23,760 --> 00:04:30,880
how we can draw the same conclusion anymore. Similarly, refactoring is cheap and reliable.

43
00:04:30,880 --> 00:04:35,280
Like you have types to help you out. The compiler is going to guide you through the process. So

44
00:04:36,080 --> 00:04:41,040
you can end up changing 10 or 20 files and be pretty confident to end that things are fine.

45
00:04:41,680 --> 00:04:46,960
So again, this premise is gone. And so this idea that the architecture has to be right from the

46
00:04:46,960 --> 00:04:56,720
start doesn't really play out in practice. So the big thing to note here is that the way Elma's

47
00:04:56,720 --> 00:05:01,840
design changes how you should grow a code base. And we have a lot of habits that come from,

48
00:05:01,840 --> 00:05:05,600
like we don't even necessarily all know the justification of these things, but we know like,

49
00:05:05,600 --> 00:05:11,200
oh, that file seems too long. That's probably, like we have these senses that guide how we write code.

50
00:05:12,160 --> 00:05:16,880
So the rest of the talk is sort of challenging these and providing a new way of seeing code

51
00:05:17,440 --> 00:05:26,240
that can help grow a program. Okay. So the life of a file. We might start out with a nice little

52
00:05:26,240 --> 00:05:32,400
file. Let's say I, and the blue is like the model, let's say the data structure and then there's

53
00:05:32,400 --> 00:05:38,320
some logic. And maybe this is, I have a personal like reading list and I want to just keep track

54
00:05:38,400 --> 00:05:46,320
of the books that I'm interested in. And maybe I have 200 lines of code. I'm not crazy. And so I

55
00:05:46,320 --> 00:05:52,160
add some features. I want to be able to mark the books as read or not. And maybe I want to reorder

56
00:05:52,160 --> 00:05:59,840
them depending on if one starts to seem more exciting. And so now I have about 400 lines.

57
00:05:59,840 --> 00:06:05,360
And I think a lot of folks at this point would be like, like something's wrong. There's a problem.

58
00:06:06,160 --> 00:06:12,320
That's generally not, that's not how I would approach programming in Elm. It's not how things

59
00:06:12,320 --> 00:06:17,520
work in Standard and Mellor or Camel or Haskell. It's just like having a file this long is pretty

60
00:06:17,520 --> 00:06:24,880
standard. So if I go through the compiler, like that's, I'd say the average. And so maybe add

61
00:06:24,880 --> 00:06:29,600
some more features. I can add annotations to each book of quotes that I really like.

62
00:06:30,560 --> 00:06:36,880
Things I want to remember. So now I have like 600 lines of code. And it's like, okay, now it's

63
00:06:36,880 --> 00:06:43,440
surely it's a problem. Not really. I don't know. I think you shouldn't be too scared of a file

64
00:06:43,440 --> 00:06:47,680
growing long. So this is something that will typically happen. Now, at this point, it's likely

65
00:06:47,680 --> 00:06:52,720
that I'll say, you know what, I think it'd be good to have the data structure for like my library

66
00:06:52,720 --> 00:06:58,640
where I can reorder books and a data structure for books. Where is it read or not? What are my notes?

67
00:06:59,600 --> 00:07:05,520
And then I can start to organize my code around those two data structures. So I can say, okay,

68
00:07:05,520 --> 00:07:10,720
mark this book as red, add this note. And so the functions in my code start to organize around

69
00:07:10,720 --> 00:07:18,480
those data structures. So, hey, we discovered this better data structure. So the next step that

70
00:07:18,480 --> 00:07:25,520
may happen is we split around the data structure, right? So once we discover that there's this other

71
00:07:25,760 --> 00:07:33,040
like chunk that we can grab onto, that can become the heart of a nice module. And so this is the

72
00:07:33,040 --> 00:07:38,800
typical process that I always follow. It's just basically grow until I find a data structure

73
00:07:38,800 --> 00:07:46,800
that I can split on. And if I don't find it, it's fine. So I'd encourage folks to sort of

74
00:07:46,800 --> 00:07:52,000
play with this in your own code. And sort of if you're feeling uncomfortable, like, oh, this seems

75
00:07:52,080 --> 00:07:57,600
like I have too much code here, just like push into that feeling and like see if it actually

76
00:07:58,480 --> 00:08:02,880
is warranted. Like, is there actually a problem? Or is it just like a feeling that you have based

77
00:08:02,880 --> 00:08:08,800
on experiences in other languages? So, okay. So at this point, this is basically just like

78
00:08:08,800 --> 00:08:15,440
an unsubstantiated claim. Let's see some more concrete examples, right? Ones where the code

79
00:08:15,440 --> 00:08:26,480
is more elaborate than lines. So, okay. So I want to look at two examples. One is

80
00:08:27,600 --> 00:08:31,040
the sort of settings. So you can imagine this is like the settings you'd have in

81
00:08:32,160 --> 00:08:36,400
a Facebook or Twitter or Pinterest or whatever. Like, do you get email notifications? Do you

82
00:08:36,400 --> 00:08:43,760
want video audio play? Do you want to use location? These kinds of things. And you could just say no,

83
00:08:43,760 --> 00:08:51,120
but they want to give you the option to say no. The other situation is checkbox is a bunch of

84
00:08:51,120 --> 00:08:56,880
fruits. Maybe I'm going to, you're going to get lunch and you are able to pick out which fruits

85
00:08:56,880 --> 00:09:01,440
you want, then you can have that one. So before we dig into this, I want to sort of take a second

86
00:09:01,440 --> 00:09:08,880
to and ask people, like, what are the questions and concerns when you see these two that pop into

87
00:09:08,880 --> 00:09:12,960
your mind? Like, when you think about how the code is probably going to look, what pops into your

88
00:09:12,960 --> 00:09:32,960
mind? Okay. Yeah. Someone said, oh, oh. Okay. Okay. Okay. We're good. We're good. Someone said generic

89
00:09:32,960 --> 00:09:39,120
checkbox list. So yeah, this idea of like, how do we share? Like, clearly we have checkboxes here.

90
00:09:39,120 --> 00:09:48,480
Like, sharing needs to happen. Okay. This, I'm going to proceed by showing how I would address

91
00:09:48,480 --> 00:09:54,640
these and then we'll see if that intuition plays out. So when I look at the settings, the first

92
00:09:54,640 --> 00:10:01,040
question I ask is, how do I model this information? Right? So do I use a record where I say there's

93
00:10:01,040 --> 00:10:08,160
email, there's video, there's location? Do I use a list of pairs where the string would be email

94
00:10:08,160 --> 00:10:17,040
and notifications true? Autoplay false? A location false? Do I choose a dictionary? Which would work

95
00:10:17,040 --> 00:10:23,760
similarly? But now it's unique on these things. Or do I do this other one that's, I have a list of

96
00:10:23,760 --> 00:10:28,640
strings. These are all options. So email, autoplay location, and then a set of which ones are selected.

97
00:10:28,640 --> 00:10:36,560
So this would just be email. And we can think of more. It's a good idea to get in the habit of

98
00:10:36,560 --> 00:10:41,680
just thinking, what are all the possible ways I can represent this? So at this point, you want to

99
00:10:41,680 --> 00:10:49,600
say, okay, well, which one should I do? So one trade-off here is this one gives us the benefit

100
00:10:49,600 --> 00:10:56,000
of types, right? So if we're messing around in our code and someone misspells email or misspells

101
00:10:56,000 --> 00:11:00,160
one of these things, the compiler is going to give us some help. So that's nice. And these other ones

102
00:11:00,480 --> 00:11:06,240
are stringly typed. So if there's some misspelling, it's sorry. Like, things are going to go weird.

103
00:11:08,160 --> 00:11:15,040
Another thing to think about is the order in this one is just determined by the view. So in my model,

104
00:11:15,040 --> 00:11:20,000
in my record, I can update however I want. It can appear however I want it to appear in my code.

105
00:11:20,000 --> 00:11:24,640
But ultimately in the view, I'm going to say, show the email, show the notification, show this. And

106
00:11:24,640 --> 00:11:30,720
if our designer says, okay, we actually want to move, use location above because everyone wants

107
00:11:30,720 --> 00:11:34,640
to turn that off and no one can find it, we get a lot of support tickets and they're really mad at

108
00:11:34,640 --> 00:11:42,640
us. So I get that. Just change it. And then it becomes very easy in this world. With this one,

109
00:11:42,640 --> 00:11:50,560
the order is stable, but you can actually change it in the update. So in the same time we're

110
00:11:50,560 --> 00:11:55,600
upping a bool from true to false, we could just swap, reverse the list. And so suddenly the UI

111
00:11:55,600 --> 00:12:00,080
is totally different based on stuff that's happening in the update code. So someone writing

112
00:12:00,080 --> 00:12:04,400
update code has to think about what was it that that designer said a while ago about support tickets.

113
00:12:06,720 --> 00:12:14,080
This one, order is dependent on the keys. It's just like not a good idea. And this one,

114
00:12:14,080 --> 00:12:19,760
the order is stable again. So it seems like we've got a pretty clear winner in this case. So let's

115
00:12:20,640 --> 00:12:36,080
run with this. So here's the initial version of it. We can check stuff. And we can, this is kind of

116
00:12:36,080 --> 00:12:47,600
small. But we can see people messing with the record. Oops. Okay. So when we look at the code,

117
00:12:47,600 --> 00:12:55,280
can people see this okay? Okay. The model is what we talked about. We have the record with our

118
00:12:55,280 --> 00:13:00,640
boolean fields. And the defaults, you know, everything needs to be true, right? We need

119
00:13:01,200 --> 00:13:08,320
autoplay to get that ad money. We need location on so that it can be location-specific advertising.

120
00:13:08,320 --> 00:13:13,120
Okay. I notice you're in the neighborhood of, and we need the email so that they can notify you

121
00:13:13,120 --> 00:13:22,160
to log in and see the autoplay has. And then in our update, things are relatively straightforward.

122
00:13:24,000 --> 00:13:30,720
We have a way to toggle each of these things. And if I mess up and say I want the model's

123
00:13:30,960 --> 00:13:40,640
email, it's like, hey, I think you have a typo. So we're getting that benefit that we wanted.

124
00:13:43,680 --> 00:13:50,960
And finally, we have a view. So we have a field set. There's labels. And each one contains a

125
00:13:50,960 --> 00:13:58,400
checkbox that we say, okay, here's the email notifications one. Is it checked? Here's the

126
00:13:58,400 --> 00:14:05,120
autoplay. Is it checked? Et cetera. Now, one of the things that you can do is say, okay,

127
00:14:05,120 --> 00:14:09,200
these actually are pretty much exactly the same. So we can factor out some of this code.

128
00:14:10,240 --> 00:14:22,640
So I can say view checkbox. I don't know if it makes sense to start with the type,

129
00:14:22,640 --> 00:14:34,480
but I practiced this so I know what it is. But we can essentially chop out this code,

130
00:14:34,480 --> 00:14:45,520
which appears a bunch of times, and fill in the blanks. So checked is checked. Message,

131
00:14:46,400 --> 00:14:55,840
description, and then where did my mouse go? Okay, there it is. And then we can say let's just

132
00:14:55,840 --> 00:15:09,680
replace all of these with the checkbox. Okay, so is it code shorter? Not really.

133
00:15:10,640 --> 00:15:16,880
But if we are applying styles to all of these in the same way, now it's a lot

134
00:15:16,880 --> 00:15:20,480
easier. We can do it in one place and be sure that it happens everywhere. So this is a nice

135
00:15:20,480 --> 00:15:28,560
refactor given the current state of affairs. So let's see if I did it right. Yeah, okay, cool.

136
00:15:30,640 --> 00:15:35,200
So we come back, we have this going. It's nice. And so we get a new feature,

137
00:15:36,080 --> 00:15:41,520
which is autoplay customizations. So instead of just autoplay, we want people to be able to use

138
00:15:41,520 --> 00:15:49,760
should it play audio by default? And should it play on Wi-Fi only or will people allow it on

139
00:15:49,760 --> 00:15:56,640
cellular data as well? So when we go back, the thing to look at is our model again. So one way

140
00:15:56,640 --> 00:16:04,800
to deal with this is, well, okay, we have two new things. So we have autoplay audio and autoplay

141
00:16:07,520 --> 00:16:16,080
Wi-Fi. I'm going to call it without Wi-Fi. I don't know because it helps me understand

142
00:16:16,080 --> 00:16:22,240
what the bull would be. And then we can go mess with our view. But this is kind of lame because

143
00:16:22,800 --> 00:16:30,000
we can do it that way and a designer will say, well, I want it to be where if there's no video

144
00:16:30,000 --> 00:16:34,560
autoplay, then you can't mess with the autoplay settings. Like you're not doing that. So those

145
00:16:34,560 --> 00:16:40,000
should be disabled. So suddenly we have this interaction between these three fields where

146
00:16:41,920 --> 00:16:46,640
we always have to check autoplay before we show this and that determines whether it's disabled.

147
00:16:46,640 --> 00:16:51,680
So we're starting to get these dependencies. So a better way to represent this would be

148
00:16:52,400 --> 00:17:02,160
to just actually model it directly. So autoplay is offer on. And if it's on, there's audio

149
00:17:03,120 --> 00:17:19,760
or without Wi-Fi. So in this version of reality, you can't mess with any of these options without

150
00:17:19,760 --> 00:17:25,360
pattern matching on or off. So if you want to change them, you have to say, okay, let me expand

151
00:17:25,440 --> 00:17:31,760
the autoplay. If it's off, oh, I don't need to deal with it. And that also means in your view,

152
00:17:32,640 --> 00:17:36,640
you handle these two scenarios and you say, okay, is autoplay on? In which case, I can show these

153
00:17:36,640 --> 00:17:42,720
things. If it's off, then I don't. So it's sort of forcing any future user of this code base

154
00:17:42,720 --> 00:17:50,160
to understand that there's a dependency between these fields. Now we say, okay, we'll show this to

155
00:17:50,160 --> 00:17:57,520
the designer again. But the thing is, if we turn things off, we lose all of our options. So we want

156
00:17:57,520 --> 00:18:06,000
those to be preserved. Some users will toggle this a lot and it's annoying. So what we can do is say,

157
00:18:06,000 --> 00:18:18,320
okay, type alias autoplay settings. And then we can actually just have it on both,

158
00:18:18,320 --> 00:18:23,040
but still force people to go through the on off check before you're doing any logic.

159
00:18:25,200 --> 00:18:28,400
So and then this will play out throughout the course of the code. We can

160
00:18:34,240 --> 00:18:39,280
a way to approach this was, well, now we have this autoplay idea. Maybe we can start to write

161
00:18:39,280 --> 00:18:44,880
some helper functions to make it nice to work with. So maybe we can say toggle autoplay and it

162
00:18:44,960 --> 00:18:49,680
switches between on and off in a nice way. And so as we create these helper functions, we start to

163
00:18:49,680 --> 00:18:54,960
have functions that are all built around the data structure, which is that pattern I was talking about.

164
00:18:54,960 --> 00:19:00,000
So once you start to see these kinds of chunks of code, you get these units that can break out and

165
00:19:00,000 --> 00:19:10,320
make your code nicer. Okay. So we have that going. So now we come to fruits. And at this point,

166
00:19:10,320 --> 00:19:13,200
the question asked yourself is like, do you think it's going to work out the same way?

167
00:19:15,840 --> 00:19:21,120
So yeah, so let's take a look. So again, we can choose between different data structures and

168
00:19:21,760 --> 00:19:28,240
I picked the same ones. So record, list of things, dictionary, the list of options and which ones

169
00:19:28,240 --> 00:19:37,440
are selected. So in this case, our constraints are very different. So we work at like fruits.com,

170
00:19:37,440 --> 00:19:43,920
I don't know. And the fruit availability, it's seasonal. We want to bring you the freshest

171
00:19:43,920 --> 00:19:50,320
seasonal fruits for your region. And like maybe we're out of bananas today. So we don't want to

172
00:19:50,320 --> 00:19:55,200
just let people say, oh, I definitely only want bananas. I'm sorry. Here's a mango.

173
00:19:58,160 --> 00:20:04,800
So if we use a record, does that mean we would have to ship code every time availability changed

174
00:20:04,800 --> 00:20:11,760
in a particular region? So that doesn't seem great. But in all these others, we can just load

175
00:20:11,760 --> 00:20:18,800
the options from the server. That seems like a benefit. From there, one thing we might consider

176
00:20:18,800 --> 00:20:23,440
is, well, which of these will be easier to just use? Which one will the code come out nicer?

177
00:20:23,440 --> 00:20:28,320
So in this case, we'll probably use list.map to do an update. We can scan through and say,

178
00:20:28,400 --> 00:20:35,280
if it's this fruit, then I'll toggle it or not. With dictionary, you can use update and say,

179
00:20:35,280 --> 00:20:43,120
okay, I want to change this particular fruit. And with this one, we can use set, insert and

180
00:20:43,120 --> 00:20:47,520
remove. So we don't have to ever mess with this. We can just say, okay, they want to add this to

181
00:20:47,520 --> 00:20:54,320
their set of their selected set, and they want to remove that one. And again, we have the ordering

182
00:20:54,320 --> 00:21:03,600
problems from before where maybe our head of fruit marketing is like, we need to put bananas up at

183
00:21:03,600 --> 00:21:12,160
the top because that's higher margin, and that's what we're all about here at fruits.com. Or maybe

184
00:21:12,160 --> 00:21:16,880
someone else is like, well, we really should put mangoes up at the top, think about the nutritional

185
00:21:16,880 --> 00:21:24,000
content, think about the bottom line. So there might be some need to change this around.

186
00:21:24,320 --> 00:21:28,560
Perhaps dynamically. So again, dictionary isn't ideal for that kind of scenario.

187
00:21:30,000 --> 00:21:38,400
So let's go with this one where it'll be kind of nice to add and remove things to the selection,

188
00:21:38,400 --> 00:21:45,920
and we can mess with the order quite easily. Okay, so now we can go look at our fruit situation.

189
00:21:46,000 --> 00:21:56,240
Which, and then we can just select, it's great. And if we look at how this goes,

190
00:21:59,120 --> 00:22:07,040
we have our fruit list, which is very stable, and then selected, which is changing as we mess with

191
00:22:07,040 --> 00:22:23,440
stuff. Okay, so let's check out how this code works. Fruits. Okay, so in our model we say

192
00:22:24,240 --> 00:22:29,920
we have two things, the fruits that are available, and the ones that are selected. And for our

193
00:22:29,920 --> 00:22:35,840
initial model, we're just pre-populating with some fruits, but you could load this from the server.

194
00:22:36,800 --> 00:22:46,240
And our selected set is none are selected. And then update logic, appreciate forward. If a fruit

195
00:22:46,240 --> 00:22:50,960
is selected, add it to the selected set. If it's deselected, remove it from the selected set.

196
00:22:52,640 --> 00:23:00,400
And then is this going to fit? Okay, cool. So in our view code, we again have a field set.

197
00:23:01,040 --> 00:23:08,320
Okay, you can see the mouse here. We have our field set, and then we're mapping over all the

198
00:23:08,320 --> 00:23:16,160
fruits. And so when we do that, we say, okay, I have a fruit. Is it in the selected fruit set?

199
00:23:16,160 --> 00:23:22,480
If so, it's checked. And then we draw things in a way that looks quite similar to what we saw

200
00:23:22,480 --> 00:23:28,000
in the previous example. So it's checkbox, whether it's checked or not, what the title is.

201
00:23:30,560 --> 00:23:35,840
But the thing that's actually interesting about this code isn't the shared part. The part that

202
00:23:35,840 --> 00:23:42,480
they have in common is, like, whatever, seven lines. It's not very crazy. And the chances that

203
00:23:42,480 --> 00:23:47,120
they're going to stay exactly the same between these two different chunks of code is very low.

204
00:23:47,120 --> 00:23:52,640
So thinking, like, focusing on just this, like, oh, I've seen a checkbox before somewhere.

205
00:23:53,840 --> 00:23:57,760
Like, doesn't really give you a lot in terms of the structure of your program.

206
00:23:57,840 --> 00:24:04,000
So at this point, we have a pretty good fruit set going on, fruit.com, business is booming,

207
00:24:04,800 --> 00:24:12,320
margins are good. Okay, but a new feature comes along, which is only two fruits can be selected.

208
00:24:12,320 --> 00:24:16,240
We have all these folks out there who want, like, three fruits, six fruits even.

209
00:24:17,840 --> 00:24:20,560
We don't have the distribution channels for that.

210
00:24:21,120 --> 00:24:28,800
So we want to cap out at two fruits per person, you know, pick a favorite, like, pick a side.

211
00:24:31,360 --> 00:24:38,800
So this is kind of a tricky situation we have found ourselves in. So we have this set,

212
00:24:38,800 --> 00:24:45,280
and we kind of need to limit the size somehow. Oh, oh, there's one other constraint, which is

213
00:24:45,280 --> 00:24:54,560
we need to check out a different fruit. No. Fruit's one, maybe. No.

214
00:24:58,880 --> 00:25:01,360
Okay, I deleted a file that I should not have deleted.

215
00:25:04,160 --> 00:25:10,480
But the thing that I wanted to show was we want to maintain the order that they were selected.

216
00:25:10,480 --> 00:25:15,520
So if I select apple, then apricot, then banana, I want the oldest thing to be the one that's

217
00:25:15,520 --> 00:25:20,400
forgotten. So I want to keep the most recently selected as I go through things.

218
00:25:23,760 --> 00:25:29,120
So with a set, it's really hard to keep track of what was the order that things were added. We

219
00:25:29,120 --> 00:25:33,280
can remove one of the things, but we don't know which of the two it was. You'll get this very

220
00:25:33,280 --> 00:25:41,280
wonky behavior. So at this point, we can ask, well, maybe it'd be good to think about the

221
00:25:41,280 --> 00:25:46,160
data structure we're using. So we want to choose two fruits in particular. So maybe we say, okay,

222
00:25:46,160 --> 00:25:52,640
so I'm going to choose a string and a string. But what happens when nothing's selected? We

223
00:25:52,640 --> 00:25:56,720
need to account for zero selections, one selection, two selections. So that's no good.

224
00:25:57,440 --> 00:25:59,200
Maybe we can say maybe string.

225
00:26:02,720 --> 00:26:08,400
So all of these can be optionally selected. But there's this weird case where if one thing is

226
00:26:08,400 --> 00:26:14,080
selected, we don't know if it's going to be the left or the right thing. So this doesn't seem great

227
00:26:14,080 --> 00:26:23,840
either. So maybe we can say, okay, there should be this type two, and it's either zero or one

228
00:26:24,560 --> 00:26:31,360
or two. Okay, that's pretty nice. You can imagine inserting into zero, you go to one,

229
00:26:31,360 --> 00:26:36,560
inserting into two, and then in two, you maintain some order moving things along.

230
00:26:38,080 --> 00:26:42,640
And that design seems okay, but we know head of fruits marketing.

231
00:26:44,000 --> 00:26:47,280
He's going to say, okay, well, in tropical areas, we can actually give them more fruits,

232
00:26:47,280 --> 00:26:52,640
so they're going to want a limit of three. But in Iceland, they only get half cucumbers there.

233
00:26:52,640 --> 00:26:54,960
That's just the rule. I don't know. That is actually how it works.

234
00:26:57,680 --> 00:27:01,600
So we're probably not going to be able to just stick with two. There may be some

235
00:27:01,600 --> 00:27:05,920
places where we need three or different limits. So another way we could do this is just a list

236
00:27:06,560 --> 00:27:12,160
of string and then limit the size. So essentially add to the front and take things,

237
00:27:12,160 --> 00:27:19,200
drop things off the back. So I don't know. It doesn't seem perfect. Clearly, you can just add

238
00:27:19,200 --> 00:27:25,120
20 things to it. But it sort of has potential. So let's explore that route.

239
00:27:28,080 --> 00:27:32,960
So instead of this being empty, this is an empty list. Oops.

240
00:27:36,640 --> 00:27:42,320
The cursor just disappears. Anyway, so when we select something, we want to say

241
00:27:42,800 --> 00:27:53,520
list.take2 fruit on the front of our selected list. So this is saying, put the fruit on the

242
00:27:53,520 --> 00:27:56,880
front and then just take the front two. So whatever else is there, we'll drop it.

243
00:27:59,840 --> 00:28:08,640
And then when we deselect, we can say list.filter. The fruit should not, any fruit,

244
00:28:08,640 --> 00:28:15,120
that's not the one we, that's a lot of nots in one sentence. We want to only keep fruits.

245
00:28:17,760 --> 00:28:21,680
You get it. We want that fruit to be deselected.

246
00:28:24,480 --> 00:28:33,680
And then in our checkbox code, we want to say and said list.member. And I think that's everything

247
00:28:34,240 --> 00:28:40,720
except we don't need that anymore. Okay. So let's see if I did this right.

248
00:28:43,920 --> 00:28:49,040
Hey. And so you can see it's maintaining the order that I clicked things. So if I,

249
00:28:51,440 --> 00:28:55,360
I don't know, it's kind of hard to remember. It's easy if you go in order and you can see.

250
00:28:55,360 --> 00:29:01,520
It's working nicely. Okay. So we're maintaining our two fruits per person situation. But when

251
00:29:01,520 --> 00:29:09,520
we come look back at our update code, it's getting, it feels like trickier, right? And as we grow

252
00:29:09,520 --> 00:29:19,920
fruits.com, like maybe someone won't realize the take two is not, oh, just some fine choice. It's

253
00:29:19,920 --> 00:29:24,560
like, head of fruits marketing decided that was two and you can't change that stuff. So we want

254
00:29:24,560 --> 00:29:30,400
to have some more security around this code. So one way we can do that is to start to break out

255
00:29:32,480 --> 00:29:39,440
the particular stuff around that data structure. So we, we know there's this selection list.

256
00:29:39,440 --> 00:29:41,520
We can make a function that is

257
00:29:41,600 --> 00:29:56,880
along these lines. So let's do it in the update part. Insert, oops, insert fruit list.

258
00:30:02,240 --> 00:30:05,120
I'm going to leave off types for now just for speed.

259
00:30:06,080 --> 00:30:16,240
And then I can say here, insert fruit. And then I can also say remove fruit from the list.

260
00:30:17,440 --> 00:30:18,640
And we'll do it the same way.

261
00:30:26,720 --> 00:30:30,800
So this code gets a bunch simpler as well. Remove fruit.

262
00:30:31,760 --> 00:30:38,800
And we can do the same thing with the checking for membership below. Now at this point it's sort

263
00:30:38,800 --> 00:30:44,720
of coalescing into, oh, there's this kind of data structure that's specifically about maintaining

264
00:30:44,720 --> 00:30:51,200
just two things in, in the list. So I'm going to check for time to see how much live coding I should

265
00:30:51,200 --> 00:31:00,400
do. Okay. Well, let's, let's start to follow this idea of like, we're starting to recognize

266
00:31:00,400 --> 00:31:06,560
a data structure. So let's try to break that out. So I can say fruit list.

267
00:31:09,680 --> 00:31:14,080
And I have this type alias fruit, selected fruit.

268
00:31:14,640 --> 00:31:25,280
So we're starting to see the, the beginnings of a, of a module, like things that we can

269
00:31:26,400 --> 00:31:32,000
box off and put in their own place. So I'm going to just skip ahead to a version of this

270
00:31:32,000 --> 00:31:37,840
in a different module. So the ideas, we have this thing called a bounded set.

271
00:31:38,560 --> 00:31:42,960
And yeah, no, I shouldn't skip ahead to this. That was a bad idea.

272
00:31:46,000 --> 00:31:49,200
So let's say, okay, we have this and we were going to put it in a new module,

273
00:31:49,200 --> 00:31:56,160
the selected fruit module. Exposing

274
00:31:56,160 --> 00:32:11,680
a selected fruit. And then in our fruits module, we can get rid of that. And we can import

275
00:32:16,880 --> 00:32:20,080
as selected fruits. And then

276
00:32:20,400 --> 00:32:31,280
we just have to go through and make a couple changes here. Oh, we'll come back to that.

277
00:32:35,120 --> 00:32:42,400
Selected fruit, that insert, remove, et cetera. So this is also selected fruit.

278
00:32:43,680 --> 00:32:48,400
We're kind of leaking details here. Okay. Let's see it. Okay. Check. Does this work? No.

279
00:32:49,200 --> 00:32:54,240
Selected fruits. It's singular.

280
00:33:04,320 --> 00:33:11,600
There's also a stray print. Spelling.

281
00:33:18,880 --> 00:33:21,680
It's nice that, yeah. Oh, geez. What the heck?

282
00:33:26,320 --> 00:33:41,760
Okay. Just imagine there wasn't a compiler there. Or just like, maybe that's wrong. I don't know.

283
00:33:42,720 --> 00:33:48,880
Okay. So this is still working. But we can kind of improve things by sort of closing down this

284
00:33:48,880 --> 00:33:54,080
module. Right now, we're exposing everything. But we could do better by saying, okay, from the

285
00:33:54,080 --> 00:34:02,000
outside, no one knows how selected fruit is implemented. It happens to be a list of string,

286
00:34:02,080 --> 00:34:13,440
but no one needs to know. So we have to do a little bit of selected.

287
00:34:15,840 --> 00:34:19,200
I'm disenchanted with this naming choice.

288
00:34:19,200 --> 00:34:32,240
Okay. So now, from the outside, no one knows how the particulars of this are implemented.

289
00:34:32,800 --> 00:34:35,120
So let's just run it. This is supposed to not work.

290
00:34:38,480 --> 00:34:43,840
So we're using list.member on a selected fruit, but we don't actually know the

291
00:34:43,920 --> 00:34:50,240
implementation deals of that anymore. And our selected, we're saying it's a list,

292
00:34:50,240 --> 00:34:55,440
but we don't have access to that information anymore. So we need to add, how do I make an

293
00:34:55,440 --> 00:35:07,680
empty selected fruit? And that would be selected fruit is empty. And then we need to test for membership.

294
00:35:14,720 --> 00:35:21,040
And then we can just say list member fruit list.

295
00:35:24,880 --> 00:35:27,680
Oh, it's still broken because they didn't actually change the broken code.

296
00:35:29,680 --> 00:35:35,920
So here we say selected fruit is empty. And then member, we say selected fruit member.

297
00:35:36,560 --> 00:35:46,720
Cool. So now we've sort of hidden all these implementation details, but we can do slightly

298
00:35:46,720 --> 00:35:54,560
better. So maybe we want to make a guarantee about the size in this data structure. So we can say

299
00:35:54,560 --> 00:35:58,640
we'll actually give the maximum size when we say it's empty or not.

300
00:35:58,880 --> 00:36:10,080
And then in all these cases, max size. So instead of taking two, we take the max size.

301
00:36:14,080 --> 00:36:21,280
And instead of removing, no, we do keep this the same, but we just have to keep the max size

302
00:36:21,280 --> 00:36:25,440
around. And then here we don't care about the max size. We just want to check.

303
00:36:26,720 --> 00:36:32,400
So we should have an error because we're just calling empty without saying how big it should be.

304
00:36:36,480 --> 00:36:42,880
Two. All right. And then things should work again. Cool.

305
00:36:45,280 --> 00:36:50,480
So at this point, we sort of taken all this complexity around maintaining the only two

306
00:36:50,480 --> 00:36:55,520
things are selected and put it in its own module. So the benefits of this is that when I'm reading

307
00:36:55,520 --> 00:37:02,320
through my normal code, all I know is there's some way to select fruits. I can say how many.

308
00:37:03,200 --> 00:37:08,320
And then I can insert and remove. And these things will just work out nicely. And I can check if

309
00:37:08,320 --> 00:37:14,960
something is a member of that. So you can go one level crazier with this, which we shouldn't get

310
00:37:14,960 --> 00:37:21,120
into, but you can. So the idea was you could generalize it so that it's a list of anything,

311
00:37:21,120 --> 00:37:26,080
not of strings or particular fruits. And then everything works the same, right? You choose

312
00:37:26,080 --> 00:37:31,200
the size. You can insert things into it. You can remove things from it. You can check membership.

313
00:37:31,760 --> 00:37:37,920
So all of these designs are possible. And the question is, which one is right for your situation,

314
00:37:37,920 --> 00:37:42,080
right? Should you go like, all right, I'm writing my own data structure that's generic in all

315
00:37:42,080 --> 00:37:46,880
sorts of things. And I'm going to optimize it. Or is it like, look, it's just a list. It's not a

316
00:37:46,880 --> 00:37:51,280
big deal. We're probably not going to get it wrong. And so that depends on what's likely to happen.

317
00:37:51,840 --> 00:37:58,320
Maybe at fruits.com, you'd make one choice. But at the new fruit stand startup, I don't know,

318
00:37:58,320 --> 00:38:08,160
they want to make different choices. Okay. So the big lesson here is that we started with two things

319
00:38:08,160 --> 00:38:13,600
that look basically the same and ended up with entirely different ways of approaching them.

320
00:38:13,600 --> 00:38:18,080
That was all about the data structure, right? And it is true that they share checkboxes, but that's

321
00:38:18,080 --> 00:38:23,120
such a small fraction of the actual difficult things that are going to happen in your code

322
00:38:23,120 --> 00:38:30,560
that it makes sense to emphasize the data structure instead. So I want to put a little extra emphasis

323
00:38:30,560 --> 00:38:38,640
on the module, right? So I showed this bounded set idea and it had, there's a bounded set.

324
00:38:39,440 --> 00:38:44,800
If it's empty, you can insert things into it. You can remove things from it. You can check

325
00:38:44,800 --> 00:38:52,080
membership. Now, the most important part of this module is the exposing line. Okay. So I'm not

326
00:38:52,080 --> 00:38:56,800
exposing everything in this module. And specifically, I'm not exposing the implementation of bounded

327
00:38:56,800 --> 00:39:03,520
set. So no one from outside can mess with the maximum size. And as long as these functions work,

328
00:39:04,240 --> 00:39:09,520
things are going to work. So I want to point out two little benefits that come from this.

329
00:39:09,520 --> 00:39:16,960
So if you reduce the public API to your module, if the implementation is hidden and if the public

330
00:39:16,960 --> 00:39:24,480
API works, the code works everywhere, right? So if I try to break this code by messing with

331
00:39:24,560 --> 00:39:31,440
these functions and I can't do it, anyone else who uses this code won't be able to do it either.

332
00:39:32,400 --> 00:39:36,960
So this is actually really nice for testing because it means you can test the public API

333
00:39:36,960 --> 00:39:41,280
very extensively. And that doesn't mean you have to test every particular usage, right? Using

334
00:39:41,840 --> 00:39:45,520
this data structure somewhere doesn't mean I can introduce bugs into that data structure

335
00:39:45,520 --> 00:39:50,480
retroactively. If it works, it's going to work well. The other thing that's nice is you get

336
00:39:50,560 --> 00:39:56,880
it easier refactoring. So I can change how things are implemented without worrying what's

337
00:39:56,880 --> 00:40:02,080
going to happen outside. And this happens in a couple ways. One is say there's an insert help

338
00:40:02,080 --> 00:40:08,880
function that's doing some extra special stuff. I know that it's not exposed outside, so I can

339
00:40:08,880 --> 00:40:14,800
mess with that. Arguments, add arguments, change shuffle things around and be sure that this is

340
00:40:14,800 --> 00:40:18,720
not going to have any effect in any other modules. I'm not going to have to go hunt stuff down.

341
00:40:19,360 --> 00:40:24,320
That's also nice because it means I don't have to worry about if it's used in 10 different

342
00:40:24,320 --> 00:40:30,000
places across the code, did they need it to work in a very particular way in each of those cases?

343
00:40:30,000 --> 00:40:34,880
And I'm covering all those cases. I can just say, oh, it's not publicly exposed. If it works in

344
00:40:34,880 --> 00:40:43,360
this file, it works. So the other thing that you can do by creating modules in this way is maintain

345
00:40:43,360 --> 00:40:49,280
invariance. So in our case, that's only two fruits. But generally speaking, this means there are

346
00:40:49,280 --> 00:40:54,960
rules that cannot be enforced entirely through data structure design. So we had our two, which is

347
00:40:54,960 --> 00:41:00,720
zero, one or two, but that wouldn't let us decide how many we want. So we now have a data structure

348
00:41:00,720 --> 00:41:06,720
that can let us decide. And by hiding all the details, we can still maintain that rule in a

349
00:41:06,720 --> 00:41:11,600
safe way, even though we can't do it purely through data. And one cool thing about finding

350
00:41:11,600 --> 00:41:17,680
invariance like this is that they're excellent for fuzz tests. So I know that whatever I do with

351
00:41:17,680 --> 00:41:23,200
this, if I say my bounded set has two things, no matter how many times I call insert, it should

352
00:41:23,200 --> 00:41:29,280
just have two things. So by thinking in this way, you also set yourself up to write tests that

353
00:41:29,280 --> 00:41:35,600
are nice and are checking the kinds of things you're worried about. So I want to add some warnings

354
00:41:36,160 --> 00:41:43,840
to this advice. So first, if you find yourself writing get and set, right, so we hid the max

355
00:41:43,840 --> 00:41:48,560
size, but maybe someone's like, well, I want the max size. I won't do a bad thing with it.

356
00:41:50,480 --> 00:41:55,280
Okay, this is a bad sign. This is a bad sign when you have get and set. So the whole point of having

357
00:41:55,280 --> 00:42:00,720
a module was that we were able to hide implementation details and say, if you use this public API,

358
00:42:00,720 --> 00:42:04,720
it will work. And inside, you don't have to worry about that. We tested it. We know it's good.

359
00:42:05,840 --> 00:42:14,000
Setters, their whole point is to expose those details. So you've done all this work to put

360
00:42:14,000 --> 00:42:18,080
it in a module, and we went through that together. It was like, it took too long.

361
00:42:22,800 --> 00:42:29,360
And now you're going to give setters that just totally defeat that entire exercise. So just use

362
00:42:29,360 --> 00:42:34,000
a record if you have data where you want people to have access, rather than hiding the details,

363
00:42:34,000 --> 00:42:40,000
then exposing get and setters. It's like, these details aren't hidden. So don't do the work to

364
00:42:40,000 --> 00:42:46,240
hide them. So another way to say this is expose as little as possible, but no less. Some things

365
00:42:46,240 --> 00:42:51,440
do need to be publicly available. So this shouldn't just be like, hide everything. That's better.

366
00:42:53,040 --> 00:42:59,680
The other thing is don't overdo it. So I'd wait until I have a problem in practice,

367
00:42:59,680 --> 00:43:04,720
and then solve that problem. So the goal shouldn't be let's just write modules, because modules help

368
00:43:04,720 --> 00:43:10,160
with this kind of stuff. It should be, hey, I'm having trouble understanding this code. I came

369
00:43:10,160 --> 00:43:14,960
back to it after a month, and it seemed kind of confusing. Maybe I can find parts that I can

370
00:43:16,080 --> 00:43:23,040
make things nicer. So if you find yourself asking, how do I make the sidebar reusable? Okay, try to

371
00:43:23,120 --> 00:43:30,720
remember to ask yourself why. Are you going to have multiple sidebars? Maybe not. In which case,

372
00:43:30,720 --> 00:43:36,640
like, why would you do the work to do that? If you are going to have multiple ones, a thing to

373
00:43:36,640 --> 00:43:43,120
think is, are these cases the same, or are they similar? If we're just talking about the HTML

374
00:43:43,120 --> 00:43:47,120
is going to look similar, but how it works behind the scenes is fundamentally different in both cases.

375
00:43:47,920 --> 00:43:53,920
I think it's probably not a good idea to, like, try to get all into how do we share code between

376
00:43:53,920 --> 00:43:59,600
these two. Focus on the data structure instead. Another thing that might happen is as you're

377
00:43:59,600 --> 00:44:04,560
growing your record, you don't have any interesting types. You don't have that autoplay thing where

378
00:44:04,560 --> 00:44:09,120
these fields are dependent on that field. It's just a bunch of independent stuff.

379
00:44:09,360 --> 00:44:17,520
If they're all independent, there's no problem. If I just have fields that have no relationship

380
00:44:17,520 --> 00:44:23,040
to each other, and I change one, there's not a chance that there's some bug elsewhere. But if I

381
00:44:23,040 --> 00:44:27,600
do have that relationship, that's a potential to start finding a data structure and do better

382
00:44:27,600 --> 00:44:33,360
modeling. So I'd say, like, don't be afraid to just grow your record and try to find these

383
00:44:34,240 --> 00:44:40,320
connections and how things fit together, as opposed to preemptively, like, ah, I'm worried

384
00:44:40,320 --> 00:44:47,280
about this code, so I'm just going to change it. So, yeah, just as there's premature optimization,

385
00:44:47,280 --> 00:44:53,200
there's premature refactoring. It's a thing, it's fun, right? It's like you get to play

386
00:44:53,200 --> 00:45:01,760
code golf at work. I don't think employers should encourage that, but people like to do it.

387
00:45:03,520 --> 00:45:14,160
Okay, so to take a step back, we saw how a file tends to grow, right? And if we focus on

388
00:45:14,160 --> 00:45:19,120
the data structures, we end up with these nice categorizations where, like, when I'm searching

389
00:45:19,200 --> 00:45:24,000
through a code base even, I say, hey, where's that stuff that's related to books? It's probably in

390
00:45:24,000 --> 00:45:30,000
the module about books, right? As opposed to, well, there's this update subdirectory, and all the

391
00:45:30,000 --> 00:45:37,440
update code is there, and the book stuff is just like, it's related to books. So, yeah, so big

392
00:45:37,440 --> 00:45:41,840
lessons are focus on data structures and choose the best representation available. So, like,

393
00:45:41,840 --> 00:45:46,800
actually think through as many cases as you can, and the others build modules around types

394
00:45:47,360 --> 00:45:57,200
and try to expose as little as possible, but no less. So, yeah, so I hope this will be a nice

395
00:45:57,200 --> 00:46:05,760
next advice in the, how do I grow my Elm code? And one of my goals was to write this up. So,

396
00:46:05,760 --> 00:46:12,880
I actually started a book that is about functional programming in Elm, and the goal of this book

397
00:46:12,880 --> 00:46:16,720
was essentially to write this talk so that people could read it online and it would work out.

398
00:46:17,440 --> 00:46:23,360
It turns out it's very hard to write that whole live coding section. So, instead, what I ended

399
00:46:23,360 --> 00:46:30,000
up with is some nice stuff about recursion and graphs. It's fun. Hopefully, I'll be able to

400
00:46:30,000 --> 00:46:34,960
distill this down into another chapter that actually emphasizes these things in a way where you

401
00:46:34,960 --> 00:46:52,000
don't have to see the live talk. But, yeah, so that's the life of a file. Thank you.

