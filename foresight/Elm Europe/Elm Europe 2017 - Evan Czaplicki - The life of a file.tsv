start	end	text
0	8440	Welcome, everyone. I want to start just saying thanks, everyone, for coming. This is kind
8440	18080	of crazy. I'm Evan. I made Elm. It's very exciting to be here. So I want to say thanks
18080	23080	one, thanks for folks for coming, thanks to Thibaut and Guillaume for setting things up,
23080	29280	and then thanks to everyone who is helping get the technology set up, and then this thank
29280	37520	you is like outer proportion. So thank you to who had the L have this tail. I really
37520	46920	appreciate that. But yeah, so thanks, everyone, for coming. And I want to emphasize sort of
46920	54800	a question that has sort of guided Elm for the last couple of years, which is how do
54800	60640	I grow Elm code? And so this is a question that somehow always sounds topical. So who
60640	66320	remembers Elm before the Elm architecture? Before the Elm architecture? Okay, there
66320	70160	are people out there. Okay. So there was a time when that didn't exist and people would
70160	74960	say how do I write a program? And so we sort of observed, okay, maybe we can call this
74960	78400	thing there's a model, there's an update of you. We saw that pattern, and they were like,
78400	84280	okay, that's cool. How do I grow an Elm program? Okay. So we had some more examples.
84680	90800	And showed it, okay, you can reuse functions in this kind of way to help make a view. And
90800	95240	people were like, okay, cool. But how do you grow an Elm program? So I want to take the
95240	102720	next step in perhaps a never ending journey. And we're going to do that by tracing the
102720	109920	life of a file. So we'll see it start small and gradually grow, and then grow a bit more,
109960	116280	and then eventually break off into two. And I think as we go through this path, it won't
116280	121920	necessarily be surprising or difficult. But I think it's hard to see if you're coming
121920	127240	from JavaScript. So before we get started with the life of a file, I want to start with
127240	134400	some JavaScript folk knowledge that may be leading people astray. So one thing that I
134480	141280	see a lot is this idea that shorter files are better. So an extreme example of this is when I
141280	148960	was doing the benchmark comparison between React and a bunch of other frameworks in Elm,
149840	155200	the Ember one just had so many files, I just didn't get it. This is a greater than file.
156080	163360	And it just felt like this surely isn't the easiest way. So when I see this thought process,
163400	171520	it sort of feels bizarre to me. And so the way I can understand it is the context is as the lines
171520	177120	of code increases, the probability of sneaky mutation approaches one. It's going to happen if
177120	181640	you're writing JavaScript code. So if you have a thousand lines of code, there's going to be some
181640	185440	object that accidentally gets shared, and two people are going to be mutating it. It's just going
185440	195760	to happen. So therefore, for shorter files, it fills this very useful function. Another thing that
195760	200640	people just know in JavaScript is you have to get the architecture right from the beginning or
200640	207200	you're doomed. It's just not going to work out for your project. This you barely need a justification
207200	213920	because obviously I'm sure many of us have seen this play out in companies we either work for or
213920	222560	people we know. And the justification behind it is refactoring is very risky. Sometimes it's cheaper
222560	227760	to just rewrite the code. And I think that accounts for some of the churn in JavaScript
227760	232720	frameworks. People like, well, this didn't work. I could try to fix it, but it'd be just as easy
232720	240400	to try a different thing that maybe doesn't suck. So we have these sort of intuitions and habits
240400	246800	that are grown out of the actual constraints of JavaScript and the languages we use. But in Elm,
247600	251840	the probability of sneaking mutation is zero. If you have a thousand lines or 10,000 lines,
251840	257040	it's just like not possible that a value gets shared and suddenly there's spooky action at
257040	263760	a distance between these two chunks of code. So this whole premise is gone. And so I don't see
263760	270880	how we can draw the same conclusion anymore. Similarly, refactoring is cheap and reliable.
270880	275280	Like you have types to help you out. The compiler is going to guide you through the process. So
276080	281040	you can end up changing 10 or 20 files and be pretty confident to end that things are fine.
281680	286960	So again, this premise is gone. And so this idea that the architecture has to be right from the
286960	296720	start doesn't really play out in practice. So the big thing to note here is that the way Elma's
296720	301840	design changes how you should grow a code base. And we have a lot of habits that come from,
301840	305600	like we don't even necessarily all know the justification of these things, but we know like,
305600	311200	oh, that file seems too long. That's probably, like we have these senses that guide how we write code.
312160	316880	So the rest of the talk is sort of challenging these and providing a new way of seeing code
317440	326240	that can help grow a program. Okay. So the life of a file. We might start out with a nice little
326240	332400	file. Let's say I, and the blue is like the model, let's say the data structure and then there's
332400	338320	some logic. And maybe this is, I have a personal like reading list and I want to just keep track
338400	346320	of the books that I'm interested in. And maybe I have 200 lines of code. I'm not crazy. And so I
346320	352160	add some features. I want to be able to mark the books as read or not. And maybe I want to reorder
352160	359840	them depending on if one starts to seem more exciting. And so now I have about 400 lines.
359840	365360	And I think a lot of folks at this point would be like, like something's wrong. There's a problem.
366160	372320	That's generally not, that's not how I would approach programming in Elm. It's not how things
372320	377520	work in Standard and Mellor or Camel or Haskell. It's just like having a file this long is pretty
377520	384880	standard. So if I go through the compiler, like that's, I'd say the average. And so maybe add
384880	389600	some more features. I can add annotations to each book of quotes that I really like.
390560	396880	Things I want to remember. So now I have like 600 lines of code. And it's like, okay, now it's
396880	403440	surely it's a problem. Not really. I don't know. I think you shouldn't be too scared of a file
403440	407680	growing long. So this is something that will typically happen. Now, at this point, it's likely
407680	412720	that I'll say, you know what, I think it'd be good to have the data structure for like my library
412720	418640	where I can reorder books and a data structure for books. Where is it read or not? What are my notes?
419600	425520	And then I can start to organize my code around those two data structures. So I can say, okay,
425520	430720	mark this book as red, add this note. And so the functions in my code start to organize around
430720	438480	those data structures. So, hey, we discovered this better data structure. So the next step that
438480	445520	may happen is we split around the data structure, right? So once we discover that there's this other
445760	453040	like chunk that we can grab onto, that can become the heart of a nice module. And so this is the
453040	458800	typical process that I always follow. It's just basically grow until I find a data structure
458800	466800	that I can split on. And if I don't find it, it's fine. So I'd encourage folks to sort of
466800	472000	play with this in your own code. And sort of if you're feeling uncomfortable, like, oh, this seems
472080	477600	like I have too much code here, just like push into that feeling and like see if it actually
478480	482880	is warranted. Like, is there actually a problem? Or is it just like a feeling that you have based
482880	488800	on experiences in other languages? So, okay. So at this point, this is basically just like
488800	495440	an unsubstantiated claim. Let's see some more concrete examples, right? Ones where the code
495440	506480	is more elaborate than lines. So, okay. So I want to look at two examples. One is
507600	511040	the sort of settings. So you can imagine this is like the settings you'd have in
512160	516400	a Facebook or Twitter or Pinterest or whatever. Like, do you get email notifications? Do you
516400	523760	want video audio play? Do you want to use location? These kinds of things. And you could just say no,
523760	531120	but they want to give you the option to say no. The other situation is checkbox is a bunch of
531120	536880	fruits. Maybe I'm going to, you're going to get lunch and you are able to pick out which fruits
536880	541440	you want, then you can have that one. So before we dig into this, I want to sort of take a second
541440	548880	to and ask people, like, what are the questions and concerns when you see these two that pop into
548880	552960	your mind? Like, when you think about how the code is probably going to look, what pops into your
552960	572960	mind? Okay. Yeah. Someone said, oh, oh. Okay. Okay. Okay. We're good. We're good. Someone said generic
572960	579120	checkbox list. So yeah, this idea of like, how do we share? Like, clearly we have checkboxes here.
579120	588480	Like, sharing needs to happen. Okay. This, I'm going to proceed by showing how I would address
588480	594640	these and then we'll see if that intuition plays out. So when I look at the settings, the first
594640	601040	question I ask is, how do I model this information? Right? So do I use a record where I say there's
601040	608160	email, there's video, there's location? Do I use a list of pairs where the string would be email
608160	617040	and notifications true? Autoplay false? A location false? Do I choose a dictionary? Which would work
617040	623760	similarly? But now it's unique on these things. Or do I do this other one that's, I have a list of
623760	628640	strings. These are all options. So email, autoplay location, and then a set of which ones are selected.
628640	636560	So this would just be email. And we can think of more. It's a good idea to get in the habit of
636560	641680	just thinking, what are all the possible ways I can represent this? So at this point, you want to
641680	649600	say, okay, well, which one should I do? So one trade-off here is this one gives us the benefit
649600	656000	of types, right? So if we're messing around in our code and someone misspells email or misspells
656000	660160	one of these things, the compiler is going to give us some help. So that's nice. And these other ones
660480	666240	are stringly typed. So if there's some misspelling, it's sorry. Like, things are going to go weird.
668160	675040	Another thing to think about is the order in this one is just determined by the view. So in my model,
675040	680000	in my record, I can update however I want. It can appear however I want it to appear in my code.
680000	684640	But ultimately in the view, I'm going to say, show the email, show the notification, show this. And
684640	690720	if our designer says, okay, we actually want to move, use location above because everyone wants
690720	694640	to turn that off and no one can find it, we get a lot of support tickets and they're really mad at
694640	702640	us. So I get that. Just change it. And then it becomes very easy in this world. With this one,
702640	710560	the order is stable, but you can actually change it in the update. So in the same time we're
710560	715600	upping a bool from true to false, we could just swap, reverse the list. And so suddenly the UI
715600	720080	is totally different based on stuff that's happening in the update code. So someone writing
720080	724400	update code has to think about what was it that that designer said a while ago about support tickets.
726720	734080	This one, order is dependent on the keys. It's just like not a good idea. And this one,
734080	739760	the order is stable again. So it seems like we've got a pretty clear winner in this case. So let's
740640	756080	run with this. So here's the initial version of it. We can check stuff. And we can, this is kind of
756080	767600	small. But we can see people messing with the record. Oops. Okay. So when we look at the code,
767600	775280	can people see this okay? Okay. The model is what we talked about. We have the record with our
775280	780640	boolean fields. And the defaults, you know, everything needs to be true, right? We need
781200	788320	autoplay to get that ad money. We need location on so that it can be location-specific advertising.
788320	793120	Okay. I notice you're in the neighborhood of, and we need the email so that they can notify you
793120	802160	to log in and see the autoplay has. And then in our update, things are relatively straightforward.
804000	810720	We have a way to toggle each of these things. And if I mess up and say I want the model's
810960	820640	email, it's like, hey, I think you have a typo. So we're getting that benefit that we wanted.
823680	830960	And finally, we have a view. So we have a field set. There's labels. And each one contains a
830960	838400	checkbox that we say, okay, here's the email notifications one. Is it checked? Here's the
838400	845120	autoplay. Is it checked? Et cetera. Now, one of the things that you can do is say, okay,
845120	849200	these actually are pretty much exactly the same. So we can factor out some of this code.
850240	862640	So I can say view checkbox. I don't know if it makes sense to start with the type,
862640	874480	but I practiced this so I know what it is. But we can essentially chop out this code,
874480	885520	which appears a bunch of times, and fill in the blanks. So checked is checked. Message,
886400	895840	description, and then where did my mouse go? Okay, there it is. And then we can say let's just
895840	909680	replace all of these with the checkbox. Okay, so is it code shorter? Not really.
910640	916880	But if we are applying styles to all of these in the same way, now it's a lot
916880	920480	easier. We can do it in one place and be sure that it happens everywhere. So this is a nice
920480	928560	refactor given the current state of affairs. So let's see if I did it right. Yeah, okay, cool.
930640	935200	So we come back, we have this going. It's nice. And so we get a new feature,
936080	941520	which is autoplay customizations. So instead of just autoplay, we want people to be able to use
941520	949760	should it play audio by default? And should it play on Wi-Fi only or will people allow it on
949760	956640	cellular data as well? So when we go back, the thing to look at is our model again. So one way
956640	964800	to deal with this is, well, okay, we have two new things. So we have autoplay audio and autoplay
967520	976080	Wi-Fi. I'm going to call it without Wi-Fi. I don't know because it helps me understand
976080	982240	what the bull would be. And then we can go mess with our view. But this is kind of lame because
982800	990000	we can do it that way and a designer will say, well, I want it to be where if there's no video
990000	994560	autoplay, then you can't mess with the autoplay settings. Like you're not doing that. So those
994560	1000000	should be disabled. So suddenly we have this interaction between these three fields where
1001920	1006640	we always have to check autoplay before we show this and that determines whether it's disabled.
1006640	1011680	So we're starting to get these dependencies. So a better way to represent this would be
1012400	1022160	to just actually model it directly. So autoplay is offer on. And if it's on, there's audio
1023120	1039760	or without Wi-Fi. So in this version of reality, you can't mess with any of these options without
1039760	1045360	pattern matching on or off. So if you want to change them, you have to say, okay, let me expand
1045440	1051760	the autoplay. If it's off, oh, I don't need to deal with it. And that also means in your view,
1052640	1056640	you handle these two scenarios and you say, okay, is autoplay on? In which case, I can show these
1056640	1062720	things. If it's off, then I don't. So it's sort of forcing any future user of this code base
1062720	1070160	to understand that there's a dependency between these fields. Now we say, okay, we'll show this to
1070160	1077520	the designer again. But the thing is, if we turn things off, we lose all of our options. So we want
1077520	1086000	those to be preserved. Some users will toggle this a lot and it's annoying. So what we can do is say,
1086000	1098320	okay, type alias autoplay settings. And then we can actually just have it on both,
1098320	1103040	but still force people to go through the on off check before you're doing any logic.
1105200	1108400	So and then this will play out throughout the course of the code. We can
1114240	1119280	a way to approach this was, well, now we have this autoplay idea. Maybe we can start to write
1119280	1124880	some helper functions to make it nice to work with. So maybe we can say toggle autoplay and it
1124960	1129680	switches between on and off in a nice way. And so as we create these helper functions, we start to
1129680	1134960	have functions that are all built around the data structure, which is that pattern I was talking about.
1134960	1140000	So once you start to see these kinds of chunks of code, you get these units that can break out and
1140000	1150320	make your code nicer. Okay. So we have that going. So now we come to fruits. And at this point,
1150320	1153200	the question asked yourself is like, do you think it's going to work out the same way?
1155840	1161120	So yeah, so let's take a look. So again, we can choose between different data structures and
1161760	1168240	I picked the same ones. So record, list of things, dictionary, the list of options and which ones
1168240	1177440	are selected. So in this case, our constraints are very different. So we work at like fruits.com,
1177440	1183920	I don't know. And the fruit availability, it's seasonal. We want to bring you the freshest
1183920	1190320	seasonal fruits for your region. And like maybe we're out of bananas today. So we don't want to
1190320	1195200	just let people say, oh, I definitely only want bananas. I'm sorry. Here's a mango.
1198160	1204800	So if we use a record, does that mean we would have to ship code every time availability changed
1204800	1211760	in a particular region? So that doesn't seem great. But in all these others, we can just load
1211760	1218800	the options from the server. That seems like a benefit. From there, one thing we might consider
1218800	1223440	is, well, which of these will be easier to just use? Which one will the code come out nicer?
1223440	1228320	So in this case, we'll probably use list.map to do an update. We can scan through and say,
1228400	1235280	if it's this fruit, then I'll toggle it or not. With dictionary, you can use update and say,
1235280	1243120	okay, I want to change this particular fruit. And with this one, we can use set, insert and
1243120	1247520	remove. So we don't have to ever mess with this. We can just say, okay, they want to add this to
1247520	1254320	their set of their selected set, and they want to remove that one. And again, we have the ordering
1254320	1263600	problems from before where maybe our head of fruit marketing is like, we need to put bananas up at
1263600	1272160	the top because that's higher margin, and that's what we're all about here at fruits.com. Or maybe
1272160	1276880	someone else is like, well, we really should put mangoes up at the top, think about the nutritional
1276880	1284000	content, think about the bottom line. So there might be some need to change this around.
1284320	1288560	Perhaps dynamically. So again, dictionary isn't ideal for that kind of scenario.
1290000	1298400	So let's go with this one where it'll be kind of nice to add and remove things to the selection,
1298400	1305920	and we can mess with the order quite easily. Okay, so now we can go look at our fruit situation.
1306000	1316240	Which, and then we can just select, it's great. And if we look at how this goes,
1319120	1327040	we have our fruit list, which is very stable, and then selected, which is changing as we mess with
1327040	1343440	stuff. Okay, so let's check out how this code works. Fruits. Okay, so in our model we say
1344240	1349920	we have two things, the fruits that are available, and the ones that are selected. And for our
1349920	1355840	initial model, we're just pre-populating with some fruits, but you could load this from the server.
1356800	1366240	And our selected set is none are selected. And then update logic, appreciate forward. If a fruit
1366240	1370960	is selected, add it to the selected set. If it's deselected, remove it from the selected set.
1372640	1380400	And then is this going to fit? Okay, cool. So in our view code, we again have a field set.
1381040	1388320	Okay, you can see the mouse here. We have our field set, and then we're mapping over all the
1388320	1396160	fruits. And so when we do that, we say, okay, I have a fruit. Is it in the selected fruit set?
1396160	1402480	If so, it's checked. And then we draw things in a way that looks quite similar to what we saw
1402480	1408000	in the previous example. So it's checkbox, whether it's checked or not, what the title is.
1410560	1415840	But the thing that's actually interesting about this code isn't the shared part. The part that
1415840	1422480	they have in common is, like, whatever, seven lines. It's not very crazy. And the chances that
1422480	1427120	they're going to stay exactly the same between these two different chunks of code is very low.
1427120	1432640	So thinking, like, focusing on just this, like, oh, I've seen a checkbox before somewhere.
1433840	1437760	Like, doesn't really give you a lot in terms of the structure of your program.
1437840	1444000	So at this point, we have a pretty good fruit set going on, fruit.com, business is booming,
1444800	1452320	margins are good. Okay, but a new feature comes along, which is only two fruits can be selected.
1452320	1456240	We have all these folks out there who want, like, three fruits, six fruits even.
1457840	1460560	We don't have the distribution channels for that.
1461120	1468800	So we want to cap out at two fruits per person, you know, pick a favorite, like, pick a side.
1471360	1478800	So this is kind of a tricky situation we have found ourselves in. So we have this set,
1478800	1485280	and we kind of need to limit the size somehow. Oh, oh, there's one other constraint, which is
1485280	1494560	we need to check out a different fruit. No. Fruit's one, maybe. No.
1498880	1501360	Okay, I deleted a file that I should not have deleted.
1504160	1510480	But the thing that I wanted to show was we want to maintain the order that they were selected.
1510480	1515520	So if I select apple, then apricot, then banana, I want the oldest thing to be the one that's
1515520	1520400	forgotten. So I want to keep the most recently selected as I go through things.
1523760	1529120	So with a set, it's really hard to keep track of what was the order that things were added. We
1529120	1533280	can remove one of the things, but we don't know which of the two it was. You'll get this very
1533280	1541280	wonky behavior. So at this point, we can ask, well, maybe it'd be good to think about the
1541280	1546160	data structure we're using. So we want to choose two fruits in particular. So maybe we say, okay,
1546160	1552640	so I'm going to choose a string and a string. But what happens when nothing's selected? We
1552640	1556720	need to account for zero selections, one selection, two selections. So that's no good.
1557440	1559200	Maybe we can say maybe string.
1562720	1568400	So all of these can be optionally selected. But there's this weird case where if one thing is
1568400	1574080	selected, we don't know if it's going to be the left or the right thing. So this doesn't seem great
1574080	1583840	either. So maybe we can say, okay, there should be this type two, and it's either zero or one
1584560	1591360	or two. Okay, that's pretty nice. You can imagine inserting into zero, you go to one,
1591360	1596560	inserting into two, and then in two, you maintain some order moving things along.
1598080	1602640	And that design seems okay, but we know head of fruits marketing.
1604000	1607280	He's going to say, okay, well, in tropical areas, we can actually give them more fruits,
1607280	1612640	so they're going to want a limit of three. But in Iceland, they only get half cucumbers there.
1612640	1614960	That's just the rule. I don't know. That is actually how it works.
1617680	1621600	So we're probably not going to be able to just stick with two. There may be some
1621600	1625920	places where we need three or different limits. So another way we could do this is just a list
1626560	1632160	of string and then limit the size. So essentially add to the front and take things,
1632160	1639200	drop things off the back. So I don't know. It doesn't seem perfect. Clearly, you can just add
1639200	1645120	20 things to it. But it sort of has potential. So let's explore that route.
1648080	1652960	So instead of this being empty, this is an empty list. Oops.
1656640	1662320	The cursor just disappears. Anyway, so when we select something, we want to say
1662800	1673520	list.take2 fruit on the front of our selected list. So this is saying, put the fruit on the
1673520	1676880	front and then just take the front two. So whatever else is there, we'll drop it.
1679840	1688640	And then when we deselect, we can say list.filter. The fruit should not, any fruit,
1688640	1695120	that's not the one we, that's a lot of nots in one sentence. We want to only keep fruits.
1697760	1701680	You get it. We want that fruit to be deselected.
1704480	1713680	And then in our checkbox code, we want to say and said list.member. And I think that's everything
1714240	1720720	except we don't need that anymore. Okay. So let's see if I did this right.
1723920	1729040	Hey. And so you can see it's maintaining the order that I clicked things. So if I,
1731440	1735360	I don't know, it's kind of hard to remember. It's easy if you go in order and you can see.
1735360	1741520	It's working nicely. Okay. So we're maintaining our two fruits per person situation. But when
1741520	1749520	we come look back at our update code, it's getting, it feels like trickier, right? And as we grow
1749520	1759920	fruits.com, like maybe someone won't realize the take two is not, oh, just some fine choice. It's
1759920	1764560	like, head of fruits marketing decided that was two and you can't change that stuff. So we want
1764560	1770400	to have some more security around this code. So one way we can do that is to start to break out
1772480	1779440	the particular stuff around that data structure. So we, we know there's this selection list.
1779440	1781520	We can make a function that is
1781600	1796880	along these lines. So let's do it in the update part. Insert, oops, insert fruit list.
1802240	1805120	I'm going to leave off types for now just for speed.
1806080	1816240	And then I can say here, insert fruit. And then I can also say remove fruit from the list.
1817440	1818640	And we'll do it the same way.
1826720	1830800	So this code gets a bunch simpler as well. Remove fruit.
1831760	1838800	And we can do the same thing with the checking for membership below. Now at this point it's sort
1838800	1844720	of coalescing into, oh, there's this kind of data structure that's specifically about maintaining
1844720	1851200	just two things in, in the list. So I'm going to check for time to see how much live coding I should
1851200	1860400	do. Okay. Well, let's, let's start to follow this idea of like, we're starting to recognize
1860400	1866560	a data structure. So let's try to break that out. So I can say fruit list.
1869680	1874080	And I have this type alias fruit, selected fruit.
1874640	1885280	So we're starting to see the, the beginnings of a, of a module, like things that we can
1886400	1892000	box off and put in their own place. So I'm going to just skip ahead to a version of this
1892000	1897840	in a different module. So the ideas, we have this thing called a bounded set.
1898560	1902960	And yeah, no, I shouldn't skip ahead to this. That was a bad idea.
1906000	1909200	So let's say, okay, we have this and we were going to put it in a new module,
1909200	1916160	the selected fruit module. Exposing
1916160	1931680	a selected fruit. And then in our fruits module, we can get rid of that. And we can import
1936880	1940080	as selected fruits. And then
1940400	1951280	we just have to go through and make a couple changes here. Oh, we'll come back to that.
1955120	1962400	Selected fruit, that insert, remove, et cetera. So this is also selected fruit.
1963680	1968400	We're kind of leaking details here. Okay. Let's see it. Okay. Check. Does this work? No.
1969200	1974240	Selected fruits. It's singular.
1984320	1991600	There's also a stray print. Spelling.
1998880	2001680	It's nice that, yeah. Oh, geez. What the heck?
2006320	2021760	Okay. Just imagine there wasn't a compiler there. Or just like, maybe that's wrong. I don't know.
2022720	2028880	Okay. So this is still working. But we can kind of improve things by sort of closing down this
2028880	2034080	module. Right now, we're exposing everything. But we could do better by saying, okay, from the
2034080	2042000	outside, no one knows how selected fruit is implemented. It happens to be a list of string,
2042080	2053440	but no one needs to know. So we have to do a little bit of selected.
2055840	2059200	I'm disenchanted with this naming choice.
2059200	2072240	Okay. So now, from the outside, no one knows how the particulars of this are implemented.
2072800	2075120	So let's just run it. This is supposed to not work.
2078480	2083840	So we're using list.member on a selected fruit, but we don't actually know the
2083920	2090240	implementation deals of that anymore. And our selected, we're saying it's a list,
2090240	2095440	but we don't have access to that information anymore. So we need to add, how do I make an
2095440	2107680	empty selected fruit? And that would be selected fruit is empty. And then we need to test for membership.
2114720	2121040	And then we can just say list member fruit list.
2124880	2127680	Oh, it's still broken because they didn't actually change the broken code.
2129680	2135920	So here we say selected fruit is empty. And then member, we say selected fruit member.
2136560	2146720	Cool. So now we've sort of hidden all these implementation details, but we can do slightly
2146720	2154560	better. So maybe we want to make a guarantee about the size in this data structure. So we can say
2154560	2158640	we'll actually give the maximum size when we say it's empty or not.
2158880	2170080	And then in all these cases, max size. So instead of taking two, we take the max size.
2174080	2181280	And instead of removing, no, we do keep this the same, but we just have to keep the max size
2181280	2185440	around. And then here we don't care about the max size. We just want to check.
2186720	2192400	So we should have an error because we're just calling empty without saying how big it should be.
2196480	2202880	Two. All right. And then things should work again. Cool.
2205280	2210480	So at this point, we sort of taken all this complexity around maintaining the only two
2210480	2215520	things are selected and put it in its own module. So the benefits of this is that when I'm reading
2215520	2222320	through my normal code, all I know is there's some way to select fruits. I can say how many.
2223200	2228320	And then I can insert and remove. And these things will just work out nicely. And I can check if
2228320	2234960	something is a member of that. So you can go one level crazier with this, which we shouldn't get
2234960	2241120	into, but you can. So the idea was you could generalize it so that it's a list of anything,
2241120	2246080	not of strings or particular fruits. And then everything works the same, right? You choose
2246080	2251200	the size. You can insert things into it. You can remove things from it. You can check membership.
2251760	2257920	So all of these designs are possible. And the question is, which one is right for your situation,
2257920	2262080	right? Should you go like, all right, I'm writing my own data structure that's generic in all
2262080	2266880	sorts of things. And I'm going to optimize it. Or is it like, look, it's just a list. It's not a
2266880	2271280	big deal. We're probably not going to get it wrong. And so that depends on what's likely to happen.
2271840	2278320	Maybe at fruits.com, you'd make one choice. But at the new fruit stand startup, I don't know,
2278320	2288160	they want to make different choices. Okay. So the big lesson here is that we started with two things
2288160	2293600	that look basically the same and ended up with entirely different ways of approaching them.
2293600	2298080	That was all about the data structure, right? And it is true that they share checkboxes, but that's
2298080	2303120	such a small fraction of the actual difficult things that are going to happen in your code
2303120	2310560	that it makes sense to emphasize the data structure instead. So I want to put a little extra emphasis
2310560	2318640	on the module, right? So I showed this bounded set idea and it had, there's a bounded set.
2319440	2324800	If it's empty, you can insert things into it. You can remove things from it. You can check
2324800	2332080	membership. Now, the most important part of this module is the exposing line. Okay. So I'm not
2332080	2336800	exposing everything in this module. And specifically, I'm not exposing the implementation of bounded
2336800	2343520	set. So no one from outside can mess with the maximum size. And as long as these functions work,
2344240	2349520	things are going to work. So I want to point out two little benefits that come from this.
2349520	2356960	So if you reduce the public API to your module, if the implementation is hidden and if the public
2356960	2364480	API works, the code works everywhere, right? So if I try to break this code by messing with
2364560	2371440	these functions and I can't do it, anyone else who uses this code won't be able to do it either.
2372400	2376960	So this is actually really nice for testing because it means you can test the public API
2376960	2381280	very extensively. And that doesn't mean you have to test every particular usage, right? Using
2381840	2385520	this data structure somewhere doesn't mean I can introduce bugs into that data structure
2385520	2390480	retroactively. If it works, it's going to work well. The other thing that's nice is you get
2390560	2396880	it easier refactoring. So I can change how things are implemented without worrying what's
2396880	2402080	going to happen outside. And this happens in a couple ways. One is say there's an insert help
2402080	2408880	function that's doing some extra special stuff. I know that it's not exposed outside, so I can
2408880	2414800	mess with that. Arguments, add arguments, change shuffle things around and be sure that this is
2414800	2418720	not going to have any effect in any other modules. I'm not going to have to go hunt stuff down.
2419360	2424320	That's also nice because it means I don't have to worry about if it's used in 10 different
2424320	2430000	places across the code, did they need it to work in a very particular way in each of those cases?
2430000	2434880	And I'm covering all those cases. I can just say, oh, it's not publicly exposed. If it works in
2434880	2443360	this file, it works. So the other thing that you can do by creating modules in this way is maintain
2443360	2449280	invariance. So in our case, that's only two fruits. But generally speaking, this means there are
2449280	2454960	rules that cannot be enforced entirely through data structure design. So we had our two, which is
2454960	2460720	zero, one or two, but that wouldn't let us decide how many we want. So we now have a data structure
2460720	2466720	that can let us decide. And by hiding all the details, we can still maintain that rule in a
2466720	2471600	safe way, even though we can't do it purely through data. And one cool thing about finding
2471600	2477680	invariance like this is that they're excellent for fuzz tests. So I know that whatever I do with
2477680	2483200	this, if I say my bounded set has two things, no matter how many times I call insert, it should
2483200	2489280	just have two things. So by thinking in this way, you also set yourself up to write tests that
2489280	2495600	are nice and are checking the kinds of things you're worried about. So I want to add some warnings
2496160	2503840	to this advice. So first, if you find yourself writing get and set, right, so we hid the max
2503840	2508560	size, but maybe someone's like, well, I want the max size. I won't do a bad thing with it.
2510480	2515280	Okay, this is a bad sign. This is a bad sign when you have get and set. So the whole point of having
2515280	2520720	a module was that we were able to hide implementation details and say, if you use this public API,
2520720	2524720	it will work. And inside, you don't have to worry about that. We tested it. We know it's good.
2525840	2534000	Setters, their whole point is to expose those details. So you've done all this work to put
2534000	2538080	it in a module, and we went through that together. It was like, it took too long.
2542800	2549360	And now you're going to give setters that just totally defeat that entire exercise. So just use
2549360	2554000	a record if you have data where you want people to have access, rather than hiding the details,
2554000	2560000	then exposing get and setters. It's like, these details aren't hidden. So don't do the work to
2560000	2566240	hide them. So another way to say this is expose as little as possible, but no less. Some things
2566240	2571440	do need to be publicly available. So this shouldn't just be like, hide everything. That's better.
2573040	2579680	The other thing is don't overdo it. So I'd wait until I have a problem in practice,
2579680	2584720	and then solve that problem. So the goal shouldn't be let's just write modules, because modules help
2584720	2590160	with this kind of stuff. It should be, hey, I'm having trouble understanding this code. I came
2590160	2594960	back to it after a month, and it seemed kind of confusing. Maybe I can find parts that I can
2596080	2603040	make things nicer. So if you find yourself asking, how do I make the sidebar reusable? Okay, try to
2603120	2610720	remember to ask yourself why. Are you going to have multiple sidebars? Maybe not. In which case,
2610720	2616640	like, why would you do the work to do that? If you are going to have multiple ones, a thing to
2616640	2623120	think is, are these cases the same, or are they similar? If we're just talking about the HTML
2623120	2627120	is going to look similar, but how it works behind the scenes is fundamentally different in both cases.
2627920	2633920	I think it's probably not a good idea to, like, try to get all into how do we share code between
2633920	2639600	these two. Focus on the data structure instead. Another thing that might happen is as you're
2639600	2644560	growing your record, you don't have any interesting types. You don't have that autoplay thing where
2644560	2649120	these fields are dependent on that field. It's just a bunch of independent stuff.
2649360	2657520	If they're all independent, there's no problem. If I just have fields that have no relationship
2657520	2663040	to each other, and I change one, there's not a chance that there's some bug elsewhere. But if I
2663040	2667600	do have that relationship, that's a potential to start finding a data structure and do better
2667600	2673360	modeling. So I'd say, like, don't be afraid to just grow your record and try to find these
2674240	2680320	connections and how things fit together, as opposed to preemptively, like, ah, I'm worried
2680320	2687280	about this code, so I'm just going to change it. So, yeah, just as there's premature optimization,
2687280	2693200	there's premature refactoring. It's a thing, it's fun, right? It's like you get to play
2693200	2701760	code golf at work. I don't think employers should encourage that, but people like to do it.
2703520	2714160	Okay, so to take a step back, we saw how a file tends to grow, right? And if we focus on
2714160	2719120	the data structures, we end up with these nice categorizations where, like, when I'm searching
2719200	2724000	through a code base even, I say, hey, where's that stuff that's related to books? It's probably in
2724000	2730000	the module about books, right? As opposed to, well, there's this update subdirectory, and all the
2730000	2737440	update code is there, and the book stuff is just like, it's related to books. So, yeah, so big
2737440	2741840	lessons are focus on data structures and choose the best representation available. So, like,
2741840	2746800	actually think through as many cases as you can, and the others build modules around types
2747360	2757200	and try to expose as little as possible, but no less. So, yeah, so I hope this will be a nice
2757200	2765760	next advice in the, how do I grow my Elm code? And one of my goals was to write this up. So,
2765760	2772880	I actually started a book that is about functional programming in Elm, and the goal of this book
2772880	2776720	was essentially to write this talk so that people could read it online and it would work out.
2777440	2783360	It turns out it's very hard to write that whole live coding section. So, instead, what I ended
2783360	2790000	up with is some nice stuff about recursion and graphs. It's fun. Hopefully, I'll be able to
2790000	2794960	distill this down into another chapter that actually emphasizes these things in a way where you
2794960	2812000	don't have to see the live talk. But, yeah, so that's the life of a file. Thank you.
