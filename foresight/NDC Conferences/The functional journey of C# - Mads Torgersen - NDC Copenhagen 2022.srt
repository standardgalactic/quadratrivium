1
00:00:00,000 --> 00:00:08,760
Wow, let's see. It recognizes me even with this fancy mic on. So, Windows Hello, yay.

2
00:00:08,760 --> 00:00:16,560
Doesn't it? Or did it just, like, turn off? It wants, no, it didn't. It wants a pin. At

3
00:00:16,560 --> 00:00:24,600
least it's not showing you my pin. There we go. Okay. This is my intro slide. My name

4
00:00:24,600 --> 00:00:34,280
is Mess Torgerson, or Mess Torwassen, or Mutz Torgerson, or something like that. I

5
00:00:34,280 --> 00:00:38,680
know we didn't friends out there are going to kill me. They're going to take a blue

6
00:00:38,680 --> 00:00:47,240
sharpie to that one after. So, I work on the C-sharp language every day for Microsoft.

7
00:00:47,240 --> 00:00:53,480
It's a great job. I wish you could all have it, but it's mine. So, and I've done that

8
00:00:53,480 --> 00:00:59,440
for a very long time. So, that means I remember things that nobody else remembers, almost.

9
00:00:59,440 --> 00:01:06,160
Except for Anders, as we call him, who was there from the beginning. I was not. I was

10
00:01:06,160 --> 00:01:12,240
a latecomer. I've only been there for 17 years. But it is an old language. We are now working

11
00:01:12,240 --> 00:01:20,520
on C-sharp 11, and there's a whole other talk about C-sharp 11 a little later today. So,

12
00:01:20,520 --> 00:01:28,600
I decided I want to talk about C-sharp 1 through 10 today. It's from the angle of how

13
00:01:28,600 --> 00:01:34,120
has functional programming influenced C-sharp over the years. I'm hoping that's interesting

14
00:01:34,120 --> 00:01:37,160
to you. Otherwise, that's a lot of people I'll be disappointing today, because it's

15
00:01:37,160 --> 00:01:42,360
a very full room. I don't know how many are out there, but you can still run without me

16
00:01:42,360 --> 00:01:49,640
noticing unlike these people in here. So, I think it's interesting, because C-sharp started

17
00:01:49,640 --> 00:01:58,000
out as a fairly typical of its age, fairly straightforward object going into imperative

18
00:01:58,000 --> 00:02:02,560
programming language. That was how it started. They didn't kind of just pull that out of

19
00:02:02,560 --> 00:02:08,240
the blue, of course. There were other languages around at the time that were similar. That

20
00:02:08,240 --> 00:02:15,360
C-sharp might happen to look a little like, by accident. But that was sort of like the

21
00:02:15,360 --> 00:02:20,600
game of the day. So, C-sharp was typical of the day, and kind of pretty much took almost

22
00:02:20,600 --> 00:02:26,600
all the functional things in along the way as they became relevant to how we do programming.

23
00:02:26,600 --> 00:02:30,920
So, I'm going to go through that same evolution essentially today and point out some of the

24
00:02:30,920 --> 00:02:35,160
different ways. I'll try to make some general points about programming language paradigms

25
00:02:35,160 --> 00:02:39,760
and so on along the way. But it's all going to be a little bit, I'm going to do it all

26
00:02:39,760 --> 00:02:46,280
in Visual Studio. I'm just going to code along. And so, and I forgot to print out my demo

27
00:02:46,280 --> 00:02:54,240
notes. So, may I go astray? It'll be a little bit of a one-off. We do have an hour, which

28
00:02:54,240 --> 00:03:00,640
means that there's time for a few questions along the way, not like a million. But I don't

29
00:03:00,640 --> 00:03:05,880
want you to say, oh, I want to ask a question about that when he's done talking. Because

30
00:03:05,960 --> 00:03:09,920
by then, the code will look different. Nobody will remember what I was talking about. So,

31
00:03:09,920 --> 00:03:14,840
if you have a question, raise your hand and ask it. And I'll try to keep us on track. And

32
00:03:14,840 --> 00:03:19,080
hopefully I'll succeed. And that might mean that I will have to be a little rude and say,

33
00:03:19,080 --> 00:03:23,600
sorry, no more questions. Come back after. So, just don't be offended when I get to there.

34
00:03:23,600 --> 00:03:32,360
But until then, please just raise a question and ask. So, with that, without much further

35
00:03:32,360 --> 00:03:40,520
ado, let's start out with C-Sharp 1. And just kind of, for those of us who were around, remind

36
00:03:40,520 --> 00:03:48,680
ourselves of the state of the art of programming, at least in the industrial space in the year

37
00:03:48,680 --> 00:03:54,880
2000. And for those of you who weren't around, you can just go, thank God I wasn't around.

38
00:03:54,880 --> 00:04:01,720
I mean, you were probably around most of you, but maybe you were still doing Legos. Aren't

39
00:04:01,720 --> 00:04:09,960
we all really? So, what I have here is a fairly simple. It's a C-Sharp 1 program. I'm cheating

40
00:04:09,960 --> 00:04:16,320
a little bit because when it comes to features that aren't part of this talk, that aren't functional,

41
00:04:16,320 --> 00:04:20,160
I'm just going to use them a little bit anyway. For instance, my code is not in a main method.

42
00:04:20,160 --> 00:04:24,680
You don't need to do that anymore in C-Sharp. And it fits better on a screen if I don't. So,

43
00:04:24,680 --> 00:04:30,800
I'm not going to stick religiously to only C-Sharp 1 features. But in terms of functionality,

44
00:04:30,880 --> 00:04:39,800
I am. So, one thing to, talking about functional, C-Sharp started out with just a tiny little hint

45
00:04:39,800 --> 00:04:46,440
of, a tiny little concession to functional programming languages compared to other languages

46
00:04:46,440 --> 00:04:53,760
at the time. And with something that they, we call delegates, which is sort of kind of like a

47
00:04:53,800 --> 00:05:01,440
function type. They were actually part of some of the, the need for delegates was part of the

48
00:05:01,440 --> 00:05:05,520
reason why we couldn't do some other programming languages and got dragged into court and stuff.

49
00:05:05,520 --> 00:05:12,520
So, C-Sharp back then already had like a notion of a function type called delegate. And those are

50
00:05:12,520 --> 00:05:18,120
still the ones that we use for function types. They're flawed in various ways, but you know,

51
00:05:18,280 --> 00:05:23,640
once you've got something throughout the whole core libraries and so on, you don't go on and

52
00:05:23,640 --> 00:05:27,800
change it. So, delegate types were function types. It's like, you know, this is the type of a

53
00:05:27,800 --> 00:05:33,160
function that takes an int and returns a bool. And it's a name type, like a class. It is in fact a

54
00:05:33,160 --> 00:05:40,200
class. And we call it predicate. And now we can use it as a function type. So, I can have a method

55
00:05:40,200 --> 00:05:48,440
here, a function that takes a predicate. And it can call the predicate as the, you know, according

56
00:05:48,440 --> 00:05:54,120
to the function type. But, and when I want to pass an argument to it, well, we don't have anything

57
00:05:54,120 --> 00:05:58,280
like lambdas yet that we're going to get to that. We don't have like anonymous functions of any kind.

58
00:05:58,280 --> 00:06:03,320
But we do have, we, but you can sort of just mention a function that happens to have the right

59
00:06:04,040 --> 00:06:08,600
signature, like great than five. Hang on a second.

60
00:06:11,480 --> 00:06:16,280
Is it going to be like this all the way? How many typos are we going to have in here? There we go.

61
00:06:17,080 --> 00:06:24,360
I did get the wordle this morning. So, I'm not like totally, there we go. So,

62
00:06:25,960 --> 00:06:31,000
so you kind of have to declare a function, then pass it. You have to declare the function type,

63
00:06:31,000 --> 00:06:34,600
then use it. Like it's all very nominal and declarative at this point.

64
00:06:35,160 --> 00:06:41,560
But it gets the job done. Like pass the predicate in. Of course, there's no such thing as generics

65
00:06:41,560 --> 00:06:45,800
yet. They're the first thing we're going to learn from functional programming languages in a minute.

66
00:06:45,800 --> 00:06:53,160
So, you know, this was the name of the game. I do, you, in order to filter this, I need to

67
00:06:53,160 --> 00:06:58,760
gather up the results. The only, like I really wanted to return an array because that's the only

68
00:06:58,760 --> 00:07:02,920
generic type I have. It's the only type that actually has an element type. So, that's, so you

69
00:07:02,920 --> 00:07:08,040
kind of, you kind of encourage to trade in arrays, horrible as that is, because otherwise you have

70
00:07:08,040 --> 00:07:14,280
no type safety. But we do have other collections. They're just all over object. So, and, and I need

71
00:07:14,280 --> 00:07:17,560
to create one of those to gather up my elements because I don't know how many are going to

72
00:07:17,560 --> 00:07:21,800
succeed yet. I don't know the size of the array to allocate. So, first I gather them up, then,

73
00:07:21,800 --> 00:07:26,360
you know, I know how many I have, then I can allocate an array that's strongly typed to int,

74
00:07:27,080 --> 00:07:33,480
then I have to stick all the elements that I found into the array. And as I'm doing so,

75
00:07:33,480 --> 00:07:37,720
I have to cast them to int because I know they're all ints, but the compiler has no idea. It's like

76
00:07:37,720 --> 00:07:42,040
you stuck, you give me a bunch of stuff, you're taking them out, all I can see is object.

77
00:07:43,800 --> 00:07:47,720
So, you know, you die a little inside every time you have to cast things coming out of

78
00:07:47,720 --> 00:07:51,320
collections. How many people in here remember that from like either C'sharp or some other,

79
00:07:51,320 --> 00:08:00,280
like Java or, yeah, out, yeah. So, what, I think what we very quickly felt all of us was,

80
00:08:02,120 --> 00:08:06,040
and with C'sharp, it was already like coming to version two, which we're coming to version two now.

81
00:08:07,000 --> 00:08:11,880
We felt like, okay, this is not, this is not like a satisfactory state of affairs.

82
00:08:13,000 --> 00:08:15,560
It's not the abstraction capabilities aren't good enough here.

83
00:08:16,920 --> 00:08:20,600
Some other languages that had been around for longer, it took them a little longer to get to

84
00:08:20,600 --> 00:08:24,840
that point. So, it ended up that, for instance, Java and C'sharp got generics, which is where we

85
00:08:24,840 --> 00:08:28,760
coming to now at around the same time. And I was actually back then, I was on the other side of

86
00:08:28,760 --> 00:08:34,920
the fence helping out with generics and Java. So, I saw it from the other side. Still think

87
00:08:34,920 --> 00:08:43,000
Microsoft and C'sharp did it better. So, this really comes down to sort of one of the fundamental

88
00:08:43,560 --> 00:08:47,000
differences between functional and object-oriented programming.

89
00:08:47,960 --> 00:08:53,720
You know, in classic imperative programming, there really is no polymorphism. There's no

90
00:08:53,720 --> 00:09:01,080
way that you can write code that applies to more than one type. Object-oriented programming and

91
00:09:01,080 --> 00:09:05,160
functional programming, to a large degree, are two different answers. At least when they're typed,

92
00:09:05,160 --> 00:09:09,720
they're two different answers to, how do you get polymorphism? How do you write code that

93
00:09:09,720 --> 00:09:14,120
works for more than one kind of thing? In object-oriented programming, we went with what's

94
00:09:14,120 --> 00:09:19,080
often called subtype polymorphism, which means everything is a subtype of something that's a

95
00:09:19,080 --> 00:09:23,960
subtype of something that all goes back up to object. So, that's what we're seeing here. Now,

96
00:09:23,960 --> 00:09:29,720
you can write a collection like ArrayList here that can contain anything. So, there's polymorphism

97
00:09:29,720 --> 00:09:36,520
in that sense. And the great thing about subtype polymorphism is it's very easy to have heterogeneous

98
00:09:36,520 --> 00:09:42,840
collections, for instance. You can put all kinds of things in the same collection. As opposed to

99
00:09:42,840 --> 00:09:50,440
functional programming, they went with what's called parametric polymorphism, where you have an

100
00:09:50,440 --> 00:09:58,920
extra type parameter on things that, you know, sort of like a placeholder for one type. So,

101
00:09:58,920 --> 00:10:03,720
you don't get to mix and match the types inside. You get to say that there's this one type that

102
00:10:03,720 --> 00:10:08,760
I'm going to give you later, and then it'll work for that type only. But it's still polymorphic,

103
00:10:08,760 --> 00:10:13,720
because you can give different type arguments in different places. And that has the benefit that

104
00:10:13,720 --> 00:10:21,000
you can, because that type parameter has a name, you can have things sync up so that the same type

105
00:10:21,000 --> 00:10:25,800
name, the same type parameter appears in multiple places, and you can sort of say, well, whatever

106
00:10:25,800 --> 00:10:29,800
it is, the same kind of thing that comes in is the kind of thing that comes out, for instance,

107
00:10:29,800 --> 00:10:34,280
which is exactly what we need here, right? We need a collection, for instance, that has

108
00:10:35,240 --> 00:10:42,120
the same stuff coming in that's coming out. Enter generics, which is parametric polymorphism.

109
00:10:42,760 --> 00:10:46,600
Most object-oriented programming languages with types at this point say, okay, let's embrace

110
00:10:46,600 --> 00:10:53,240
that too, so we have both kinds in the language. So, that's sort of one of the first big imports

111
00:10:53,240 --> 00:10:59,800
from the functional space. So, let's do that. Now, let's see, where do we start?

112
00:10:59,880 --> 00:11:08,360
Now, we can have, well, instead of a RayList here, we could now use the new fancy generic

113
00:11:08,360 --> 00:11:13,720
collections that we have, and I'm cheating and having the imports in another file, so either

114
00:11:13,720 --> 00:11:20,360
using, so you don't have to bother with that. So, we can say list of int here instead is a new list

115
00:11:20,440 --> 00:11:30,280
of int, and now, as I'm gathering things up, it should be graying out this. I know that my

116
00:11:32,680 --> 00:11:39,480
destination here is actually a list of int and not just a list of whatever, and so I can now get

117
00:11:39,480 --> 00:11:47,240
rid of this cast of death. Back in business. Somebody wrote a generic collection for us,

118
00:11:47,240 --> 00:11:55,640
we can use it. But, of course, now, there are other, I can write generic things too. Maybe I

119
00:11:55,640 --> 00:12:01,800
want my predicate type to be more general. Maybe I don't actually want to write new delegate types

120
00:12:01,800 --> 00:12:08,840
for everything all the time, so maybe we could say predicate of t and have it work for all t's

121
00:12:08,840 --> 00:12:14,920
and not just for ints. It still returns bool, but I can, I now have a generic predicate type,

122
00:12:15,000 --> 00:12:18,840
and I can then here say, well, it's actually here, it's a predicate of int that I want,

123
00:12:18,840 --> 00:12:23,480
and boom, things don't work, or we can, we could actually go a step further and say,

124
00:12:23,480 --> 00:12:29,000
well, filtering isn't really particularly about ints, is it? And now we can write our own generic

125
00:12:30,200 --> 00:12:37,640
function, a method that is a filter of t, and now we get to, say, t in all the places,

126
00:12:37,640 --> 00:12:44,120
it's actually a predicate of t coming in and an array of t, and I'm returning an array of t,

127
00:12:44,200 --> 00:12:48,840
and in all the other places where it says int, except one, so you have to be a little careful,

128
00:12:49,560 --> 00:13:03,480
here, here, here, where else? The int result, of course, and, you know, so now I've completely

129
00:13:03,480 --> 00:13:07,240
generified the thing, and this is the int I shouldn't replace, because that's the counter for the,

130
00:13:07,240 --> 00:13:11,880
you know, filling out the array, so that's why I didn't just do a search replace here.

131
00:13:12,840 --> 00:13:17,320
So there we go, now we, all of a sudden, we've generified a thing, it's fully strongly typed,

132
00:13:17,960 --> 00:13:22,600
as if it was for a specific type, but now you can apply it everywhere, and the full,

133
00:13:22,600 --> 00:13:30,760
like, generic, generification is a strong, strong tool, and it, the, there were some, like,

134
00:13:31,720 --> 00:13:37,400
choices made in the different languages at the time that, that actually were imbued with destiny,

135
00:13:37,400 --> 00:13:43,240
even much more than we realized at the time. In Java, we, on the, I was over here, in the

136
00:13:43,240 --> 00:13:53,560
Java side, sorry, camera person, we, we were, we decided we couldn't change the JVM, the runtime

137
00:13:53,560 --> 00:13:58,760
under Java, because it was, you know, too entrenched, and how you couldn't control, like, what,

138
00:13:58,760 --> 00:14:04,200
but Java runtime they had out there, so, so all the generics in Java was done in the compiler by

139
00:14:04,200 --> 00:14:09,800
erasure, which means, you know, there wasn't any generics at runtime, it was just there

140
00:14:09,800 --> 00:14:14,600
in the code for as much type checking as you could get, but that meant that there were some

141
00:14:14,600 --> 00:14:19,160
things, like reflection and so on, that didn't embrace it, and there were certain, certain

142
00:14:19,160 --> 00:14:25,480
holes in the experience, essentially. And whereas in, in .NET, and, and C Sharp, we went all out

143
00:14:25,480 --> 00:14:32,680
and said, yes, generics goes into the runtime, and is shared across all the languages at target.net,

144
00:14:32,680 --> 00:14:34,920
and it's a real runtime thing. Question.

145
00:14:44,920 --> 00:14:50,280
So, to repeat the question for the, for the mic, when did we know that we wanted generics in C

146
00:14:50,280 --> 00:14:59,160
Sharp? So, I wasn't there, but I kind of was, because in 99, I was an intern, I was doing my

147
00:14:59,160 --> 00:15:04,200
PhD, I was an intern at Microsoft Research, Cambridge, which is where Don Simon is, if anybody

148
00:15:04,200 --> 00:15:08,920
has heard of him, the father of F Sharp, and there were a bunch of language people there,

149
00:15:08,920 --> 00:15:14,840
so I got actually to be privy to decisions that were secret for a number of years, and I was under

150
00:15:14,840 --> 00:15:20,360
NDA until, until things came out, and they were already talking about .NET, they weren't calling

151
00:15:20,360 --> 00:15:24,840
it that at the time, and they were already talking about generics for it, and decisions were made

152
00:15:24,920 --> 00:15:31,080
that it would take too long to make it work right, and we should have a version without it first.

153
00:15:31,080 --> 00:15:37,080
So, yeah, that, that, I think that answers your question precisely, so it was always felt that

154
00:15:38,120 --> 00:15:45,000
that we're gonna, we're gonna need to do this, and indeed, generics was, was the, pretty much the

155
00:15:45,000 --> 00:15:52,200
almost the only and, and last thing that language feature that was added to the runtime for a very

156
00:15:52,200 --> 00:15:57,400
long time, because after that .NET became popular, it was Windows component, and so we had the same

157
00:15:57,400 --> 00:16:02,920
problem as Java, as the one causing Java to not do it in the runtime, which was too many people

158
00:16:02,920 --> 00:16:07,320
have it installed, we don't know which version of Windows they have, we have no way of, you know,

159
00:16:07,960 --> 00:16:13,160
making sure that they have the right runtime features that we are compiling for, so we stopped

160
00:16:13,160 --> 00:16:17,320
doing language features in the runtime after that for a very, very long time, now we're doing it again,

161
00:16:18,280 --> 00:16:27,560
and we might get to one at the end, so that's generics, and let's see if I can get back on

162
00:16:27,560 --> 00:16:34,520
track here, so it's, well, that's not generics, that's not all there is to say about generics,

163
00:16:34,520 --> 00:16:42,920
because once you get these, like, very lovely generic collections, for instance, they can have

164
00:16:43,000 --> 00:16:48,040
smarter, they can have smarter types, smarter methods as well, they can have generic methods,

165
00:16:48,040 --> 00:16:53,960
so instead of, instead of like doing this, building this result array myself, I could just actually

166
00:16:53,960 --> 00:17:01,240
take that dst thing and just call to array on it, because now it knows its element type and you

167
00:17:01,240 --> 00:17:09,800
can build an array of the right, of the right type, namely t, you also notice, so which means I can,

168
00:17:09,800 --> 00:17:15,640
I can delete these two lines of code, I don't need that anymore, so many more utilities now,

169
00:17:15,640 --> 00:17:25,080
strongly typed utilities become available, and one last thing to notice is that when I'm calling

170
00:17:25,080 --> 00:17:30,440
the generic method here, I'm not passing a type argument, you need to pass a type argument to,

171
00:17:30,440 --> 00:17:35,400
to the, to generic types, but not to generic methods, and that again is a thing that type

172
00:17:35,400 --> 00:17:40,600
inference is something that we start stealing from functional programming languages, we can't do

173
00:17:40,600 --> 00:17:44,440
as much type inference in object-oriented programming languages as you can in a functional

174
00:17:44,440 --> 00:17:50,280
language because of the subtype polymorphism, it means that you can't actually, there are many

175
00:17:50,280 --> 00:17:54,440
places where you can't know the exact type, where you could if you didn't have subtype polymorphism,

176
00:17:54,440 --> 00:17:58,360
so we can't go all out on, on type inference, which is probably all the same because it's

177
00:17:58,360 --> 00:18:03,320
confusing to a lot of people, it's a quiet taste, so, so we kind of, we have to strike a balance

178
00:18:03,320 --> 00:18:14,040
there, but it certainly makes sense here, so with that lovely generics, we, we can also get out of

179
00:18:14,040 --> 00:18:21,640
this addiction to, to arrays as the, as kind of like the, the, the currency of collections

180
00:18:21,640 --> 00:18:26,920
being passed around, because arrays are, you know, they're very low-level, fixed size, they

181
00:18:26,920 --> 00:18:32,040
expose too much, they're unsafe in various ways because you pass your array to someone and they,

182
00:18:32,040 --> 00:18:35,480
they're messing with it while you're watching it somewhere else, and you know, that's just, you

183
00:18:35,480 --> 00:18:41,880
know, nasty, so we can start having other interfaces, for instance, that are, that are more

184
00:18:41,880 --> 00:18:51,560
suitable, so, Ionumable of T is a good one, I can return Ionumable of T as well here, and,

185
00:18:53,960 --> 00:18:58,760
and I don't even have to say to array, I can, but I don't have to say to array because, of course,

186
00:18:58,840 --> 00:19:02,120
a list of T is also an Ionumable, so, you know, things get simpler.

187
00:19:04,600 --> 00:19:09,960
We could do one better, actually, we, we also, well,

188
00:19:11,400 --> 00:19:14,920
oh, but, well, it's because I'm saying, in the array here, yeah, yeah, I have to,

189
00:19:15,720 --> 00:19:18,600
I have to just make all the changes, okay, so,

190
00:19:19,160 --> 00:19:23,800
oh, Eint, thank you.

191
00:19:26,360 --> 00:19:30,520
Say, are you developers or something? It's like, it's like you, it's like you understand what I'm

192
00:19:30,520 --> 00:19:40,760
saying. Hey, I also debugged something once, you know, it's fun, so, so, so far so good, we,

193
00:19:41,480 --> 00:19:45,560
one thing we actually decided was, now we have Ionumable of T, it's like a very,

194
00:19:45,560 --> 00:19:51,080
in abstraction over just sequences of data, we're going to meet this a lot more in C-sharp 3,

195
00:19:51,080 --> 00:19:55,960
but already in C-sharp 2, we were like, actually, the compiler could help a lot with this kind of

196
00:19:55,960 --> 00:20:00,600
work here, of producing Ionumables, because they don't have to be produced eagerly,

197
00:20:00,600 --> 00:20:04,040
they don't have to have all the elements pre-computed, they can actually sort of

198
00:20:04,040 --> 00:20:08,280
be lazy and compute things along the way, and we can build a language feature to help with that,

199
00:20:08,280 --> 00:20:12,920
and that's what we call iterators in C-sharp, they're called generators in some other languages,

200
00:20:12,920 --> 00:20:18,120
which is essentially write a function, and then once in a while you say, oh, here's another element

201
00:20:18,120 --> 00:20:21,880
for the result, and then you compute some more, and then, or here's another element for the result,

202
00:20:21,880 --> 00:20:27,320
and it actually gets executed lazily, up to every one of those points, you just pause and,

203
00:20:27,320 --> 00:20:32,040
and give the result back, and then the next time the consumer asks for a result, they come, you

204
00:20:32,040 --> 00:20:36,920
know, execute some more, so that's iterators in C-sharp, that means we don't even need like an

205
00:20:36,920 --> 00:20:45,800
accumulator, we can just say, if that thing, you know, just yield return the value, I'm not

206
00:20:46,600 --> 00:20:51,640
super excited about the syntax we chose there, I will just say I was not around,

207
00:20:53,720 --> 00:20:58,360
we liked keywords a lot still back then, we kind of do still a little bit, and now I'm,

208
00:20:59,000 --> 00:21:06,040
you know, that's it, that's the filter method, you know, you cycle through,

209
00:21:06,120 --> 00:21:11,400
you yield return something, if you decide that, hey, let me do that, and that's it, right, so boom,

210
00:21:11,400 --> 00:21:18,680
very nice. Also in C-sharp too, we're like, hey, we've heard about lambda expressions,

211
00:21:19,400 --> 00:21:26,760
let's do not that, something similar, let's have anonymous functions, why do you have to declare

212
00:21:26,760 --> 00:21:31,560
all the functions that you want to pass, that's just like a pain, let's get rid of all these

213
00:21:31,560 --> 00:21:36,760
declarations and stuff, so instead of saying greater than five here, what if I could just

214
00:21:36,760 --> 00:21:41,960
write the function with the body and everything in place here, so we come up with an elegant

215
00:21:41,960 --> 00:21:53,720
syntax saying delegate, delegate all the crap, there we go, beautiful, right, it's, well,

216
00:21:53,720 --> 00:21:59,800
we can laugh now, but you know, it's certainly an improvement, now, you know, I'm free to just

217
00:21:59,800 --> 00:22:03,480
come up with functionality and pass it along, and of course the compiler generates

218
00:22:03,480 --> 00:22:07,160
something under the hood that's similar to before, but hey, all languages do it like that,

219
00:22:07,160 --> 00:22:14,840
pretty much, so great, our first take on anonymous functions, now C-sharp three,

220
00:22:15,480 --> 00:22:19,880
now we have big ambitions, this functional thing has really gotten into our blood, and this is

221
00:22:19,880 --> 00:22:24,280
where I'm starting to be around, so I've witnessed more of this firsthand, so in C-sharp three,

222
00:22:24,600 --> 00:22:32,520
we want to, we want to solve querying once and for all, the functional languages can do it,

223
00:22:32,520 --> 00:22:37,720
we can do it too, so we want to mainstream functional approaches to solving querying,

224
00:22:38,280 --> 00:22:44,600
let's do that, and we have, filter is a great example, like it's a function that does querying,

225
00:22:45,720 --> 00:22:49,720
a one aspect of querying, we kind of have the generics in place to do this,

226
00:22:49,720 --> 00:22:58,680
why don't we, why don't we actually declare an even more general library of function types,

227
00:22:58,680 --> 00:23:06,680
and then we also declare a library of, of querying methods, and get all that stuff working,

228
00:23:10,040 --> 00:23:18,200
so we, so instead of just having predicate of t, we create a family, families of functions called,

229
00:23:18,520 --> 00:23:27,400
funk and action, funk for the ones that return stuff, so funk of t1, t result, or something like

230
00:23:27,400 --> 00:23:35,240
that, that take a t and return a t result, so that's what the funks look like, take a t1 here,

231
00:23:36,360 --> 00:23:40,520
and we just declare them in the core library, so I don't even have to do it here, they're available

232
00:23:40,520 --> 00:23:47,400
to everyone who wants to be a little bit functional, and we can just here, actually it doesn't

233
00:23:47,400 --> 00:23:52,600
predicate itself actually in the core libraries from back way, way back when, so it doesn't give

234
00:23:52,600 --> 00:24:00,120
me a red squiggle here, but let's say funk of t, instead to describe the function we're passing in

235
00:24:00,120 --> 00:24:10,680
here, and then instead of me writing the filter method as kind of a, one thing that you quickly

236
00:24:10,680 --> 00:24:14,920
find out when you want to, you want to query things is, hey I want to, I want to filter some more,

237
00:24:14,920 --> 00:24:19,160
for instance, I want to call query methods on top of query methods, so I could call filter twice,

238
00:24:19,160 --> 00:24:26,680
you know, I could say filter on the result of the first filter, comma, you know, some other

239
00:24:27,560 --> 00:24:35,080
delegate thing, and you know, it quickly becomes long, I should probably have done lambdas first,

240
00:24:35,080 --> 00:24:41,480
shouldn't I? I'm going to be doing more typing, okay, hold that thought, let me do, let me switch

241
00:24:41,480 --> 00:24:48,840
to lambdas quickly, we get better syntax, that's actual lambdas, you can do this, it's a little

242
00:24:48,840 --> 00:24:55,000
shorter, or we have, so this is still like a statement body there, or we can actually do

243
00:24:57,320 --> 00:25:02,200
just a single expression, and now it starts, it starts being a little expression oriented,

244
00:25:02,200 --> 00:25:07,880
like the functional languages, that's kind of exciting, but we still have the problem now,

245
00:25:07,880 --> 00:25:14,840
if I want to filter that one some more, I can say int, why, arrow, something, stuff,

246
00:25:15,880 --> 00:25:21,960
oh it needs to be in parentheses here, actually does it, you know, lambdas, you don't actually

247
00:25:21,960 --> 00:25:26,040
have to say the type, if it's given from context, you don't have to say it, that's kind of cool,

248
00:25:27,720 --> 00:25:33,800
but so why, I want to get the ones that are even, stupid example, but just, you know,

249
00:25:34,760 --> 00:25:45,160
equals zero, you know, I can compose my query methods, but it sucks, right, I'm composing sort

250
00:25:45,160 --> 00:25:51,080
of inside out, like this first stuff is in the middle, and then I'm slapping stuff on both sides

251
00:25:51,080 --> 00:25:55,400
of it, and it's completely unreadable, well what do the functional people do when they, I mean,

252
00:25:55,400 --> 00:25:59,320
they're doing this stuff, how do they do it, well they have pipelining operators, you can call

253
00:25:59,320 --> 00:26:03,320
functions like this, but you can also pipeline, so in a functional language, what you would do is,

254
00:26:03,320 --> 00:26:09,800
you would start out with the array on the left side, and then you would, so let me, let me do some

255
00:26:09,800 --> 00:26:14,920
horrendous doctoring here, you know, start out with the array, you would have some kind of pipeline

256
00:26:14,920 --> 00:26:19,800
operator, which we don't have in C sharp, and you pass it into filter, filtering the first thing,

257
00:26:21,240 --> 00:26:26,280
and that's just the implicit first argument for it there, and then you'd pipe that into

258
00:26:27,080 --> 00:26:33,560
filtering the second thing, and now you have things in the right order, they're sort of cascading

259
00:26:33,560 --> 00:26:39,240
beautifully in the order that you're doing them, it's kind of fluent, man, as we said, so,

260
00:26:40,920 --> 00:26:44,840
so that's, can we do something like that in C sharp, and that's where extension, we come up

261
00:26:44,840 --> 00:26:49,480
with extension methods, which is essentially just to solve this little problem in the beginning,

262
00:26:49,480 --> 00:26:54,200
where they turn out to be like extremely useful in extremely many scenarios, we're still being

263
00:26:54,200 --> 00:26:58,600
inspired by them, and we want to do more with them, where what you're saying is, we're just,

264
00:26:59,320 --> 00:27:06,360
what if you just pretend that the static method or this function is actually like a, and it's,

265
00:27:06,360 --> 00:27:14,200
I can't do it with a, I can't do it with just this method here, because it's not actually,

266
00:27:15,720 --> 00:27:19,160
it's not declared in a proper space, but we can do, the syntax is like this,

267
00:27:20,120 --> 00:27:25,560
we just pretend it's an instance method on the first argument, and now I can go and add

268
00:27:26,120 --> 00:27:31,880
method, what looks like instance methods to other people's types, and that kind of gives you that

269
00:27:31,880 --> 00:27:37,720
flow, so luckily, I don't have to like go in and do it properly here, because it turns out that

270
00:27:37,720 --> 00:27:42,920
method just like filter is being added to the libraries at the same time, and now we can just

271
00:27:42,920 --> 00:27:48,360
do the where stuff, so we can get rid of our own filter method and use the one that's part

272
00:27:48,360 --> 00:27:55,080
of the query library that we are now providing, okay, so we can break it up a little here, and now

273
00:27:55,080 --> 00:27:59,800
it starts to kind of look decent, right, now we have a select for projecting, because why would we

274
00:27:59,800 --> 00:28:06,840
call it project, we have various methods, I'll tell you why we call it select, that's because

275
00:28:06,840 --> 00:28:12,680
another place where you do querying is in, you know, SQL, which is also kind of functional,

276
00:28:12,680 --> 00:28:19,400
right, it's also just, there are aspects of SQL where it can mutate stuff and actually get

277
00:28:19,400 --> 00:28:23,960
things into the database, but the actual querying is functional too, and so we want to provide

278
00:28:23,960 --> 00:28:36,600
syntactic sugar for querying on top of methods like this, where you can say from value in,

279
00:28:36,600 --> 00:28:46,600
I should call them x, I like x, from x in array, where the keyword, where x is greater than five,

280
00:28:49,320 --> 00:28:57,160
and where something else, where y, let's call it x again then, because we are now using the

281
00:28:57,160 --> 00:29:04,040
same variable name all the way down, select something, so we now have query syntax, select,

282
00:29:04,920 --> 00:29:10,600
you know, maybe just x, and the point here is it looks like SQL, it's a little different,

283
00:29:10,600 --> 00:29:15,640
because in SQL they start with a select clause, which means we don't like that in programming

284
00:29:15,640 --> 00:29:21,000
languages, because they start out by describing the result, and what you want is to start out by

285
00:29:21,640 --> 00:29:27,720
describing the source, like where do things come from, so you can get types going and have your

286
00:29:27,720 --> 00:29:31,880
tooling kind of help you out as you type the code from one end to another, so we want to start with

287
00:29:31,880 --> 00:29:38,760
the array, figure out what its type is, get completion in our classes, and so on, so that's

288
00:29:38,760 --> 00:29:43,960
a programming, proper programming language way of doing it, sorry SQL folks, but you got it wrong,

289
00:29:43,960 --> 00:29:51,640
and you didn't think about ID, you didn't think about IDEs back in 1970, I went out, IDE focused

290
00:29:51,640 --> 00:30:00,440
language design, that's the way, that's why we have TypeScript, so great, but now that actually

291
00:30:00,440 --> 00:30:05,800
just queries my in-memory data, wouldn't it be cool if I could actually use the same syntax,

292
00:30:07,000 --> 00:30:11,000
both the syntactic sugar and actually also the method called syntax, to query actual

293
00:30:11,000 --> 00:30:18,440
SQL databases, and with no difference in syntax, and that's where we get to yet another functional

294
00:30:19,000 --> 00:30:28,520
loan, which is code quotations, so in Lisp for instance, it's all based around the fact that

295
00:30:29,480 --> 00:30:34,280
code and data are no different, and you can always easily take code and represent it as a data

296
00:30:34,280 --> 00:30:37,960
structure, well that's kind of cool because then you can do metaprogramming, you can take that

297
00:30:37,960 --> 00:30:41,400
data structure and do stuff with it, and one of the things you can do with a data structure

298
00:30:41,400 --> 00:30:46,600
representing a query is you can translate it to SQL and send it to a SQL database, and have it run

299
00:30:46,600 --> 00:30:51,400
a SQL, and have the result come back, and then you do a little translating back, and now you have

300
00:30:51,400 --> 00:31:01,960
an object-oriented, an object relational model, so if we take that, let's just say var here,

301
00:31:01,960 --> 00:31:08,920
more type inference, if we take that array and say, is it too queryable or ask queryable,

302
00:31:08,920 --> 00:31:14,600
isn't it ask queryable, there you go, and say ask queryable, I'm sort of cheating a little,

303
00:31:14,600 --> 00:31:21,800
and I'm representing it as now a queryable is like a representative of some other data source

304
00:31:21,800 --> 00:31:31,480
that uses quote quotation in order to do the querying, so when I do that, what changes as well,

305
00:31:31,480 --> 00:31:39,160
not much, you know, I get a queryable back instead, whoop-de-doo, but if we go and look at that query,

306
00:31:39,320 --> 00:31:46,200
query dot, you can see that it has something inside called an expression, and that expression,

307
00:31:46,200 --> 00:31:54,600
in fact, represents the data structure of all this query, okay, so we're building up,

308
00:31:54,600 --> 00:32:00,200
instead of having the code just code that we can run, instead we build up a data structure

309
00:32:00,200 --> 00:32:05,800
with exactly the same syntax, and now querying of in-memory data and querying of

310
00:32:06,360 --> 00:32:13,480
SQL databases look the same just like you can do in many functional languages that have code

311
00:32:13,480 --> 00:32:20,440
quotation, so yet another loan there, and I just cheated a little bit and showed you var as well,

312
00:32:21,000 --> 00:32:27,880
which is like the last one more concession to type inference, like very simple one, it's like,

313
00:32:27,880 --> 00:32:31,080
why do I have to say the types all the time, it's really bothersome to have to say int,

314
00:32:31,160 --> 00:32:37,160
can you let me say a three-letter keyword instead? Obviously, that's not the best example,

315
00:32:37,160 --> 00:32:44,040
this is the best example, right, I don't want to have to write, I want to just say, hey,

316
00:32:44,040 --> 00:32:49,800
the thing, you know, give me the thing, if it's clear from context that it's what kind of thing

317
00:32:49,800 --> 00:32:56,760
it roughly is, you know, who cares, so that's functional up until C3, it's a good time to

318
00:32:56,760 --> 00:33:00,200
ask for questions, we're about halfway through the story and about halfway through the hour,

319
00:33:00,200 --> 00:33:05,800
so it's still on track. Anything, any thoughts coming up here, questions, meta questions,

320
00:33:06,600 --> 00:33:08,760
programming questions, meta programming questions, yes?

321
00:33:15,000 --> 00:33:16,040
What made me decide?

322
00:33:18,440 --> 00:33:28,520
Anders Heilsberg made me decide. Okay, short version of the story, I was a professor,

323
00:33:29,080 --> 00:33:35,560
I wasn't liking it too much, I was collaborating with the Java team at Sun Microsystems then,

324
00:33:35,560 --> 00:33:43,240
had a great time doing real world, you know, real world language design for real customers,

325
00:33:44,680 --> 00:33:48,760
they got to do it all day, I got to do it like whenever I could get away from teaching and

326
00:33:48,760 --> 00:33:54,920
stuff and I just like, well, I have great time when I'm working with them and they make twice as

327
00:33:54,920 --> 00:34:00,280
much money as me at least, I think, just like maybe I'm not in the right career here and as I

328
00:34:00,280 --> 00:34:06,520
was thinking that, there was a conference in Ohos, Anders was there talking about how they

329
00:34:06,520 --> 00:34:09,800
were going to do generics in C sharp, I was there talking about how we were going to do

330
00:34:09,800 --> 00:34:20,440
generics in Java, you know, the rest is history, he had money, I didn't, so he hired, he hired me,

331
00:34:20,440 --> 00:34:27,160
not the other way around. Actually also, I liked how he talked about language design,

332
00:34:27,160 --> 00:34:31,960
when I was involved in Java language design, there was always a lot of stop energy,

333
00:34:31,960 --> 00:34:36,440
it's like we can't do this because, and we can't do this because, and he had a bunch of can-do

334
00:34:36,440 --> 00:34:42,600
attitude, you know, a small example, the generic method is gone from the screen here,

335
00:34:43,160 --> 00:34:47,480
but in Java they said, oh, we can't put the type parameter for generic methods

336
00:34:47,560 --> 00:34:51,960
after the parameters, because that might be a syntactic ambiguity in rare cases.

337
00:34:52,680 --> 00:34:58,760
And in C sharp, when he showed examples, that would also be a syntactic ambiguity in rare

338
00:34:58,760 --> 00:35:03,560
cases in C sharp, because syntaxes are a little bit alike, but they just put it there anyway,

339
00:35:03,560 --> 00:35:09,160
and I asked him after, how do you do that? He's like, we just do some tricks in the

340
00:35:09,160 --> 00:35:15,160
compiler, it's not like LR1 or whatever, it's fine, we figure it out, and who cares about

341
00:35:15,160 --> 00:35:20,440
those rare cases, you know, we come up with a rule that works 97% at the time, if you

342
00:35:20,440 --> 00:35:25,240
can run into it, and does the right thing mostly, and we're good. It was always like,

343
00:35:25,240 --> 00:35:28,680
we can probably solve that problem attitude, and that spoke to me in a way, and that's

344
00:35:29,720 --> 00:35:33,320
still the case, and that's still why I love being there, so, oh.

345
00:35:35,800 --> 00:35:38,760
Thanks for that question, now I'm going to have a tear in my eye for the rest of the day.

346
00:35:39,720 --> 00:35:45,000
Anything else? I want to hear about my childhood. Yeah.

347
00:35:52,680 --> 00:36:00,200
Why, oh, great question, so why are the delegate types that have the same shape,

348
00:36:00,200 --> 00:36:02,680
like the same signature, why aren't they interchangeable?

349
00:36:03,640 --> 00:36:09,960
So, they used to be predicate of T, and then it turned into, we started using

350
00:36:09,960 --> 00:36:17,240
funk of T, and they're not actually interchangeable, you can pass the same lambdas to them,

351
00:36:18,360 --> 00:36:24,680
but you can't assign one to the other, they're not structurally equivalent, so, and that comes

352
00:36:24,680 --> 00:36:31,880
back to, you know, I kind of hinted that I'm not a super fan of delegates, and one of the

353
00:36:31,880 --> 00:36:35,800
problems with them is that they're a nominal type, they have a declaration, and just like classes

354
00:36:35,800 --> 00:36:41,400
that look the same, you can't take an object of a class and duck type it to another class that

355
00:36:41,400 --> 00:36:47,560
happens to be the same, it's all based on the declarations, it's very, very nominal, as we say,

356
00:36:47,560 --> 00:36:54,280
and the same is true for the delegate types, they are actually classes, and they are nominally tight.

357
00:36:54,920 --> 00:37:05,400
Now, in Visual Basic, for instance, vb.net, they paper over this by inserting implicit,

358
00:37:05,400 --> 00:37:12,200
like, wrapper functions to translate from one to another, so there you get the great experience of

359
00:37:12,200 --> 00:37:16,680
it all just assigns to each other, it looks extremely structural, but the problem is it

360
00:37:16,680 --> 00:37:21,640
isn't, like it comes with a cost, like you're wrapping more and more, if you keep passing

361
00:37:21,640 --> 00:37:26,280
back and forth, you get like layers and layers of, oh, here's a predicate of a fung of a predicate of,

362
00:37:26,280 --> 00:37:33,880
you know, all the way, so we don't let you go down that rabbit hole in C sharp,

363
00:37:34,680 --> 00:37:39,000
we think about it sometimes, and we also think about, well, could we just do better

364
00:37:39,000 --> 00:37:45,720
function types, but then you have a library that is gigantic, and that is using delegates

365
00:37:45,720 --> 00:37:50,840
everywhere, and you look at that and you go, hmm, I wonder how we could do this and not mess up

366
00:37:50,840 --> 00:37:57,640
a million customers, you know, or, you know, we choose not to roll it out in our big library

367
00:37:57,640 --> 00:38:02,760
and just make it, you know, an option for new code, and then doesn't really, there's no bang there,

368
00:38:02,760 --> 00:38:07,400
right, you know, you don't get enough value, so that's a tough problem, that's, you know,

369
00:38:07,400 --> 00:38:13,160
the problem of legacy code and the problem of compatibility shoots down a lot of good feature

370
00:38:13,160 --> 00:38:21,080
ideas, and we haven't found a way around this one. It's one of several, interestingly,

371
00:38:22,440 --> 00:38:26,600
functionally inspired topics that we'll be discussing this summer, we're having sort of a

372
00:38:26,600 --> 00:38:30,600
series of summer camps on the team where we'll discuss topics that are normally out of bounds,

373
00:38:30,600 --> 00:38:36,600
because we don't know how to deal with them, and this is one of them, so maybe one day we'll figure

374
00:38:36,680 --> 00:38:40,440
out a way to make that good. Yeah?

375
00:38:54,440 --> 00:39:03,560
Yeah, so the question is, is the, is the sequel style syntax still in broad use,

376
00:39:04,040 --> 00:39:09,640
and it's true, it does feel very different from the rest of the language, it's, yeah, it's just,

377
00:39:09,640 --> 00:39:19,800
it's like you enter another world. Yeah, we have to maintain compatibility with it, but also,

378
00:39:19,800 --> 00:39:25,000
furthermore, I think it is still, it is still used a bit, like a bunch, not more than a bit,

379
00:39:25,000 --> 00:39:28,920
actually, a bunch of people actually do prefer the method called syntax, even when they're using

380
00:39:28,920 --> 00:39:40,520
the query methods. I find that if I have to do more than one from, from x in blah, from y in

381
00:39:41,480 --> 00:39:47,640
x dot, or something like that, then writing the corresponding query with method calls becomes,

382
00:39:50,440 --> 00:39:55,960
becomes mind-blowingly hard, and you have to use select many, and select many is mind-blowing,

383
00:39:55,960 --> 00:40:01,560
and so I always, if I have to, if I have to, like, do more than one from, if I have to, like,

384
00:40:01,560 --> 00:40:05,880
dig into data with froms, I switch to query syntax and let the compiler figure it out for me,

385
00:40:05,880 --> 00:40:11,160
because I, my brain can't handle it. It's all, actually, it's all down to monads,

386
00:40:11,160 --> 00:40:16,760
so how many people here know about monads? Yes, that's more than I would have expected,

387
00:40:16,760 --> 00:40:21,640
actually. It's this concept that is super central to a bunch of functional, a typed functional

388
00:40:21,640 --> 00:40:26,120
programming, and nobody understands it. A bunch of people claim that they do, but they're actually

389
00:40:26,120 --> 00:40:33,720
just, you know, it's a collective kind of like, it's a hoax. They don't, not for long anyway. I've

390
00:40:33,720 --> 00:40:37,880
understood it many times, and then, you know, the next day I was like, what was it again? Maybe I

391
00:40:37,880 --> 00:40:43,960
was just dreaming it. It made, it totally makes sense at the time, but query, query expressions,

392
00:40:44,760 --> 00:40:51,400
they are a monad. They're a language support for a monad, and when you use more than one from,

393
00:40:51,960 --> 00:40:57,320
that is where you get into monadic territory, where the select many is the thing that makes them,

394
00:40:57,320 --> 00:41:02,440
makes them a monad, and that's, that's exactly why it gets mind blowing to do it directly. It's

395
00:41:02,440 --> 00:41:07,480
because it's monad, and you want syntax for that. But other than that, people have different styles.

396
00:41:07,480 --> 00:41:11,960
There are also people who work on low level code that would be like, this is way too inefficient.

397
00:41:12,840 --> 00:41:18,200
It does you, there's all this laziness, right? The, the iterators are generating things along the

398
00:41:18,200 --> 00:41:23,880
way, which means you have all this like, you have a bunch of structure, you have all these calls

399
00:41:23,880 --> 00:41:28,840
through interfaces and so on. So if you're doing performance intensive code, one of the things

400
00:41:28,840 --> 00:41:34,920
that people look for in code reviews is, oh, oh, you have a query there. Well, fix that, you know,

401
00:41:34,920 --> 00:41:44,440
go back to ugly array based stuff, because then it's going to be faster. So I will say that entity

402
00:41:44,520 --> 00:41:51,640
framework, live and kicking offers up, you know, a query provider implementation,

403
00:41:51,640 --> 00:41:55,800
and people do use that, and they do use the query syntax when they're interacting with that,

404
00:41:55,800 --> 00:42:04,440
because it is a database technology outside of that, maybe not so much. Okay. All right. One more.

405
00:42:14,680 --> 00:42:19,400
That's true. Yes.

406
00:42:30,760 --> 00:42:35,320
So that's a great question because, and we might touch on it a little bit later.

407
00:42:37,160 --> 00:42:43,240
So let me repeat again. The one thing you can do in the query syntax is you can use let

408
00:42:43,320 --> 00:42:48,680
to actually introduce more temporary variables inside of the query. I haven't done it in many

409
00:42:48,680 --> 00:42:54,280
years, actually. Let's see if we can do that. Let y equal x times two or something like that.

410
00:42:55,320 --> 00:43:01,000
Yeah, it worked, at least it compiles. So now the rest of the query has access to x and y,

411
00:43:03,000 --> 00:43:09,800
and that's really useful because you have sort of like variable declaration inside of an expression

412
00:43:09,800 --> 00:43:15,720
rather than as a separate statement. And that has continued to doggers. That statement-based

413
00:43:17,320 --> 00:43:21,640
approach to variable declarations has continued to doggers. And in later versions of C-sharp,

414
00:43:21,640 --> 00:43:26,200
there are more and more places where you can now declare variables inside of an

415
00:43:27,320 --> 00:43:31,000
expression. We haven't done it completely generally. We had a proposal for it where we never

416
00:43:31,000 --> 00:43:35,480
went that far, but there are many situations now where you can declare an inline variable,

417
00:43:35,480 --> 00:43:39,080
particularly in pattern matching, which we're going to get to soon. So that even provides

418
00:43:39,800 --> 00:43:50,200
a good segue for that. Another big difference is functional languages tend to be very expression-based.

419
00:43:50,200 --> 00:43:58,520
Typically, a function doesn't have side effects in a pure functional sense, so you don't really

420
00:43:58,520 --> 00:44:03,800
need statements. You just need an expression saying what the whole thing is, and then you stick it

421
00:44:03,800 --> 00:44:08,040
together, you put sub-expressions inside, and it's all expression-based, and so you need things like

422
00:44:08,040 --> 00:44:12,200
variable declaration to be expression-based. And the more expression-based, the more we get

423
00:44:12,200 --> 00:44:16,760
inspired by that in C-sharp, the more of a shortcoming it becomes that variable declaration

424
00:44:16,760 --> 00:44:21,560
isn't one of them. So great, great point. And this is a way to sneak it in. You can't do that with

425
00:44:21,560 --> 00:44:25,800
method call syntax, because it does sneaky things under the hood. It builds little, like,

426
00:44:25,800 --> 00:44:32,920
tuple-like things to keep track of all the variables under the hood. Okay. Yep. Okay.

427
00:44:32,920 --> 00:44:37,800
Let's fast forward a little bit. Then we did dynamic. That was certainly not very functional.

428
00:44:37,800 --> 00:44:44,040
C-sharp 4. C-sharp 5, we did async, which was potentially very functional. F-sharp already

429
00:44:44,040 --> 00:44:50,600
had a solution to async, which was also sort of monadic, and which is beautiful, but is very

430
00:44:50,600 --> 00:44:57,400
ill-suited for a predominantly imperative language. So we went in a different direction with async,

431
00:44:57,400 --> 00:45:05,720
and the general functional approach to async is quite different from the imperative approach

432
00:45:05,800 --> 00:45:12,120
that we use in C-sharp. Essentially, they use an approach where they built up the whole control

433
00:45:12,120 --> 00:45:17,400
flow of the async ahead of time, and then you kind of pull a handle in, and it runs. It's like

434
00:45:17,400 --> 00:45:25,080
you built all the pipes, and then you turn on the water. And in our async, we sort of more like

435
00:45:26,520 --> 00:45:31,640
laying out the pipes as the water is coming. It's sometimes called a cold and hot async.

436
00:45:31,640 --> 00:45:40,600
Like we work with tasks, which are things that are already happening, things that are already

437
00:45:40,600 --> 00:45:46,280
concurrently operating, and then you can take a task, and then you can say, well, I'm ready for

438
00:45:46,280 --> 00:45:50,440
you. Are you ready for me and get a result out of them? So that's all much more imperative

439
00:45:50,440 --> 00:45:54,920
fits better with imperative workflow. So there, we didn't go the functional way. We don't always do it.

440
00:45:55,480 --> 00:46:02,280
In C-sharp 6, we started getting interested in the expression-based stuff again, though. So I'm

441
00:46:02,280 --> 00:46:10,120
going to switch to a different file here. So one thing that we really like, the expression bodies

442
00:46:10,120 --> 00:46:14,360
of lambdas, we're like, why should only lambdas be allowed to have expression bodies? Why can't

443
00:46:14,360 --> 00:46:18,840
all our functions, all our function members have expression bodies, and we're like, okay,

444
00:46:18,840 --> 00:46:24,360
C-sharp 6, we did kind of half of them, and then C-sharp 7, we did the rest. So now

445
00:46:25,400 --> 00:46:29,800
all function members in C-sharp can have expression bodies where you just put that lambda

446
00:46:29,800 --> 00:46:38,040
arrow there, the fat arrow, as we shouldn't call it, and you get it. You don't have to say return.

447
00:46:38,040 --> 00:46:45,080
If your only statement is return something, cut the boilerplate. But it's just in tactic sugar,

448
00:46:45,080 --> 00:46:53,560
right? So, but coming to C-sharp 7, we're starting to think about more fundamental

449
00:46:53,560 --> 00:47:01,800
things again. So not so much in the syntax, syntactic sugar, you know, as feel kind of layer,

450
00:47:01,800 --> 00:47:09,400
but really like, uh-oh, object-oriented program is kind of screwed in these new scenarios that are

451
00:47:09,400 --> 00:47:18,360
becoming very predominant and widespread. Essentially, when it comes to cloud programming,

452
00:47:20,520 --> 00:47:24,280
history is on the side of functional programming. I'm sorry, object-oriented programming is not

453
00:47:24,280 --> 00:47:31,800
good for that. If you think about, and that comes down to how you describe aberrations over types

454
00:47:31,880 --> 00:47:39,720
of data. In both object-oriented and functional programming, there are ways that you can write

455
00:47:39,720 --> 00:47:45,800
functions so that they have appropriate behavior for each shape of data, for each type. But those

456
00:47:45,800 --> 00:47:51,640
ways are very different. They're like actually, I think probably if Eric Meyer was here, he would

457
00:47:51,640 --> 00:47:56,920
say that there's a duality, like they're completely like the opposite of each other.

458
00:47:57,880 --> 00:48:03,560
What we do in classic object-oriented programming, we love encapsulation. We love saying the data

459
00:48:03,560 --> 00:48:08,440
is actually secret. I'm not even, I'm not exposing it because then I can change it whenever I like,

460
00:48:08,440 --> 00:48:13,240
and then I just offer up some functions, and I can have a class hierarchy with virtual functions

461
00:48:13,800 --> 00:48:18,520
that I can then describe for each type of data what it does. So the super like,

462
00:48:19,480 --> 00:48:23,720
idiotically simple example here is the two-string virtual method, right, where I am

463
00:48:24,440 --> 00:48:32,840
I am describing the string representation of the object by overriding the virtual method

464
00:48:32,840 --> 00:48:41,560
two-string. Great, you know, that means that whenever I write a new derived class from person

465
00:48:41,560 --> 00:48:47,080
here or from object actually in this case, you know, I can just overwrite that behavior to suit

466
00:48:47,080 --> 00:48:53,080
whatever my shape is, and somebody else can call it on the base class and not even know I exist,

467
00:48:53,080 --> 00:49:01,720
but still get the right behavior. Excellent, except when you have a world where data is long

468
00:49:01,720 --> 00:49:07,080
lived in the cloud, maybe, or in databases and whatnot, and different people are writing different

469
00:49:07,080 --> 00:49:12,520
functionality over the same data models, well, oops, now it's not so good to encapsulate those

470
00:49:13,480 --> 00:49:20,280
behaviors with the data model, right? You want to independently be able to express behaviors over

471
00:49:20,280 --> 00:49:31,160
the data model that still depend on, like, still type specific, but that the original type knows

472
00:49:31,160 --> 00:49:38,600
nothing about, and that the different domains of behavior have no idea about each other. So

473
00:49:38,600 --> 00:49:43,400
encapsulation is dead, right? You need, for those scenarios, you need the data to be public,

474
00:49:43,880 --> 00:49:52,760
and luckily we have, you know, auto properties to make that easy, and you need the functions to

475
00:49:52,760 --> 00:50:01,000
work from the outside. But in a C-sharp 6 setting, so let's say we're still in 6, doing something,

476
00:50:02,120 --> 00:50:07,880
let's say I want to write the two-string method from the outside, that's actually fairly hard,

477
00:50:07,880 --> 00:50:15,000
that's annoyingly clunky, and that you get back to that dying inside feeling. So let's try to do

478
00:50:15,000 --> 00:50:19,640
it, I'm making you all die a little bit inside, I'm sorry, we'll revive that part, and there'll

479
00:50:19,640 --> 00:50:26,520
be flowers, and it'll be good in a minute, but you know. So let's say two-string, let's call it

480
00:50:27,080 --> 00:50:39,640
something else, render, and you take a person, it's not even generics involved here, you take

481
00:50:39,640 --> 00:50:44,200
a person, P, and then you want to render it according to which kind of, you know, which person

482
00:50:44,920 --> 00:50:50,840
derived class it is. So we could do that, we can say, you know, we have type testing in C-sharp,

483
00:50:50,840 --> 00:50:57,240
we can say if P is a student, and that's the only derived class that I actually put in here,

484
00:50:57,240 --> 00:51:03,160
but you know, imagine there are dozens. For each of those, you say if P is student,

485
00:51:03,160 --> 00:51:09,000
then do, at least we have expression-bodied members here, no I can't do that here, return

486
00:51:11,320 --> 00:51:16,760
whatever the student does, okay, I'm cheating a little using interpolated strings here,

487
00:51:17,720 --> 00:51:26,120
return that, except of course I have to dot my way into that public data, no problem,

488
00:51:26,760 --> 00:51:34,120
but as I get to the student-specific property here, oh, you know, I already, I just asked,

489
00:51:34,120 --> 00:51:40,440
but I already forgot that it was a student, so I don't get to. If only we were type script,

490
00:51:40,440 --> 00:51:45,560
you know, type script, it has flow-based typing, you know, a variable, you know, if you figured

491
00:51:45,560 --> 00:51:49,960
out it wasn't something on this branch, then, you know, it'll know you're something else,

492
00:51:49,960 --> 00:51:53,880
and it's beautiful, but we can't, that's, oh, we're super-breaking in C-sharp, and also their

493
00:51:53,880 --> 00:52:00,440
compiler is, you know, just thank God that they don't promise type safety, let me just put it like

494
00:52:00,440 --> 00:52:08,200
that, so that is kind of annoying, what to do, well, you know, in C-sharp 6, your best option is to,

495
00:52:08,200 --> 00:52:13,320
you know, cast P to student, knowing it will succeed, because you're smarter than the compiler,

496
00:52:13,800 --> 00:52:18,200
until you maintain your code a little bit, and I know somebody else takes over,

497
00:52:18,200 --> 00:52:25,320
and they do a refactoring manually, and stuff blows up, but that, we can do that,

498
00:52:25,320 --> 00:52:30,120
and then there's an else, you know, else return that other stuff, let's just get it in there,

499
00:52:30,120 --> 00:52:38,440
so we can, so we can mutate the code a little bit, return that stuff, and of course there would be

500
00:52:38,440 --> 00:52:45,640
else ifs for every other, like, derived class here, so here we get to do p.this and p.that,

501
00:52:45,640 --> 00:52:53,480
so far so good, but functional languages, they do this all the time, and it's interesting to note

502
00:52:53,480 --> 00:53:04,440
that there's a fundamental difference in how the, you know, what kind of contract you have here,

503
00:53:04,440 --> 00:53:08,280
when you use opti-growing programming, as I said, you can add a new class whenever you want,

504
00:53:08,280 --> 00:53:12,200
and you can just overwrite that virtual method, and everyone's happy, right, because the code and

505
00:53:12,200 --> 00:53:19,240
the class are together, if you add a new type, like, in this functional setting, you are explicitly

506
00:53:19,240 --> 00:53:24,120
in the function, you are mentioning all the different shapes that you care about, and if somebody

507
00:53:24,120 --> 00:53:29,320
adds another shape of data, and you know, your code is no longer handling that, so there's a

508
00:53:29,320 --> 00:53:35,560
different, you can't add new data with impunity, but you can add new functions with impunity,

509
00:53:35,560 --> 00:53:41,560
which you can't do in the opti-growing world, you can't go without going back and editing the

510
00:53:41,560 --> 00:53:45,320
original, right, you can't independently add new functions in opti-growing programming,

511
00:53:45,320 --> 00:53:52,600
but you can add new types, in functional programming, you can't independently add

512
00:53:52,600 --> 00:53:57,880
new types, but you can add new functions, this really is a duality, but they do the other things

513
00:53:57,880 --> 00:54:02,360
so well, and what is it they do, well, they do pattern matching, so the first step there is,

514
00:54:02,360 --> 00:54:08,920
let's actually let you declare a variable inside of this expression, you know,

515
00:54:09,480 --> 00:54:14,760
after this expression, that's actually let you put a variable name, and say, okay, I just checked,

516
00:54:14,760 --> 00:54:20,760
can I just get a name for that, can I get a receipt, and you use that throughout here, and that is

517
00:54:20,760 --> 00:54:27,480
your P typed a student with its own name, and now we can, we can, you know, we're not dying

518
00:54:27,480 --> 00:54:37,560
inside anymore, if I can, at least if I can, what, oh no, what's that, yes, it was the wrong

519
00:54:37,560 --> 00:54:49,400
province, no, yes, thank you, thank you, I'm code blind, thank god I only have six minutes left,

520
00:54:49,480 --> 00:54:55,240
oh my god, I only have six minutes left, so what we're getting into is pattern matching,

521
00:54:55,240 --> 00:54:59,560
and pattern matching is this whole new concept that we're adding to C-sharp at this point,

522
00:54:59,560 --> 00:55:05,960
but it's not new in the global sense, it's a well-trodden path in functional programming,

523
00:55:05,960 --> 00:55:11,320
we just have to adapt it to an object-oriented context, and this is a pattern, a pattern is

524
00:55:11,320 --> 00:55:17,720
something that can either succeed or not when you apply it to a value, and if it succeeds,

525
00:55:17,720 --> 00:55:22,120
it can extract some extra information and put it in variables for you, that's what a pattern is,

526
00:55:22,120 --> 00:55:26,440
and we have a few patterns from the beginning in C-sharp 7, and then we start adding some more

527
00:55:26,440 --> 00:55:30,840
along the way, and we keep, we're still adding patterns to this date, like C-sharp 11 has

528
00:55:30,840 --> 00:55:33,880
list patterns, which you will, if you go to the other talk, you'll get to see those,

529
00:55:35,160 --> 00:55:40,520
but it's still like the shape of the code, like we solved the micro problem, but the larger problem

530
00:55:40,520 --> 00:55:43,800
of if, you know, having a very imperative way of checking, that's also very like

531
00:55:44,680 --> 00:55:51,400
a kind of fraud with danger in terms of maintenance and so on, what we want along with pattern

532
00:55:51,400 --> 00:55:57,320
matching is we want what functional programming often calls matching, pattern matching,

533
00:55:58,440 --> 00:56:03,960
we have a keyword already called switch, so we're using that one, so let me go and just, you know,

534
00:56:03,960 --> 00:56:12,040
do this again, so I'm gonna do it in a functional way, let's just, we can comment this out,

535
00:56:13,000 --> 00:56:18,600
so we're gonna do just an expression body, we're gonna take the person, and we're gonna switch

536
00:56:18,600 --> 00:56:25,480
on them, but not with an old-fashioned clunky switch statement from C in the early 60s that

537
00:56:25,480 --> 00:56:29,720
we have in C-sharp, but with a switch expression, you know, like the cool kids, so this is an

538
00:56:29,720 --> 00:56:34,920
expression body, that's a switch expression, it's empty right now, that's actually okay,

539
00:56:34,920 --> 00:56:38,600
but you get a warning saying you're not handling all the different kinds of input, yeah, okay, thank

540
00:56:38,600 --> 00:56:46,200
you, so and now we can write patterns directly here, student S, arrow, and now we can just

541
00:56:46,200 --> 00:56:53,160
put an expression for the result that you want in case it is a student, right, so I can, I now

542
00:56:53,160 --> 00:56:58,760
have like a clean structure within which I can just list comma separated patterns and results,

543
00:57:00,360 --> 00:57:06,440
and I, right now I only need the two, so we're gonna take, we're gonna just do this

544
00:57:07,080 --> 00:57:14,920
for now, and then just quickly touch on the fact that patterns can be, pattern matching

545
00:57:14,920 --> 00:57:19,400
is smarter, right, we saw that it said that you were not handling all the cases, it still did that

546
00:57:19,400 --> 00:57:24,600
when we only had the, when we only had the student, but when I do a catch-all, which I can do with a

547
00:57:25,400 --> 00:57:31,480
fancy modern discard, then it says, hey, you're handling everything, you're good, no more warning,

548
00:57:32,280 --> 00:57:36,200
well, what if I go the other way, like let's just, let's just swap the order of these two,

549
00:57:36,200 --> 00:57:40,520
they are in order, then I actually get an error saying, hey, you handled, you handled this case

550
00:57:40,520 --> 00:57:46,600
already, so, so you can see how maintenance of these things becomes much, not only is it clear

551
00:57:46,600 --> 00:57:51,960
to read, but the compiler is helping you much more, keep your logic straight, so it's beautiful,

552
00:57:51,960 --> 00:57:59,000
and it's safe, that sounds like functional to me, so, so you can do that, but you know,

553
00:57:59,880 --> 00:58:03,400
you're noticing, I'm actually writing out just the first letter of the first name,

554
00:58:03,400 --> 00:58:10,600
and in this case here, actually, what if the, what if the first name is empty, I'm not going to

555
00:58:10,600 --> 00:58:14,600
talk about null right now, that's a whole nother talk, but what if it's empty, that's kind of,

556
00:58:14,600 --> 00:58:19,560
you know, I should probably do something else if it's empty, so let's, let's use, just to show

557
00:58:19,560 --> 00:58:24,360
an example of a recursive pattern, I know now that it's just a person, but what if the first name

558
00:58:25,320 --> 00:58:31,720
of that person actually is an empty string, I want to do something else, and I just want

559
00:58:31,720 --> 00:58:35,560
to write out the last name, I don't want to, like, do the whole abbreviation thing,

560
00:58:37,880 --> 00:58:47,640
p dot last name, or, you know, I could actually, so this is a property pattern, I can dig out

561
00:58:47,640 --> 00:58:51,720
specific properties inside of the pattern and recursively apply a pattern, here I'm just applying

562
00:58:51,720 --> 00:58:58,360
the pattern, I use this constant, but I could also say last name, colon, and then apply a var

563
00:58:58,360 --> 00:59:04,120
pattern, which always succeeds, but which will give you a name, so that's your let, that's your

564
00:59:04,120 --> 00:59:12,280
pattern let, it's the var pattern, and then instead of saying p dot last name here, I already dug

565
00:59:12,280 --> 00:59:18,360
out the last name and I gave it a name, so I can just say l here, so, and these things compose,

566
00:59:18,360 --> 00:59:24,120
you know, if I wanted the actual, if I wanted a new name for the the person object itself,

567
00:59:24,120 --> 00:59:30,520
I could put it here, let's call it p2 or whatever, so, so patterns kind of compose, and over time

568
00:59:30,520 --> 00:59:36,840
we've added more and more kinds of them, that essentially make them more and more expressive,

569
00:59:36,840 --> 00:59:43,160
and allow you to put more and more of your logic into patterns, so that your shape dependent

570
00:59:44,040 --> 00:59:53,320
code is now as beautiful, or some would say even more, I don't, but, you know, it's a great

571
00:59:53,320 --> 00:59:58,200
beautiful first-class alternative to virtual methods, when you, when describing the functionality

572
00:59:58,200 --> 01:00:04,680
on the outside is what you want to do, you do pay something, you pay the fact that you can't

573
01:00:04,680 --> 01:00:09,320
willy-nilly add new types, you pay the fact that your data has to be public, so that it can be

574
01:00:09,320 --> 01:00:14,040
operated on from the outside, so encapsulation is at the window, but you get this other beauty,

575
01:00:14,040 --> 01:00:18,520
so, you know, pick your poison, depending on the scenario, now you have both obstinacy sharp,

576
01:00:19,800 --> 01:00:29,400
and I also wanted to mention immutability, but I just did, we did work for immutability, first

577
01:00:29,400 --> 01:00:35,480
we let you have auto properties without setters, but that wasn't so good for the, for the object

578
01:00:35,480 --> 01:00:42,200
initializers, now there's a more, now you have a new kind of setter, it's called an initter,

579
01:00:42,200 --> 01:00:46,360
which is the setter that can only be called from object initializers, and now, so that means we

580
01:00:46,360 --> 01:00:51,080
made immutable objects more first-class, you don't need to initialize them with constructors, you

581
01:00:51,080 --> 01:00:55,240
can use object initializers for those as well, immutability is another functional concept that

582
01:00:56,120 --> 01:01:04,280
we're starting to support more, so I'm going to stop here in the C-sharp 7s,

583
01:01:05,960 --> 01:01:10,280
and if you want to see some C-sharp 11 functional influence, you know, there's another talk,

584
01:01:10,280 --> 01:01:19,320
and just an hour and a half or whatever, and for now, thank you very much.

585
01:01:25,240 --> 01:01:26,520
you

