WEBVTT

00:00.000 --> 00:08.760
Wow, let's see. It recognizes me even with this fancy mic on. So, Windows Hello, yay.

00:08.760 --> 00:16.560
Doesn't it? Or did it just, like, turn off? It wants, no, it didn't. It wants a pin. At

00:16.560 --> 00:24.600
least it's not showing you my pin. There we go. Okay. This is my intro slide. My name

00:24.600 --> 00:34.280
is Mess Torgerson, or Mess Torwassen, or Mutz Torgerson, or something like that. I

00:34.280 --> 00:38.680
know we didn't friends out there are going to kill me. They're going to take a blue

00:38.680 --> 00:47.240
sharpie to that one after. So, I work on the C-sharp language every day for Microsoft.

00:47.240 --> 00:53.480
It's a great job. I wish you could all have it, but it's mine. So, and I've done that

00:53.480 --> 00:59.440
for a very long time. So, that means I remember things that nobody else remembers, almost.

00:59.440 --> 01:06.160
Except for Anders, as we call him, who was there from the beginning. I was not. I was

01:06.160 --> 01:12.240
a latecomer. I've only been there for 17 years. But it is an old language. We are now working

01:12.240 --> 01:20.520
on C-sharp 11, and there's a whole other talk about C-sharp 11 a little later today. So,

01:20.520 --> 01:28.600
I decided I want to talk about C-sharp 1 through 10 today. It's from the angle of how

01:28.600 --> 01:34.120
has functional programming influenced C-sharp over the years. I'm hoping that's interesting

01:34.120 --> 01:37.160
to you. Otherwise, that's a lot of people I'll be disappointing today, because it's

01:37.160 --> 01:42.360
a very full room. I don't know how many are out there, but you can still run without me

01:42.360 --> 01:49.640
noticing unlike these people in here. So, I think it's interesting, because C-sharp started

01:49.640 --> 01:58.000
out as a fairly typical of its age, fairly straightforward object going into imperative

01:58.000 --> 02:02.560
programming language. That was how it started. They didn't kind of just pull that out of

02:02.560 --> 02:08.240
the blue, of course. There were other languages around at the time that were similar. That

02:08.240 --> 02:15.360
C-sharp might happen to look a little like, by accident. But that was sort of like the

02:15.360 --> 02:20.600
game of the day. So, C-sharp was typical of the day, and kind of pretty much took almost

02:20.600 --> 02:26.600
all the functional things in along the way as they became relevant to how we do programming.

02:26.600 --> 02:30.920
So, I'm going to go through that same evolution essentially today and point out some of the

02:30.920 --> 02:35.160
different ways. I'll try to make some general points about programming language paradigms

02:35.160 --> 02:39.760
and so on along the way. But it's all going to be a little bit, I'm going to do it all

02:39.760 --> 02:46.280
in Visual Studio. I'm just going to code along. And so, and I forgot to print out my demo

02:46.280 --> 02:54.240
notes. So, may I go astray? It'll be a little bit of a one-off. We do have an hour, which

02:54.240 --> 03:00.640
means that there's time for a few questions along the way, not like a million. But I don't

03:00.640 --> 03:05.880
want you to say, oh, I want to ask a question about that when he's done talking. Because

03:05.960 --> 03:09.920
by then, the code will look different. Nobody will remember what I was talking about. So,

03:09.920 --> 03:14.840
if you have a question, raise your hand and ask it. And I'll try to keep us on track. And

03:14.840 --> 03:19.080
hopefully I'll succeed. And that might mean that I will have to be a little rude and say,

03:19.080 --> 03:23.600
sorry, no more questions. Come back after. So, just don't be offended when I get to there.

03:23.600 --> 03:32.360
But until then, please just raise a question and ask. So, with that, without much further

03:32.360 --> 03:40.520
ado, let's start out with C-Sharp 1. And just kind of, for those of us who were around, remind

03:40.520 --> 03:48.680
ourselves of the state of the art of programming, at least in the industrial space in the year

03:48.680 --> 03:54.880
2000. And for those of you who weren't around, you can just go, thank God I wasn't around.

03:54.880 --> 04:01.720
I mean, you were probably around most of you, but maybe you were still doing Legos. Aren't

04:01.720 --> 04:09.960
we all really? So, what I have here is a fairly simple. It's a C-Sharp 1 program. I'm cheating

04:09.960 --> 04:16.320
a little bit because when it comes to features that aren't part of this talk, that aren't functional,

04:16.320 --> 04:20.160
I'm just going to use them a little bit anyway. For instance, my code is not in a main method.

04:20.160 --> 04:24.680
You don't need to do that anymore in C-Sharp. And it fits better on a screen if I don't. So,

04:24.680 --> 04:30.800
I'm not going to stick religiously to only C-Sharp 1 features. But in terms of functionality,

04:30.880 --> 04:39.800
I am. So, one thing to, talking about functional, C-Sharp started out with just a tiny little hint

04:39.800 --> 04:46.440
of, a tiny little concession to functional programming languages compared to other languages

04:46.440 --> 04:53.760
at the time. And with something that they, we call delegates, which is sort of kind of like a

04:53.800 --> 05:01.440
function type. They were actually part of some of the, the need for delegates was part of the

05:01.440 --> 05:05.520
reason why we couldn't do some other programming languages and got dragged into court and stuff.

05:05.520 --> 05:12.520
So, C-Sharp back then already had like a notion of a function type called delegate. And those are

05:12.520 --> 05:18.120
still the ones that we use for function types. They're flawed in various ways, but you know,

05:18.280 --> 05:23.640
once you've got something throughout the whole core libraries and so on, you don't go on and

05:23.640 --> 05:27.800
change it. So, delegate types were function types. It's like, you know, this is the type of a

05:27.800 --> 05:33.160
function that takes an int and returns a bool. And it's a name type, like a class. It is in fact a

05:33.160 --> 05:40.200
class. And we call it predicate. And now we can use it as a function type. So, I can have a method

05:40.200 --> 05:48.440
here, a function that takes a predicate. And it can call the predicate as the, you know, according

05:48.440 --> 05:54.120
to the function type. But, and when I want to pass an argument to it, well, we don't have anything

05:54.120 --> 05:58.280
like lambdas yet that we're going to get to that. We don't have like anonymous functions of any kind.

05:58.280 --> 06:03.320
But we do have, we, but you can sort of just mention a function that happens to have the right

06:04.040 --> 06:08.600
signature, like great than five. Hang on a second.

06:11.480 --> 06:16.280
Is it going to be like this all the way? How many typos are we going to have in here? There we go.

06:17.080 --> 06:24.360
I did get the wordle this morning. So, I'm not like totally, there we go. So,

06:25.960 --> 06:31.000
so you kind of have to declare a function, then pass it. You have to declare the function type,

06:31.000 --> 06:34.600
then use it. Like it's all very nominal and declarative at this point.

06:35.160 --> 06:41.560
But it gets the job done. Like pass the predicate in. Of course, there's no such thing as generics

06:41.560 --> 06:45.800
yet. They're the first thing we're going to learn from functional programming languages in a minute.

06:45.800 --> 06:53.160
So, you know, this was the name of the game. I do, you, in order to filter this, I need to

06:53.160 --> 06:58.760
gather up the results. The only, like I really wanted to return an array because that's the only

06:58.760 --> 07:02.920
generic type I have. It's the only type that actually has an element type. So, that's, so you

07:02.920 --> 07:08.040
kind of, you kind of encourage to trade in arrays, horrible as that is, because otherwise you have

07:08.040 --> 07:14.280
no type safety. But we do have other collections. They're just all over object. So, and, and I need

07:14.280 --> 07:17.560
to create one of those to gather up my elements because I don't know how many are going to

07:17.560 --> 07:21.800
succeed yet. I don't know the size of the array to allocate. So, first I gather them up, then,

07:21.800 --> 07:26.360
you know, I know how many I have, then I can allocate an array that's strongly typed to int,

07:27.080 --> 07:33.480
then I have to stick all the elements that I found into the array. And as I'm doing so,

07:33.480 --> 07:37.720
I have to cast them to int because I know they're all ints, but the compiler has no idea. It's like

07:37.720 --> 07:42.040
you stuck, you give me a bunch of stuff, you're taking them out, all I can see is object.

07:43.800 --> 07:47.720
So, you know, you die a little inside every time you have to cast things coming out of

07:47.720 --> 07:51.320
collections. How many people in here remember that from like either C'sharp or some other,

07:51.320 --> 08:00.280
like Java or, yeah, out, yeah. So, what, I think what we very quickly felt all of us was,

08:02.120 --> 08:06.040
and with C'sharp, it was already like coming to version two, which we're coming to version two now.

08:07.000 --> 08:11.880
We felt like, okay, this is not, this is not like a satisfactory state of affairs.

08:13.000 --> 08:15.560
It's not the abstraction capabilities aren't good enough here.

08:16.920 --> 08:20.600
Some other languages that had been around for longer, it took them a little longer to get to

08:20.600 --> 08:24.840
that point. So, it ended up that, for instance, Java and C'sharp got generics, which is where we

08:24.840 --> 08:28.760
coming to now at around the same time. And I was actually back then, I was on the other side of

08:28.760 --> 08:34.920
the fence helping out with generics and Java. So, I saw it from the other side. Still think

08:34.920 --> 08:43.000
Microsoft and C'sharp did it better. So, this really comes down to sort of one of the fundamental

08:43.560 --> 08:47.000
differences between functional and object-oriented programming.

08:47.960 --> 08:53.720
You know, in classic imperative programming, there really is no polymorphism. There's no

08:53.720 --> 09:01.080
way that you can write code that applies to more than one type. Object-oriented programming and

09:01.080 --> 09:05.160
functional programming, to a large degree, are two different answers. At least when they're typed,

09:05.160 --> 09:09.720
they're two different answers to, how do you get polymorphism? How do you write code that

09:09.720 --> 09:14.120
works for more than one kind of thing? In object-oriented programming, we went with what's

09:14.120 --> 09:19.080
often called subtype polymorphism, which means everything is a subtype of something that's a

09:19.080 --> 09:23.960
subtype of something that all goes back up to object. So, that's what we're seeing here. Now,

09:23.960 --> 09:29.720
you can write a collection like ArrayList here that can contain anything. So, there's polymorphism

09:29.720 --> 09:36.520
in that sense. And the great thing about subtype polymorphism is it's very easy to have heterogeneous

09:36.520 --> 09:42.840
collections, for instance. You can put all kinds of things in the same collection. As opposed to

09:42.840 --> 09:50.440
functional programming, they went with what's called parametric polymorphism, where you have an

09:50.440 --> 09:58.920
extra type parameter on things that, you know, sort of like a placeholder for one type. So,

09:58.920 --> 10:03.720
you don't get to mix and match the types inside. You get to say that there's this one type that

10:03.720 --> 10:08.760
I'm going to give you later, and then it'll work for that type only. But it's still polymorphic,

10:08.760 --> 10:13.720
because you can give different type arguments in different places. And that has the benefit that

10:13.720 --> 10:21.000
you can, because that type parameter has a name, you can have things sync up so that the same type

10:21.000 --> 10:25.800
name, the same type parameter appears in multiple places, and you can sort of say, well, whatever

10:25.800 --> 10:29.800
it is, the same kind of thing that comes in is the kind of thing that comes out, for instance,

10:29.800 --> 10:34.280
which is exactly what we need here, right? We need a collection, for instance, that has

10:35.240 --> 10:42.120
the same stuff coming in that's coming out. Enter generics, which is parametric polymorphism.

10:42.760 --> 10:46.600
Most object-oriented programming languages with types at this point say, okay, let's embrace

10:46.600 --> 10:53.240
that too, so we have both kinds in the language. So, that's sort of one of the first big imports

10:53.240 --> 10:59.800
from the functional space. So, let's do that. Now, let's see, where do we start?

10:59.880 --> 11:08.360
Now, we can have, well, instead of a RayList here, we could now use the new fancy generic

11:08.360 --> 11:13.720
collections that we have, and I'm cheating and having the imports in another file, so either

11:13.720 --> 11:20.360
using, so you don't have to bother with that. So, we can say list of int here instead is a new list

11:20.440 --> 11:30.280
of int, and now, as I'm gathering things up, it should be graying out this. I know that my

11:32.680 --> 11:39.480
destination here is actually a list of int and not just a list of whatever, and so I can now get

11:39.480 --> 11:47.240
rid of this cast of death. Back in business. Somebody wrote a generic collection for us,

11:47.240 --> 11:55.640
we can use it. But, of course, now, there are other, I can write generic things too. Maybe I

11:55.640 --> 12:01.800
want my predicate type to be more general. Maybe I don't actually want to write new delegate types

12:01.800 --> 12:08.840
for everything all the time, so maybe we could say predicate of t and have it work for all t's

12:08.840 --> 12:14.920
and not just for ints. It still returns bool, but I can, I now have a generic predicate type,

12:15.000 --> 12:18.840
and I can then here say, well, it's actually here, it's a predicate of int that I want,

12:18.840 --> 12:23.480
and boom, things don't work, or we can, we could actually go a step further and say,

12:23.480 --> 12:29.000
well, filtering isn't really particularly about ints, is it? And now we can write our own generic

12:30.200 --> 12:37.640
function, a method that is a filter of t, and now we get to, say, t in all the places,

12:37.640 --> 12:44.120
it's actually a predicate of t coming in and an array of t, and I'm returning an array of t,

12:44.200 --> 12:48.840
and in all the other places where it says int, except one, so you have to be a little careful,

12:49.560 --> 13:03.480
here, here, here, where else? The int result, of course, and, you know, so now I've completely

13:03.480 --> 13:07.240
generified the thing, and this is the int I shouldn't replace, because that's the counter for the,

13:07.240 --> 13:11.880
you know, filling out the array, so that's why I didn't just do a search replace here.

13:12.840 --> 13:17.320
So there we go, now we, all of a sudden, we've generified a thing, it's fully strongly typed,

13:17.960 --> 13:22.600
as if it was for a specific type, but now you can apply it everywhere, and the full,

13:22.600 --> 13:30.760
like, generic, generification is a strong, strong tool, and it, the, there were some, like,

13:31.720 --> 13:37.400
choices made in the different languages at the time that, that actually were imbued with destiny,

13:37.400 --> 13:43.240
even much more than we realized at the time. In Java, we, on the, I was over here, in the

13:43.240 --> 13:53.560
Java side, sorry, camera person, we, we were, we decided we couldn't change the JVM, the runtime

13:53.560 --> 13:58.760
under Java, because it was, you know, too entrenched, and how you couldn't control, like, what,

13:58.760 --> 14:04.200
but Java runtime they had out there, so, so all the generics in Java was done in the compiler by

14:04.200 --> 14:09.800
erasure, which means, you know, there wasn't any generics at runtime, it was just there

14:09.800 --> 14:14.600
in the code for as much type checking as you could get, but that meant that there were some

14:14.600 --> 14:19.160
things, like reflection and so on, that didn't embrace it, and there were certain, certain

14:19.160 --> 14:25.480
holes in the experience, essentially. And whereas in, in .NET, and, and C Sharp, we went all out

14:25.480 --> 14:32.680
and said, yes, generics goes into the runtime, and is shared across all the languages at target.net,

14:32.680 --> 14:34.920
and it's a real runtime thing. Question.

14:44.920 --> 14:50.280
So, to repeat the question for the, for the mic, when did we know that we wanted generics in C

14:50.280 --> 14:59.160
Sharp? So, I wasn't there, but I kind of was, because in 99, I was an intern, I was doing my

14:59.160 --> 15:04.200
PhD, I was an intern at Microsoft Research, Cambridge, which is where Don Simon is, if anybody

15:04.200 --> 15:08.920
has heard of him, the father of F Sharp, and there were a bunch of language people there,

15:08.920 --> 15:14.840
so I got actually to be privy to decisions that were secret for a number of years, and I was under

15:14.840 --> 15:20.360
NDA until, until things came out, and they were already talking about .NET, they weren't calling

15:20.360 --> 15:24.840
it that at the time, and they were already talking about generics for it, and decisions were made

15:24.920 --> 15:31.080
that it would take too long to make it work right, and we should have a version without it first.

15:31.080 --> 15:37.080
So, yeah, that, that, I think that answers your question precisely, so it was always felt that

15:38.120 --> 15:45.000
that we're gonna, we're gonna need to do this, and indeed, generics was, was the, pretty much the

15:45.000 --> 15:52.200
almost the only and, and last thing that language feature that was added to the runtime for a very

15:52.200 --> 15:57.400
long time, because after that .NET became popular, it was Windows component, and so we had the same

15:57.400 --> 16:02.920
problem as Java, as the one causing Java to not do it in the runtime, which was too many people

16:02.920 --> 16:07.320
have it installed, we don't know which version of Windows they have, we have no way of, you know,

16:07.960 --> 16:13.160
making sure that they have the right runtime features that we are compiling for, so we stopped

16:13.160 --> 16:17.320
doing language features in the runtime after that for a very, very long time, now we're doing it again,

16:18.280 --> 16:27.560
and we might get to one at the end, so that's generics, and let's see if I can get back on

16:27.560 --> 16:34.520
track here, so it's, well, that's not generics, that's not all there is to say about generics,

16:34.520 --> 16:42.920
because once you get these, like, very lovely generic collections, for instance, they can have

16:43.000 --> 16:48.040
smarter, they can have smarter types, smarter methods as well, they can have generic methods,

16:48.040 --> 16:53.960
so instead of, instead of like doing this, building this result array myself, I could just actually

16:53.960 --> 17:01.240
take that dst thing and just call to array on it, because now it knows its element type and you

17:01.240 --> 17:09.800
can build an array of the right, of the right type, namely t, you also notice, so which means I can,

17:09.800 --> 17:15.640
I can delete these two lines of code, I don't need that anymore, so many more utilities now,

17:15.640 --> 17:25.080
strongly typed utilities become available, and one last thing to notice is that when I'm calling

17:25.080 --> 17:30.440
the generic method here, I'm not passing a type argument, you need to pass a type argument to,

17:30.440 --> 17:35.400
to the, to generic types, but not to generic methods, and that again is a thing that type

17:35.400 --> 17:40.600
inference is something that we start stealing from functional programming languages, we can't do

17:40.600 --> 17:44.440
as much type inference in object-oriented programming languages as you can in a functional

17:44.440 --> 17:50.280
language because of the subtype polymorphism, it means that you can't actually, there are many

17:50.280 --> 17:54.440
places where you can't know the exact type, where you could if you didn't have subtype polymorphism,

17:54.440 --> 17:58.360
so we can't go all out on, on type inference, which is probably all the same because it's

17:58.360 --> 18:03.320
confusing to a lot of people, it's a quiet taste, so, so we kind of, we have to strike a balance

18:03.320 --> 18:14.040
there, but it certainly makes sense here, so with that lovely generics, we, we can also get out of

18:14.040 --> 18:21.640
this addiction to, to arrays as the, as kind of like the, the, the currency of collections

18:21.640 --> 18:26.920
being passed around, because arrays are, you know, they're very low-level, fixed size, they

18:26.920 --> 18:32.040
expose too much, they're unsafe in various ways because you pass your array to someone and they,

18:32.040 --> 18:35.480
they're messing with it while you're watching it somewhere else, and you know, that's just, you

18:35.480 --> 18:41.880
know, nasty, so we can start having other interfaces, for instance, that are, that are more

18:41.880 --> 18:51.560
suitable, so, Ionumable of T is a good one, I can return Ionumable of T as well here, and,

18:53.960 --> 18:58.760
and I don't even have to say to array, I can, but I don't have to say to array because, of course,

18:58.840 --> 19:02.120
a list of T is also an Ionumable, so, you know, things get simpler.

19:04.600 --> 19:09.960
We could do one better, actually, we, we also, well,

19:11.400 --> 19:14.920
oh, but, well, it's because I'm saying, in the array here, yeah, yeah, I have to,

19:15.720 --> 19:18.600
I have to just make all the changes, okay, so,

19:19.160 --> 19:23.800
oh, Eint, thank you.

19:26.360 --> 19:30.520
Say, are you developers or something? It's like, it's like you, it's like you understand what I'm

19:30.520 --> 19:40.760
saying. Hey, I also debugged something once, you know, it's fun, so, so, so far so good, we,

19:41.480 --> 19:45.560
one thing we actually decided was, now we have Ionumable of T, it's like a very,

19:45.560 --> 19:51.080
in abstraction over just sequences of data, we're going to meet this a lot more in C-sharp 3,

19:51.080 --> 19:55.960
but already in C-sharp 2, we were like, actually, the compiler could help a lot with this kind of

19:55.960 --> 20:00.600
work here, of producing Ionumables, because they don't have to be produced eagerly,

20:00.600 --> 20:04.040
they don't have to have all the elements pre-computed, they can actually sort of

20:04.040 --> 20:08.280
be lazy and compute things along the way, and we can build a language feature to help with that,

20:08.280 --> 20:12.920
and that's what we call iterators in C-sharp, they're called generators in some other languages,

20:12.920 --> 20:18.120
which is essentially write a function, and then once in a while you say, oh, here's another element

20:18.120 --> 20:21.880
for the result, and then you compute some more, and then, or here's another element for the result,

20:21.880 --> 20:27.320
and it actually gets executed lazily, up to every one of those points, you just pause and,

20:27.320 --> 20:32.040
and give the result back, and then the next time the consumer asks for a result, they come, you

20:32.040 --> 20:36.920
know, execute some more, so that's iterators in C-sharp, that means we don't even need like an

20:36.920 --> 20:45.800
accumulator, we can just say, if that thing, you know, just yield return the value, I'm not

20:46.600 --> 20:51.640
super excited about the syntax we chose there, I will just say I was not around,

20:53.720 --> 20:58.360
we liked keywords a lot still back then, we kind of do still a little bit, and now I'm,

20:59.000 --> 21:06.040
you know, that's it, that's the filter method, you know, you cycle through,

21:06.120 --> 21:11.400
you yield return something, if you decide that, hey, let me do that, and that's it, right, so boom,

21:11.400 --> 21:18.680
very nice. Also in C-sharp too, we're like, hey, we've heard about lambda expressions,

21:19.400 --> 21:26.760
let's do not that, something similar, let's have anonymous functions, why do you have to declare

21:26.760 --> 21:31.560
all the functions that you want to pass, that's just like a pain, let's get rid of all these

21:31.560 --> 21:36.760
declarations and stuff, so instead of saying greater than five here, what if I could just

21:36.760 --> 21:41.960
write the function with the body and everything in place here, so we come up with an elegant

21:41.960 --> 21:53.720
syntax saying delegate, delegate all the crap, there we go, beautiful, right, it's, well,

21:53.720 --> 21:59.800
we can laugh now, but you know, it's certainly an improvement, now, you know, I'm free to just

21:59.800 --> 22:03.480
come up with functionality and pass it along, and of course the compiler generates

22:03.480 --> 22:07.160
something under the hood that's similar to before, but hey, all languages do it like that,

22:07.160 --> 22:14.840
pretty much, so great, our first take on anonymous functions, now C-sharp three,

22:15.480 --> 22:19.880
now we have big ambitions, this functional thing has really gotten into our blood, and this is

22:19.880 --> 22:24.280
where I'm starting to be around, so I've witnessed more of this firsthand, so in C-sharp three,

22:24.600 --> 22:32.520
we want to, we want to solve querying once and for all, the functional languages can do it,

22:32.520 --> 22:37.720
we can do it too, so we want to mainstream functional approaches to solving querying,

22:38.280 --> 22:44.600
let's do that, and we have, filter is a great example, like it's a function that does querying,

22:45.720 --> 22:49.720
a one aspect of querying, we kind of have the generics in place to do this,

22:49.720 --> 22:58.680
why don't we, why don't we actually declare an even more general library of function types,

22:58.680 --> 23:06.680
and then we also declare a library of, of querying methods, and get all that stuff working,

23:10.040 --> 23:18.200
so we, so instead of just having predicate of t, we create a family, families of functions called,

23:18.520 --> 23:27.400
funk and action, funk for the ones that return stuff, so funk of t1, t result, or something like

23:27.400 --> 23:35.240
that, that take a t and return a t result, so that's what the funks look like, take a t1 here,

23:36.360 --> 23:40.520
and we just declare them in the core library, so I don't even have to do it here, they're available

23:40.520 --> 23:47.400
to everyone who wants to be a little bit functional, and we can just here, actually it doesn't

23:47.400 --> 23:52.600
predicate itself actually in the core libraries from back way, way back when, so it doesn't give

23:52.600 --> 24:00.120
me a red squiggle here, but let's say funk of t, instead to describe the function we're passing in

24:00.120 --> 24:10.680
here, and then instead of me writing the filter method as kind of a, one thing that you quickly

24:10.680 --> 24:14.920
find out when you want to, you want to query things is, hey I want to, I want to filter some more,

24:14.920 --> 24:19.160
for instance, I want to call query methods on top of query methods, so I could call filter twice,

24:19.160 --> 24:26.680
you know, I could say filter on the result of the first filter, comma, you know, some other

24:27.560 --> 24:35.080
delegate thing, and you know, it quickly becomes long, I should probably have done lambdas first,

24:35.080 --> 24:41.480
shouldn't I? I'm going to be doing more typing, okay, hold that thought, let me do, let me switch

24:41.480 --> 24:48.840
to lambdas quickly, we get better syntax, that's actual lambdas, you can do this, it's a little

24:48.840 --> 24:55.000
shorter, or we have, so this is still like a statement body there, or we can actually do

24:57.320 --> 25:02.200
just a single expression, and now it starts, it starts being a little expression oriented,

25:02.200 --> 25:07.880
like the functional languages, that's kind of exciting, but we still have the problem now,

25:07.880 --> 25:14.840
if I want to filter that one some more, I can say int, why, arrow, something, stuff,

25:15.880 --> 25:21.960
oh it needs to be in parentheses here, actually does it, you know, lambdas, you don't actually

25:21.960 --> 25:26.040
have to say the type, if it's given from context, you don't have to say it, that's kind of cool,

25:27.720 --> 25:33.800
but so why, I want to get the ones that are even, stupid example, but just, you know,

25:34.760 --> 25:45.160
equals zero, you know, I can compose my query methods, but it sucks, right, I'm composing sort

25:45.160 --> 25:51.080
of inside out, like this first stuff is in the middle, and then I'm slapping stuff on both sides

25:51.080 --> 25:55.400
of it, and it's completely unreadable, well what do the functional people do when they, I mean,

25:55.400 --> 25:59.320
they're doing this stuff, how do they do it, well they have pipelining operators, you can call

25:59.320 --> 26:03.320
functions like this, but you can also pipeline, so in a functional language, what you would do is,

26:03.320 --> 26:09.800
you would start out with the array on the left side, and then you would, so let me, let me do some

26:09.800 --> 26:14.920
horrendous doctoring here, you know, start out with the array, you would have some kind of pipeline

26:14.920 --> 26:19.800
operator, which we don't have in C sharp, and you pass it into filter, filtering the first thing,

26:21.240 --> 26:26.280
and that's just the implicit first argument for it there, and then you'd pipe that into

26:27.080 --> 26:33.560
filtering the second thing, and now you have things in the right order, they're sort of cascading

26:33.560 --> 26:39.240
beautifully in the order that you're doing them, it's kind of fluent, man, as we said, so,

26:40.920 --> 26:44.840
so that's, can we do something like that in C sharp, and that's where extension, we come up

26:44.840 --> 26:49.480
with extension methods, which is essentially just to solve this little problem in the beginning,

26:49.480 --> 26:54.200
where they turn out to be like extremely useful in extremely many scenarios, we're still being

26:54.200 --> 26:58.600
inspired by them, and we want to do more with them, where what you're saying is, we're just,

26:59.320 --> 27:06.360
what if you just pretend that the static method or this function is actually like a, and it's,

27:06.360 --> 27:14.200
I can't do it with a, I can't do it with just this method here, because it's not actually,

27:15.720 --> 27:19.160
it's not declared in a proper space, but we can do, the syntax is like this,

27:20.120 --> 27:25.560
we just pretend it's an instance method on the first argument, and now I can go and add

27:26.120 --> 27:31.880
method, what looks like instance methods to other people's types, and that kind of gives you that

27:31.880 --> 27:37.720
flow, so luckily, I don't have to like go in and do it properly here, because it turns out that

27:37.720 --> 27:42.920
method just like filter is being added to the libraries at the same time, and now we can just

27:42.920 --> 27:48.360
do the where stuff, so we can get rid of our own filter method and use the one that's part

27:48.360 --> 27:55.080
of the query library that we are now providing, okay, so we can break it up a little here, and now

27:55.080 --> 27:59.800
it starts to kind of look decent, right, now we have a select for projecting, because why would we

27:59.800 --> 28:06.840
call it project, we have various methods, I'll tell you why we call it select, that's because

28:06.840 --> 28:12.680
another place where you do querying is in, you know, SQL, which is also kind of functional,

28:12.680 --> 28:19.400
right, it's also just, there are aspects of SQL where it can mutate stuff and actually get

28:19.400 --> 28:23.960
things into the database, but the actual querying is functional too, and so we want to provide

28:23.960 --> 28:36.600
syntactic sugar for querying on top of methods like this, where you can say from value in,

28:36.600 --> 28:46.600
I should call them x, I like x, from x in array, where the keyword, where x is greater than five,

28:49.320 --> 28:57.160
and where something else, where y, let's call it x again then, because we are now using the

28:57.160 --> 29:04.040
same variable name all the way down, select something, so we now have query syntax, select,

29:04.920 --> 29:10.600
you know, maybe just x, and the point here is it looks like SQL, it's a little different,

29:10.600 --> 29:15.640
because in SQL they start with a select clause, which means we don't like that in programming

29:15.640 --> 29:21.000
languages, because they start out by describing the result, and what you want is to start out by

29:21.640 --> 29:27.720
describing the source, like where do things come from, so you can get types going and have your

29:27.720 --> 29:31.880
tooling kind of help you out as you type the code from one end to another, so we want to start with

29:31.880 --> 29:38.760
the array, figure out what its type is, get completion in our classes, and so on, so that's

29:38.760 --> 29:43.960
a programming, proper programming language way of doing it, sorry SQL folks, but you got it wrong,

29:43.960 --> 29:51.640
and you didn't think about ID, you didn't think about IDEs back in 1970, I went out, IDE focused

29:51.640 --> 30:00.440
language design, that's the way, that's why we have TypeScript, so great, but now that actually

30:00.440 --> 30:05.800
just queries my in-memory data, wouldn't it be cool if I could actually use the same syntax,

30:07.000 --> 30:11.000
both the syntactic sugar and actually also the method called syntax, to query actual

30:11.000 --> 30:18.440
SQL databases, and with no difference in syntax, and that's where we get to yet another functional

30:19.000 --> 30:28.520
loan, which is code quotations, so in Lisp for instance, it's all based around the fact that

30:29.480 --> 30:34.280
code and data are no different, and you can always easily take code and represent it as a data

30:34.280 --> 30:37.960
structure, well that's kind of cool because then you can do metaprogramming, you can take that

30:37.960 --> 30:41.400
data structure and do stuff with it, and one of the things you can do with a data structure

30:41.400 --> 30:46.600
representing a query is you can translate it to SQL and send it to a SQL database, and have it run

30:46.600 --> 30:51.400
a SQL, and have the result come back, and then you do a little translating back, and now you have

30:51.400 --> 31:01.960
an object-oriented, an object relational model, so if we take that, let's just say var here,

31:01.960 --> 31:08.920
more type inference, if we take that array and say, is it too queryable or ask queryable,

31:08.920 --> 31:14.600
isn't it ask queryable, there you go, and say ask queryable, I'm sort of cheating a little,

31:14.600 --> 31:21.800
and I'm representing it as now a queryable is like a representative of some other data source

31:21.800 --> 31:31.480
that uses quote quotation in order to do the querying, so when I do that, what changes as well,

31:31.480 --> 31:39.160
not much, you know, I get a queryable back instead, whoop-de-doo, but if we go and look at that query,

31:39.320 --> 31:46.200
query dot, you can see that it has something inside called an expression, and that expression,

31:46.200 --> 31:54.600
in fact, represents the data structure of all this query, okay, so we're building up,

31:54.600 --> 32:00.200
instead of having the code just code that we can run, instead we build up a data structure

32:00.200 --> 32:05.800
with exactly the same syntax, and now querying of in-memory data and querying of

32:06.360 --> 32:13.480
SQL databases look the same just like you can do in many functional languages that have code

32:13.480 --> 32:20.440
quotation, so yet another loan there, and I just cheated a little bit and showed you var as well,

32:21.000 --> 32:27.880
which is like the last one more concession to type inference, like very simple one, it's like,

32:27.880 --> 32:31.080
why do I have to say the types all the time, it's really bothersome to have to say int,

32:31.160 --> 32:37.160
can you let me say a three-letter keyword instead? Obviously, that's not the best example,

32:37.160 --> 32:44.040
this is the best example, right, I don't want to have to write, I want to just say, hey,

32:44.040 --> 32:49.800
the thing, you know, give me the thing, if it's clear from context that it's what kind of thing

32:49.800 --> 32:56.760
it roughly is, you know, who cares, so that's functional up until C3, it's a good time to

32:56.760 --> 33:00.200
ask for questions, we're about halfway through the story and about halfway through the hour,

33:00.200 --> 33:05.800
so it's still on track. Anything, any thoughts coming up here, questions, meta questions,

33:06.600 --> 33:08.760
programming questions, meta programming questions, yes?

33:15.000 --> 33:16.040
What made me decide?

33:18.440 --> 33:28.520
Anders Heilsberg made me decide. Okay, short version of the story, I was a professor,

33:29.080 --> 33:35.560
I wasn't liking it too much, I was collaborating with the Java team at Sun Microsystems then,

33:35.560 --> 33:43.240
had a great time doing real world, you know, real world language design for real customers,

33:44.680 --> 33:48.760
they got to do it all day, I got to do it like whenever I could get away from teaching and

33:48.760 --> 33:54.920
stuff and I just like, well, I have great time when I'm working with them and they make twice as

33:54.920 --> 34:00.280
much money as me at least, I think, just like maybe I'm not in the right career here and as I

34:00.280 --> 34:06.520
was thinking that, there was a conference in Ohos, Anders was there talking about how they

34:06.520 --> 34:09.800
were going to do generics in C sharp, I was there talking about how we were going to do

34:09.800 --> 34:20.440
generics in Java, you know, the rest is history, he had money, I didn't, so he hired, he hired me,

34:20.440 --> 34:27.160
not the other way around. Actually also, I liked how he talked about language design,

34:27.160 --> 34:31.960
when I was involved in Java language design, there was always a lot of stop energy,

34:31.960 --> 34:36.440
it's like we can't do this because, and we can't do this because, and he had a bunch of can-do

34:36.440 --> 34:42.600
attitude, you know, a small example, the generic method is gone from the screen here,

34:43.160 --> 34:47.480
but in Java they said, oh, we can't put the type parameter for generic methods

34:47.560 --> 34:51.960
after the parameters, because that might be a syntactic ambiguity in rare cases.

34:52.680 --> 34:58.760
And in C sharp, when he showed examples, that would also be a syntactic ambiguity in rare

34:58.760 --> 35:03.560
cases in C sharp, because syntaxes are a little bit alike, but they just put it there anyway,

35:03.560 --> 35:09.160
and I asked him after, how do you do that? He's like, we just do some tricks in the

35:09.160 --> 35:15.160
compiler, it's not like LR1 or whatever, it's fine, we figure it out, and who cares about

35:15.160 --> 35:20.440
those rare cases, you know, we come up with a rule that works 97% at the time, if you

35:20.440 --> 35:25.240
can run into it, and does the right thing mostly, and we're good. It was always like,

35:25.240 --> 35:28.680
we can probably solve that problem attitude, and that spoke to me in a way, and that's

35:29.720 --> 35:33.320
still the case, and that's still why I love being there, so, oh.

35:35.800 --> 35:38.760
Thanks for that question, now I'm going to have a tear in my eye for the rest of the day.

35:39.720 --> 35:45.000
Anything else? I want to hear about my childhood. Yeah.

35:52.680 --> 36:00.200
Why, oh, great question, so why are the delegate types that have the same shape,

36:00.200 --> 36:02.680
like the same signature, why aren't they interchangeable?

36:03.640 --> 36:09.960
So, they used to be predicate of T, and then it turned into, we started using

36:09.960 --> 36:17.240
funk of T, and they're not actually interchangeable, you can pass the same lambdas to them,

36:18.360 --> 36:24.680
but you can't assign one to the other, they're not structurally equivalent, so, and that comes

36:24.680 --> 36:31.880
back to, you know, I kind of hinted that I'm not a super fan of delegates, and one of the

36:31.880 --> 36:35.800
problems with them is that they're a nominal type, they have a declaration, and just like classes

36:35.800 --> 36:41.400
that look the same, you can't take an object of a class and duck type it to another class that

36:41.400 --> 36:47.560
happens to be the same, it's all based on the declarations, it's very, very nominal, as we say,

36:47.560 --> 36:54.280
and the same is true for the delegate types, they are actually classes, and they are nominally tight.

36:54.920 --> 37:05.400
Now, in Visual Basic, for instance, vb.net, they paper over this by inserting implicit,

37:05.400 --> 37:12.200
like, wrapper functions to translate from one to another, so there you get the great experience of

37:12.200 --> 37:16.680
it all just assigns to each other, it looks extremely structural, but the problem is it

37:16.680 --> 37:21.640
isn't, like it comes with a cost, like you're wrapping more and more, if you keep passing

37:21.640 --> 37:26.280
back and forth, you get like layers and layers of, oh, here's a predicate of a fung of a predicate of,

37:26.280 --> 37:33.880
you know, all the way, so we don't let you go down that rabbit hole in C sharp,

37:34.680 --> 37:39.000
we think about it sometimes, and we also think about, well, could we just do better

37:39.000 --> 37:45.720
function types, but then you have a library that is gigantic, and that is using delegates

37:45.720 --> 37:50.840
everywhere, and you look at that and you go, hmm, I wonder how we could do this and not mess up

37:50.840 --> 37:57.640
a million customers, you know, or, you know, we choose not to roll it out in our big library

37:57.640 --> 38:02.760
and just make it, you know, an option for new code, and then doesn't really, there's no bang there,

38:02.760 --> 38:07.400
right, you know, you don't get enough value, so that's a tough problem, that's, you know,

38:07.400 --> 38:13.160
the problem of legacy code and the problem of compatibility shoots down a lot of good feature

38:13.160 --> 38:21.080
ideas, and we haven't found a way around this one. It's one of several, interestingly,

38:22.440 --> 38:26.600
functionally inspired topics that we'll be discussing this summer, we're having sort of a

38:26.600 --> 38:30.600
series of summer camps on the team where we'll discuss topics that are normally out of bounds,

38:30.600 --> 38:36.600
because we don't know how to deal with them, and this is one of them, so maybe one day we'll figure

38:36.680 --> 38:40.440
out a way to make that good. Yeah?

38:54.440 --> 39:03.560
Yeah, so the question is, is the, is the sequel style syntax still in broad use,

39:04.040 --> 39:09.640
and it's true, it does feel very different from the rest of the language, it's, yeah, it's just,

39:09.640 --> 39:19.800
it's like you enter another world. Yeah, we have to maintain compatibility with it, but also,

39:19.800 --> 39:25.000
furthermore, I think it is still, it is still used a bit, like a bunch, not more than a bit,

39:25.000 --> 39:28.920
actually, a bunch of people actually do prefer the method called syntax, even when they're using

39:28.920 --> 39:40.520
the query methods. I find that if I have to do more than one from, from x in blah, from y in

39:41.480 --> 39:47.640
x dot, or something like that, then writing the corresponding query with method calls becomes,

39:50.440 --> 39:55.960
becomes mind-blowingly hard, and you have to use select many, and select many is mind-blowing,

39:55.960 --> 40:01.560
and so I always, if I have to, if I have to, like, do more than one from, if I have to, like,

40:01.560 --> 40:05.880
dig into data with froms, I switch to query syntax and let the compiler figure it out for me,

40:05.880 --> 40:11.160
because I, my brain can't handle it. It's all, actually, it's all down to monads,

40:11.160 --> 40:16.760
so how many people here know about monads? Yes, that's more than I would have expected,

40:16.760 --> 40:21.640
actually. It's this concept that is super central to a bunch of functional, a typed functional

40:21.640 --> 40:26.120
programming, and nobody understands it. A bunch of people claim that they do, but they're actually

40:26.120 --> 40:33.720
just, you know, it's a collective kind of like, it's a hoax. They don't, not for long anyway. I've

40:33.720 --> 40:37.880
understood it many times, and then, you know, the next day I was like, what was it again? Maybe I

40:37.880 --> 40:43.960
was just dreaming it. It made, it totally makes sense at the time, but query, query expressions,

40:44.760 --> 40:51.400
they are a monad. They're a language support for a monad, and when you use more than one from,

40:51.960 --> 40:57.320
that is where you get into monadic territory, where the select many is the thing that makes them,

40:57.320 --> 41:02.440
makes them a monad, and that's, that's exactly why it gets mind blowing to do it directly. It's

41:02.440 --> 41:07.480
because it's monad, and you want syntax for that. But other than that, people have different styles.

41:07.480 --> 41:11.960
There are also people who work on low level code that would be like, this is way too inefficient.

41:12.840 --> 41:18.200
It does you, there's all this laziness, right? The, the iterators are generating things along the

41:18.200 --> 41:23.880
way, which means you have all this like, you have a bunch of structure, you have all these calls

41:23.880 --> 41:28.840
through interfaces and so on. So if you're doing performance intensive code, one of the things

41:28.840 --> 41:34.920
that people look for in code reviews is, oh, oh, you have a query there. Well, fix that, you know,

41:34.920 --> 41:44.440
go back to ugly array based stuff, because then it's going to be faster. So I will say that entity

41:44.520 --> 41:51.640
framework, live and kicking offers up, you know, a query provider implementation,

41:51.640 --> 41:55.800
and people do use that, and they do use the query syntax when they're interacting with that,

41:55.800 --> 42:04.440
because it is a database technology outside of that, maybe not so much. Okay. All right. One more.

42:14.680 --> 42:19.400
That's true. Yes.

42:30.760 --> 42:35.320
So that's a great question because, and we might touch on it a little bit later.

42:37.160 --> 42:43.240
So let me repeat again. The one thing you can do in the query syntax is you can use let

42:43.320 --> 42:48.680
to actually introduce more temporary variables inside of the query. I haven't done it in many

42:48.680 --> 42:54.280
years, actually. Let's see if we can do that. Let y equal x times two or something like that.

42:55.320 --> 43:01.000
Yeah, it worked, at least it compiles. So now the rest of the query has access to x and y,

43:03.000 --> 43:09.800
and that's really useful because you have sort of like variable declaration inside of an expression

43:09.800 --> 43:15.720
rather than as a separate statement. And that has continued to doggers. That statement-based

43:17.320 --> 43:21.640
approach to variable declarations has continued to doggers. And in later versions of C-sharp,

43:21.640 --> 43:26.200
there are more and more places where you can now declare variables inside of an

43:27.320 --> 43:31.000
expression. We haven't done it completely generally. We had a proposal for it where we never

43:31.000 --> 43:35.480
went that far, but there are many situations now where you can declare an inline variable,

43:35.480 --> 43:39.080
particularly in pattern matching, which we're going to get to soon. So that even provides

43:39.800 --> 43:50.200
a good segue for that. Another big difference is functional languages tend to be very expression-based.

43:50.200 --> 43:58.520
Typically, a function doesn't have side effects in a pure functional sense, so you don't really

43:58.520 --> 44:03.800
need statements. You just need an expression saying what the whole thing is, and then you stick it

44:03.800 --> 44:08.040
together, you put sub-expressions inside, and it's all expression-based, and so you need things like

44:08.040 --> 44:12.200
variable declaration to be expression-based. And the more expression-based, the more we get

44:12.200 --> 44:16.760
inspired by that in C-sharp, the more of a shortcoming it becomes that variable declaration

44:16.760 --> 44:21.560
isn't one of them. So great, great point. And this is a way to sneak it in. You can't do that with

44:21.560 --> 44:25.800
method call syntax, because it does sneaky things under the hood. It builds little, like,

44:25.800 --> 44:32.920
tuple-like things to keep track of all the variables under the hood. Okay. Yep. Okay.

44:32.920 --> 44:37.800
Let's fast forward a little bit. Then we did dynamic. That was certainly not very functional.

44:37.800 --> 44:44.040
C-sharp 4. C-sharp 5, we did async, which was potentially very functional. F-sharp already

44:44.040 --> 44:50.600
had a solution to async, which was also sort of monadic, and which is beautiful, but is very

44:50.600 --> 44:57.400
ill-suited for a predominantly imperative language. So we went in a different direction with async,

44:57.400 --> 45:05.720
and the general functional approach to async is quite different from the imperative approach

45:05.800 --> 45:12.120
that we use in C-sharp. Essentially, they use an approach where they built up the whole control

45:12.120 --> 45:17.400
flow of the async ahead of time, and then you kind of pull a handle in, and it runs. It's like

45:17.400 --> 45:25.080
you built all the pipes, and then you turn on the water. And in our async, we sort of more like

45:26.520 --> 45:31.640
laying out the pipes as the water is coming. It's sometimes called a cold and hot async.

45:31.640 --> 45:40.600
Like we work with tasks, which are things that are already happening, things that are already

45:40.600 --> 45:46.280
concurrently operating, and then you can take a task, and then you can say, well, I'm ready for

45:46.280 --> 45:50.440
you. Are you ready for me and get a result out of them? So that's all much more imperative

45:50.440 --> 45:54.920
fits better with imperative workflow. So there, we didn't go the functional way. We don't always do it.

45:55.480 --> 46:02.280
In C-sharp 6, we started getting interested in the expression-based stuff again, though. So I'm

46:02.280 --> 46:10.120
going to switch to a different file here. So one thing that we really like, the expression bodies

46:10.120 --> 46:14.360
of lambdas, we're like, why should only lambdas be allowed to have expression bodies? Why can't

46:14.360 --> 46:18.840
all our functions, all our function members have expression bodies, and we're like, okay,

46:18.840 --> 46:24.360
C-sharp 6, we did kind of half of them, and then C-sharp 7, we did the rest. So now

46:25.400 --> 46:29.800
all function members in C-sharp can have expression bodies where you just put that lambda

46:29.800 --> 46:38.040
arrow there, the fat arrow, as we shouldn't call it, and you get it. You don't have to say return.

46:38.040 --> 46:45.080
If your only statement is return something, cut the boilerplate. But it's just in tactic sugar,

46:45.080 --> 46:53.560
right? So, but coming to C-sharp 7, we're starting to think about more fundamental

46:53.560 --> 47:01.800
things again. So not so much in the syntax, syntactic sugar, you know, as feel kind of layer,

47:01.800 --> 47:09.400
but really like, uh-oh, object-oriented program is kind of screwed in these new scenarios that are

47:09.400 --> 47:18.360
becoming very predominant and widespread. Essentially, when it comes to cloud programming,

47:20.520 --> 47:24.280
history is on the side of functional programming. I'm sorry, object-oriented programming is not

47:24.280 --> 47:31.800
good for that. If you think about, and that comes down to how you describe aberrations over types

47:31.880 --> 47:39.720
of data. In both object-oriented and functional programming, there are ways that you can write

47:39.720 --> 47:45.800
functions so that they have appropriate behavior for each shape of data, for each type. But those

47:45.800 --> 47:51.640
ways are very different. They're like actually, I think probably if Eric Meyer was here, he would

47:51.640 --> 47:56.920
say that there's a duality, like they're completely like the opposite of each other.

47:57.880 --> 48:03.560
What we do in classic object-oriented programming, we love encapsulation. We love saying the data

48:03.560 --> 48:08.440
is actually secret. I'm not even, I'm not exposing it because then I can change it whenever I like,

48:08.440 --> 48:13.240
and then I just offer up some functions, and I can have a class hierarchy with virtual functions

48:13.800 --> 48:18.520
that I can then describe for each type of data what it does. So the super like,

48:19.480 --> 48:23.720
idiotically simple example here is the two-string virtual method, right, where I am

48:24.440 --> 48:32.840
I am describing the string representation of the object by overriding the virtual method

48:32.840 --> 48:41.560
two-string. Great, you know, that means that whenever I write a new derived class from person

48:41.560 --> 48:47.080
here or from object actually in this case, you know, I can just overwrite that behavior to suit

48:47.080 --> 48:53.080
whatever my shape is, and somebody else can call it on the base class and not even know I exist,

48:53.080 --> 49:01.720
but still get the right behavior. Excellent, except when you have a world where data is long

49:01.720 --> 49:07.080
lived in the cloud, maybe, or in databases and whatnot, and different people are writing different

49:07.080 --> 49:12.520
functionality over the same data models, well, oops, now it's not so good to encapsulate those

49:13.480 --> 49:20.280
behaviors with the data model, right? You want to independently be able to express behaviors over

49:20.280 --> 49:31.160
the data model that still depend on, like, still type specific, but that the original type knows

49:31.160 --> 49:38.600
nothing about, and that the different domains of behavior have no idea about each other. So

49:38.600 --> 49:43.400
encapsulation is dead, right? You need, for those scenarios, you need the data to be public,

49:43.880 --> 49:52.760
and luckily we have, you know, auto properties to make that easy, and you need the functions to

49:52.760 --> 50:01.000
work from the outside. But in a C-sharp 6 setting, so let's say we're still in 6, doing something,

50:02.120 --> 50:07.880
let's say I want to write the two-string method from the outside, that's actually fairly hard,

50:07.880 --> 50:15.000
that's annoyingly clunky, and that you get back to that dying inside feeling. So let's try to do

50:15.000 --> 50:19.640
it, I'm making you all die a little bit inside, I'm sorry, we'll revive that part, and there'll

50:19.640 --> 50:26.520
be flowers, and it'll be good in a minute, but you know. So let's say two-string, let's call it

50:27.080 --> 50:39.640
something else, render, and you take a person, it's not even generics involved here, you take

50:39.640 --> 50:44.200
a person, P, and then you want to render it according to which kind of, you know, which person

50:44.920 --> 50:50.840
derived class it is. So we could do that, we can say, you know, we have type testing in C-sharp,

50:50.840 --> 50:57.240
we can say if P is a student, and that's the only derived class that I actually put in here,

50:57.240 --> 51:03.160
but you know, imagine there are dozens. For each of those, you say if P is student,

51:03.160 --> 51:09.000
then do, at least we have expression-bodied members here, no I can't do that here, return

51:11.320 --> 51:16.760
whatever the student does, okay, I'm cheating a little using interpolated strings here,

51:17.720 --> 51:26.120
return that, except of course I have to dot my way into that public data, no problem,

51:26.760 --> 51:34.120
but as I get to the student-specific property here, oh, you know, I already, I just asked,

51:34.120 --> 51:40.440
but I already forgot that it was a student, so I don't get to. If only we were type script,

51:40.440 --> 51:45.560
you know, type script, it has flow-based typing, you know, a variable, you know, if you figured

51:45.560 --> 51:49.960
out it wasn't something on this branch, then, you know, it'll know you're something else,

51:49.960 --> 51:53.880
and it's beautiful, but we can't, that's, oh, we're super-breaking in C-sharp, and also their

51:53.880 --> 52:00.440
compiler is, you know, just thank God that they don't promise type safety, let me just put it like

52:00.440 --> 52:08.200
that, so that is kind of annoying, what to do, well, you know, in C-sharp 6, your best option is to,

52:08.200 --> 52:13.320
you know, cast P to student, knowing it will succeed, because you're smarter than the compiler,

52:13.800 --> 52:18.200
until you maintain your code a little bit, and I know somebody else takes over,

52:18.200 --> 52:25.320
and they do a refactoring manually, and stuff blows up, but that, we can do that,

52:25.320 --> 52:30.120
and then there's an else, you know, else return that other stuff, let's just get it in there,

52:30.120 --> 52:38.440
so we can, so we can mutate the code a little bit, return that stuff, and of course there would be

52:38.440 --> 52:45.640
else ifs for every other, like, derived class here, so here we get to do p.this and p.that,

52:45.640 --> 52:53.480
so far so good, but functional languages, they do this all the time, and it's interesting to note

52:53.480 --> 53:04.440
that there's a fundamental difference in how the, you know, what kind of contract you have here,

53:04.440 --> 53:08.280
when you use opti-growing programming, as I said, you can add a new class whenever you want,

53:08.280 --> 53:12.200
and you can just overwrite that virtual method, and everyone's happy, right, because the code and

53:12.200 --> 53:19.240
the class are together, if you add a new type, like, in this functional setting, you are explicitly

53:19.240 --> 53:24.120
in the function, you are mentioning all the different shapes that you care about, and if somebody

53:24.120 --> 53:29.320
adds another shape of data, and you know, your code is no longer handling that, so there's a

53:29.320 --> 53:35.560
different, you can't add new data with impunity, but you can add new functions with impunity,

53:35.560 --> 53:41.560
which you can't do in the opti-growing world, you can't go without going back and editing the

53:41.560 --> 53:45.320
original, right, you can't independently add new functions in opti-growing programming,

53:45.320 --> 53:52.600
but you can add new types, in functional programming, you can't independently add

53:52.600 --> 53:57.880
new types, but you can add new functions, this really is a duality, but they do the other things

53:57.880 --> 54:02.360
so well, and what is it they do, well, they do pattern matching, so the first step there is,

54:02.360 --> 54:08.920
let's actually let you declare a variable inside of this expression, you know,

54:09.480 --> 54:14.760
after this expression, that's actually let you put a variable name, and say, okay, I just checked,

54:14.760 --> 54:20.760
can I just get a name for that, can I get a receipt, and you use that throughout here, and that is

54:20.760 --> 54:27.480
your P typed a student with its own name, and now we can, we can, you know, we're not dying

54:27.480 --> 54:37.560
inside anymore, if I can, at least if I can, what, oh no, what's that, yes, it was the wrong

54:37.560 --> 54:49.400
province, no, yes, thank you, thank you, I'm code blind, thank god I only have six minutes left,

54:49.480 --> 54:55.240
oh my god, I only have six minutes left, so what we're getting into is pattern matching,

54:55.240 --> 54:59.560
and pattern matching is this whole new concept that we're adding to C-sharp at this point,

54:59.560 --> 55:05.960
but it's not new in the global sense, it's a well-trodden path in functional programming,

55:05.960 --> 55:11.320
we just have to adapt it to an object-oriented context, and this is a pattern, a pattern is

55:11.320 --> 55:17.720
something that can either succeed or not when you apply it to a value, and if it succeeds,

55:17.720 --> 55:22.120
it can extract some extra information and put it in variables for you, that's what a pattern is,

55:22.120 --> 55:26.440
and we have a few patterns from the beginning in C-sharp 7, and then we start adding some more

55:26.440 --> 55:30.840
along the way, and we keep, we're still adding patterns to this date, like C-sharp 11 has

55:30.840 --> 55:33.880
list patterns, which you will, if you go to the other talk, you'll get to see those,

55:35.160 --> 55:40.520
but it's still like the shape of the code, like we solved the micro problem, but the larger problem

55:40.520 --> 55:43.800
of if, you know, having a very imperative way of checking, that's also very like

55:44.680 --> 55:51.400
a kind of fraud with danger in terms of maintenance and so on, what we want along with pattern

55:51.400 --> 55:57.320
matching is we want what functional programming often calls matching, pattern matching,

55:58.440 --> 56:03.960
we have a keyword already called switch, so we're using that one, so let me go and just, you know,

56:03.960 --> 56:12.040
do this again, so I'm gonna do it in a functional way, let's just, we can comment this out,

56:13.000 --> 56:18.600
so we're gonna do just an expression body, we're gonna take the person, and we're gonna switch

56:18.600 --> 56:25.480
on them, but not with an old-fashioned clunky switch statement from C in the early 60s that

56:25.480 --> 56:29.720
we have in C-sharp, but with a switch expression, you know, like the cool kids, so this is an

56:29.720 --> 56:34.920
expression body, that's a switch expression, it's empty right now, that's actually okay,

56:34.920 --> 56:38.600
but you get a warning saying you're not handling all the different kinds of input, yeah, okay, thank

56:38.600 --> 56:46.200
you, so and now we can write patterns directly here, student S, arrow, and now we can just

56:46.200 --> 56:53.160
put an expression for the result that you want in case it is a student, right, so I can, I now

56:53.160 --> 56:58.760
have like a clean structure within which I can just list comma separated patterns and results,

57:00.360 --> 57:06.440
and I, right now I only need the two, so we're gonna take, we're gonna just do this

57:07.080 --> 57:14.920
for now, and then just quickly touch on the fact that patterns can be, pattern matching

57:14.920 --> 57:19.400
is smarter, right, we saw that it said that you were not handling all the cases, it still did that

57:19.400 --> 57:24.600
when we only had the, when we only had the student, but when I do a catch-all, which I can do with a

57:25.400 --> 57:31.480
fancy modern discard, then it says, hey, you're handling everything, you're good, no more warning,

57:32.280 --> 57:36.200
well, what if I go the other way, like let's just, let's just swap the order of these two,

57:36.200 --> 57:40.520
they are in order, then I actually get an error saying, hey, you handled, you handled this case

57:40.520 --> 57:46.600
already, so, so you can see how maintenance of these things becomes much, not only is it clear

57:46.600 --> 57:51.960
to read, but the compiler is helping you much more, keep your logic straight, so it's beautiful,

57:51.960 --> 57:59.000
and it's safe, that sounds like functional to me, so, so you can do that, but you know,

57:59.880 --> 58:03.400
you're noticing, I'm actually writing out just the first letter of the first name,

58:03.400 --> 58:10.600
and in this case here, actually, what if the, what if the first name is empty, I'm not going to

58:10.600 --> 58:14.600
talk about null right now, that's a whole nother talk, but what if it's empty, that's kind of,

58:14.600 --> 58:19.560
you know, I should probably do something else if it's empty, so let's, let's use, just to show

58:19.560 --> 58:24.360
an example of a recursive pattern, I know now that it's just a person, but what if the first name

58:25.320 --> 58:31.720
of that person actually is an empty string, I want to do something else, and I just want

58:31.720 --> 58:35.560
to write out the last name, I don't want to, like, do the whole abbreviation thing,

58:37.880 --> 58:47.640
p dot last name, or, you know, I could actually, so this is a property pattern, I can dig out

58:47.640 --> 58:51.720
specific properties inside of the pattern and recursively apply a pattern, here I'm just applying

58:51.720 --> 58:58.360
the pattern, I use this constant, but I could also say last name, colon, and then apply a var

58:58.360 --> 59:04.120
pattern, which always succeeds, but which will give you a name, so that's your let, that's your

59:04.120 --> 59:12.280
pattern let, it's the var pattern, and then instead of saying p dot last name here, I already dug

59:12.280 --> 59:18.360
out the last name and I gave it a name, so I can just say l here, so, and these things compose,

59:18.360 --> 59:24.120
you know, if I wanted the actual, if I wanted a new name for the the person object itself,

59:24.120 --> 59:30.520
I could put it here, let's call it p2 or whatever, so, so patterns kind of compose, and over time

59:30.520 --> 59:36.840
we've added more and more kinds of them, that essentially make them more and more expressive,

59:36.840 --> 59:43.160
and allow you to put more and more of your logic into patterns, so that your shape dependent

59:44.040 --> 59:53.320
code is now as beautiful, or some would say even more, I don't, but, you know, it's a great

59:53.320 --> 59:58.200
beautiful first-class alternative to virtual methods, when you, when describing the functionality

59:58.200 --> 01:00:04.680
on the outside is what you want to do, you do pay something, you pay the fact that you can't

01:00:04.680 --> 01:00:09.320
willy-nilly add new types, you pay the fact that your data has to be public, so that it can be

01:00:09.320 --> 01:00:14.040
operated on from the outside, so encapsulation is at the window, but you get this other beauty,

01:00:14.040 --> 01:00:18.520
so, you know, pick your poison, depending on the scenario, now you have both obstinacy sharp,

01:00:19.800 --> 01:00:29.400
and I also wanted to mention immutability, but I just did, we did work for immutability, first

01:00:29.400 --> 01:00:35.480
we let you have auto properties without setters, but that wasn't so good for the, for the object

01:00:35.480 --> 01:00:42.200
initializers, now there's a more, now you have a new kind of setter, it's called an initter,

01:00:42.200 --> 01:00:46.360
which is the setter that can only be called from object initializers, and now, so that means we

01:00:46.360 --> 01:00:51.080
made immutable objects more first-class, you don't need to initialize them with constructors, you

01:00:51.080 --> 01:00:55.240
can use object initializers for those as well, immutability is another functional concept that

01:00:56.120 --> 01:01:04.280
we're starting to support more, so I'm going to stop here in the C-sharp 7s,

01:01:05.960 --> 01:01:10.280
and if you want to see some C-sharp 11 functional influence, you know, there's another talk,

01:01:10.280 --> 01:01:19.320
and just an hour and a half or whatever, and for now, thank you very much.

01:01:25.240 --> 01:01:26.520
you

