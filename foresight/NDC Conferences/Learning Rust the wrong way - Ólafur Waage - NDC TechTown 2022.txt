In Sundarst, in 1853, a boy named Vincent van Gogh was born.
In 1880, at the age of 27, he decides to become an artist.
In his early years, he taught himself to draw and paint, but his style changed significantly
under the influence of Impressionism.
His career was very short, lasting between 1880 and 1890.
Quoting the Britannica biography on Vincent van Gogh, his palette at last became colorful,
his vision less traditional, and his tonality lighter, as may be seen, is one of his first
paintings of Montemarte.
By the summer of 1887, he was painting in pure colors, using broken brushwork, and at
times what's called pointillistic.
Finally, by the beginning of 1888, van Gogh's post-impressionist style had crystallized.
The main painting technique associated with van Gogh is something called Impasto, where
the paint is applied directly onto the canvas and then spread around.
It can even be mixed together, using other paints and sometimes your very own fingers.
Very pretty.
This gives the painting a thick, three-dimensional texture, and the paint itself is undiluted.
A common practice is to work the paint as little as possible, because the more you
touch it and move with it, the duller and flatter it becomes with each stroke.
The most famous example of this is Starry Night, 1889.
Coding again the van Gogh experience, had the painting been done with flat paint, it
would not have been the memorable piece that it is.
Okay, now I have taught you something.
It's time for a quiz.
Who's ready?
Lock the doors.
Is this a painting by van Gogh?
Give me hands for those who think it's a painting by van Gogh.
Nobody.
I have taught you well.
This is Adamon Breen skating on the Frossel, I'm still a rival.
Even not even the same centuries.
Still dots though.
Still dots.
Is this a painting by van Gogh?
Give me some hands.
Oh, again, I have taught you very well.
This is Vincent van Gogh, the farmhouse in Provence, 1888.
Is this a painting by van Gogh?
Huh, any hands?
Scattered hands.
All right.
I mean, yeah, could be early work, could be like inspired by other painters.
That's fine.
No, no, though.
Still touch.
But in the area, so Jonathan Bartholth, town path, all right, is this a van Gogh?
Oh, again, scattered, okay?
Yes, this is van Gogh.
You can see the brushwork on the head of the crab is disjointed, if you think of it that
way.
Crab on its back.
Poor crab.
1888.
Okay, good work.
So hi.
My name is Ola Favogh, I'm a senior software developer at TotalSec AS.
If you don't like this talk you can yell at me on Twitter.
People seem to enjoy doing that.
So I work for a company called TotalSec here in Norway.
We are a consultancy and teaching training company.
So again, if you like our work, please hire us.
We do training as we did here at this conference.
Good stuff.
So this talk is titled learning rust the wrong way.
So the reason why I named the talk that way is, yeah, it is in part about rust.
But it's also about learning.
So I hope you will enjoy.
So what's wrong with knowing what you know now and not knowing what you don't know until
later, right?
I love coding philosophers, which is Winnie the Pooh.
Good, good stuff.
So what's going on here?
So yeah, as you get my guest by the title of the talk and the introduction, this, yeah,
this isn't one of my normal talks.
The structure itself is a bit of an experiment on my end.
So let me know how you think about it.
Yes, you will learn some rust.
It's kind of enough for me to make a point.
But you will also learn about learning the wrong way.
And yeah, the talk might have a point, but we will go places before we get there.
Everybody ready?
Accepting?
Wonderful.
Wonderful.
So since the title was Wrong Ways to Learn Rust, let's do actual wrong ways to learn
rust, right?
Because let's be literal here.
So at least we will have that covered.
While skydiving.
No.
You will not learn rust while skydiving.
Even though this person might be having fun.
No.
I do not recommend learning rust while skydiving.
Next example, as an 18th century aristocrat, since we'll be talking about the paintings
from the 18th century, no, not with this.
But for some reason, they have Windows 11 on that laptop.
So not recommended, all right?
Just to give a talk at a technical conference.
We can skip this one.
All right.
So what is rust?
Let's begin with that.
So it's a programming language that focuses on performance, safety, and productivity.
That's kind of their guiding light.
It looks kind of like this.
So here I'm defining a function.
Here's the main function.
Here I'm defining a variable.
How is the visibility for those in the back?
Okayish.
Good.
All right.
So I'm creating a variable called float.
It is of F64, which is the double from us in other languages.
The value of 42, you don't have to put an F score.
Here I'm creating a variable.
So I'm saying let the mood, so it's a value.
Because in rust, it's cons by default.
So you have to say that the value is movable, so you have to say let mood.
I can ask a question about the float.
No parentheses needed.
Very good.
I can then mutate the value, and then I can call print line exclamation point and similar
formatting style.
So the print line with the exclamation point is from something called a macro in the language.
So if you see these, they are macros.
They are defined in a little bit different way.
A way of thinking of them is, like, what if C macros had types and also looked more
like functions?
But in a way.
Yes.
Good.
So 2006 personal project by a Mozilla employee called Graydon Horpe, 2009 turned into a Mozilla
sponsored project.
2011, we have the first bootstrap version, which is rust compiling rust.
And then version 0.1 in 2012.
So it is a new language, but it's, again, not that new.
Like, when you think of new languages, that's like stuff coming out yesterday.
So at least the idea has been around since, like, 2006, seven, eight, nine, that kind of
thing.
Right?
Good.
So more code examples here.
I have main.
I'm creating a value.
Here's an integer.
I32.
So the language talks a lot about borrowing and what is alive and what is not alive and
what can you mess with while you are programming.
So here I'm going to borrow my value into the function borrow value.
All right?
So I have the little reference value there.
I can borrow it again.
That's fine.
And I can print out those two, those two values.
So notice that I'm borrowing into the function, but I'm getting a value out of the function.
So the function looks something like this.
So here we define a function borrow value.
Again the type is on the end.
It is the reference of I32 and I'm returning an I32.
Good.
I can create a mutable value within it, which is a copy of the borrowed value.
I can change it in some fun ways.
And then returning a value from a function usually looks like this, which is like the
last expression, the last statement within the line and with no semicolon.
You can do the return.
So for things like early exits, like if you do an if something, something you want to
return out, you can do that.
That's fine.
Good.
Well, what happens if I do this?
So here I am borrowing the value mutably.
So I want the mutable reference to the value or as in C++, just a reference.
Because the thing we had before is a const reference.
All right.
What happens then?
Any hands now?
Since I've been training you on the hands.
It doesn't work.
Does not work.
So here's the main thing.
We're looking at line 11 there.
New value, borrow value, and we're sending in reference.
Types differ in mutability.
The blue line might not be visible.
I can read it out.
Arguments to this function are incorrect.
We expected a mutable reference, so ref mutify32, but we found the regular reference.
So this has to match, which is like one of the early walls you will hit with the language.
Good.
So if I have another main, I have my value and how much.
So my value is mutable.
How much is not mutable?
So here I am sending in my value into the function as a mutable reference.
You can now, the mutate value is allowed to change the value and how much I'm just sending
it by reference.
By the way, I don't have to send it in as reference.
I can send it in a copy, but I'm just showing you the referencing part of it.
And then I can print out my value, and it will have changed.
So I take value in as mutable, I32, I take in how much as a reference to I32, I change
the value.
We are happy.
This is fine.
I mean, fine, not fine.
The language is happy with you, basically, the sentences.
So what if I change this to this?
So this is a thing in C++, which is the, like, this is a problem people have.
And we have to learn, like, in what order things are evaluated, like, oh, it's from
the left, from the right to the left for the arguments and all these kinds of things.
So here, I'm sending in a mutable reference of my value, and then I'm also sending a reference
to my value.
But within the function, they are a different variable, but they're referencing the same
value from the outside.
So again, hence, what's going to happen?
Yes.
Compiler error, that's right.
So you are asking for mutability from one variable, you're asking for a non-mutability
from another variable, but it happens to be the same variable.
So think of the single writer, multi-reader locks that we have, where you can, like,
when you can only have one writer to a variable, but you can have many readers.
So imagine a programming language where every single variable is an MSRV lock, not the
actual lock, but the language feature.
So yeah.
Any mutable borrow occurs here while we have a mutable borrow for the first argument.
This won't work.
Cool.
Let's talk about baseball.
Who likes baseball?
Yeah?
More for American sport, maybe?
So hitting a baseball is a relatively complicated skill.
You need speed to recognize what kind of ball is being thrown at you, you need precision
to hit the ball, and strength to make sure it goes as far as possible.
In 2018, the batting average was .248, which means that the average baseball player had
a 24.8% chance to hit the ball, okay?
This is not per ball thrown, but for the entire attempt.
How many balls are being thrown at the person?
Some of them can be strikes, some of them can be what's called balls.
So there is a bit more to it, but that's the general idea of ball on the way.
So Cal Poly Mustangs, or a baseball team that represents the California Polytechnic State
University.
The team was founded in 1948 and have competed in what's called the Big West Conference since
1997, and they even won it in 2014.
In 1994, the university published a paper by Hall Dominiques and Caravazos called Contextual
Inference Effects with Skilled Baseball Players, and the reference is also down there if you're
looking at this later on.
The study took a group of baseball players and measured their batting averages.
The idea was then to give them extra batting practices for six weeks.
The baseball study.
They were split into three groups.
One of the groups got thrown balls in a structured order.
15, first of them, were fast balls.
The next 15 balls in the practice were curve balls, the next 15 were change-ups.
A change-up is a ball that starts out looking like a fast ball, but becomes a curve ball
the other way around.
The idea is that it changes halfway.
They were always thrown in this order, and the players always knew what type of ball
was being thrown next.
This is sometimes called blocked practice, where you split the exercise into similarly
structured blocks.
The second group got the same number of baseballs, but the order was still 45, but the order
was random.
They had no idea what ball was next.
Maybe they knew the last one, if they were counting, but anyway.
Then there was a control group who did not get any extra practice.
Let's look at the results.
What do you think happened?
Think about what kind of practice this was.
One group got, they knew what they were getting.
I can know I can practice for one of the balls.
I will then practice for that.
The other group had no idea.
There's a ball happening.
Then the third group got nothing, so we have a control group.
After the six weeks, there was another test, so we had a test at the beginning, six weeks
and then another test, where they got 45 random balls.
The control group improved by 6.2%.
People are getting better, or there's some random variation in how you're testing, so
you can ignore the 6%, or you can reduce the results by 6%.
The blocked group, which is they know what they're getting, they improved by 24.8%.
It's pretty nice.
What do you think the random group hit?
Any guessers around the blocked?
The same?
56.7%.
What?
They don't know what they're practicing for, they get some stuff, and it's like they practiced
for twice the amount of time than the blocked group.
What's going on?
This is weird.
Some might say, shouldn't the blocked practice have helped more?
Because in the random practice, you don't know what you're practicing for.
You have no way to prepare any sort of mental model or muscle memory for the throws that
are coming.
We'll get into this a bit later.
What's going on here?
I wanted to learn Rust, the programming language, not the chemical process.
I had the idea that I am a programmer, right?
I have certain skills.
I had some experience with programming, I think.
Those skills should transfer.
Learning another language, like really learning it, should be easy, because I have no C++,
I know JavaScript for crying out loud.
Doing the next one should be easy, right?
This is not a jab at the idea that Rust is difficult, because I don't think that matters.
That's not the point here.
Rust is a jab at my hubris, so if you want to do a jab at my hubris, you can do that.
Enjoy it.
What I found that, I actually didn't learn that much of Rust until I really sat down
and I really sunk my teeth into it.
Doing a tutorial here or there, doing a video lecture, no, didn't help at all.
Why?
So as a curious person, I wanted to know why.
So instead of learning more Rust, I wanted to learn about why I wasn't learning more
Rust.
I think this is called yak shaving for some people, but at least you will enjoy the fruits
of that labor.
So I sat down and I read books and I studied papers like these ones.
I wanted to know why when you have a skill beforehand, it doesn't transfer that well.
It's not until you actually sit down and work on it, only then it actually works.
So let's talk about Pokemon.
Okay, okay, and Rust, and Rust.
So after going through these exercises that cover the basics of Rust, I used that exercise
called Rustlings to begin with, very good to recommend them.
I started to look at my older projects that I had made in C++, so with the idea that I
would just convert them over.
I have a skill here.
I want to see how this looks in the other language.
I can compare and contrast very scientist.
So and yeah, this is a great technique.
If you're doing this, if you have an older project, if you know another language, you
should convert stuff over.
So now you have to take a Pokemon quiz.
No.
So the general idea, the only thing you have to know about Pokemon is that they are of
a certain type.
There are probably thousands, hundreds, whatever.
But they are of a certain type.
There could be a fire Pokemon, a water Pokemon, yada, yada.
And if a fire Pokemon attacks a grass Pokemon, they do twice the amount of damage.
If an electric Pokemon attacks, let's say, a dark Pokemon, which is one of the types,
they do half damage.
And for the black squares, they do no damage.
That's the only thing you have to know.
Now you are a Pokemon expert.
Enjoy.
So what this means is, so I made a project, I think now 10 years ago, that takes where
every pixel on the grid, I will show you a grid in a bit, is a Pokemon of a certain
type.
It will look around the grid, look for other Pokemons, and then do an attack, do some
damage.
If the Pokemon you attacked dies, and let's say you are an electric Pokemon, they will
then turn into an electric Pokemon.
It's kind of like this.
Happy how well the GIF looks in this.
So this is the C++ version.
And this is also, I'm going to show you the Rust version later on, but it will look quite
a bit different.
But I had a different parameter for the GIF that I had, but yeah, it looks pretty, right?
They're growing, they're shrinking.
Yeah, Pokemon attacking.
So let's look at the C++ code.
And yeah, this is from 10 years ago, so you can totally make fun of me.
That's fine.
So you have an X coordinate, which is the where you are on the X grid, on the Y
coordinate, same grid size, because it's a one by one grid.
The idea is that you have an array of a ray of Pokemon.
You will then get the attacker, which is the first Pokemon, you get a reference to
it, and then you find out who your weakest neighbor is.
So you take, you create a position out of your position.
You have an out variable, yes, out variable, 10 years ago, off the enemy
position, you have a function called weakest neighbor.
You take in your position, the enemy position, and the list of the Pokemon, then
you will get out the weakest Pokemon around you.
Let's, you get the position for that Pokemon.
Let's then get that Pokemon itself, and then you fight.
Simple enough, right?
Where you are, who is the weakest, get a reference to it, fight.
Cool.
This is the Rust version.
So in the Rust version, the colors are correct.
So yellow is lightning.
The purple one is dark, I think.
I don't know the other.
Green is grass, maybe.
It's very pretty.
I like it.
Yeah, it has other parameters.
I think it's running faster.
So these are more generations than the other one.
Okay, so let's implement that in Rust.
So a Pokemon is, you have certain health and you can do a certain amount of damage.
I think in the tests I had, they all had the same damage, but then you had the
multiplier, but it's nice to have like a variable for it.
So when you want to implement functions onto a class in Rust or struct in Rust,
they are separated out.
You have the struct, and then you have the implementation for the struct.
So this is a, what we might think of as a static function.
So this is to create a new Pokemon.
It returns a type of itself.
So here we just create a Pokemon.
You might think of this as an R value that I return.
So remember that I'm returning, it doesn't have a semicolon.
So I'm actually returning the Pokemon out from the function.
So I'm just creating a Pokemon and returning it.
It has 10 health and it does five damage.
Then I have a function.
So you can say it's a function, take damage.
It has a mutable self.
So this is a non-const function and the amount of damage that I want to take.
And you look here, I'm not taking in reference of anything, just a value.
And yeah, simple as that.
Simple as that.
I reduce the health.
So a battle is then a container of Pokemons.
So Rust has container stuff.
We have here vector.
They work generally similar as the vector that we have.
So I want to implement the battle in the same way I have a static function to
new the battle.
For this example, I'm only going to have two Pokemons.
So I'm not going to have the full grid just to simplify the code.
So I just say Pokemon new, Pokemon new, and I have a vector from two Pokemons.
Okay.
And again, I have a battle and I'm returning the battle.
So now I have a battle of two Pokemons.
So let's fight.
Cool.
So because we, when we're fighting, one of the health of one of the Pokemons goes
down, so I want to mutate, mutate whatever's in the Pokemon.
So this is a way of doing a loop.
If I want the index for N and I dot, dot, dot, self, I can have some length.
So self Pokemon length.
So again, same way I'm doing a super plus, since I was converting stuff over, I
get a reference to the attacker.
I get a mutable reference to the defender.
And I say fight.
Okay.
Sounds good.
I have the rust teacher shaking his head.
No, this doesn't work.
Okay.
So this is another thing.
So here we have cannot borrow self Pokemons as mutable because it's also
borrowed as immutable there.
What?
What?
So the, the, the idea that I had in the C++ version actually has a problem
because in one sense I'm having a, a non mutable borrow to a value and I'm
having a mutable borrow to another value, which is something that C++ doesn't care
about.
But here they're like, no, this is scary.
This is dangerous.
Don't do this.
So how would you fix this?
Right.
Well, what do I actually need from the attacker?
I don't need the actual attacker.
I only need the damage.
So the solution in this case is we just get the damage and then we do the attack.
We don't need the actual, we don't need the entire structure to do a combat when
only one parameter of the Pokemon actually matters.
So here's the language and telling you, you're being silly.
You should rethink this.
This is not, uh, you're not playing.
You're programming in the wrong way.
The language is saying, please rethink this.
All right.
So in the actual version, that's what we do.
We just take the values we need out to use them.
Cool.
Let's go back to paintings.
Right.
Beautiful paintings.
So in 2008, an experiment was conducted at the University of California.
The goal of the research was to detect the difference between two teaching methods,
masked versus spaced.
They were asked to study paintings grouped by the artist, which is called masked.
You get a bunch of paintings by one artist.
And then you have to have a quiz after that.
Uh, or they were interleaved by other artists.
So you'd have artist A, artist B, artist C, and then mixed together.
So each masked participant would get a set of paintings by the same artist and you
would spend time looking at the style, the next painting, since it's by the same
artist and look for similarities.
Like you look at painting A by artist A, looking paint, next painting by artist A,
like, okay, what is this similar thing here?
Like we did with Van Gogh in the beginning, but the space participants would get a
mix of artists all over the place.
Okay.
So what they would then have to ask the quiz was basically like we did in the
beginning, is this a painting by artist A?
Is this by Van Gogh?
In the actual test, they used like non famous artists or like, like they wouldn't
have starry night, right?
They would have just some, some artists.
Uh, so the results were counterintuitive because they were not
counterintuitive because the spaced version did better.
Always better.
Never like there isn't a variance here.
So the people who did not get to focus on art, one artist, the next one, the next
one, they did worse.
Oh, sorry.
The, yeah, the people who, who did not get to do that, they did better.
Sorry.
Other way around my brain.
But not only that, yeah, the space version where the participants are not able
to study a single painter at a time and focus on their styles, got a better
result.
So, and even if the masked version did worse, they liked that way.
They were asked afterwards, even after they've known the results, which one
do you like?
Do you like to learn one painter at a time to focus on the thing?
Or do you want it spread out and randomly selected?
Even if they knew the results, no, they still like learning one at a time.
They did worse.
They didn't care.
So from quoting from the, the test in experiments, one A and two combined, 85% of
the participants did at least well in the space condition, as well as the mask,
mask condition, but 83 of the participants rated the mask condition as equally
effective or more effective than the space condition.
It's not even slight difference.
Like, no, most people wanted the one same artist.
Looking back at our own inability to foresee the benefits of spacing, perhaps we
felt victim to the same illusion that we have railed against.
So these are the, the study, the testers, Bjork and Cornell.
And this has been done over many years.
So 94, 99 and 2007, different types of studies, namely the illusion that a sense
of ease and fluency accompanies effective learning, whereas a sense of
difficulty signifies ineffective learning.
In the case of the induction, the case of induction, as many as other types of
learning spacing appears to be sometimes, if not always, at the desirable
difficulty.
So this is the word, the desirable difficulties.
This is 94.
And this is the concept that's used, the concept that you see here is the
important point, the desirable difficulty.
We don't want things to be hard just for the sake of being hard.
The next slide is not a better version of this one.
I can tell you that this is a, a, a Caesar cipher of two.
Now go read the slide.
It's not better.
So these, this is, this slide is more difficult than this slide.
That's not, does not mean it's better.
So the key concept is the desirable difficulty.
So, sorry, man.
So quoting Elizabeth Bjork and Robert Bjork again about the desirable
difficulties, they trigger encoding and retrieval processes that support
learning, comprehension, and remembering.
So this is, this is kind of my summary for this.
Practicing easy things is fooling your brain and thinking that you're doing well.
Okay.
Good.
Good.
So empirical studies have looked at the different learning methods and
strategies that have a positive impact on your learning.
So spacing that we talked about before, also interleaving.
So spacing is like spacing out the different types you have.
Interleaving is different kinds of learning, doing different methods of like,
I want to learn in one style and then I learn another style.
And yeah, variation, like learn different things as well.
And also this thing, generation.
So what generation is, at least what they were thinking is you will be taught
something and now you have to create questions about the thing that you learned.
You will not be given questions.
You will not be given material.
You have to form your own thoughts about this thing.
Which sounds difficult, which it is, and that's good.
That's what generation is.
So there was even a study done, Karen Poth, 1978.
So kids were supposed to throw bean bags at a target.
Group A, practice by throwing at a single target, like these things here.
Group B, practice by throwing at many targets, either close or further away,
but never the same distance as group A.
Then a test was conducted to throw at the same target that group A used
and group B did better.
So here we have variation, practice different things.
So let's go back to Rust or any language.
So what does it actually take to learn a new programming language?
So is it enough to watch a YouTube video?
Good.
To read a blog post-tutorial?
To watch an hour-long conference talk?
To sit down in the program?
More hands, more nods?
No.
But you need all of these and more because mixed together over a long period of time.
So this is kind of the key that I've been seeing through obsessing about learning,
is watching a YouTube video is one style of learning.
And then reading a blog post-tutorial, watching a talk, doing a programming,
like you are interweaving everything that is happening here, different learning styles.
And this also adds time.
So this is the...
What I've been seeing through all of the studies is it takes time,
and different things that you do, and then at some point, yeah, you will learn something.
But it is difficult, and that is good.
Not the first is difficult.
Maybe it is, but that's another point.
So let's learn programming in 10 days, right?
Or 10 hours or 30 days.
So who has seen the books?
Have they become less common, right?
Yeah, learning Java in 30 days or whatever they're called.
There's a blog post by Peter Norwick, which he's very angry at these books, and rightly so.
So, yeah, I don't think you learn programming in 10 days.
So, remembering.
So what I can see from the literature, yeah, mixing up practice styles,
waiting between study sessions.
So now you have an excuse, right?
I'm not procrastinating.
This is the waiting period.
This is the incubation period between the study sessions.
Don't cram.
That's another thing they've shown.
Cramming has no point.
They've been doing tests on students that, and I don't have the example of,
some of them had to really cram before a test.
The others were not allowed to study before the test, and there was no
significant difference between them.
There's even like the, what's it called, the cue cards, that they would like really
learn through the cue cards, and yeah, there's no difference.
Don't cram.
So, and this is a re-wording of one of the quotes.
Difficult to remember in things, and then finding the right results
strengthens the memory.
I told you something, and then you had to recall it again.
An anecdotal evidence, or anecdotal story that I heard about something
like this is, the memories you have of when you were a kid exist as pictures
in your parents' house.
Because you go back and you look at the pictures.
So you remember the time you went to the theme park, or you remember the time
you climbed that hill, because you see it again and again over time.
There are other memories, but the ones that are pictures in your parents'
house, those are the ones you remember.
So, in 1950s and 60s, the concept of errorless learning was advocated by
B.F. Skinner.
Yes, that's Skinner, that's you, might be thinking about.
So, the idea was to give you the information, and then immediately a quiz.
So, who remembers what I was doing in the beginning of the talk?
So, we are fetching information straight from the short-term memory.
That was the big thing, like, if I tell you something, and immediately quiz you
on it, you won't fail the quiz, and then you are an expert.
Right?
No.
Yeah, the opposite has actually been shown to be true.
To quiz people later.
So, there was a case of, and I think, yeah, there's another thing I'm going to show you.
There's a case of the, like, a class has been taught in multiple ways, where there
was a bunch of quizzes during the poll session.
Wow.
Not the seminar, during the whole year, half a year, where they were giving a
bunch of quizzes along the way, and there was no final exam, and then just a
grade from that, or there was no quiz and one big final exam at the end with
everything, but then they tested the people again, I think a year later, and the
people who had the one quiz at the end still remembered more than the people who
just, because that's what you're doing.
You're, I learned A, have a test on A.
I learned B, I have a test on B, then I don't have to think about it, but those
who have to learn everything and take a test on everything, they had to really
sit and, yeah, remember everything that was happening.
So, they were giving kids a set of hard puzzles, like the anagram puzzles.
Half of them were just said, yeah, it's going to be hard.
Difficulty is just a part of it, and that's okay.
Don't worry about it.
Uh, the other halves were asked to, like, explain how they would solve a puzzle.
Like, yeah, you have to solve this.
Tell me how you're thinking about the problem.
The first group did better.
Yeah.
Just saying, like, it's going to be hard.
That's okay.
You're going to fail something.
That's fine.
Just let's, let's go through this.
The other one, we talk about, like, how are you doing things?
Or I'll give you a little tip on how to solve these puzzles.
No, no.
It's, it's, it's fine to be hard.
Um, there's, there is a festival of errors in, I think, Paris from the 90s,
where they're just celebrating that we're going to fail.
And then it's like a festival for school kids and it's going to be okay.
And then we're going to fail things and it's going to be hard.
And yeah, it's kind of fun.
So a question on my throughout there is, isn't this how we learn as programming
also over time?
So blocking versus spacing.
So we might think about a specific feature or we might learn about a specific
feature, but then, like, we don't learn about the vector and then only use vector
for a long time.
No, we learn about vector and then we learn about algorithms or then you learn
about, um, I don't know, something else, right?
So we do this blocking versus spacing.
Like we don't teach, there's not a class on vectors.
I don't think, uh, variation.
We learn about different programming languages, programming language styles,
different libraries, we're reading other people's code.
Yeah.
All these kinds of things.
Uh, generation.
I mean, we write our own code.
We read code by others.
We form questions about the code that needs to be answered.
So we are not doing this, but over time and quizzing.
I mean, I'd argue that code reviews are quizzes that we take every day.
That is the question.
Is this block of code okay?
So we take a bunch of quizzes.
All right.
How are we on time?
Good.
So how are we learning rushed the wrong way?
Uh, in the same way, we're learning everything the wrong way, basically, by
looking for the easy way out, like I did my hubris.
Uh, and we also fall into the curse of knowledge while teaching because I find
this easy to explain, so it must be easy for others as well.
I know what subsumption is.
So I can explain to you what subsumption is, right?
No, that doesn't work.
So what is the rusty key to all this?
I like this one.
Oh, I was so happy when I found this image.
Get up, get a basket in this image, right?
All right.
Good.
Thank you.
It's going to take time.
That's the key.
It's going to require practice.
It's going to feel difficult and that's good because not because rushed
itself with difficult, because that's how you get the best results.
I mean, we as programmers are min maxers.
We think about like, what's the best way optimal way?
And I'm sorry, but the study show that the best way is the hard way in a way.
I mean, it's not like learning C++ was easy, right?
Yes.
So now I'm going to be mean to myself as well.
Unfortunately, in this case, there is considerable evidence that in many
situations, this strategy, which is the one hour lecture is rather poor.
From 71.
What have we, what are we doing?
What are we doing here?
Just go home.
A lecture may inspire, motivate, and inform, but I'm not going to tell you
but rarely fulfills the principles for effective learning.
It's certainly inadequate for developing high, the high level skills.
71.
Oops.
Yeah.
Students who study the topic and then generate their own questions scored an average
of 14% higher than on a test than students that use passive strategies like
studying the notes or rereading classroom materials.
Creating questions, researchers found, not only encourage students to think more
deeply about the topic, but also strengthen their ability to remember what
they were studying.
Yes.
When Pablo Casals, the cellist, was asked why he continued to practice that
cello three hours a day at the age of 93.
He answered and beginning to notice some improvements.
And because, like I talked about the one hour lecture is not good enough, it's, it's
15 minutes until I think it should be safe, right?
So thank you.
So form your own questions, please.
Yes.
Yeah.
What if we need, so it needs to be restructed, reconstructed that the thing that
is going to do the, the mutation, the value is not the same thing as the
class because the, the, the key of the issue, which I think is correct is because
the self is mutable, that means that the, the, the vector is mutable and I'm
asking for a mutable value of the vector that means that the, I'm asking for the
whole vector to be in a, I don't know, mutable state.
So take it out of the class because we are, we're asking, we're asking the
class to be mutable when we actually don't need it to be mutable.
And that's that we don't need that one value to be mutable.
So I can, I can show you the actual worst code.
It's, it's on GitHub.
I can show you the actual Pokemon code and it's a bit, it's a, it's
oddly structured, but yeah, we, we don't do the compact there.
That's basically the case.
And the other form questions, I know it's hard.
Yeah, that was before here.
Have I found the thing I feel I still haven't mastered is the, the lifetime
part where you do the lifetime annotation.
I'm still in the, in the, in the area where like, I will just put the
lifetime annotations until it works, which I don't, I don't, I don't, I don't
know if it works, which I don't, like, yeah, exactly, which is, which is the,
if you do the rustling exercises, that is what that is, is you have a compiler
error and it will tell you, like, fix, fix the error in file number one.
And then you fix the error in file number one, it will read through the
tests and then it will say, fix the error in file number two, and it will go
into file number two and read about it.
And the first errors are like, said, we call it missing or the if statements
is wrong, but then it's like, I think it's like 40, 50 exercises.
But the, and what I found from the rustlings when I was doing those, there
are no exercises about the lifetime, because you can do so much with the
language without even thinking about that.
Because a lot of the times if there is, I think it's, if it's one
argument into the function, the compiler will do the lifetime thing for you
correctly, because there's only one way to do it, I think.
So yeah, the whole lifetime thing is, is weird.
It actually, I, I found, again, the language kind of guided me in the
right direction, which was I had, I was doing some web stuff where you can
write rust and compile to web assembly and then run that.
And I wanted a, a callback to the JavaScript code.
And I wanted the callback to be a, a lambda within rust.
But the thing is that the lifetime of a lambda that is capturing variables
cannot be static or cannot be like globally alive, which is
kind of what is necessary if you want to be callable from outside, because you
always need to exist because you never know when you're going to be called.
So in other languages, I might just get a function pointer and just hope
that works.
And probably 99% of the cases, yeah, that works.
But, but actually, like that doesn't work.
And the language will say no to you.
Yeah.
Yeah, one.
I think the entire rust language is lava and it's a hello from me to, I'm
going to be at Rust Fest next year and I'm sorry, everyone, this is my laughing
question.
Where are you on that?
70% towards the second one.
I like rust.
It's fun.
Yeah.
So, so here's the thing about learning that I, because I learned this way.
So this is the path that I've learned.
So I recommend learning wrong and then doing a conference talk about it in the
same way that people sometimes ask me, like, how did you learn C++?
I'm like, yeah, I went to university for four years and studied there for four
years.
So you should also go to university for four years.
They're like, do you recommend this book?
Like, I've never read it, so I don't know.
I do recommend the rustling exercises that I've mentioned.
I do recommend doing things in smaller incremental steps.
I do recommend moving projects you have, like smaller hobby projects over,
because there's a lot of like walls you will hit along the way.
And it will be hard.
Also find like a good, like rust community to chat with.
A bunch of them on Twitter, probably because a lot of them migrated from C++.
But yeah, at least start there and then, yeah, time.
Yeah.
Any more well-formed questions?
Yeah.
Yes, yes.
Yeah, because like an example I had with the Pokemon code, like I was doing
in-out variables.
I was like taking references to like arrays and stuff like, yeah, I have done
smaller projects where I, so there's another teaching idea that I've had is,
is to create limitations for yourselves.
And like an example is you can, you can write a small hobby project or do
like a small thing, but every single variable you have has to be a unique
pointer, like all of them have to be unique pointers and that creates a
bunch of problems, but that also teaches you a lot about unique pointer.
So I've done that kind of thing.
I haven't taken my own older project and like, that a modern version of them.
Maybe I should.
Yeah.
Yes.
Yeah.
I, I think I've done that with TypeScript.
I think that would describe my TypeScript like initially when I learned it
because it was a, a, like a, and what's it called?
A serverless AWS, AWS project with all sorts of like everything was async in
the code.
And like it was very, like it took me a long while to get like used to how
things worked and how things looked and also had to learn AWS at the same time.
And then how this whole, you have to like upload the lambdas up to the cloud and
stuff.
So, so I've done that.
The main issue is, I guess it's hard, which I think is why, like, like last
year I did a talk on TypeScript because yeah, I think I knew it pretty well.
Maybe that was the, the reason why I knew it that well.
But yeah, I think that's, that's how I learned that.
So if you can use it, try it because it is difficult.
It is very, very difficult.
And I think it's, it will take a while for you to be, to feel productive.
And, and for some people that might feel uncomfortable.
So.
Then thank you.
