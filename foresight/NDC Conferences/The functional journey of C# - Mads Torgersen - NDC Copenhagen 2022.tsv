start	end	text
0	8760	Wow, let's see. It recognizes me even with this fancy mic on. So, Windows Hello, yay.
8760	16560	Doesn't it? Or did it just, like, turn off? It wants, no, it didn't. It wants a pin. At
16560	24600	least it's not showing you my pin. There we go. Okay. This is my intro slide. My name
24600	34280	is Mess Torgerson, or Mess Torwassen, or Mutz Torgerson, or something like that. I
34280	38680	know we didn't friends out there are going to kill me. They're going to take a blue
38680	47240	sharpie to that one after. So, I work on the C-sharp language every day for Microsoft.
47240	53480	It's a great job. I wish you could all have it, but it's mine. So, and I've done that
53480	59440	for a very long time. So, that means I remember things that nobody else remembers, almost.
59440	66160	Except for Anders, as we call him, who was there from the beginning. I was not. I was
66160	72240	a latecomer. I've only been there for 17 years. But it is an old language. We are now working
72240	80520	on C-sharp 11, and there's a whole other talk about C-sharp 11 a little later today. So,
80520	88600	I decided I want to talk about C-sharp 1 through 10 today. It's from the angle of how
88600	94120	has functional programming influenced C-sharp over the years. I'm hoping that's interesting
94120	97160	to you. Otherwise, that's a lot of people I'll be disappointing today, because it's
97160	102360	a very full room. I don't know how many are out there, but you can still run without me
102360	109640	noticing unlike these people in here. So, I think it's interesting, because C-sharp started
109640	118000	out as a fairly typical of its age, fairly straightforward object going into imperative
118000	122560	programming language. That was how it started. They didn't kind of just pull that out of
122560	128240	the blue, of course. There were other languages around at the time that were similar. That
128240	135360	C-sharp might happen to look a little like, by accident. But that was sort of like the
135360	140600	game of the day. So, C-sharp was typical of the day, and kind of pretty much took almost
140600	146600	all the functional things in along the way as they became relevant to how we do programming.
146600	150920	So, I'm going to go through that same evolution essentially today and point out some of the
150920	155160	different ways. I'll try to make some general points about programming language paradigms
155160	159760	and so on along the way. But it's all going to be a little bit, I'm going to do it all
159760	166280	in Visual Studio. I'm just going to code along. And so, and I forgot to print out my demo
166280	174240	notes. So, may I go astray? It'll be a little bit of a one-off. We do have an hour, which
174240	180640	means that there's time for a few questions along the way, not like a million. But I don't
180640	185880	want you to say, oh, I want to ask a question about that when he's done talking. Because
185960	189920	by then, the code will look different. Nobody will remember what I was talking about. So,
189920	194840	if you have a question, raise your hand and ask it. And I'll try to keep us on track. And
194840	199080	hopefully I'll succeed. And that might mean that I will have to be a little rude and say,
199080	203600	sorry, no more questions. Come back after. So, just don't be offended when I get to there.
203600	212360	But until then, please just raise a question and ask. So, with that, without much further
212360	220520	ado, let's start out with C-Sharp 1. And just kind of, for those of us who were around, remind
220520	228680	ourselves of the state of the art of programming, at least in the industrial space in the year
228680	234880	2000. And for those of you who weren't around, you can just go, thank God I wasn't around.
234880	241720	I mean, you were probably around most of you, but maybe you were still doing Legos. Aren't
241720	249960	we all really? So, what I have here is a fairly simple. It's a C-Sharp 1 program. I'm cheating
249960	256320	a little bit because when it comes to features that aren't part of this talk, that aren't functional,
256320	260160	I'm just going to use them a little bit anyway. For instance, my code is not in a main method.
260160	264680	You don't need to do that anymore in C-Sharp. And it fits better on a screen if I don't. So,
264680	270800	I'm not going to stick religiously to only C-Sharp 1 features. But in terms of functionality,
270880	279800	I am. So, one thing to, talking about functional, C-Sharp started out with just a tiny little hint
279800	286440	of, a tiny little concession to functional programming languages compared to other languages
286440	293760	at the time. And with something that they, we call delegates, which is sort of kind of like a
293800	301440	function type. They were actually part of some of the, the need for delegates was part of the
301440	305520	reason why we couldn't do some other programming languages and got dragged into court and stuff.
305520	312520	So, C-Sharp back then already had like a notion of a function type called delegate. And those are
312520	318120	still the ones that we use for function types. They're flawed in various ways, but you know,
318280	323640	once you've got something throughout the whole core libraries and so on, you don't go on and
323640	327800	change it. So, delegate types were function types. It's like, you know, this is the type of a
327800	333160	function that takes an int and returns a bool. And it's a name type, like a class. It is in fact a
333160	340200	class. And we call it predicate. And now we can use it as a function type. So, I can have a method
340200	348440	here, a function that takes a predicate. And it can call the predicate as the, you know, according
348440	354120	to the function type. But, and when I want to pass an argument to it, well, we don't have anything
354120	358280	like lambdas yet that we're going to get to that. We don't have like anonymous functions of any kind.
358280	363320	But we do have, we, but you can sort of just mention a function that happens to have the right
364040	368600	signature, like great than five. Hang on a second.
371480	376280	Is it going to be like this all the way? How many typos are we going to have in here? There we go.
377080	384360	I did get the wordle this morning. So, I'm not like totally, there we go. So,
385960	391000	so you kind of have to declare a function, then pass it. You have to declare the function type,
391000	394600	then use it. Like it's all very nominal and declarative at this point.
395160	401560	But it gets the job done. Like pass the predicate in. Of course, there's no such thing as generics
401560	405800	yet. They're the first thing we're going to learn from functional programming languages in a minute.
405800	413160	So, you know, this was the name of the game. I do, you, in order to filter this, I need to
413160	418760	gather up the results. The only, like I really wanted to return an array because that's the only
418760	422920	generic type I have. It's the only type that actually has an element type. So, that's, so you
422920	428040	kind of, you kind of encourage to trade in arrays, horrible as that is, because otherwise you have
428040	434280	no type safety. But we do have other collections. They're just all over object. So, and, and I need
434280	437560	to create one of those to gather up my elements because I don't know how many are going to
437560	441800	succeed yet. I don't know the size of the array to allocate. So, first I gather them up, then,
441800	446360	you know, I know how many I have, then I can allocate an array that's strongly typed to int,
447080	453480	then I have to stick all the elements that I found into the array. And as I'm doing so,
453480	457720	I have to cast them to int because I know they're all ints, but the compiler has no idea. It's like
457720	462040	you stuck, you give me a bunch of stuff, you're taking them out, all I can see is object.
463800	467720	So, you know, you die a little inside every time you have to cast things coming out of
467720	471320	collections. How many people in here remember that from like either C'sharp or some other,
471320	480280	like Java or, yeah, out, yeah. So, what, I think what we very quickly felt all of us was,
482120	486040	and with C'sharp, it was already like coming to version two, which we're coming to version two now.
487000	491880	We felt like, okay, this is not, this is not like a satisfactory state of affairs.
493000	495560	It's not the abstraction capabilities aren't good enough here.
496920	500600	Some other languages that had been around for longer, it took them a little longer to get to
500600	504840	that point. So, it ended up that, for instance, Java and C'sharp got generics, which is where we
504840	508760	coming to now at around the same time. And I was actually back then, I was on the other side of
508760	514920	the fence helping out with generics and Java. So, I saw it from the other side. Still think
514920	523000	Microsoft and C'sharp did it better. So, this really comes down to sort of one of the fundamental
523560	527000	differences between functional and object-oriented programming.
527960	533720	You know, in classic imperative programming, there really is no polymorphism. There's no
533720	541080	way that you can write code that applies to more than one type. Object-oriented programming and
541080	545160	functional programming, to a large degree, are two different answers. At least when they're typed,
545160	549720	they're two different answers to, how do you get polymorphism? How do you write code that
549720	554120	works for more than one kind of thing? In object-oriented programming, we went with what's
554120	559080	often called subtype polymorphism, which means everything is a subtype of something that's a
559080	563960	subtype of something that all goes back up to object. So, that's what we're seeing here. Now,
563960	569720	you can write a collection like ArrayList here that can contain anything. So, there's polymorphism
569720	576520	in that sense. And the great thing about subtype polymorphism is it's very easy to have heterogeneous
576520	582840	collections, for instance. You can put all kinds of things in the same collection. As opposed to
582840	590440	functional programming, they went with what's called parametric polymorphism, where you have an
590440	598920	extra type parameter on things that, you know, sort of like a placeholder for one type. So,
598920	603720	you don't get to mix and match the types inside. You get to say that there's this one type that
603720	608760	I'm going to give you later, and then it'll work for that type only. But it's still polymorphic,
608760	613720	because you can give different type arguments in different places. And that has the benefit that
613720	621000	you can, because that type parameter has a name, you can have things sync up so that the same type
621000	625800	name, the same type parameter appears in multiple places, and you can sort of say, well, whatever
625800	629800	it is, the same kind of thing that comes in is the kind of thing that comes out, for instance,
629800	634280	which is exactly what we need here, right? We need a collection, for instance, that has
635240	642120	the same stuff coming in that's coming out. Enter generics, which is parametric polymorphism.
642760	646600	Most object-oriented programming languages with types at this point say, okay, let's embrace
646600	653240	that too, so we have both kinds in the language. So, that's sort of one of the first big imports
653240	659800	from the functional space. So, let's do that. Now, let's see, where do we start?
659880	668360	Now, we can have, well, instead of a RayList here, we could now use the new fancy generic
668360	673720	collections that we have, and I'm cheating and having the imports in another file, so either
673720	680360	using, so you don't have to bother with that. So, we can say list of int here instead is a new list
680440	690280	of int, and now, as I'm gathering things up, it should be graying out this. I know that my
692680	699480	destination here is actually a list of int and not just a list of whatever, and so I can now get
699480	707240	rid of this cast of death. Back in business. Somebody wrote a generic collection for us,
707240	715640	we can use it. But, of course, now, there are other, I can write generic things too. Maybe I
715640	721800	want my predicate type to be more general. Maybe I don't actually want to write new delegate types
721800	728840	for everything all the time, so maybe we could say predicate of t and have it work for all t's
728840	734920	and not just for ints. It still returns bool, but I can, I now have a generic predicate type,
735000	738840	and I can then here say, well, it's actually here, it's a predicate of int that I want,
738840	743480	and boom, things don't work, or we can, we could actually go a step further and say,
743480	749000	well, filtering isn't really particularly about ints, is it? And now we can write our own generic
750200	757640	function, a method that is a filter of t, and now we get to, say, t in all the places,
757640	764120	it's actually a predicate of t coming in and an array of t, and I'm returning an array of t,
764200	768840	and in all the other places where it says int, except one, so you have to be a little careful,
769560	783480	here, here, here, where else? The int result, of course, and, you know, so now I've completely
783480	787240	generified the thing, and this is the int I shouldn't replace, because that's the counter for the,
787240	791880	you know, filling out the array, so that's why I didn't just do a search replace here.
792840	797320	So there we go, now we, all of a sudden, we've generified a thing, it's fully strongly typed,
797960	802600	as if it was for a specific type, but now you can apply it everywhere, and the full,
802600	810760	like, generic, generification is a strong, strong tool, and it, the, there were some, like,
811720	817400	choices made in the different languages at the time that, that actually were imbued with destiny,
817400	823240	even much more than we realized at the time. In Java, we, on the, I was over here, in the
823240	833560	Java side, sorry, camera person, we, we were, we decided we couldn't change the JVM, the runtime
833560	838760	under Java, because it was, you know, too entrenched, and how you couldn't control, like, what,
838760	844200	but Java runtime they had out there, so, so all the generics in Java was done in the compiler by
844200	849800	erasure, which means, you know, there wasn't any generics at runtime, it was just there
849800	854600	in the code for as much type checking as you could get, but that meant that there were some
854600	859160	things, like reflection and so on, that didn't embrace it, and there were certain, certain
859160	865480	holes in the experience, essentially. And whereas in, in .NET, and, and C Sharp, we went all out
865480	872680	and said, yes, generics goes into the runtime, and is shared across all the languages at target.net,
872680	874920	and it's a real runtime thing. Question.
884920	890280	So, to repeat the question for the, for the mic, when did we know that we wanted generics in C
890280	899160	Sharp? So, I wasn't there, but I kind of was, because in 99, I was an intern, I was doing my
899160	904200	PhD, I was an intern at Microsoft Research, Cambridge, which is where Don Simon is, if anybody
904200	908920	has heard of him, the father of F Sharp, and there were a bunch of language people there,
908920	914840	so I got actually to be privy to decisions that were secret for a number of years, and I was under
914840	920360	NDA until, until things came out, and they were already talking about .NET, they weren't calling
920360	924840	it that at the time, and they were already talking about generics for it, and decisions were made
924920	931080	that it would take too long to make it work right, and we should have a version without it first.
931080	937080	So, yeah, that, that, I think that answers your question precisely, so it was always felt that
938120	945000	that we're gonna, we're gonna need to do this, and indeed, generics was, was the, pretty much the
945000	952200	almost the only and, and last thing that language feature that was added to the runtime for a very
952200	957400	long time, because after that .NET became popular, it was Windows component, and so we had the same
957400	962920	problem as Java, as the one causing Java to not do it in the runtime, which was too many people
962920	967320	have it installed, we don't know which version of Windows they have, we have no way of, you know,
967960	973160	making sure that they have the right runtime features that we are compiling for, so we stopped
973160	977320	doing language features in the runtime after that for a very, very long time, now we're doing it again,
978280	987560	and we might get to one at the end, so that's generics, and let's see if I can get back on
987560	994520	track here, so it's, well, that's not generics, that's not all there is to say about generics,
994520	1002920	because once you get these, like, very lovely generic collections, for instance, they can have
1003000	1008040	smarter, they can have smarter types, smarter methods as well, they can have generic methods,
1008040	1013960	so instead of, instead of like doing this, building this result array myself, I could just actually
1013960	1021240	take that dst thing and just call to array on it, because now it knows its element type and you
1021240	1029800	can build an array of the right, of the right type, namely t, you also notice, so which means I can,
1029800	1035640	I can delete these two lines of code, I don't need that anymore, so many more utilities now,
1035640	1045080	strongly typed utilities become available, and one last thing to notice is that when I'm calling
1045080	1050440	the generic method here, I'm not passing a type argument, you need to pass a type argument to,
1050440	1055400	to the, to generic types, but not to generic methods, and that again is a thing that type
1055400	1060600	inference is something that we start stealing from functional programming languages, we can't do
1060600	1064440	as much type inference in object-oriented programming languages as you can in a functional
1064440	1070280	language because of the subtype polymorphism, it means that you can't actually, there are many
1070280	1074440	places where you can't know the exact type, where you could if you didn't have subtype polymorphism,
1074440	1078360	so we can't go all out on, on type inference, which is probably all the same because it's
1078360	1083320	confusing to a lot of people, it's a quiet taste, so, so we kind of, we have to strike a balance
1083320	1094040	there, but it certainly makes sense here, so with that lovely generics, we, we can also get out of
1094040	1101640	this addiction to, to arrays as the, as kind of like the, the, the currency of collections
1101640	1106920	being passed around, because arrays are, you know, they're very low-level, fixed size, they
1106920	1112040	expose too much, they're unsafe in various ways because you pass your array to someone and they,
1112040	1115480	they're messing with it while you're watching it somewhere else, and you know, that's just, you
1115480	1121880	know, nasty, so we can start having other interfaces, for instance, that are, that are more
1121880	1131560	suitable, so, Ionumable of T is a good one, I can return Ionumable of T as well here, and,
1133960	1138760	and I don't even have to say to array, I can, but I don't have to say to array because, of course,
1138840	1142120	a list of T is also an Ionumable, so, you know, things get simpler.
1144600	1149960	We could do one better, actually, we, we also, well,
1151400	1154920	oh, but, well, it's because I'm saying, in the array here, yeah, yeah, I have to,
1155720	1158600	I have to just make all the changes, okay, so,
1159160	1163800	oh, Eint, thank you.
1166360	1170520	Say, are you developers or something? It's like, it's like you, it's like you understand what I'm
1170520	1180760	saying. Hey, I also debugged something once, you know, it's fun, so, so, so far so good, we,
1181480	1185560	one thing we actually decided was, now we have Ionumable of T, it's like a very,
1185560	1191080	in abstraction over just sequences of data, we're going to meet this a lot more in C-sharp 3,
1191080	1195960	but already in C-sharp 2, we were like, actually, the compiler could help a lot with this kind of
1195960	1200600	work here, of producing Ionumables, because they don't have to be produced eagerly,
1200600	1204040	they don't have to have all the elements pre-computed, they can actually sort of
1204040	1208280	be lazy and compute things along the way, and we can build a language feature to help with that,
1208280	1212920	and that's what we call iterators in C-sharp, they're called generators in some other languages,
1212920	1218120	which is essentially write a function, and then once in a while you say, oh, here's another element
1218120	1221880	for the result, and then you compute some more, and then, or here's another element for the result,
1221880	1227320	and it actually gets executed lazily, up to every one of those points, you just pause and,
1227320	1232040	and give the result back, and then the next time the consumer asks for a result, they come, you
1232040	1236920	know, execute some more, so that's iterators in C-sharp, that means we don't even need like an
1236920	1245800	accumulator, we can just say, if that thing, you know, just yield return the value, I'm not
1246600	1251640	super excited about the syntax we chose there, I will just say I was not around,
1253720	1258360	we liked keywords a lot still back then, we kind of do still a little bit, and now I'm,
1259000	1266040	you know, that's it, that's the filter method, you know, you cycle through,
1266120	1271400	you yield return something, if you decide that, hey, let me do that, and that's it, right, so boom,
1271400	1278680	very nice. Also in C-sharp too, we're like, hey, we've heard about lambda expressions,
1279400	1286760	let's do not that, something similar, let's have anonymous functions, why do you have to declare
1286760	1291560	all the functions that you want to pass, that's just like a pain, let's get rid of all these
1291560	1296760	declarations and stuff, so instead of saying greater than five here, what if I could just
1296760	1301960	write the function with the body and everything in place here, so we come up with an elegant
1301960	1313720	syntax saying delegate, delegate all the crap, there we go, beautiful, right, it's, well,
1313720	1319800	we can laugh now, but you know, it's certainly an improvement, now, you know, I'm free to just
1319800	1323480	come up with functionality and pass it along, and of course the compiler generates
1323480	1327160	something under the hood that's similar to before, but hey, all languages do it like that,
1327160	1334840	pretty much, so great, our first take on anonymous functions, now C-sharp three,
1335480	1339880	now we have big ambitions, this functional thing has really gotten into our blood, and this is
1339880	1344280	where I'm starting to be around, so I've witnessed more of this firsthand, so in C-sharp three,
1344600	1352520	we want to, we want to solve querying once and for all, the functional languages can do it,
1352520	1357720	we can do it too, so we want to mainstream functional approaches to solving querying,
1358280	1364600	let's do that, and we have, filter is a great example, like it's a function that does querying,
1365720	1369720	a one aspect of querying, we kind of have the generics in place to do this,
1369720	1378680	why don't we, why don't we actually declare an even more general library of function types,
1378680	1386680	and then we also declare a library of, of querying methods, and get all that stuff working,
1390040	1398200	so we, so instead of just having predicate of t, we create a family, families of functions called,
1398520	1407400	funk and action, funk for the ones that return stuff, so funk of t1, t result, or something like
1407400	1415240	that, that take a t and return a t result, so that's what the funks look like, take a t1 here,
1416360	1420520	and we just declare them in the core library, so I don't even have to do it here, they're available
1420520	1427400	to everyone who wants to be a little bit functional, and we can just here, actually it doesn't
1427400	1432600	predicate itself actually in the core libraries from back way, way back when, so it doesn't give
1432600	1440120	me a red squiggle here, but let's say funk of t, instead to describe the function we're passing in
1440120	1450680	here, and then instead of me writing the filter method as kind of a, one thing that you quickly
1450680	1454920	find out when you want to, you want to query things is, hey I want to, I want to filter some more,
1454920	1459160	for instance, I want to call query methods on top of query methods, so I could call filter twice,
1459160	1466680	you know, I could say filter on the result of the first filter, comma, you know, some other
1467560	1475080	delegate thing, and you know, it quickly becomes long, I should probably have done lambdas first,
1475080	1481480	shouldn't I? I'm going to be doing more typing, okay, hold that thought, let me do, let me switch
1481480	1488840	to lambdas quickly, we get better syntax, that's actual lambdas, you can do this, it's a little
1488840	1495000	shorter, or we have, so this is still like a statement body there, or we can actually do
1497320	1502200	just a single expression, and now it starts, it starts being a little expression oriented,
1502200	1507880	like the functional languages, that's kind of exciting, but we still have the problem now,
1507880	1514840	if I want to filter that one some more, I can say int, why, arrow, something, stuff,
1515880	1521960	oh it needs to be in parentheses here, actually does it, you know, lambdas, you don't actually
1521960	1526040	have to say the type, if it's given from context, you don't have to say it, that's kind of cool,
1527720	1533800	but so why, I want to get the ones that are even, stupid example, but just, you know,
1534760	1545160	equals zero, you know, I can compose my query methods, but it sucks, right, I'm composing sort
1545160	1551080	of inside out, like this first stuff is in the middle, and then I'm slapping stuff on both sides
1551080	1555400	of it, and it's completely unreadable, well what do the functional people do when they, I mean,
1555400	1559320	they're doing this stuff, how do they do it, well they have pipelining operators, you can call
1559320	1563320	functions like this, but you can also pipeline, so in a functional language, what you would do is,
1563320	1569800	you would start out with the array on the left side, and then you would, so let me, let me do some
1569800	1574920	horrendous doctoring here, you know, start out with the array, you would have some kind of pipeline
1574920	1579800	operator, which we don't have in C sharp, and you pass it into filter, filtering the first thing,
1581240	1586280	and that's just the implicit first argument for it there, and then you'd pipe that into
1587080	1593560	filtering the second thing, and now you have things in the right order, they're sort of cascading
1593560	1599240	beautifully in the order that you're doing them, it's kind of fluent, man, as we said, so,
1600920	1604840	so that's, can we do something like that in C sharp, and that's where extension, we come up
1604840	1609480	with extension methods, which is essentially just to solve this little problem in the beginning,
1609480	1614200	where they turn out to be like extremely useful in extremely many scenarios, we're still being
1614200	1618600	inspired by them, and we want to do more with them, where what you're saying is, we're just,
1619320	1626360	what if you just pretend that the static method or this function is actually like a, and it's,
1626360	1634200	I can't do it with a, I can't do it with just this method here, because it's not actually,
1635720	1639160	it's not declared in a proper space, but we can do, the syntax is like this,
1640120	1645560	we just pretend it's an instance method on the first argument, and now I can go and add
1646120	1651880	method, what looks like instance methods to other people's types, and that kind of gives you that
1651880	1657720	flow, so luckily, I don't have to like go in and do it properly here, because it turns out that
1657720	1662920	method just like filter is being added to the libraries at the same time, and now we can just
1662920	1668360	do the where stuff, so we can get rid of our own filter method and use the one that's part
1668360	1675080	of the query library that we are now providing, okay, so we can break it up a little here, and now
1675080	1679800	it starts to kind of look decent, right, now we have a select for projecting, because why would we
1679800	1686840	call it project, we have various methods, I'll tell you why we call it select, that's because
1686840	1692680	another place where you do querying is in, you know, SQL, which is also kind of functional,
1692680	1699400	right, it's also just, there are aspects of SQL where it can mutate stuff and actually get
1699400	1703960	things into the database, but the actual querying is functional too, and so we want to provide
1703960	1716600	syntactic sugar for querying on top of methods like this, where you can say from value in,
1716600	1726600	I should call them x, I like x, from x in array, where the keyword, where x is greater than five,
1729320	1737160	and where something else, where y, let's call it x again then, because we are now using the
1737160	1744040	same variable name all the way down, select something, so we now have query syntax, select,
1744920	1750600	you know, maybe just x, and the point here is it looks like SQL, it's a little different,
1750600	1755640	because in SQL they start with a select clause, which means we don't like that in programming
1755640	1761000	languages, because they start out by describing the result, and what you want is to start out by
1761640	1767720	describing the source, like where do things come from, so you can get types going and have your
1767720	1771880	tooling kind of help you out as you type the code from one end to another, so we want to start with
1771880	1778760	the array, figure out what its type is, get completion in our classes, and so on, so that's
1778760	1783960	a programming, proper programming language way of doing it, sorry SQL folks, but you got it wrong,
1783960	1791640	and you didn't think about ID, you didn't think about IDEs back in 1970, I went out, IDE focused
1791640	1800440	language design, that's the way, that's why we have TypeScript, so great, but now that actually
1800440	1805800	just queries my in-memory data, wouldn't it be cool if I could actually use the same syntax,
1807000	1811000	both the syntactic sugar and actually also the method called syntax, to query actual
1811000	1818440	SQL databases, and with no difference in syntax, and that's where we get to yet another functional
1819000	1828520	loan, which is code quotations, so in Lisp for instance, it's all based around the fact that
1829480	1834280	code and data are no different, and you can always easily take code and represent it as a data
1834280	1837960	structure, well that's kind of cool because then you can do metaprogramming, you can take that
1837960	1841400	data structure and do stuff with it, and one of the things you can do with a data structure
1841400	1846600	representing a query is you can translate it to SQL and send it to a SQL database, and have it run
1846600	1851400	a SQL, and have the result come back, and then you do a little translating back, and now you have
1851400	1861960	an object-oriented, an object relational model, so if we take that, let's just say var here,
1861960	1868920	more type inference, if we take that array and say, is it too queryable or ask queryable,
1868920	1874600	isn't it ask queryable, there you go, and say ask queryable, I'm sort of cheating a little,
1874600	1881800	and I'm representing it as now a queryable is like a representative of some other data source
1881800	1891480	that uses quote quotation in order to do the querying, so when I do that, what changes as well,
1891480	1899160	not much, you know, I get a queryable back instead, whoop-de-doo, but if we go and look at that query,
1899320	1906200	query dot, you can see that it has something inside called an expression, and that expression,
1906200	1914600	in fact, represents the data structure of all this query, okay, so we're building up,
1914600	1920200	instead of having the code just code that we can run, instead we build up a data structure
1920200	1925800	with exactly the same syntax, and now querying of in-memory data and querying of
1926360	1933480	SQL databases look the same just like you can do in many functional languages that have code
1933480	1940440	quotation, so yet another loan there, and I just cheated a little bit and showed you var as well,
1941000	1947880	which is like the last one more concession to type inference, like very simple one, it's like,
1947880	1951080	why do I have to say the types all the time, it's really bothersome to have to say int,
1951160	1957160	can you let me say a three-letter keyword instead? Obviously, that's not the best example,
1957160	1964040	this is the best example, right, I don't want to have to write, I want to just say, hey,
1964040	1969800	the thing, you know, give me the thing, if it's clear from context that it's what kind of thing
1969800	1976760	it roughly is, you know, who cares, so that's functional up until C3, it's a good time to
1976760	1980200	ask for questions, we're about halfway through the story and about halfway through the hour,
1980200	1985800	so it's still on track. Anything, any thoughts coming up here, questions, meta questions,
1986600	1988760	programming questions, meta programming questions, yes?
1995000	1996040	What made me decide?
1998440	2008520	Anders Heilsberg made me decide. Okay, short version of the story, I was a professor,
2009080	2015560	I wasn't liking it too much, I was collaborating with the Java team at Sun Microsystems then,
2015560	2023240	had a great time doing real world, you know, real world language design for real customers,
2024680	2028760	they got to do it all day, I got to do it like whenever I could get away from teaching and
2028760	2034920	stuff and I just like, well, I have great time when I'm working with them and they make twice as
2034920	2040280	much money as me at least, I think, just like maybe I'm not in the right career here and as I
2040280	2046520	was thinking that, there was a conference in Ohos, Anders was there talking about how they
2046520	2049800	were going to do generics in C sharp, I was there talking about how we were going to do
2049800	2060440	generics in Java, you know, the rest is history, he had money, I didn't, so he hired, he hired me,
2060440	2067160	not the other way around. Actually also, I liked how he talked about language design,
2067160	2071960	when I was involved in Java language design, there was always a lot of stop energy,
2071960	2076440	it's like we can't do this because, and we can't do this because, and he had a bunch of can-do
2076440	2082600	attitude, you know, a small example, the generic method is gone from the screen here,
2083160	2087480	but in Java they said, oh, we can't put the type parameter for generic methods
2087560	2091960	after the parameters, because that might be a syntactic ambiguity in rare cases.
2092680	2098760	And in C sharp, when he showed examples, that would also be a syntactic ambiguity in rare
2098760	2103560	cases in C sharp, because syntaxes are a little bit alike, but they just put it there anyway,
2103560	2109160	and I asked him after, how do you do that? He's like, we just do some tricks in the
2109160	2115160	compiler, it's not like LR1 or whatever, it's fine, we figure it out, and who cares about
2115160	2120440	those rare cases, you know, we come up with a rule that works 97% at the time, if you
2120440	2125240	can run into it, and does the right thing mostly, and we're good. It was always like,
2125240	2128680	we can probably solve that problem attitude, and that spoke to me in a way, and that's
2129720	2133320	still the case, and that's still why I love being there, so, oh.
2135800	2138760	Thanks for that question, now I'm going to have a tear in my eye for the rest of the day.
2139720	2145000	Anything else? I want to hear about my childhood. Yeah.
2152680	2160200	Why, oh, great question, so why are the delegate types that have the same shape,
2160200	2162680	like the same signature, why aren't they interchangeable?
2163640	2169960	So, they used to be predicate of T, and then it turned into, we started using
2169960	2177240	funk of T, and they're not actually interchangeable, you can pass the same lambdas to them,
2178360	2184680	but you can't assign one to the other, they're not structurally equivalent, so, and that comes
2184680	2191880	back to, you know, I kind of hinted that I'm not a super fan of delegates, and one of the
2191880	2195800	problems with them is that they're a nominal type, they have a declaration, and just like classes
2195800	2201400	that look the same, you can't take an object of a class and duck type it to another class that
2201400	2207560	happens to be the same, it's all based on the declarations, it's very, very nominal, as we say,
2207560	2214280	and the same is true for the delegate types, they are actually classes, and they are nominally tight.
2214920	2225400	Now, in Visual Basic, for instance, vb.net, they paper over this by inserting implicit,
2225400	2232200	like, wrapper functions to translate from one to another, so there you get the great experience of
2232200	2236680	it all just assigns to each other, it looks extremely structural, but the problem is it
2236680	2241640	isn't, like it comes with a cost, like you're wrapping more and more, if you keep passing
2241640	2246280	back and forth, you get like layers and layers of, oh, here's a predicate of a fung of a predicate of,
2246280	2253880	you know, all the way, so we don't let you go down that rabbit hole in C sharp,
2254680	2259000	we think about it sometimes, and we also think about, well, could we just do better
2259000	2265720	function types, but then you have a library that is gigantic, and that is using delegates
2265720	2270840	everywhere, and you look at that and you go, hmm, I wonder how we could do this and not mess up
2270840	2277640	a million customers, you know, or, you know, we choose not to roll it out in our big library
2277640	2282760	and just make it, you know, an option for new code, and then doesn't really, there's no bang there,
2282760	2287400	right, you know, you don't get enough value, so that's a tough problem, that's, you know,
2287400	2293160	the problem of legacy code and the problem of compatibility shoots down a lot of good feature
2293160	2301080	ideas, and we haven't found a way around this one. It's one of several, interestingly,
2302440	2306600	functionally inspired topics that we'll be discussing this summer, we're having sort of a
2306600	2310600	series of summer camps on the team where we'll discuss topics that are normally out of bounds,
2310600	2316600	because we don't know how to deal with them, and this is one of them, so maybe one day we'll figure
2316680	2320440	out a way to make that good. Yeah?
2334440	2343560	Yeah, so the question is, is the, is the sequel style syntax still in broad use,
2344040	2349640	and it's true, it does feel very different from the rest of the language, it's, yeah, it's just,
2349640	2359800	it's like you enter another world. Yeah, we have to maintain compatibility with it, but also,
2359800	2365000	furthermore, I think it is still, it is still used a bit, like a bunch, not more than a bit,
2365000	2368920	actually, a bunch of people actually do prefer the method called syntax, even when they're using
2368920	2380520	the query methods. I find that if I have to do more than one from, from x in blah, from y in
2381480	2387640	x dot, or something like that, then writing the corresponding query with method calls becomes,
2390440	2395960	becomes mind-blowingly hard, and you have to use select many, and select many is mind-blowing,
2395960	2401560	and so I always, if I have to, if I have to, like, do more than one from, if I have to, like,
2401560	2405880	dig into data with froms, I switch to query syntax and let the compiler figure it out for me,
2405880	2411160	because I, my brain can't handle it. It's all, actually, it's all down to monads,
2411160	2416760	so how many people here know about monads? Yes, that's more than I would have expected,
2416760	2421640	actually. It's this concept that is super central to a bunch of functional, a typed functional
2421640	2426120	programming, and nobody understands it. A bunch of people claim that they do, but they're actually
2426120	2433720	just, you know, it's a collective kind of like, it's a hoax. They don't, not for long anyway. I've
2433720	2437880	understood it many times, and then, you know, the next day I was like, what was it again? Maybe I
2437880	2443960	was just dreaming it. It made, it totally makes sense at the time, but query, query expressions,
2444760	2451400	they are a monad. They're a language support for a monad, and when you use more than one from,
2451960	2457320	that is where you get into monadic territory, where the select many is the thing that makes them,
2457320	2462440	makes them a monad, and that's, that's exactly why it gets mind blowing to do it directly. It's
2462440	2467480	because it's monad, and you want syntax for that. But other than that, people have different styles.
2467480	2471960	There are also people who work on low level code that would be like, this is way too inefficient.
2472840	2478200	It does you, there's all this laziness, right? The, the iterators are generating things along the
2478200	2483880	way, which means you have all this like, you have a bunch of structure, you have all these calls
2483880	2488840	through interfaces and so on. So if you're doing performance intensive code, one of the things
2488840	2494920	that people look for in code reviews is, oh, oh, you have a query there. Well, fix that, you know,
2494920	2504440	go back to ugly array based stuff, because then it's going to be faster. So I will say that entity
2504520	2511640	framework, live and kicking offers up, you know, a query provider implementation,
2511640	2515800	and people do use that, and they do use the query syntax when they're interacting with that,
2515800	2524440	because it is a database technology outside of that, maybe not so much. Okay. All right. One more.
2534680	2539400	That's true. Yes.
2550760	2555320	So that's a great question because, and we might touch on it a little bit later.
2557160	2563240	So let me repeat again. The one thing you can do in the query syntax is you can use let
2563320	2568680	to actually introduce more temporary variables inside of the query. I haven't done it in many
2568680	2574280	years, actually. Let's see if we can do that. Let y equal x times two or something like that.
2575320	2581000	Yeah, it worked, at least it compiles. So now the rest of the query has access to x and y,
2583000	2589800	and that's really useful because you have sort of like variable declaration inside of an expression
2589800	2595720	rather than as a separate statement. And that has continued to doggers. That statement-based
2597320	2601640	approach to variable declarations has continued to doggers. And in later versions of C-sharp,
2601640	2606200	there are more and more places where you can now declare variables inside of an
2607320	2611000	expression. We haven't done it completely generally. We had a proposal for it where we never
2611000	2615480	went that far, but there are many situations now where you can declare an inline variable,
2615480	2619080	particularly in pattern matching, which we're going to get to soon. So that even provides
2619800	2630200	a good segue for that. Another big difference is functional languages tend to be very expression-based.
2630200	2638520	Typically, a function doesn't have side effects in a pure functional sense, so you don't really
2638520	2643800	need statements. You just need an expression saying what the whole thing is, and then you stick it
2643800	2648040	together, you put sub-expressions inside, and it's all expression-based, and so you need things like
2648040	2652200	variable declaration to be expression-based. And the more expression-based, the more we get
2652200	2656760	inspired by that in C-sharp, the more of a shortcoming it becomes that variable declaration
2656760	2661560	isn't one of them. So great, great point. And this is a way to sneak it in. You can't do that with
2661560	2665800	method call syntax, because it does sneaky things under the hood. It builds little, like,
2665800	2672920	tuple-like things to keep track of all the variables under the hood. Okay. Yep. Okay.
2672920	2677800	Let's fast forward a little bit. Then we did dynamic. That was certainly not very functional.
2677800	2684040	C-sharp 4. C-sharp 5, we did async, which was potentially very functional. F-sharp already
2684040	2690600	had a solution to async, which was also sort of monadic, and which is beautiful, but is very
2690600	2697400	ill-suited for a predominantly imperative language. So we went in a different direction with async,
2697400	2705720	and the general functional approach to async is quite different from the imperative approach
2705800	2712120	that we use in C-sharp. Essentially, they use an approach where they built up the whole control
2712120	2717400	flow of the async ahead of time, and then you kind of pull a handle in, and it runs. It's like
2717400	2725080	you built all the pipes, and then you turn on the water. And in our async, we sort of more like
2726520	2731640	laying out the pipes as the water is coming. It's sometimes called a cold and hot async.
2731640	2740600	Like we work with tasks, which are things that are already happening, things that are already
2740600	2746280	concurrently operating, and then you can take a task, and then you can say, well, I'm ready for
2746280	2750440	you. Are you ready for me and get a result out of them? So that's all much more imperative
2750440	2754920	fits better with imperative workflow. So there, we didn't go the functional way. We don't always do it.
2755480	2762280	In C-sharp 6, we started getting interested in the expression-based stuff again, though. So I'm
2762280	2770120	going to switch to a different file here. So one thing that we really like, the expression bodies
2770120	2774360	of lambdas, we're like, why should only lambdas be allowed to have expression bodies? Why can't
2774360	2778840	all our functions, all our function members have expression bodies, and we're like, okay,
2778840	2784360	C-sharp 6, we did kind of half of them, and then C-sharp 7, we did the rest. So now
2785400	2789800	all function members in C-sharp can have expression bodies where you just put that lambda
2789800	2798040	arrow there, the fat arrow, as we shouldn't call it, and you get it. You don't have to say return.
2798040	2805080	If your only statement is return something, cut the boilerplate. But it's just in tactic sugar,
2805080	2813560	right? So, but coming to C-sharp 7, we're starting to think about more fundamental
2813560	2821800	things again. So not so much in the syntax, syntactic sugar, you know, as feel kind of layer,
2821800	2829400	but really like, uh-oh, object-oriented program is kind of screwed in these new scenarios that are
2829400	2838360	becoming very predominant and widespread. Essentially, when it comes to cloud programming,
2840520	2844280	history is on the side of functional programming. I'm sorry, object-oriented programming is not
2844280	2851800	good for that. If you think about, and that comes down to how you describe aberrations over types
2851880	2859720	of data. In both object-oriented and functional programming, there are ways that you can write
2859720	2865800	functions so that they have appropriate behavior for each shape of data, for each type. But those
2865800	2871640	ways are very different. They're like actually, I think probably if Eric Meyer was here, he would
2871640	2876920	say that there's a duality, like they're completely like the opposite of each other.
2877880	2883560	What we do in classic object-oriented programming, we love encapsulation. We love saying the data
2883560	2888440	is actually secret. I'm not even, I'm not exposing it because then I can change it whenever I like,
2888440	2893240	and then I just offer up some functions, and I can have a class hierarchy with virtual functions
2893800	2898520	that I can then describe for each type of data what it does. So the super like,
2899480	2903720	idiotically simple example here is the two-string virtual method, right, where I am
2904440	2912840	I am describing the string representation of the object by overriding the virtual method
2912840	2921560	two-string. Great, you know, that means that whenever I write a new derived class from person
2921560	2927080	here or from object actually in this case, you know, I can just overwrite that behavior to suit
2927080	2933080	whatever my shape is, and somebody else can call it on the base class and not even know I exist,
2933080	2941720	but still get the right behavior. Excellent, except when you have a world where data is long
2941720	2947080	lived in the cloud, maybe, or in databases and whatnot, and different people are writing different
2947080	2952520	functionality over the same data models, well, oops, now it's not so good to encapsulate those
2953480	2960280	behaviors with the data model, right? You want to independently be able to express behaviors over
2960280	2971160	the data model that still depend on, like, still type specific, but that the original type knows
2971160	2978600	nothing about, and that the different domains of behavior have no idea about each other. So
2978600	2983400	encapsulation is dead, right? You need, for those scenarios, you need the data to be public,
2983880	2992760	and luckily we have, you know, auto properties to make that easy, and you need the functions to
2992760	3001000	work from the outside. But in a C-sharp 6 setting, so let's say we're still in 6, doing something,
3002120	3007880	let's say I want to write the two-string method from the outside, that's actually fairly hard,
3007880	3015000	that's annoyingly clunky, and that you get back to that dying inside feeling. So let's try to do
3015000	3019640	it, I'm making you all die a little bit inside, I'm sorry, we'll revive that part, and there'll
3019640	3026520	be flowers, and it'll be good in a minute, but you know. So let's say two-string, let's call it
3027080	3039640	something else, render, and you take a person, it's not even generics involved here, you take
3039640	3044200	a person, P, and then you want to render it according to which kind of, you know, which person
3044920	3050840	derived class it is. So we could do that, we can say, you know, we have type testing in C-sharp,
3050840	3057240	we can say if P is a student, and that's the only derived class that I actually put in here,
3057240	3063160	but you know, imagine there are dozens. For each of those, you say if P is student,
3063160	3069000	then do, at least we have expression-bodied members here, no I can't do that here, return
3071320	3076760	whatever the student does, okay, I'm cheating a little using interpolated strings here,
3077720	3086120	return that, except of course I have to dot my way into that public data, no problem,
3086760	3094120	but as I get to the student-specific property here, oh, you know, I already, I just asked,
3094120	3100440	but I already forgot that it was a student, so I don't get to. If only we were type script,
3100440	3105560	you know, type script, it has flow-based typing, you know, a variable, you know, if you figured
3105560	3109960	out it wasn't something on this branch, then, you know, it'll know you're something else,
3109960	3113880	and it's beautiful, but we can't, that's, oh, we're super-breaking in C-sharp, and also their
3113880	3120440	compiler is, you know, just thank God that they don't promise type safety, let me just put it like
3120440	3128200	that, so that is kind of annoying, what to do, well, you know, in C-sharp 6, your best option is to,
3128200	3133320	you know, cast P to student, knowing it will succeed, because you're smarter than the compiler,
3133800	3138200	until you maintain your code a little bit, and I know somebody else takes over,
3138200	3145320	and they do a refactoring manually, and stuff blows up, but that, we can do that,
3145320	3150120	and then there's an else, you know, else return that other stuff, let's just get it in there,
3150120	3158440	so we can, so we can mutate the code a little bit, return that stuff, and of course there would be
3158440	3165640	else ifs for every other, like, derived class here, so here we get to do p.this and p.that,
3165640	3173480	so far so good, but functional languages, they do this all the time, and it's interesting to note
3173480	3184440	that there's a fundamental difference in how the, you know, what kind of contract you have here,
3184440	3188280	when you use opti-growing programming, as I said, you can add a new class whenever you want,
3188280	3192200	and you can just overwrite that virtual method, and everyone's happy, right, because the code and
3192200	3199240	the class are together, if you add a new type, like, in this functional setting, you are explicitly
3199240	3204120	in the function, you are mentioning all the different shapes that you care about, and if somebody
3204120	3209320	adds another shape of data, and you know, your code is no longer handling that, so there's a
3209320	3215560	different, you can't add new data with impunity, but you can add new functions with impunity,
3215560	3221560	which you can't do in the opti-growing world, you can't go without going back and editing the
3221560	3225320	original, right, you can't independently add new functions in opti-growing programming,
3225320	3232600	but you can add new types, in functional programming, you can't independently add
3232600	3237880	new types, but you can add new functions, this really is a duality, but they do the other things
3237880	3242360	so well, and what is it they do, well, they do pattern matching, so the first step there is,
3242360	3248920	let's actually let you declare a variable inside of this expression, you know,
3249480	3254760	after this expression, that's actually let you put a variable name, and say, okay, I just checked,
3254760	3260760	can I just get a name for that, can I get a receipt, and you use that throughout here, and that is
3260760	3267480	your P typed a student with its own name, and now we can, we can, you know, we're not dying
3267480	3277560	inside anymore, if I can, at least if I can, what, oh no, what's that, yes, it was the wrong
3277560	3289400	province, no, yes, thank you, thank you, I'm code blind, thank god I only have six minutes left,
3289480	3295240	oh my god, I only have six minutes left, so what we're getting into is pattern matching,
3295240	3299560	and pattern matching is this whole new concept that we're adding to C-sharp at this point,
3299560	3305960	but it's not new in the global sense, it's a well-trodden path in functional programming,
3305960	3311320	we just have to adapt it to an object-oriented context, and this is a pattern, a pattern is
3311320	3317720	something that can either succeed or not when you apply it to a value, and if it succeeds,
3317720	3322120	it can extract some extra information and put it in variables for you, that's what a pattern is,
3322120	3326440	and we have a few patterns from the beginning in C-sharp 7, and then we start adding some more
3326440	3330840	along the way, and we keep, we're still adding patterns to this date, like C-sharp 11 has
3330840	3333880	list patterns, which you will, if you go to the other talk, you'll get to see those,
3335160	3340520	but it's still like the shape of the code, like we solved the micro problem, but the larger problem
3340520	3343800	of if, you know, having a very imperative way of checking, that's also very like
3344680	3351400	a kind of fraud with danger in terms of maintenance and so on, what we want along with pattern
3351400	3357320	matching is we want what functional programming often calls matching, pattern matching,
3358440	3363960	we have a keyword already called switch, so we're using that one, so let me go and just, you know,
3363960	3372040	do this again, so I'm gonna do it in a functional way, let's just, we can comment this out,
3373000	3378600	so we're gonna do just an expression body, we're gonna take the person, and we're gonna switch
3378600	3385480	on them, but not with an old-fashioned clunky switch statement from C in the early 60s that
3385480	3389720	we have in C-sharp, but with a switch expression, you know, like the cool kids, so this is an
3389720	3394920	expression body, that's a switch expression, it's empty right now, that's actually okay,
3394920	3398600	but you get a warning saying you're not handling all the different kinds of input, yeah, okay, thank
3398600	3406200	you, so and now we can write patterns directly here, student S, arrow, and now we can just
3406200	3413160	put an expression for the result that you want in case it is a student, right, so I can, I now
3413160	3418760	have like a clean structure within which I can just list comma separated patterns and results,
3420360	3426440	and I, right now I only need the two, so we're gonna take, we're gonna just do this
3427080	3434920	for now, and then just quickly touch on the fact that patterns can be, pattern matching
3434920	3439400	is smarter, right, we saw that it said that you were not handling all the cases, it still did that
3439400	3444600	when we only had the, when we only had the student, but when I do a catch-all, which I can do with a
3445400	3451480	fancy modern discard, then it says, hey, you're handling everything, you're good, no more warning,
3452280	3456200	well, what if I go the other way, like let's just, let's just swap the order of these two,
3456200	3460520	they are in order, then I actually get an error saying, hey, you handled, you handled this case
3460520	3466600	already, so, so you can see how maintenance of these things becomes much, not only is it clear
3466600	3471960	to read, but the compiler is helping you much more, keep your logic straight, so it's beautiful,
3471960	3479000	and it's safe, that sounds like functional to me, so, so you can do that, but you know,
3479880	3483400	you're noticing, I'm actually writing out just the first letter of the first name,
3483400	3490600	and in this case here, actually, what if the, what if the first name is empty, I'm not going to
3490600	3494600	talk about null right now, that's a whole nother talk, but what if it's empty, that's kind of,
3494600	3499560	you know, I should probably do something else if it's empty, so let's, let's use, just to show
3499560	3504360	an example of a recursive pattern, I know now that it's just a person, but what if the first name
3505320	3511720	of that person actually is an empty string, I want to do something else, and I just want
3511720	3515560	to write out the last name, I don't want to, like, do the whole abbreviation thing,
3517880	3527640	p dot last name, or, you know, I could actually, so this is a property pattern, I can dig out
3527640	3531720	specific properties inside of the pattern and recursively apply a pattern, here I'm just applying
3531720	3538360	the pattern, I use this constant, but I could also say last name, colon, and then apply a var
3538360	3544120	pattern, which always succeeds, but which will give you a name, so that's your let, that's your
3544120	3552280	pattern let, it's the var pattern, and then instead of saying p dot last name here, I already dug
3552280	3558360	out the last name and I gave it a name, so I can just say l here, so, and these things compose,
3558360	3564120	you know, if I wanted the actual, if I wanted a new name for the the person object itself,
3564120	3570520	I could put it here, let's call it p2 or whatever, so, so patterns kind of compose, and over time
3570520	3576840	we've added more and more kinds of them, that essentially make them more and more expressive,
3576840	3583160	and allow you to put more and more of your logic into patterns, so that your shape dependent
3584040	3593320	code is now as beautiful, or some would say even more, I don't, but, you know, it's a great
3593320	3598200	beautiful first-class alternative to virtual methods, when you, when describing the functionality
3598200	3604680	on the outside is what you want to do, you do pay something, you pay the fact that you can't
3604680	3609320	willy-nilly add new types, you pay the fact that your data has to be public, so that it can be
3609320	3614040	operated on from the outside, so encapsulation is at the window, but you get this other beauty,
3614040	3618520	so, you know, pick your poison, depending on the scenario, now you have both obstinacy sharp,
3619800	3629400	and I also wanted to mention immutability, but I just did, we did work for immutability, first
3629400	3635480	we let you have auto properties without setters, but that wasn't so good for the, for the object
3635480	3642200	initializers, now there's a more, now you have a new kind of setter, it's called an initter,
3642200	3646360	which is the setter that can only be called from object initializers, and now, so that means we
3646360	3651080	made immutable objects more first-class, you don't need to initialize them with constructors, you
3651080	3655240	can use object initializers for those as well, immutability is another functional concept that
3656120	3664280	we're starting to support more, so I'm going to stop here in the C-sharp 7s,
3665960	3670280	and if you want to see some C-sharp 11 functional influence, you know, there's another talk,
3670280	3679320	and just an hour and a half or whatever, and for now, thank you very much.
3685240	3686520	you
