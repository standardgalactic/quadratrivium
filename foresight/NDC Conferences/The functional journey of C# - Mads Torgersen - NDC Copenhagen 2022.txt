Wow, let's see. It recognizes me even with this fancy mic on. So, Windows Hello, yay.
Doesn't it? Or did it just, like, turn off? It wants, no, it didn't. It wants a pin. At
least it's not showing you my pin. There we go. Okay. This is my intro slide. My name
is Mess Torgerson, or Mess Torwassen, or Mutz Torgerson, or something like that. I
know we didn't friends out there are going to kill me. They're going to take a blue
sharpie to that one after. So, I work on the C-sharp language every day for Microsoft.
It's a great job. I wish you could all have it, but it's mine. So, and I've done that
for a very long time. So, that means I remember things that nobody else remembers, almost.
Except for Anders, as we call him, who was there from the beginning. I was not. I was
a latecomer. I've only been there for 17 years. But it is an old language. We are now working
on C-sharp 11, and there's a whole other talk about C-sharp 11 a little later today. So,
I decided I want to talk about C-sharp 1 through 10 today. It's from the angle of how
has functional programming influenced C-sharp over the years. I'm hoping that's interesting
to you. Otherwise, that's a lot of people I'll be disappointing today, because it's
a very full room. I don't know how many are out there, but you can still run without me
noticing unlike these people in here. So, I think it's interesting, because C-sharp started
out as a fairly typical of its age, fairly straightforward object going into imperative
programming language. That was how it started. They didn't kind of just pull that out of
the blue, of course. There were other languages around at the time that were similar. That
C-sharp might happen to look a little like, by accident. But that was sort of like the
game of the day. So, C-sharp was typical of the day, and kind of pretty much took almost
all the functional things in along the way as they became relevant to how we do programming.
So, I'm going to go through that same evolution essentially today and point out some of the
different ways. I'll try to make some general points about programming language paradigms
and so on along the way. But it's all going to be a little bit, I'm going to do it all
in Visual Studio. I'm just going to code along. And so, and I forgot to print out my demo
notes. So, may I go astray? It'll be a little bit of a one-off. We do have an hour, which
means that there's time for a few questions along the way, not like a million. But I don't
want you to say, oh, I want to ask a question about that when he's done talking. Because
by then, the code will look different. Nobody will remember what I was talking about. So,
if you have a question, raise your hand and ask it. And I'll try to keep us on track. And
hopefully I'll succeed. And that might mean that I will have to be a little rude and say,
sorry, no more questions. Come back after. So, just don't be offended when I get to there.
But until then, please just raise a question and ask. So, with that, without much further
ado, let's start out with C-Sharp 1. And just kind of, for those of us who were around, remind
ourselves of the state of the art of programming, at least in the industrial space in the year
2000. And for those of you who weren't around, you can just go, thank God I wasn't around.
I mean, you were probably around most of you, but maybe you were still doing Legos. Aren't
we all really? So, what I have here is a fairly simple. It's a C-Sharp 1 program. I'm cheating
a little bit because when it comes to features that aren't part of this talk, that aren't functional,
I'm just going to use them a little bit anyway. For instance, my code is not in a main method.
You don't need to do that anymore in C-Sharp. And it fits better on a screen if I don't. So,
I'm not going to stick religiously to only C-Sharp 1 features. But in terms of functionality,
I am. So, one thing to, talking about functional, C-Sharp started out with just a tiny little hint
of, a tiny little concession to functional programming languages compared to other languages
at the time. And with something that they, we call delegates, which is sort of kind of like a
function type. They were actually part of some of the, the need for delegates was part of the
reason why we couldn't do some other programming languages and got dragged into court and stuff.
So, C-Sharp back then already had like a notion of a function type called delegate. And those are
still the ones that we use for function types. They're flawed in various ways, but you know,
once you've got something throughout the whole core libraries and so on, you don't go on and
change it. So, delegate types were function types. It's like, you know, this is the type of a
function that takes an int and returns a bool. And it's a name type, like a class. It is in fact a
class. And we call it predicate. And now we can use it as a function type. So, I can have a method
here, a function that takes a predicate. And it can call the predicate as the, you know, according
to the function type. But, and when I want to pass an argument to it, well, we don't have anything
like lambdas yet that we're going to get to that. We don't have like anonymous functions of any kind.
But we do have, we, but you can sort of just mention a function that happens to have the right
signature, like great than five. Hang on a second.
Is it going to be like this all the way? How many typos are we going to have in here? There we go.
I did get the wordle this morning. So, I'm not like totally, there we go. So,
so you kind of have to declare a function, then pass it. You have to declare the function type,
then use it. Like it's all very nominal and declarative at this point.
But it gets the job done. Like pass the predicate in. Of course, there's no such thing as generics
yet. They're the first thing we're going to learn from functional programming languages in a minute.
So, you know, this was the name of the game. I do, you, in order to filter this, I need to
gather up the results. The only, like I really wanted to return an array because that's the only
generic type I have. It's the only type that actually has an element type. So, that's, so you
kind of, you kind of encourage to trade in arrays, horrible as that is, because otherwise you have
no type safety. But we do have other collections. They're just all over object. So, and, and I need
to create one of those to gather up my elements because I don't know how many are going to
succeed yet. I don't know the size of the array to allocate. So, first I gather them up, then,
you know, I know how many I have, then I can allocate an array that's strongly typed to int,
then I have to stick all the elements that I found into the array. And as I'm doing so,
I have to cast them to int because I know they're all ints, but the compiler has no idea. It's like
you stuck, you give me a bunch of stuff, you're taking them out, all I can see is object.
So, you know, you die a little inside every time you have to cast things coming out of
collections. How many people in here remember that from like either C'sharp or some other,
like Java or, yeah, out, yeah. So, what, I think what we very quickly felt all of us was,
and with C'sharp, it was already like coming to version two, which we're coming to version two now.
We felt like, okay, this is not, this is not like a satisfactory state of affairs.
It's not the abstraction capabilities aren't good enough here.
Some other languages that had been around for longer, it took them a little longer to get to
that point. So, it ended up that, for instance, Java and C'sharp got generics, which is where we
coming to now at around the same time. And I was actually back then, I was on the other side of
the fence helping out with generics and Java. So, I saw it from the other side. Still think
Microsoft and C'sharp did it better. So, this really comes down to sort of one of the fundamental
differences between functional and object-oriented programming.
You know, in classic imperative programming, there really is no polymorphism. There's no
way that you can write code that applies to more than one type. Object-oriented programming and
functional programming, to a large degree, are two different answers. At least when they're typed,
they're two different answers to, how do you get polymorphism? How do you write code that
works for more than one kind of thing? In object-oriented programming, we went with what's
often called subtype polymorphism, which means everything is a subtype of something that's a
subtype of something that all goes back up to object. So, that's what we're seeing here. Now,
you can write a collection like ArrayList here that can contain anything. So, there's polymorphism
in that sense. And the great thing about subtype polymorphism is it's very easy to have heterogeneous
collections, for instance. You can put all kinds of things in the same collection. As opposed to
functional programming, they went with what's called parametric polymorphism, where you have an
extra type parameter on things that, you know, sort of like a placeholder for one type. So,
you don't get to mix and match the types inside. You get to say that there's this one type that
I'm going to give you later, and then it'll work for that type only. But it's still polymorphic,
because you can give different type arguments in different places. And that has the benefit that
you can, because that type parameter has a name, you can have things sync up so that the same type
name, the same type parameter appears in multiple places, and you can sort of say, well, whatever
it is, the same kind of thing that comes in is the kind of thing that comes out, for instance,
which is exactly what we need here, right? We need a collection, for instance, that has
the same stuff coming in that's coming out. Enter generics, which is parametric polymorphism.
Most object-oriented programming languages with types at this point say, okay, let's embrace
that too, so we have both kinds in the language. So, that's sort of one of the first big imports
from the functional space. So, let's do that. Now, let's see, where do we start?
Now, we can have, well, instead of a RayList here, we could now use the new fancy generic
collections that we have, and I'm cheating and having the imports in another file, so either
using, so you don't have to bother with that. So, we can say list of int here instead is a new list
of int, and now, as I'm gathering things up, it should be graying out this. I know that my
destination here is actually a list of int and not just a list of whatever, and so I can now get
rid of this cast of death. Back in business. Somebody wrote a generic collection for us,
we can use it. But, of course, now, there are other, I can write generic things too. Maybe I
want my predicate type to be more general. Maybe I don't actually want to write new delegate types
for everything all the time, so maybe we could say predicate of t and have it work for all t's
and not just for ints. It still returns bool, but I can, I now have a generic predicate type,
and I can then here say, well, it's actually here, it's a predicate of int that I want,
and boom, things don't work, or we can, we could actually go a step further and say,
well, filtering isn't really particularly about ints, is it? And now we can write our own generic
function, a method that is a filter of t, and now we get to, say, t in all the places,
it's actually a predicate of t coming in and an array of t, and I'm returning an array of t,
and in all the other places where it says int, except one, so you have to be a little careful,
here, here, here, where else? The int result, of course, and, you know, so now I've completely
generified the thing, and this is the int I shouldn't replace, because that's the counter for the,
you know, filling out the array, so that's why I didn't just do a search replace here.
So there we go, now we, all of a sudden, we've generified a thing, it's fully strongly typed,
as if it was for a specific type, but now you can apply it everywhere, and the full,
like, generic, generification is a strong, strong tool, and it, the, there were some, like,
choices made in the different languages at the time that, that actually were imbued with destiny,
even much more than we realized at the time. In Java, we, on the, I was over here, in the
Java side, sorry, camera person, we, we were, we decided we couldn't change the JVM, the runtime
under Java, because it was, you know, too entrenched, and how you couldn't control, like, what,
but Java runtime they had out there, so, so all the generics in Java was done in the compiler by
erasure, which means, you know, there wasn't any generics at runtime, it was just there
in the code for as much type checking as you could get, but that meant that there were some
things, like reflection and so on, that didn't embrace it, and there were certain, certain
holes in the experience, essentially. And whereas in, in .NET, and, and C Sharp, we went all out
and said, yes, generics goes into the runtime, and is shared across all the languages at target.net,
and it's a real runtime thing. Question.
So, to repeat the question for the, for the mic, when did we know that we wanted generics in C
Sharp? So, I wasn't there, but I kind of was, because in 99, I was an intern, I was doing my
PhD, I was an intern at Microsoft Research, Cambridge, which is where Don Simon is, if anybody
has heard of him, the father of F Sharp, and there were a bunch of language people there,
so I got actually to be privy to decisions that were secret for a number of years, and I was under
NDA until, until things came out, and they were already talking about .NET, they weren't calling
it that at the time, and they were already talking about generics for it, and decisions were made
that it would take too long to make it work right, and we should have a version without it first.
So, yeah, that, that, I think that answers your question precisely, so it was always felt that
that we're gonna, we're gonna need to do this, and indeed, generics was, was the, pretty much the
almost the only and, and last thing that language feature that was added to the runtime for a very
long time, because after that .NET became popular, it was Windows component, and so we had the same
problem as Java, as the one causing Java to not do it in the runtime, which was too many people
have it installed, we don't know which version of Windows they have, we have no way of, you know,
making sure that they have the right runtime features that we are compiling for, so we stopped
doing language features in the runtime after that for a very, very long time, now we're doing it again,
and we might get to one at the end, so that's generics, and let's see if I can get back on
track here, so it's, well, that's not generics, that's not all there is to say about generics,
because once you get these, like, very lovely generic collections, for instance, they can have
smarter, they can have smarter types, smarter methods as well, they can have generic methods,
so instead of, instead of like doing this, building this result array myself, I could just actually
take that dst thing and just call to array on it, because now it knows its element type and you
can build an array of the right, of the right type, namely t, you also notice, so which means I can,
I can delete these two lines of code, I don't need that anymore, so many more utilities now,
strongly typed utilities become available, and one last thing to notice is that when I'm calling
the generic method here, I'm not passing a type argument, you need to pass a type argument to,
to the, to generic types, but not to generic methods, and that again is a thing that type
inference is something that we start stealing from functional programming languages, we can't do
as much type inference in object-oriented programming languages as you can in a functional
language because of the subtype polymorphism, it means that you can't actually, there are many
places where you can't know the exact type, where you could if you didn't have subtype polymorphism,
so we can't go all out on, on type inference, which is probably all the same because it's
confusing to a lot of people, it's a quiet taste, so, so we kind of, we have to strike a balance
there, but it certainly makes sense here, so with that lovely generics, we, we can also get out of
this addiction to, to arrays as the, as kind of like the, the, the currency of collections
being passed around, because arrays are, you know, they're very low-level, fixed size, they
expose too much, they're unsafe in various ways because you pass your array to someone and they,
they're messing with it while you're watching it somewhere else, and you know, that's just, you
know, nasty, so we can start having other interfaces, for instance, that are, that are more
suitable, so, Ionumable of T is a good one, I can return Ionumable of T as well here, and,
and I don't even have to say to array, I can, but I don't have to say to array because, of course,
a list of T is also an Ionumable, so, you know, things get simpler.
We could do one better, actually, we, we also, well,
oh, but, well, it's because I'm saying, in the array here, yeah, yeah, I have to,
I have to just make all the changes, okay, so,
oh, Eint, thank you.
Say, are you developers or something? It's like, it's like you, it's like you understand what I'm
saying. Hey, I also debugged something once, you know, it's fun, so, so, so far so good, we,
one thing we actually decided was, now we have Ionumable of T, it's like a very,
in abstraction over just sequences of data, we're going to meet this a lot more in C-sharp 3,
but already in C-sharp 2, we were like, actually, the compiler could help a lot with this kind of
work here, of producing Ionumables, because they don't have to be produced eagerly,
they don't have to have all the elements pre-computed, they can actually sort of
be lazy and compute things along the way, and we can build a language feature to help with that,
and that's what we call iterators in C-sharp, they're called generators in some other languages,
which is essentially write a function, and then once in a while you say, oh, here's another element
for the result, and then you compute some more, and then, or here's another element for the result,
and it actually gets executed lazily, up to every one of those points, you just pause and,
and give the result back, and then the next time the consumer asks for a result, they come, you
know, execute some more, so that's iterators in C-sharp, that means we don't even need like an
accumulator, we can just say, if that thing, you know, just yield return the value, I'm not
super excited about the syntax we chose there, I will just say I was not around,
we liked keywords a lot still back then, we kind of do still a little bit, and now I'm,
you know, that's it, that's the filter method, you know, you cycle through,
you yield return something, if you decide that, hey, let me do that, and that's it, right, so boom,
very nice. Also in C-sharp too, we're like, hey, we've heard about lambda expressions,
let's do not that, something similar, let's have anonymous functions, why do you have to declare
all the functions that you want to pass, that's just like a pain, let's get rid of all these
declarations and stuff, so instead of saying greater than five here, what if I could just
write the function with the body and everything in place here, so we come up with an elegant
syntax saying delegate, delegate all the crap, there we go, beautiful, right, it's, well,
we can laugh now, but you know, it's certainly an improvement, now, you know, I'm free to just
come up with functionality and pass it along, and of course the compiler generates
something under the hood that's similar to before, but hey, all languages do it like that,
pretty much, so great, our first take on anonymous functions, now C-sharp three,
now we have big ambitions, this functional thing has really gotten into our blood, and this is
where I'm starting to be around, so I've witnessed more of this firsthand, so in C-sharp three,
we want to, we want to solve querying once and for all, the functional languages can do it,
we can do it too, so we want to mainstream functional approaches to solving querying,
let's do that, and we have, filter is a great example, like it's a function that does querying,
a one aspect of querying, we kind of have the generics in place to do this,
why don't we, why don't we actually declare an even more general library of function types,
and then we also declare a library of, of querying methods, and get all that stuff working,
so we, so instead of just having predicate of t, we create a family, families of functions called,
funk and action, funk for the ones that return stuff, so funk of t1, t result, or something like
that, that take a t and return a t result, so that's what the funks look like, take a t1 here,
and we just declare them in the core library, so I don't even have to do it here, they're available
to everyone who wants to be a little bit functional, and we can just here, actually it doesn't
predicate itself actually in the core libraries from back way, way back when, so it doesn't give
me a red squiggle here, but let's say funk of t, instead to describe the function we're passing in
here, and then instead of me writing the filter method as kind of a, one thing that you quickly
find out when you want to, you want to query things is, hey I want to, I want to filter some more,
for instance, I want to call query methods on top of query methods, so I could call filter twice,
you know, I could say filter on the result of the first filter, comma, you know, some other
delegate thing, and you know, it quickly becomes long, I should probably have done lambdas first,
shouldn't I? I'm going to be doing more typing, okay, hold that thought, let me do, let me switch
to lambdas quickly, we get better syntax, that's actual lambdas, you can do this, it's a little
shorter, or we have, so this is still like a statement body there, or we can actually do
just a single expression, and now it starts, it starts being a little expression oriented,
like the functional languages, that's kind of exciting, but we still have the problem now,
if I want to filter that one some more, I can say int, why, arrow, something, stuff,
oh it needs to be in parentheses here, actually does it, you know, lambdas, you don't actually
have to say the type, if it's given from context, you don't have to say it, that's kind of cool,
but so why, I want to get the ones that are even, stupid example, but just, you know,
equals zero, you know, I can compose my query methods, but it sucks, right, I'm composing sort
of inside out, like this first stuff is in the middle, and then I'm slapping stuff on both sides
of it, and it's completely unreadable, well what do the functional people do when they, I mean,
they're doing this stuff, how do they do it, well they have pipelining operators, you can call
functions like this, but you can also pipeline, so in a functional language, what you would do is,
you would start out with the array on the left side, and then you would, so let me, let me do some
horrendous doctoring here, you know, start out with the array, you would have some kind of pipeline
operator, which we don't have in C sharp, and you pass it into filter, filtering the first thing,
and that's just the implicit first argument for it there, and then you'd pipe that into
filtering the second thing, and now you have things in the right order, they're sort of cascading
beautifully in the order that you're doing them, it's kind of fluent, man, as we said, so,
so that's, can we do something like that in C sharp, and that's where extension, we come up
with extension methods, which is essentially just to solve this little problem in the beginning,
where they turn out to be like extremely useful in extremely many scenarios, we're still being
inspired by them, and we want to do more with them, where what you're saying is, we're just,
what if you just pretend that the static method or this function is actually like a, and it's,
I can't do it with a, I can't do it with just this method here, because it's not actually,
it's not declared in a proper space, but we can do, the syntax is like this,
we just pretend it's an instance method on the first argument, and now I can go and add
method, what looks like instance methods to other people's types, and that kind of gives you that
flow, so luckily, I don't have to like go in and do it properly here, because it turns out that
method just like filter is being added to the libraries at the same time, and now we can just
do the where stuff, so we can get rid of our own filter method and use the one that's part
of the query library that we are now providing, okay, so we can break it up a little here, and now
it starts to kind of look decent, right, now we have a select for projecting, because why would we
call it project, we have various methods, I'll tell you why we call it select, that's because
another place where you do querying is in, you know, SQL, which is also kind of functional,
right, it's also just, there are aspects of SQL where it can mutate stuff and actually get
things into the database, but the actual querying is functional too, and so we want to provide
syntactic sugar for querying on top of methods like this, where you can say from value in,
I should call them x, I like x, from x in array, where the keyword, where x is greater than five,
and where something else, where y, let's call it x again then, because we are now using the
same variable name all the way down, select something, so we now have query syntax, select,
you know, maybe just x, and the point here is it looks like SQL, it's a little different,
because in SQL they start with a select clause, which means we don't like that in programming
languages, because they start out by describing the result, and what you want is to start out by
describing the source, like where do things come from, so you can get types going and have your
tooling kind of help you out as you type the code from one end to another, so we want to start with
the array, figure out what its type is, get completion in our classes, and so on, so that's
a programming, proper programming language way of doing it, sorry SQL folks, but you got it wrong,
and you didn't think about ID, you didn't think about IDEs back in 1970, I went out, IDE focused
language design, that's the way, that's why we have TypeScript, so great, but now that actually
just queries my in-memory data, wouldn't it be cool if I could actually use the same syntax,
both the syntactic sugar and actually also the method called syntax, to query actual
SQL databases, and with no difference in syntax, and that's where we get to yet another functional
loan, which is code quotations, so in Lisp for instance, it's all based around the fact that
code and data are no different, and you can always easily take code and represent it as a data
structure, well that's kind of cool because then you can do metaprogramming, you can take that
data structure and do stuff with it, and one of the things you can do with a data structure
representing a query is you can translate it to SQL and send it to a SQL database, and have it run
a SQL, and have the result come back, and then you do a little translating back, and now you have
an object-oriented, an object relational model, so if we take that, let's just say var here,
more type inference, if we take that array and say, is it too queryable or ask queryable,
isn't it ask queryable, there you go, and say ask queryable, I'm sort of cheating a little,
and I'm representing it as now a queryable is like a representative of some other data source
that uses quote quotation in order to do the querying, so when I do that, what changes as well,
not much, you know, I get a queryable back instead, whoop-de-doo, but if we go and look at that query,
query dot, you can see that it has something inside called an expression, and that expression,
in fact, represents the data structure of all this query, okay, so we're building up,
instead of having the code just code that we can run, instead we build up a data structure
with exactly the same syntax, and now querying of in-memory data and querying of
SQL databases look the same just like you can do in many functional languages that have code
quotation, so yet another loan there, and I just cheated a little bit and showed you var as well,
which is like the last one more concession to type inference, like very simple one, it's like,
why do I have to say the types all the time, it's really bothersome to have to say int,
can you let me say a three-letter keyword instead? Obviously, that's not the best example,
this is the best example, right, I don't want to have to write, I want to just say, hey,
the thing, you know, give me the thing, if it's clear from context that it's what kind of thing
it roughly is, you know, who cares, so that's functional up until C3, it's a good time to
ask for questions, we're about halfway through the story and about halfway through the hour,
so it's still on track. Anything, any thoughts coming up here, questions, meta questions,
programming questions, meta programming questions, yes?
What made me decide?
Anders Heilsberg made me decide. Okay, short version of the story, I was a professor,
I wasn't liking it too much, I was collaborating with the Java team at Sun Microsystems then,
had a great time doing real world, you know, real world language design for real customers,
they got to do it all day, I got to do it like whenever I could get away from teaching and
stuff and I just like, well, I have great time when I'm working with them and they make twice as
much money as me at least, I think, just like maybe I'm not in the right career here and as I
was thinking that, there was a conference in Ohos, Anders was there talking about how they
were going to do generics in C sharp, I was there talking about how we were going to do
generics in Java, you know, the rest is history, he had money, I didn't, so he hired, he hired me,
not the other way around. Actually also, I liked how he talked about language design,
when I was involved in Java language design, there was always a lot of stop energy,
it's like we can't do this because, and we can't do this because, and he had a bunch of can-do
attitude, you know, a small example, the generic method is gone from the screen here,
but in Java they said, oh, we can't put the type parameter for generic methods
after the parameters, because that might be a syntactic ambiguity in rare cases.
And in C sharp, when he showed examples, that would also be a syntactic ambiguity in rare
cases in C sharp, because syntaxes are a little bit alike, but they just put it there anyway,
and I asked him after, how do you do that? He's like, we just do some tricks in the
compiler, it's not like LR1 or whatever, it's fine, we figure it out, and who cares about
those rare cases, you know, we come up with a rule that works 97% at the time, if you
can run into it, and does the right thing mostly, and we're good. It was always like,
we can probably solve that problem attitude, and that spoke to me in a way, and that's
still the case, and that's still why I love being there, so, oh.
Thanks for that question, now I'm going to have a tear in my eye for the rest of the day.
Anything else? I want to hear about my childhood. Yeah.
Why, oh, great question, so why are the delegate types that have the same shape,
like the same signature, why aren't they interchangeable?
So, they used to be predicate of T, and then it turned into, we started using
funk of T, and they're not actually interchangeable, you can pass the same lambdas to them,
but you can't assign one to the other, they're not structurally equivalent, so, and that comes
back to, you know, I kind of hinted that I'm not a super fan of delegates, and one of the
problems with them is that they're a nominal type, they have a declaration, and just like classes
that look the same, you can't take an object of a class and duck type it to another class that
happens to be the same, it's all based on the declarations, it's very, very nominal, as we say,
and the same is true for the delegate types, they are actually classes, and they are nominally tight.
Now, in Visual Basic, for instance, vb.net, they paper over this by inserting implicit,
like, wrapper functions to translate from one to another, so there you get the great experience of
it all just assigns to each other, it looks extremely structural, but the problem is it
isn't, like it comes with a cost, like you're wrapping more and more, if you keep passing
back and forth, you get like layers and layers of, oh, here's a predicate of a fung of a predicate of,
you know, all the way, so we don't let you go down that rabbit hole in C sharp,
we think about it sometimes, and we also think about, well, could we just do better
function types, but then you have a library that is gigantic, and that is using delegates
everywhere, and you look at that and you go, hmm, I wonder how we could do this and not mess up
a million customers, you know, or, you know, we choose not to roll it out in our big library
and just make it, you know, an option for new code, and then doesn't really, there's no bang there,
right, you know, you don't get enough value, so that's a tough problem, that's, you know,
the problem of legacy code and the problem of compatibility shoots down a lot of good feature
ideas, and we haven't found a way around this one. It's one of several, interestingly,
functionally inspired topics that we'll be discussing this summer, we're having sort of a
series of summer camps on the team where we'll discuss topics that are normally out of bounds,
because we don't know how to deal with them, and this is one of them, so maybe one day we'll figure
out a way to make that good. Yeah?
Yeah, so the question is, is the, is the sequel style syntax still in broad use,
and it's true, it does feel very different from the rest of the language, it's, yeah, it's just,
it's like you enter another world. Yeah, we have to maintain compatibility with it, but also,
furthermore, I think it is still, it is still used a bit, like a bunch, not more than a bit,
actually, a bunch of people actually do prefer the method called syntax, even when they're using
the query methods. I find that if I have to do more than one from, from x in blah, from y in
x dot, or something like that, then writing the corresponding query with method calls becomes,
becomes mind-blowingly hard, and you have to use select many, and select many is mind-blowing,
and so I always, if I have to, if I have to, like, do more than one from, if I have to, like,
dig into data with froms, I switch to query syntax and let the compiler figure it out for me,
because I, my brain can't handle it. It's all, actually, it's all down to monads,
so how many people here know about monads? Yes, that's more than I would have expected,
actually. It's this concept that is super central to a bunch of functional, a typed functional
programming, and nobody understands it. A bunch of people claim that they do, but they're actually
just, you know, it's a collective kind of like, it's a hoax. They don't, not for long anyway. I've
understood it many times, and then, you know, the next day I was like, what was it again? Maybe I
was just dreaming it. It made, it totally makes sense at the time, but query, query expressions,
they are a monad. They're a language support for a monad, and when you use more than one from,
that is where you get into monadic territory, where the select many is the thing that makes them,
makes them a monad, and that's, that's exactly why it gets mind blowing to do it directly. It's
because it's monad, and you want syntax for that. But other than that, people have different styles.
There are also people who work on low level code that would be like, this is way too inefficient.
It does you, there's all this laziness, right? The, the iterators are generating things along the
way, which means you have all this like, you have a bunch of structure, you have all these calls
through interfaces and so on. So if you're doing performance intensive code, one of the things
that people look for in code reviews is, oh, oh, you have a query there. Well, fix that, you know,
go back to ugly array based stuff, because then it's going to be faster. So I will say that entity
framework, live and kicking offers up, you know, a query provider implementation,
and people do use that, and they do use the query syntax when they're interacting with that,
because it is a database technology outside of that, maybe not so much. Okay. All right. One more.
That's true. Yes.
So that's a great question because, and we might touch on it a little bit later.
So let me repeat again. The one thing you can do in the query syntax is you can use let
to actually introduce more temporary variables inside of the query. I haven't done it in many
years, actually. Let's see if we can do that. Let y equal x times two or something like that.
Yeah, it worked, at least it compiles. So now the rest of the query has access to x and y,
and that's really useful because you have sort of like variable declaration inside of an expression
rather than as a separate statement. And that has continued to doggers. That statement-based
approach to variable declarations has continued to doggers. And in later versions of C-sharp,
there are more and more places where you can now declare variables inside of an
expression. We haven't done it completely generally. We had a proposal for it where we never
went that far, but there are many situations now where you can declare an inline variable,
particularly in pattern matching, which we're going to get to soon. So that even provides
a good segue for that. Another big difference is functional languages tend to be very expression-based.
Typically, a function doesn't have side effects in a pure functional sense, so you don't really
need statements. You just need an expression saying what the whole thing is, and then you stick it
together, you put sub-expressions inside, and it's all expression-based, and so you need things like
variable declaration to be expression-based. And the more expression-based, the more we get
inspired by that in C-sharp, the more of a shortcoming it becomes that variable declaration
isn't one of them. So great, great point. And this is a way to sneak it in. You can't do that with
method call syntax, because it does sneaky things under the hood. It builds little, like,
tuple-like things to keep track of all the variables under the hood. Okay. Yep. Okay.
Let's fast forward a little bit. Then we did dynamic. That was certainly not very functional.
C-sharp 4. C-sharp 5, we did async, which was potentially very functional. F-sharp already
had a solution to async, which was also sort of monadic, and which is beautiful, but is very
ill-suited for a predominantly imperative language. So we went in a different direction with async,
and the general functional approach to async is quite different from the imperative approach
that we use in C-sharp. Essentially, they use an approach where they built up the whole control
flow of the async ahead of time, and then you kind of pull a handle in, and it runs. It's like
you built all the pipes, and then you turn on the water. And in our async, we sort of more like
laying out the pipes as the water is coming. It's sometimes called a cold and hot async.
Like we work with tasks, which are things that are already happening, things that are already
concurrently operating, and then you can take a task, and then you can say, well, I'm ready for
you. Are you ready for me and get a result out of them? So that's all much more imperative
fits better with imperative workflow. So there, we didn't go the functional way. We don't always do it.
In C-sharp 6, we started getting interested in the expression-based stuff again, though. So I'm
going to switch to a different file here. So one thing that we really like, the expression bodies
of lambdas, we're like, why should only lambdas be allowed to have expression bodies? Why can't
all our functions, all our function members have expression bodies, and we're like, okay,
C-sharp 6, we did kind of half of them, and then C-sharp 7, we did the rest. So now
all function members in C-sharp can have expression bodies where you just put that lambda
arrow there, the fat arrow, as we shouldn't call it, and you get it. You don't have to say return.
If your only statement is return something, cut the boilerplate. But it's just in tactic sugar,
right? So, but coming to C-sharp 7, we're starting to think about more fundamental
things again. So not so much in the syntax, syntactic sugar, you know, as feel kind of layer,
but really like, uh-oh, object-oriented program is kind of screwed in these new scenarios that are
becoming very predominant and widespread. Essentially, when it comes to cloud programming,
history is on the side of functional programming. I'm sorry, object-oriented programming is not
good for that. If you think about, and that comes down to how you describe aberrations over types
of data. In both object-oriented and functional programming, there are ways that you can write
functions so that they have appropriate behavior for each shape of data, for each type. But those
ways are very different. They're like actually, I think probably if Eric Meyer was here, he would
say that there's a duality, like they're completely like the opposite of each other.
What we do in classic object-oriented programming, we love encapsulation. We love saying the data
is actually secret. I'm not even, I'm not exposing it because then I can change it whenever I like,
and then I just offer up some functions, and I can have a class hierarchy with virtual functions
that I can then describe for each type of data what it does. So the super like,
idiotically simple example here is the two-string virtual method, right, where I am
I am describing the string representation of the object by overriding the virtual method
two-string. Great, you know, that means that whenever I write a new derived class from person
here or from object actually in this case, you know, I can just overwrite that behavior to suit
whatever my shape is, and somebody else can call it on the base class and not even know I exist,
but still get the right behavior. Excellent, except when you have a world where data is long
lived in the cloud, maybe, or in databases and whatnot, and different people are writing different
functionality over the same data models, well, oops, now it's not so good to encapsulate those
behaviors with the data model, right? You want to independently be able to express behaviors over
the data model that still depend on, like, still type specific, but that the original type knows
nothing about, and that the different domains of behavior have no idea about each other. So
encapsulation is dead, right? You need, for those scenarios, you need the data to be public,
and luckily we have, you know, auto properties to make that easy, and you need the functions to
work from the outside. But in a C-sharp 6 setting, so let's say we're still in 6, doing something,
let's say I want to write the two-string method from the outside, that's actually fairly hard,
that's annoyingly clunky, and that you get back to that dying inside feeling. So let's try to do
it, I'm making you all die a little bit inside, I'm sorry, we'll revive that part, and there'll
be flowers, and it'll be good in a minute, but you know. So let's say two-string, let's call it
something else, render, and you take a person, it's not even generics involved here, you take
a person, P, and then you want to render it according to which kind of, you know, which person
derived class it is. So we could do that, we can say, you know, we have type testing in C-sharp,
we can say if P is a student, and that's the only derived class that I actually put in here,
but you know, imagine there are dozens. For each of those, you say if P is student,
then do, at least we have expression-bodied members here, no I can't do that here, return
whatever the student does, okay, I'm cheating a little using interpolated strings here,
return that, except of course I have to dot my way into that public data, no problem,
but as I get to the student-specific property here, oh, you know, I already, I just asked,
but I already forgot that it was a student, so I don't get to. If only we were type script,
you know, type script, it has flow-based typing, you know, a variable, you know, if you figured
out it wasn't something on this branch, then, you know, it'll know you're something else,
and it's beautiful, but we can't, that's, oh, we're super-breaking in C-sharp, and also their
compiler is, you know, just thank God that they don't promise type safety, let me just put it like
that, so that is kind of annoying, what to do, well, you know, in C-sharp 6, your best option is to,
you know, cast P to student, knowing it will succeed, because you're smarter than the compiler,
until you maintain your code a little bit, and I know somebody else takes over,
and they do a refactoring manually, and stuff blows up, but that, we can do that,
and then there's an else, you know, else return that other stuff, let's just get it in there,
so we can, so we can mutate the code a little bit, return that stuff, and of course there would be
else ifs for every other, like, derived class here, so here we get to do p.this and p.that,
so far so good, but functional languages, they do this all the time, and it's interesting to note
that there's a fundamental difference in how the, you know, what kind of contract you have here,
when you use opti-growing programming, as I said, you can add a new class whenever you want,
and you can just overwrite that virtual method, and everyone's happy, right, because the code and
the class are together, if you add a new type, like, in this functional setting, you are explicitly
in the function, you are mentioning all the different shapes that you care about, and if somebody
adds another shape of data, and you know, your code is no longer handling that, so there's a
different, you can't add new data with impunity, but you can add new functions with impunity,
which you can't do in the opti-growing world, you can't go without going back and editing the
original, right, you can't independently add new functions in opti-growing programming,
but you can add new types, in functional programming, you can't independently add
new types, but you can add new functions, this really is a duality, but they do the other things
so well, and what is it they do, well, they do pattern matching, so the first step there is,
let's actually let you declare a variable inside of this expression, you know,
after this expression, that's actually let you put a variable name, and say, okay, I just checked,
can I just get a name for that, can I get a receipt, and you use that throughout here, and that is
your P typed a student with its own name, and now we can, we can, you know, we're not dying
inside anymore, if I can, at least if I can, what, oh no, what's that, yes, it was the wrong
province, no, yes, thank you, thank you, I'm code blind, thank god I only have six minutes left,
oh my god, I only have six minutes left, so what we're getting into is pattern matching,
and pattern matching is this whole new concept that we're adding to C-sharp at this point,
but it's not new in the global sense, it's a well-trodden path in functional programming,
we just have to adapt it to an object-oriented context, and this is a pattern, a pattern is
something that can either succeed or not when you apply it to a value, and if it succeeds,
it can extract some extra information and put it in variables for you, that's what a pattern is,
and we have a few patterns from the beginning in C-sharp 7, and then we start adding some more
along the way, and we keep, we're still adding patterns to this date, like C-sharp 11 has
list patterns, which you will, if you go to the other talk, you'll get to see those,
but it's still like the shape of the code, like we solved the micro problem, but the larger problem
of if, you know, having a very imperative way of checking, that's also very like
a kind of fraud with danger in terms of maintenance and so on, what we want along with pattern
matching is we want what functional programming often calls matching, pattern matching,
we have a keyword already called switch, so we're using that one, so let me go and just, you know,
do this again, so I'm gonna do it in a functional way, let's just, we can comment this out,
so we're gonna do just an expression body, we're gonna take the person, and we're gonna switch
on them, but not with an old-fashioned clunky switch statement from C in the early 60s that
we have in C-sharp, but with a switch expression, you know, like the cool kids, so this is an
expression body, that's a switch expression, it's empty right now, that's actually okay,
but you get a warning saying you're not handling all the different kinds of input, yeah, okay, thank
you, so and now we can write patterns directly here, student S, arrow, and now we can just
put an expression for the result that you want in case it is a student, right, so I can, I now
have like a clean structure within which I can just list comma separated patterns and results,
and I, right now I only need the two, so we're gonna take, we're gonna just do this
for now, and then just quickly touch on the fact that patterns can be, pattern matching
is smarter, right, we saw that it said that you were not handling all the cases, it still did that
when we only had the, when we only had the student, but when I do a catch-all, which I can do with a
fancy modern discard, then it says, hey, you're handling everything, you're good, no more warning,
well, what if I go the other way, like let's just, let's just swap the order of these two,
they are in order, then I actually get an error saying, hey, you handled, you handled this case
already, so, so you can see how maintenance of these things becomes much, not only is it clear
to read, but the compiler is helping you much more, keep your logic straight, so it's beautiful,
and it's safe, that sounds like functional to me, so, so you can do that, but you know,
you're noticing, I'm actually writing out just the first letter of the first name,
and in this case here, actually, what if the, what if the first name is empty, I'm not going to
talk about null right now, that's a whole nother talk, but what if it's empty, that's kind of,
you know, I should probably do something else if it's empty, so let's, let's use, just to show
an example of a recursive pattern, I know now that it's just a person, but what if the first name
of that person actually is an empty string, I want to do something else, and I just want
to write out the last name, I don't want to, like, do the whole abbreviation thing,
p dot last name, or, you know, I could actually, so this is a property pattern, I can dig out
specific properties inside of the pattern and recursively apply a pattern, here I'm just applying
the pattern, I use this constant, but I could also say last name, colon, and then apply a var
pattern, which always succeeds, but which will give you a name, so that's your let, that's your
pattern let, it's the var pattern, and then instead of saying p dot last name here, I already dug
out the last name and I gave it a name, so I can just say l here, so, and these things compose,
you know, if I wanted the actual, if I wanted a new name for the the person object itself,
I could put it here, let's call it p2 or whatever, so, so patterns kind of compose, and over time
we've added more and more kinds of them, that essentially make them more and more expressive,
and allow you to put more and more of your logic into patterns, so that your shape dependent
code is now as beautiful, or some would say even more, I don't, but, you know, it's a great
beautiful first-class alternative to virtual methods, when you, when describing the functionality
on the outside is what you want to do, you do pay something, you pay the fact that you can't
willy-nilly add new types, you pay the fact that your data has to be public, so that it can be
operated on from the outside, so encapsulation is at the window, but you get this other beauty,
so, you know, pick your poison, depending on the scenario, now you have both obstinacy sharp,
and I also wanted to mention immutability, but I just did, we did work for immutability, first
we let you have auto properties without setters, but that wasn't so good for the, for the object
initializers, now there's a more, now you have a new kind of setter, it's called an initter,
which is the setter that can only be called from object initializers, and now, so that means we
made immutable objects more first-class, you don't need to initialize them with constructors, you
can use object initializers for those as well, immutability is another functional concept that
we're starting to support more, so I'm going to stop here in the C-sharp 7s,
and if you want to see some C-sharp 11 functional influence, you know, there's another talk,
and just an hour and a half or whatever, and for now, thank you very much.
you
